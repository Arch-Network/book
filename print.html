<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Arch Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for the Arch Network - A Bitcoin-native computation environment">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Choose Your Path</li><li class="chapter-item "><a href="getting-started/quick-start.html">üöÄ Quick Start Guide</a></li><li class="chapter-item "><a href="getting-started/bitcoin-and-titan-setup.html">üèóÔ∏è Run a Validator</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="getting-started/requirements.html">System Requirements</a></li><li class="chapter-item "><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html">Network Selection</a></li><li class="chapter-item "><a href="getting-started/validator-staking.html">Validator Staking</a></li></ol></li><li class="chapter-item "><li class="part-title">Program Development</li><li class="chapter-item "><a href="guides/understanding-arch-programs.html">Understanding Arch Programs</a></li><li class="chapter-item "><a href="guides/writing-your-first-program.html">Writing Your First Program</a></li><li class="chapter-item "><a href="guides/guides.html">Program Examples</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li><li class="chapter-item "><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li><li class="chapter-item "><a href="guides/how-to-build-runes-swap.html">Runes Swap</a></li><li class="chapter-item "><a href="guides/how-to-build-lending-protocol.html">Lending Protocol</a></li></ol></li><li class="chapter-item "><li class="part-title">Arch Program Library (APL)</li><li class="chapter-item "><a href="apl/introduction.html">Introduction</a></li><li class="chapter-item "><a href="apl/token-program.html">Token Program</a></li><li class="chapter-item "><a href="apl/associated-token-account.html">Associated Token Account Program</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="concepts/architecture.html">Architecture Overview</a></li><li class="chapter-item "><a href="concepts/network-architecture.html">Network Architecture</a></li><li class="chapter-item "><a href="concepts/bitcoin-integration.html">Bitcoin Integration</a></li><li class="chapter-item "><a href="concepts/consensus.html">ROAST and FROST Consensus</a></li><li class="chapter-item "><a href="program/program.html">Programs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="program/utxo.html">UTXOs</a></li><li class="chapter-item "><a href="program/accounts.html">Accounts</a></li><li class="chapter-item "><a href="program/instructions-and-messages.html">Instructions</a></li><li class="chapter-item "><a href="program/syscall.html">System Calls</a></li></ol></li><li class="chapter-item "><a href="concepts/nodes.html">Node Operation</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="rpc/rpc.html">API Reference</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rpc/http-methods.html">HTTP Methods</a></li><li class="chapter-item "><a href="sdk/processed-transaction.html">Transaction Processing</a></li></ol></li><li class="chapter-item "><a href="system-program/system-program.html">System Program</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="system-program/create-account.html">Account Creation</a></li><li class="chapter-item "><a href="system-program/make-executable.html">Program Deployment</a></li></ol></li><li class="chapter-item "><li class="part-title">Resources</li><li class="chapter-item "><a href="getting-started/troubleshooting.html">Troubleshooting</a></li><li class="chapter-item "><a href="getting-started/faq.html">FAQ</a></li><li class="chapter-item "><a href="getting-started/resources.html">External Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Arch Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arch-network/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-arch-network"><a class="header" href="#welcome-to-arch-network">Welcome to Arch Network</a></h1>
<div class="info">
This documentation is actively maintained. If you find any issues or have suggestions for improvements, please visit our <a href="https://github.com/arch-network/docs">GitHub repository</a>.
</div>
<div style="float: right; margin: 0 0 20px 20px; max-width: 40%;">
    <img src="images/coders.png" alt="Developer coding" style="width: 100%; height: auto;">
</div>
<h2 id="what-is-arch-network"><a class="header" href="#what-is-arch-network">What is Arch Network?</a></h2>
<p>Arch Network is a computation environment that enhances Bitcoin‚Äôs capabilities by enabling complex operations on Bitcoin UTXOs through its specialized virtual machine. Unlike Layer 2 solutions, Arch Network provides a native computation layer that works directly with Bitcoin‚Äôs security model.</p>
<h2 id="choose-your-path-"><a class="header" href="#choose-your-path-">Choose Your Path üëã</a></h2>
<div class="path-selector">
    <div class="path-option">
        <h3 id="-deploy-first"><a class="header" href="#-deploy-first">üöÄ Deploy First</a></h3>
        <p>Get your first smart contract running on Arch Network as quickly as possible</p>
        <ul>
            <li>Download CLI and deploy a program in 15 minutes</li>
            <li>Use our pre-configured development environment</li>
            <li>Perfect for developers wanting to try Arch Network</li>
        </ul>
        <a href="getting-started/quick-start.html" class="button">Start Building ‚Üí</a>
    </div>
</div>
<h3 id="-run-a-validator"><a class="header" href="#-run-a-validator">üèóÔ∏è Run a Validator</a></h3>
<p>Set up and run your own validator node on the Arch Network</p>
<ul>
<li>Set up Bitcoin Core and Titan</li>
<li>Configure and run a validator node</li>
<li>Perfect for those wanting to participate in network security</li>
</ul>
<p><a href="getting-started/bitcoin-and-titan-setup.html">Start Running ‚Üí</a></p>
<div class="network-selector">
    <h3 id="network-options"><a class="header" href="#network-options">Network Options</a></h3>
    <div class="network-grid">
        <div class="network-option">
            <h4 id="-regtest"><a class="header" href="#-regtest">üîß Regtest</a></h4>
            <p>Local development environment with instant block confirmation. Perfect for development and testing.</p>
        </div>
        <div class="network-option">
            <h4 id="-testnet"><a class="header" href="#-testnet">üß™ Testnet</a></h4>
            <p>Test network with real Bitcoin testnet integration. For testing in a live environment.</p>
        </div>
    </div>
</div>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<div class="feature-grid">
<div class="feature">
    <h4 id="bitcoin-native"><a class="header" href="#bitcoin-native">Bitcoin-Native</a></h4>
    <p>Direct <a href="concepts/bitcoin-integration.html">integration with Bitcoin</a> through UTXO management</p>
</div>
<div class="feature">
    <h4 id="computation-environment"><a class="header" href="#computation-environment">Computation Environment</a></h4>
    <p>Execute complex programs within the <a href="concepts/architecture.html">Arch VM</a></p>
</div>
<div class="feature">
    <h4 id="program-development"><a class="header" href="#program-development">Program Development</a></h4>
    <p>Write <a href="program/program.html">programs in Rust</a> to interact with <a href="program/utxo.html">Bitcoin UTXOs</a></p>
</div>
<div class="feature">
    <h4 id="security"><a class="header" href="#security">Security</a></h4>
    <p>Leverages Bitcoin's proven security guarantees through <a href="concepts/network-architecture.html#security-model">multi-signature validation</a></p>
</div>
<div class="feature">
    <h4 id="developer-tools"><a class="header" href="#developer-tools">Developer Tools</a></h4>
    <p>Complete development environment with <a href="getting-started/environment-setup.html">CLI tools</a> and explorer</p>
</div>
</div>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<div class="prerequisites-box">
Before you begin, ensure you have:
<ul>
<li>Node.js v19+ (<a href="getting-started/requirements.html">installation guide</a>)</li>
<li>Rust (latest stable)</li>
<li>Docker for local development</li>
<li>Basic understanding of <a href="program/utxo.html">Bitcoin UTXOs</a></li>
</ul>
</div>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<h3 id="how-arch-works"><a class="header" href="#how-arch-works">How Arch Works</a></h3>
<div class="architecture-overview">
Arch Network consists of three main components:
<ol>
<li><strong>Network Layer</strong></li>
</ol>
<ul>
<li><a href="concepts/network-architecture.html">Network Architecture</a>
<ul>
<li><a href="concepts/network-architecture.html#1-bootnode">Bootnode</a>: Network discovery and peer management</li>
<li><a href="concepts/network-architecture.html#2-leader-node">Leader Node</a>: Transaction coordination</li>
<li><a href="concepts/network-architecture.html#3-validator-nodes">Validator Nodes</a>: Program execution</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Bitcoin Integration</strong></li>
</ol>
<ul>
<li><a href="concepts/bitcoin-integration.html#1-utxo-management">UTXO Management</a>
<ul>
<li>Transaction tracking</li>
<li>State anchoring</li>
<li>Ownership validation</li>
</ul>
</li>
<li><a href="concepts/bitcoin-integration.html#2-bitcoin-rpc-integration">RPC Integration</a>
<ul>
<li>Bitcoin node communication</li>
<li>Transaction submission</li>
<li>Network synchronization</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Computation Layer</strong></li>
</ol>
<ul>
<li><a href="program/program.html">Programs</a>
<ul>
<li><a href="program/instructions-and-messages.html">Instructions</a></li>
<li><a href="program/accounts.html">Accounts</a></li>
<li><a href="program/syscall.html">System Calls</a></li>
</ul>
</li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a>
<ul>
<li>Message validation</li>
<li>State updates</li>
<li>UTXO management</li>
</ul>
</li>
</ul>
</div>
<h3 id="-reference-documentation"><a class="header" href="#-reference-documentation">üõ† Reference Documentation</a></h3>
<div class="reference-grid">
Technical documentation:
<ul>
<li><a href="rpc/rpc.html">API Reference</a>
<ul>
<li><a href="rpc/http-methods.html">HTTP Methods</a></li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a></li>
</ul>
</li>
<li><a href="guides/how-to-write-arch-program.html">Program Examples</a>
<ul>
<li><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li>
</ul>
</li>
<li><a href="system-program/system-program.html">System Program</a>
<ul>
<li><a href="system-program/create-account.html">Account Creation</a></li>
<li><a href="system-program/make-executable.html">Program Deployment</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="need-help"><a class="header" href="#need-help">Need Help?</a></h2>
<div class="help-box">
<ul>
<li><a href="https://discord.gg/archnetwork">Join our Discord</a></li>
<li><a href="concepts/architecture.html">Read the Architecture Overview</a></li>
<li><a href="guides/how-to-write-arch-program.html">View Example Programs</a></li>
<li><a href="concepts/network-architecture.html#monitoring-and-telemetry">Check Network Status</a></li>
<li><a href="rpc/rpc.html">API Reference</a></li>
</ul>
</div>
<div class="tip">
üí° <strong>Pro Tip:</strong> Use the search function (press 's' or '/' on your keyboard) to quickly find what you're looking for in the documentation.
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-quick-start-guide"><a class="header" href="#-quick-start-guide">üöÄ Quick Start Guide</a></h1>
<p>Welcome to Arch Network! Let‚Äôs get your first program running in under 15 minutes.</p>
<h2 id="-what-youll-build"><a class="header" href="#-what-youll-build">üéØ What You‚Äôll Build</a></h2>
<pre class="mermaid">graph LR
    A[Your Program] --&gt;|Deploy| B[Local Validator]
    B --&gt;|Execute| C[Arch Network]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef program fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef network fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    class A program
    class B validator
    class C network
    linkStyle default stroke:#a4b0be,stroke-width:2px
</pre>
<h2 id="-time-estimate"><a class="header" href="#-time-estimate">‚è±Ô∏è Time Estimate</a></h2>
<ul>
<li>Total time: ~15 minutes</li>
<li>Active time: ~10 minutes</li>
<li>Waiting time: ~5 minutes (during installations)</li>
</ul>
<h2 id="-quick-setup"><a class="header" href="#-quick-setup">üìã Quick Setup</a></h2>
<h3 id="1-install-cli-2-minutes"><a class="header" href="#1-install-cli-2-minutes">1. Install CLI (2 minutes)</a></h3>
<p>Download the appropriate binary for your system from the <a href="https://github.com/Arch-Network/arch-node/releases/latest">latest releases page</a>:</p>
<div class="network-mode-container">
<div class="network-mode-header">
    <h4 id="arch-mode-title"><a class="header" href="#arch-mode-title">macOS - Apple Silicon (M1/M2/M3)</a></h4>
</div>
<div class="network-mode-content">
<div id="mac-arm-command">
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div id="mac-intel-command" style="display: none;">
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div id="linux-x64-command" style="display: none;">
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div id="linux-arm-command" style="display: none;">
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
</div>
<div class="network-mode-buttons">
    <button class="network-mode-button active" onclick="switchArch('mac-arm')">macOS ARM</button>
    <button class="network-mode-button" onclick="switchArch('mac-intel')">macOS Intel</button>
    <button class="network-mode-button" onclick="switchArch('linux-x64')">Linux x64</button>
    <button class="network-mode-button" onclick="switchArch('linux-arm')">Linux ARM</button>
</div>
</div>
<script>
function switchArch(arch) {
    // Update buttons
    document.querySelectorAll('.network-mode-button').forEach(btn => {
        btn.classList.remove('active');
        if (
            (arch === 'mac-arm' && btn.textContent.includes('macOS ARM')) ||
            (arch === 'mac-intel' && btn.textContent.includes('macOS Intel')) ||
            (arch === 'linux-x64' && btn.textContent.includes('Linux x64')) ||
            (arch === 'linux-arm' && btn.textContent.includes('Linux ARM'))
        ) {
            btn.classList.add('active');
        }
    });

    // Update title
    const title = document.getElementById('arch-mode-title');
    switch (arch) {
        case 'mac-arm':
            title.textContent = 'macOS - Apple Silicon (M1/M2/M3)';
            break;
        case 'mac-intel':
            title.textContent = 'macOS - Intel';
            break;
        case 'linux-x64':
            title.textContent = 'Linux - x86_64';
            break;
        case 'linux-arm':
            title.textContent = 'Linux - ARM64';
            break;
    }

    // Show/hide appropriate command
    document.getElementById('mac-arm-command').style.display = arch === 'mac-arm' ? 'block' : 'none';
    document.getElementById('mac-intel-command').style.display = arch === 'mac-intel' ? 'block' : 'none';
    document.getElementById('linux-x64-command').style.display = arch === 'linux-x64' ? 'block' : 'none';
    document.getElementById('linux-arm-command').style.display = arch === 'linux-arm' ? 'block' : 'none';
}
</script>
<p>After installation, verify it works:</p>
<pre><code class="language-bash">cli --version
</code></pre>
<h3 id="2-start-local-validator-1-minute"><a class="header" href="#2-start-local-validator-1-minute">2. Start Local Validator (1 minute)</a></h3>
<p>Start the local validator:</p>
<div class="network-mode-container">
<div class="network-mode-header">
    <h4 id="network-mode-title"><a class="header" href="#network-mode-title">Development Network (Default)</a></h4>
</div>
<div class="network-mode-content">
<div id="dev-network-command">
<pre><code class="language-bash"># Start a local validator
cli validator-start \
    --network-mode devnet \
    --data-dir ./.arch_data \
    --rpc-bind-ip 127.0.0.1 \
    --rpc-bind-port 9002 \
    --titan-endpoint titan-node.dev.aws.archnetwork.xyz \
    --titan-socket-endpoint titan-node.dev.aws.archnetwork.xyz:18443
</code></pre>
</div>
<div id="test-network-command" style="display: none;">
<pre><code class="language-bash"># Start a local validator
cli validator-start \
    --network-mode testnet \
    --data-dir ./.arch_data \
    --rpc-bind-ip 127.0.0.1 \
    --rpc-bind-port 9002 \
    --titan-endpoint titan-node.test.aws.archnetwork.xyz \
    --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
</div>
</div>
<div class="network-mode-buttons">
    <button class="network-mode-button active" onclick="switchNetwork('dev')">Development Network</button>
    <button class="network-mode-button" onclick="switchNetwork('test')">Test Network</button>
</div>
</div>
<style>
.network-mode-container {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
}

.network-mode-header h4 {
    margin: 0;
    padding: 0.5rem 0;
    color: #ff4757;
}

.network-mode-buttons {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
}

.network-mode-button {
    padding: 0.5rem 1rem;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background: #fff;
    cursor: pointer;
    font-size: 0.9rem;
}

.network-mode-button.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
}

.network-mode-button:hover:not(.active) {
    background: #f1f3f5;
}
</style>
<script>
function switchNetwork(mode) {
    // Update buttons
    document.querySelectorAll('.network-mode-button').forEach(btn => {
        btn.classList.remove('active');
        if ((mode === 'dev' && btn.textContent.includes('Development')) ||
            (mode === 'test' && btn.textContent.includes('Test'))) {
            btn.classList.add('active');
        }
    });

    // Update title
    const title = document.getElementById('network-mode-title');
    title.textContent = mode === 'dev' ? 'Development Network (Default)' : 'Test Network';

    // Show/hide appropriate command
    document.getElementById('dev-network-command').style.display = mode === 'dev' ? 'block' : 'none';
    document.getElementById('test-network-command').style.display = mode === 'test' ? 'block' : 'none';
}
</script>
<h3 id="3-clone-example-project-2-minutes"><a class="header" href="#3-clone-example-project-2-minutes">3. Clone Example Project (2 minutes)</a></h3>
<pre><code class="language-bash"># Get the starter example
git clone https://github.com/Arch-Network/arch-examples
cd arch-examples/examples/helloworld
</code></pre>
<h3 id="4-build-and-deploy-5-minutes"><a class="header" href="#4-build-and-deploy-5-minutes">4. Build and Deploy (5 minutes)</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="first-time-setup"><a class="header" href="#first-time-setup">First Time Setup</a></h4>
<p>If this is your first time building Arch programs, install the required dependencies:</p>
<details>
<summary>macOS Dependencies</summary>
<pre><code class="language-bash"># Install Rust if not already installed
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
# Install Solana CLI tools
sh -c "$(curl -sSfL https://release.solana.com/v1.18.18/install)"
</code></pre>
</details>
<details>
<summary>Linux Dependencies</summary>
<pre><code class="language-bash"># Install Rust if not already installed
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
# Install build essentials
sudo apt-get update &amp;&amp; sudo apt-get install -y build-essential
# Install Solana CLI tools
sh -c "$(curl -sSfL https://release.solana.com/v1.18.18/install)"
</code></pre>
</details>
</div>
</div>
<p>Build and deploy the program:</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy to your local validator
cli deploy ./target/deploy/helloworld.so
</code></pre>
<h2 id="-test-your-deployment"><a class="header" href="#-test-your-deployment">üéÆ Test Your Deployment</a></h2>
<p>Once deployed, you can interact with your program:</p>
<pre><code class="language-bash"># Show program information
cli show &lt;PROGRAM_ADDRESS&gt;

# Get block information
cli get-block &lt;BLOCK_HASH&gt;
</code></pre>
<h2 id="-ready-for-testnet"><a class="header" href="#-ready-for-testnet">üåê Ready for Testnet?</a></h2>
<p>When you‚Äôre ready to deploy to testnet:</p>
<pre><code class="language-bash">cli validator-start --network-mode testnet
cli deploy ./target/deploy/helloworld.so --network-mode testnet
</code></pre>
<h2 id="-next-steps"><a class="header" href="#-next-steps">üìö Next Steps</a></h2>
<ul>
<li><a href="getting-started/../guides/how-to-write-arch-program.html">Modify the Hello World program</a></li>
<li><a href="getting-started/../guides/how-to-create-a-fungible-token.html">Create a fungible token</a></li>
<li><a href="getting-started/../guides/how-to-build-runes-swap.html">Build a Runes swap application</a></li>
<li><a href="getting-started/bitcoin-and-titan-setup.html">Set up a full validator node</a></li>
</ul>
<h2 id="-need-help"><a class="header" href="#-need-help">üÜò Need Help?</a></h2>
<ul>
<li>Join our <a href="https://discord.gg/archnetwork">Discord</a> for real-time support</li>
<li>Check the <a href="getting-started/troubleshooting.html">Troubleshooting Guide</a></li>
<li>Browse the <a href="getting-started/faq.html">FAQ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-running-an-arch-network-validator"><a class="header" href="#-running-an-arch-network-validator">üèóÔ∏è Running an Arch Network Validator</a></h1>
<p>Welcome to the validator setup guide! This comprehensive guide will walk you through setting up a full Arch Network validator node, including all required components. As a validator, you‚Äôll be an integral part of the network‚Äôs security and computation infrastructure.</p>
<h2 id="-what-youll-build-1"><a class="header" href="#-what-youll-build-1">üéØ What You‚Äôll Build</a></h2>
<pre class="mermaid">graph TD
    A[Bitcoin Core] --&gt;|Blockchain Data| B[Titan]
    B --&gt;|Efficient Queries| C[Validator Node]
    C --&gt;|Participate in| D[Arch Network]
    D --&gt;|Secure| E[Bitcoin Network]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef bitcoin fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    classDef titan fill:#4a90e2,stroke:#357abd,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef arch fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    class A,E bitcoin
    class B titan
    class C validator
    class D arch
    linkStyle default stroke:#a4b0be,stroke-width:2px
</pre>
<h2 id="-understanding-your-role"><a class="header" href="#-understanding-your-role">üí° Understanding Your Role</a></h2>
<p>As a validator, you will:</p>
<ul>
<li>Execute smart contracts and validate transactions</li>
<li>Participate in network consensus</li>
<li>Help secure the Bitcoin integration</li>
<li>Earn rewards for your contribution</li>
</ul>
<h2 id="-system-requirements"><a class="header" href="#-system-requirements">üìã System Requirements</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>4+ CPU cores</li>
<li>16GB+ RAM</li>
<li>100GB+ SSD storage</li>
<li>Stable internet connection</li>
<li>Linux (Ubuntu 20.04+ or similar) or macOS (12.0+)</li>
</ul>
<h2 id="-setup-overview"><a class="header" href="#-setup-overview">üó∫Ô∏è Setup Overview</a></h2>
<ol>
<li>
<p><strong>Bitcoin Core Setup</strong> (30-45 minutes)</p>
<ul>
<li>Install dependencies</li>
<li>Build from source</li>
<li>Configure for your network</li>
</ul>
</li>
<li>
<p><strong>Titan Setup</strong> (15-20 minutes)</p>
<ul>
<li>Build our custom fork</li>
<li>Configure for your network</li>
</ul>
</li>
<li>
<p><strong>Validator Setup</strong> (10-15 minutes)</p>
<ul>
<li>Install Arch Network CLI</li>
<li>Configure validator node</li>
<li>Join the network</li>
</ul>
</li>
</ol>
<p>Total estimated time: 1-1.5 hours</p>
<h2 id="-what-were-building"><a class="header" href="#-what-were-building">üéØ What We‚Äôre Building</a></h2>
<pre class="mermaid">graph TD
    A[Your dApp] --&gt;|Interacts with| B[Local Validator]
    B --&gt;|Queries| C[Titan]
    C --&gt;|Reads| D[Bitcoin Core]
    D --&gt;|Manages| E[Local Blockchain]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef dapp fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef titan fill:#4a90e2,stroke:#357abd,stroke-width:2px,rx:10px,ry:10px
    classDef bitcoin fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    classDef blockchain fill:#a4b0be,stroke:#747d8c,stroke-width:2px,rx:10px,ry:10px
    class A dapp
    class B validator
    class C titan
    class D bitcoin
    class E blockchain
    linkStyle default stroke:#a4b0be,stroke-width:2px
</pre>
<h3 id="-understanding-the-components"><a class="header" href="#-understanding-the-components">üß© Understanding the Components</a></h3>
<h4 id="bitcoin-core-"><a class="header" href="#bitcoin-core-">Bitcoin Core üè¶</a></h4>
<ul>
<li>Your personal Bitcoin node</li>
<li>Manages a local blockchain in regtest mode</li>
<li>Perfect for development - create test Bitcoin at will!</li>
</ul>
<h4 id="titan-"><a class="header" href="#titan-">Titan ‚ö°</a></h4>
<ul>
<li>Lightning-fast Bitcoin data indexer</li>
<li>Makes blockchain queries super efficient</li>
<li>Essential for real-time dApp responses</li>
</ul>
<h2 id="-progress-tracker"><a class="header" href="#-progress-tracker">üìã Progress Tracker</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Install Bitcoin Core dependencies</li>
<li><input disabled="" type="checkbox"/>
Build Bitcoin Core</li>
<li><input disabled="" type="checkbox"/>
Configure Bitcoin Core</li>
<li><input disabled="" type="checkbox"/>
Test Bitcoin Core</li>
<li><input disabled="" type="checkbox"/>
Build Titan</li>
<li><input disabled="" type="checkbox"/>
Configure Titan</li>
<li><input disabled="" type="checkbox"/>
Test the full stack</li>
</ul>
<h2 id="1--bitcoin-core-setup"><a class="header" href="#1--bitcoin-core-setup">1. üèóÔ∏è Bitcoin Core Setup</a></h2>
<h3 id="11-installing-dependencies"><a class="header" href="#11-installing-dependencies">1.1 Installing Dependencies</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<pre><code class="language-bash"># Install required dependencies via Homebrew
brew install automake boost ccache git libevent libnatpmp libtool \
    llvm miniupnpc pkg-config python qrencode qt@5 sqlite zeromq
</code></pre>
</div>
<div class="platform-option">
<h4 id="ubuntudebian-linux"><a class="header" href="#ubuntudebian-linux">Ubuntu/Debian Linux</a></h4>
<pre><code class="language-bash"># Install required dependencies
sudo apt-get update &amp;&amp; sudo apt-get install -y \
    automake autotools-dev bsdmainutils build-essential ccache \
    clang gcc git libboost-dev libboost-filesystem-dev \
    libboost-system-dev libboost-test-dev libevent-dev \
    libminiupnpc-dev libnatpmp-dev libsqlite3-dev libtool \
    libzmq3-dev pkg-config python3 qtbase5-dev qttools5-dev \
    qttools5-dev-tools qtwayland5 systemtap-sdt-dev
</code></pre>
</div>
<div class="platform-option">
<h4 id="rhelfedora-linux"><a class="header" href="#rhelfedora-linux">RHEL/Fedora Linux</a></h4>
<pre><code class="language-bash"># Install required dependencies
sudo dnf install -y automake boost-devel ccache clang gcc git \
    libevent-devel libnatpmp-devel libtool make miniupnpc-devel \
    pkg-config python3 qt5-qtbase-devel qt5-qttools-devel \
    sqlite-devel systemtap-sdt-devel zeromq-devel
</code></pre>
</div>
</div>
<h3 id="12--building-bitcoin-core"><a class="header" href="#12--building-bitcoin-core">1.2 üè≠ Building Bitcoin Core</a></h3>
<pre><code class="language-bash"># Clone Bitcoin Core
git clone https://github.com/bitcoin/bitcoin.git
cd bitcoin

# Switch to latest stable version
git checkout v28.0

# Prepare the build system
./autogen.sh

# Configure the build
./configure

# Build Bitcoin Core (this might take 30-45 minutes)
make -j$(nproc)  # Uses all available CPU cores

# Install the binaries
sudo make install
</code></pre>
<h3 id="13--bitcoin-core-configuration"><a class="header" href="#13--bitcoin-core-configuration">1.3 ‚öôÔ∏è Bitcoin Core Configuration</a></h3>
<p>Create your configuration directory:</p>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos-1"><a class="header" href="#macos-1">macOS</a></h4>
<pre><code class="language-bash">mkdir -p ~/Library/'Application Support'/Bitcoin
CONFIG_DIR=~/Library/'Application Support'/Bitcoin
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<pre><code class="language-bash">mkdir -p ~/.bitcoin
CONFIG_DIR=~/.bitcoin
</code></pre>
</div>
</div>
<p>Create and edit your configuration file:</p>
<pre><code class="language-bash">cat &gt; "$CONFIG_DIR/bitcoin.conf" &lt;&lt; 'EOF'
# üåê Network Settings
server=1
regtest=1
txindex=1
prune=0

# üîí Security (Change these values in production!)
rpcuser=bitcoin
rpcpassword=bitcoinpass  

# üîß Performance
dbcache=150
maxmempool=100

# üöÄ Development Settings
fallbackfee=0.001
maxtxfee=0.002

[regtest]
rpcbind=0.0.0.0
rpcport=18443
wallet=testwallet
EOF
</code></pre>
<h3 id="14--launch-bitcoin-core"><a class="header" href="#14--launch-bitcoin-core">1.4 üöÄ Launch Bitcoin Core</a></h3>
<pre><code class="language-bash"># Start Bitcoin Core in regtest mode
bitcoind -regtest -daemon

# Verify it's running
bitcoin-cli -regtest getblockchaininfo
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h1>
<p>Welcome to the Arch Network development guide. This page will walk you through setting up your development environment with all necessary dependencies. Please follow each section carefully to ensure a smooth setup process.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Before you begin development with Arch Network, you‚Äôll need to install and configure the following tools:</p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Minimum Version</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="getting-started/requirements.html#install-rust">Rust</a></td><td>Latest stable</td><td>Core development language</td></tr>
<tr><td><a href="getting-started/requirements.html#install-c-compiler">C++ Compiler</a></td><td>gcc/clang</td><td>Required for native builds</td></tr>
<tr><td><a href="getting-started/requirements.html#install-solana-cli">Solana CLI</a></td><td>v1.18.18</td><td>Solana development tools</td></tr>
<tr><td><a href="getting-started/requirements.html#install-arch-network-cli">Arch Network CLI</a></td><td>Latest</td><td>Arch Network development toolkit</td></tr>
</tbody></table>
</div>
<h2 id="detailed-installation-guide"><a class="header" href="#detailed-installation-guide">Detailed Installation Guide</a></h2>
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<p>Rust is the primary development language for Arch Network programs.</p>
<pre><code class="language-bash"># Install Rust using rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Verify installation
rustc --version
cargo --version
</code></pre>
<blockquote>
<p>üí° <strong>Note:</strong> Make sure you‚Äôre using the stable channel throughout this book.</p>
</blockquote>
<h3 id="2-c-compiler-setup"><a class="header" href="#2-c-compiler-setup">2. C++ Compiler Setup</a></h3>
<h4 id="macos-users"><a class="header" href="#macos-users">MacOS Users</a></h4>
<p>The C++ compiler comes pre-installed with Xcode Command Line Tools. Verify with:</p>
<pre><code class="language-bash">gcc --version
</code></pre>
<p>If not installed, run:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<h4 id="linux-users-debianubuntu"><a class="header" href="#linux-users-debianubuntu">Linux Users (Debian/Ubuntu)</a></h4>
<p>Install the required compiler tools:</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install gcc-multilib build-essential jq
</code></pre>
<h3 id="3-install-solana-cli"><a class="header" href="#3-install-solana-cli">3. Install Solana CLI</a></h3>
<p>The Solana CLI is required for program compilation and deployment.</p>
<pre><code class="language-bash">sh -c "$(curl -sSfL https://release.anza.xyz/v2.1.13/install)"
</code></pre>
<blockquote>
<p>‚ö†Ô∏è <strong>Important Notes:</strong></p>
<ul>
<li>Add Solana to your PATH as instructed after installation</li>
</ul>
</blockquote>
<h4 id="troubleshooting-solana-installation"><a class="header" href="#troubleshooting-solana-installation">Troubleshooting Solana Installation</a></h4>
<p>If you installed Rust through Homebrew and encounter <code>cargo-build-sbf</code> issues:</p>
<ol>
<li>Remove existing Rust installation:</li>
</ol>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<ol start="2">
<li>Verify removal:</li>
</ol>
<pre><code class="language-bash">rustup --version  # Should show "command not found"
</code></pre>
<ol start="3">
<li>Perform clean Rust installation:</li>
</ol>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<ol start="4">
<li>Reinstall Solana:</li>
</ol>
<pre><code class="language-bash">sh -c "$(curl -sSfL https://release.solana.com/v1.18.18/install)"
</code></pre>
<h3 id="4-install-arch-network-cli"><a class="header" href="#4-install-arch-network-cli">4. Install Arch Network CLI</a></h3>
<p>The Arch Network CLI provides essential development tools and a local development environment.</p>
<pre><code class="language-bash"># Download the appropriate CLI binary for your architecture from:
# https://github.com/Arch-Network/arch-node/releases/latest
# For example, for macOS with Apple Silicon:
curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/

# Verify installation
cli --version
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>The Arch Network CLI provides:</p>
<ul>
<li>Local validator node for development</li>
<li>Program deployment and management</li>
<li>Account and transaction management</li>
<li>Block data and program logging</li>
<li>Group key and network controls</li>
</ul>
<h2 id="need-help-1"><a class="header" href="#need-help-1">Need Help?</a></h2>
<ul>
<li>Check our <a href="getting-started/requirements.html#troubleshooting-solana-installation">Troubleshooting Guide</a></li>
<li>Join our <a href="https://discord.com/channels/1241112027963986001/1270921925991989268">Discord dev-chat</a> for community support</li>
<li>Review the <a href="https://github.com/arch-network/arch-node/releases">Arch Network CLI repo</a> documentation</li>
<li>Ensure all version requirements are met</li>
</ul>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-configure-the-local-validator-with-bitcoin-testnet4"><a class="header" href="#how-to-configure-the-local-validator-with-bitcoin-testnet4">How to configure the local validator with Bitcoin Testnet4</a></h1>
<p>This guide is intended for those wishing to view logs from their programs while benefitting from being connected to Bitcoin testnet4 and therefore gaining access to ordinals/runes helper tools.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#config">Config</a></li>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#local-validator">Local validator</a></li>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#help-commands">Help commands</a></li>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#log-assistance">Log assistance</a></li>
</ul>
<h3 id="config"><a class="header" href="#config">Config</a></h3>
<p>First, you‚Äôll need to configure the network settings for connecting to Bitcoin testnet4. The CLI accepts these parameters directly when starting the validator.</p>
<blockquote>
<p>Note: We have redacted our Bitcoin node password to prevent abuse; contact us if you need this, otherwise provide your own node credentials and use the below as a reference.</p>
</blockquote>
<p>When starting the validator, you can include the following parameters:</p>
<pre><code class="language-bash">cli validator-start \
  --network-mode testnet \
  --data-dir ./.arch_data \
  --rpc-bind-ip 127.0.0.1 \
  --rpc-bind-port 9002 \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<p>Optional parameters:</p>
<ul>
<li><code>--data-dir</code> - Directory for storing validator data (default: ./.arch_data)</li>
<li><code>--rpc-bind-ip</code> - IP Address for the RPC handler (default: 127.0.0.1)</li>
<li><code>--rpc-bind-port</code> - Port for the RPC handler (default: 9002)</li>
<li><code>--titan-endpoint</code> - HTTP endpoint for the Titan node</li>
<li><code>--titan-socket-endpoint</code> - WebSocket endpoint for the Titan node</li>
</ul>
<h3 id="local-validator"><a class="header" href="#local-validator">Local validator</a></h3>
<blockquote>
<p>Note: You can start a local validator using the Arch Network CLI tool.</p>
<p>Additionally, you can download pre-built binaries from the <a href="https://github.com/Arch-Network/arch-node/releases">arch-node releases page</a>.</p>
<p><strong>Be sure to download the local validator binary, not the regular validator.</strong></p>
</blockquote>
<h4 id="run-the-local-validator"><a class="header" href="#run-the-local-validator">Run the local validator</a></h4>
<p>Use the CLI command to run the local validator. You‚Äôll need to have <a href="https://docker.com">Docker</a> installed and running.</p>
<pre><code class="language-bash">cli validator-start --network-mode testnet
</code></pre>
<p>The validator logs can be viewed easily within the <a href="https://docker.com">Docker</a> desktop dashboard.</p>
<blockquote>
<p>Note: You can also run the standalone local validator binary where the logs will be streamed to <code>stdout</code> unless otherwise redirected.</p>
</blockquote>
<p><strong>Steps for running standalone validator binary:</strong></p>
<ol>
<li>
<p>Download the appropriate binary as well as the <code>system_program.so</code> file from <a href="https://github.com/Arch-Network/arch-node/releases/latest">arch-node releases page</a>.</p>
</li>
<li>
<p>Store the <code>system_program.so</code> file within a new directory called <code>/ebpf</code>.</p>
<p>Your directory structure should resemble the following:</p>
<pre><code class="language-bash">tmp/
‚îú‚îÄ ebpf/
‚îÇ  ‚îú‚îÄ system_program.so
‚îú‚îÄ local_validator
</code></pre>
</li>
<li>
<p>Run the binary and pass the relevant flags dependening on your target network.</p>
<pre><code class="language-bash">RUST_LOG=info \
./local_validator \
--network-mode testnet \
--rpc-bind-ip 127.0.0.1 \
--rpc-bind-port 9002 \
--titan-endpoint titan-node.test.aws.archnetwork.xyz \
--titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
</li>
</ol>
<h3 id="help-commands"><a class="header" href="#help-commands">Help commands</a></h3>
<p>This section includes some helpful material when needing to restart the node state or better ensure our infrastructure is operational before proceeding.</p>
<h4 id="arch-node"><a class="header" href="#arch-node">Arch node</a></h4>
<p>The below commands can be used to assist with running the <a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#local-validator">Local validator</a>.</p>
<h5 id="start-fresh"><a class="header" href="#start-fresh">Start fresh</a></h5>
<p>By removing the <code>/.arch_data</code> directory, we can wipe the state and effective start the node again from genesis (block: 0).</p>
<pre><code class="language-bash">rm -rf .arch_data &amp;&amp; RUST_LOG=info \
./local_validator \
--network-mode testnet \
--rpc-bind-ip 127.0.0.1 \
--rpc-bind-port 9002 \
--titan-endpoint titan-node.test.aws.archnetwork.xyz \
--titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h5 id="pulse-check"><a class="header" href="#pulse-check">Pulse check</a></h5>
<p>This <code>cURL</code> command will allow us to ensure that our <a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#local-validator">Local validator</a> is up and running correctly. We can use this to effective get a pulse check on the node which is helpful for debugging.</p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<h3 id="log-assistance"><a class="header" href="#log-assistance">Log assistance</a></h3>
<p>Ordinarily, the arch-node logs will flood your terminal screen (or the <a href="https://docker.com">Docker</a> logs). This is less than idea when needing to review them carefully, so you can also direct the <code>stdout</code> to a file for later reading.</p>
<p>Here‚Äôs an example of how to do this:</p>
<pre><code class="language-bash">rm -rf .arch_data &amp;&amp; RUST_LOG=info \
./local_validator \
--network-mode testnet \
--rpc-bind-ip 127.0.0.1 \
--rpc-bind-port 9002 \
--titan-endpoint titan-node.test.aws.archnetwork.xyz \
--titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332 \
&gt; node-logs.txt
</code></pre>
<p>Then you can <code>tail</code> the output and view the logs as they stream in.</p>
<pre><code class="language-bash">tail -f node-logs.txt
</code></pre>
<h3 id="deploy--interact"><a class="header" href="#deploy--interact">Deploy + interact</a></h3>
<p>Now that everything is setup correctly, we can now deploy our program and begin interacting with it. The deploy step will prove everything works correctly.</p>
<pre><code class="language-bash">cli deploy --network-mode testnet
</code></pre>
<p>And if you are running the local validator binary directly from the command-line, set the <code>--rpc-url</code> flag to specify your validator endpoint:</p>
<pre><code class="language-bash">cli deploy --network-mode testnet --rpc-url http://localhost:9002
</code></pre>
<p>We hope this guide has been helpful, but as always, feel free to ask question within our <a href="https://discord.com/channels/1241112027963986001/1270921925991989268">Discord dev-chat</a> or submit issues within out <a href="https://github.com/arch-network/public-issues">public-issues</a> repo.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="validator-staking-guide"><a class="header" href="#validator-staking-guide">Validator Staking Guide</a></h1>
<p>This guide will walk you through the process of staking ARCH tokens to become a validator on the Arch Network. As a validator, you‚Äôll be an integral part of the network‚Äôs security and computation infrastructure.</p>
<div class="toc">
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<div class="toc-list">
<a href="getting-started/validator-staking.html#prerequisites" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">01</span>
        <span class="toc-text">Prerequisites</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#validator-responsibilities" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">02</span>
        <span class="toc-text">Validator Responsibilities</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#setup-and-configuration" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">03</span>
        <span class="toc-text">Setup & Configuration</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#monitoring-and-maintenance" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">04</span>
        <span class="toc-text">Monitoring & Maintenance</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
</div>
</div>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<div class="requirement-grid">
<div class="requirement-card">
<h3 id="-system-requirements-1"><a class="header" href="#-system-requirements-1">üñ•Ô∏è System Requirements</a></h3>
<table>
<tr><th>Component</th><th>Minimum</th><th>Recommended</th></tr>
<tr><td>CPU</td><td>4+ cores</td><td>8+ cores</td></tr>
<tr><td>RAM</td><td>16GB</td><td>32GB</td></tr>
<tr><td>Storage</td><td>100GB SSD</td><td>500GB+ SSD</td></tr>
<tr><td>Network</td><td>100Mbps</td><td>1Gbps+</td></tr>
<tr><td>OS</td><td>Ubuntu 20.04+ / macOS 12.0+</td><td>Latest LTS</td></tr>
</table>
</div>
<div class="requirement-card">
<h3 id="-arch-tokens"><a class="header" href="#-arch-tokens">üîë ARCH Tokens</a></h3>
<p>Contact the Arch Network team for current staking requirements, including:</p>
<ul>
<li>Minimum stake amounts</li>
<li>Lockup periods</li>
<li>Commission rates</li>
</ul>
</div>
</div>
<h2 id="validator-responsibilities"><a class="header" href="#validator-responsibilities">Validator Responsibilities</a></h2>
<div class="responsibility-grid">
<div class="responsibility-card">
<h3 id="-transaction-processing"><a class="header" href="#-transaction-processing">üîÑ Transaction Processing</a></h3>
<ul>
<li>Execute programs in Arch VM</li>
<li>Validate transaction signatures</li>
<li>Process Bitcoin-related transactions</li>
<li>Maintain transaction history</li>
</ul>
</div>
<div class="responsibility-card">
<h3 id="-consensus-participation"><a class="header" href="#-consensus-participation">ü§ù Consensus Participation</a></h3>
<ul>
<li>Participate in ROAST protocol</li>
<li>Contribute to threshold signing</li>
<li>Coordinate transaction finality</li>
<li>Verify state transitions</li>
</ul>
</div>
<div class="responsibility-card">
<h3 id="-state-management"><a class="header" href="#-state-management">üìä State Management</a></h3>
<ul>
<li>Track UTXO states</li>
<li>Validate Bitcoin operations</li>
<li>Maintain state consistency</li>
<li>Verify network state</li>
</ul>
</div>
</div>
<h2 id="setup--configuration"><a class="header" href="#setup--configuration">Setup &amp; Configuration</a></h2>
<h3 id="1-install-arch-network-cli"><a class="header" href="#1-install-arch-network-cli">1. Install Arch Network CLI</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos---apple-silicon"><a class="header" href="#macos---apple-silicon">macOS - Apple Silicon</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="macos---intel"><a class="header" href="#macos---intel">macOS - Intel</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---x86_64"><a class="header" href="#linux---x86_64">Linux - x86_64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---arm64"><a class="header" href="#linux---arm64">Linux - ARM64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
</div>
<p>Verify installation:</p>
<pre><code class="language-bash">cli --version
</code></pre>
<h3 id="2-configure-bitcoin-node-access"><a class="header" href="#2-configure-bitcoin-node-access">2. Configure Bitcoin Node Access</a></h3>
<div class="network-select">
<div class="network-option">
<h4 id="-remote-node-recommended"><a class="header" href="#-remote-node-recommended">üì° Remote Node (Recommended)</a></h4>
<p><strong>Regtest/Development:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint bitcoin-node.dev.aws.archnetwork.xyz \
--bitcoin-rpc-port 18443 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testwallet
</code></pre>
<p><strong>Testnet:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint bitcoin-node.test.aws.archnetwork.xyz \
--bitcoin-rpc-port 49332 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testwallet
</code></pre>
</div>
<div class="network-option">
<h4 id="-local-node"><a class="header" href="#-local-node">üñ•Ô∏è Local Node</a></h4>
<p>For advanced users who want full control. See our <a href="getting-started/bitcoin-and-titan-setup.html">Bitcoin Node Setup Guide</a>.</p>
<p><strong>Local Regtest Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 18443 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet regtest
</code></pre>
<p><strong>Local Testnet Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 18332 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testnet
</code></pre>
<p><strong>Local Mainnet Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 8332 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet mainnet
</code></pre>
</div>
</div>
<h3 id="3-start-your-validator"><a class="header" href="#3-start-your-validator">3. Start Your Validator</a></h3>
<pre><code class="language-bash">cli validator start \
  --network-mode mainnet \
  --titan-rpc-endpoint your_endpoint \
  --titan-rpc-port your_port \
  --titan-rpc-username your_username \
  --titan-rpc-password your_password \
  --titan-rpc-wallet your_wallet
</code></pre>
<h2 id="monitoring--maintenance"><a class="header" href="#monitoring--maintenance">Monitoring &amp; Maintenance</a></h2>
<div class="monitoring-grid">
<div class="monitoring-card">
<h3 id="-health-checks"><a class="header" href="#-health-checks">üìä Health Checks</a></h3>
<pre><code class="language-bash"># Node status
cli validator status

# Performance metrics
cli validator metrics
</code></pre>
</div>
<div class="monitoring-card">
<h3 id="-sync-management"><a class="header" href="#-sync-management">üîÑ Sync Management</a></h3>
<pre><code class="language-bash"># Check sync status
cli validator sync-status

# Force resync if needed
cli validator resync
</code></pre>
</div>
</div>
<h2 id="understanding-staking-in-arch-network"><a class="header" href="#understanding-staking-in-arch-network">Understanding Staking in Arch Network</a></h2>
<div class="staking-explanation">
<h3 id="-what-is-staking"><a class="header" href="#-what-is-staking">üîê What is Staking?</a></h3>
<p>Staking in Arch Network is fundamentally different from traditional Proof of Stake systems. Instead of using staking for consensus, Arch Network uses staked validators to participate in the ROAST protocol for secure Bitcoin transaction signing.</p>
<pre class="mermaid">flowchart TB
    subgraph Staking[&quot;Staking Process&quot;]
        direction TB
        V[Validator Node] --&gt;|1. Stakes ARCH| N[Network]
        N --&gt;|2. Assigns Share| DKG[Distributed Key]
        DKG --&gt;|3. Participates in| ROAST[ROAST Protocol]
    end

    subgraph Validation[&quot;Transaction Validation&quot;]
        direction TB
        TX[Transaction] --&gt;|1. Submitted| L[Leader]
        L --&gt;|2. Distributes| VS[Validator Set]
        VS --&gt;|3. Execute &amp; Sign| R[Results]
        R --&gt;|4. Aggregate| BTC[Bitcoin Network]
    end

    style Staking fill:#f3e5f5,stroke:#4a148c
    style Validation fill:#e8f5e9,stroke:#1b5e20
</pre>
<h3 id="-solana-vs-arch-network-validator-comparison"><a class="header" href="#-solana-vs-arch-network-validator-comparison">ü§î Solana vs. Arch Network: Validator Comparison</a></h3>
<div class="comparison-table">
<table>
<tr><th>Feature</th><th>Solana</th><th>Arch Network</th></tr>
<tr>
  <td><b>Consensus Role</b></td>
  <td>Validators vote on blocks and produce blocks when selected as leader</td>
  <td>Validators execute transactions and sign Bitcoin transactions using threshold signatures</td>
</tr>
<tr>
  <td><b>Economic Model</b></td>
  <td>Block rewards + transaction fees</td>
  <td>Transaction fees + commission from Bitcoin operations</td>
</tr>
<tr>
  <td><b>Selection Mechanism</b></td>
  <td>Stake-weighted leader selection</td>
  <td>Stake-weighted participation in threshold signing committee</td>
</tr>
<tr>
  <td><b>Performance Metrics</b></td>
  <td>Vote signing speed, block production, uptime</td>
  <td>Transaction execution correctness, signing participation, uptime</td>
</tr>
<tr>
  <td><b>Slashing Conditions</b></td>
  <td>Double signing, unavailability</td>
  <td>Malicious signing, transaction manipulation attempts</td>
</tr>
<tr>
  <td><b>Hardware Requirements</b></td>
  <td>High-end CPU, 128GB+ RAM, 2TB+ NVMe</td>
  <td>4+ CPU cores, 16GB+ RAM, 100GB+ SSD</td>
</tr>
</table>
</div>
<h3 id="-from-solana-to-arch-operational-transition-guide"><a class="header" href="#-from-solana-to-arch-operational-transition-guide">üöÄ From Solana to Arch: Operational Transition Guide</a></h3>
<p>If you‚Äôre an experienced Solana validator operator, here‚Äôs what you need to know about running an Arch Network validator:</p>
<div class="transition-grid">
<div class="transition-card">
<h4 id="-technical-setup"><a class="header" href="#-technical-setup">‚öôÔ∏è Technical Setup</a></h4>
<ul>
<li><b>Lower Hardware Requirements:</b> Arch Network requires less powerful hardware than Solana</li>
<li><b>Bitcoin RPC Access:</b> Validators need Bitcoin node access (remote or local)</li>
<li><b>Key Management:</b> Different key structure focusing on distributed key generation</li>
<li><b>Monitoring:</b> Focus on signing participation rather than block production</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-economic-considerations"><a class="header" href="#-economic-considerations">üí∞ Economic Considerations</a></h4>
<ul>
<li><b>Staking Return Model:</b> Fee-based with transaction execution rewards</li>
<li><b>Reward Distribution:</b> Based on stake proportion and signing participation</li>
<li><b>Commission Structure:</b> Set during validator configuration</li>
<li><b>Lockup Periods:</b> Network-defined based on security requirements</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-operational-differences"><a class="header" href="#-operational-differences">üîÑ Operational Differences</a></h4>
<ul>
<li><b>Signing vs. Voting:</b> Focus on correct transaction execution and signing</li>
<li><b>Performance Metrics:</b> Measured by signing participation and availability</li>
<li><b>Updates:</b> Less frequent than Solana's rapid release cycle</li>
<li><b>Network Bandwidth:</b> Lower requirements due to different architecture</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-onboarding-process"><a class="header" href="#-onboarding-process">üõ£Ô∏è Onboarding Process</a></h4>
<ul>
<li><b>Registration:</b> Complete validator registration through the network portal</li>
<li><b>Stake Deposit:</b> Transfer ARCH tokens to the validator staking contract</li>
<li><b>Configuration:</b> Set up your validator with proper Bitcoin node access</li>
<li><b>Key Generation:</b> Participate in distributed key generation ceremony</li>
<li><b>Activation:</b> Begin participation after stake activation period</li>
</ul>
</div>
</div>
<h3 id="-staking-economics"><a class="header" href="#-staking-economics">üìä Staking Economics</a></h3>
<div class="economics-grid">
<div class="economics-card">
<h4 id="validator-requirements"><a class="header" href="#validator-requirements">Validator Requirements</a></h4>
<ul>
<li><b>Minimum Stake:</b> Contact Arch Network team for current requirements</li>
<li><b>Lockup Period:</b> Network-defined based on security requirements</li>
<li><b>Uptime Requirement:</b> High availability expected for signing participation</li>
<li><b>Performance Bonding:</b> Stake acts as bond for correct behavior</li>
</ul>
</div>
<div class="economics-card">
<h4 id="reward-structure"><a class="header" href="#reward-structure">Reward Structure</a></h4>
<ul>
<li><b>Base Rewards:</b> From transaction fees distributed proportionally to stake</li>
<li><b>Signing Rewards:</b> Additional rewards for participating in threshold signing</li>
<li><b>Commission:</b> Set percentage of rewards retained by validator</li>
<li><b>Distribution Frequency:</b> Continuous as transactions are processed</li>
</ul>
</div>
</div>
<h3 id="-roast-protocol-integration"><a class="header" href="#-roast-protocol-integration">üîÑ ROAST Protocol Integration</a></h3>
<p>The ROAST (Robust Asynchronous Schnorr Threshold) protocol enables validators to collectively sign Bitcoin transactions:</p>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;L: 4. Sign Results
    L-&gt;&gt;B: 5. Submit to Bitcoin
</pre>
<h3 id="-security-model"><a class="header" href="#-security-model">üõ°Ô∏è Security Model</a></h3>
<pre class="mermaid">flowchart LR
    subgraph Security[&quot;Security Layers&quot;]
        direction TB
        UTXO[UTXO Validation] --&gt;|Verifies| Own[Ownership]
        Own --&gt;|Ensures| State[State Consistency]
        State --&gt;|Commits to| BTC[Bitcoin]
    end

    subgraph Threshold[&quot;Threshold Signing&quot;]
        direction TB
        Val[Validators] --&gt;|t-of-n| Sign[Signature]
        Sign --&gt;|ROAST| Agg[Aggregation]
        Agg --&gt;|Submit| Final[Final Transaction]
    end

    style Security fill:#e1f5fe,stroke:#01579b
    style Threshold fill:#fff3e0,stroke:#e65100
</pre>
<div class="staking-card">
<h4 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h4>
<ul>
<li>Distributed key generation for secure signing</li>
<li>Threshold signature scheme (t-of-n) for fault tolerance</li>
<li>Bitcoin-based finality guarantees</li>
<li>Automatic malicious node detection</li>
</ul>
</div>
</div>
<style>
.requirement-grid, .responsibility-grid, .monitoring-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.requirement-card, .responsibility-card, .monitoring-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.requirement-card h3, .responsibility-card h3, .monitoring-card h3 {
    margin-top: 0;
    color: #2c3e50;
}

.platform-select, .network-select {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
    margin: 1.5rem 0;
}

.platform-option, .network-option {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
    width: 100%;
    border-collapse: collapse;
}

th, td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    background: #f1f3f5;
}

.staking-explanation {
    background: #ffffff;
    border-radius: 8px;
    padding: 2rem;
    margin: 2rem 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.staking-explanation h3 {
    color: #2c3e50;
    margin-top: 2rem;
}

.staking-explanation h3:first-child {
    margin-top: 0;
}

.staking-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    margin-top: 2rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.staking-card h4 {
    margin-top: 0;
    color: #2c3e50;
}

.comparison-table {
    overflow-x: auto;
    margin: 1.5rem 0;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
}

.comparison-table th {
    background: #f1f3f5;
    padding: 0.75rem;
    text-align: left;
}

.comparison-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #ddd;
}

.transition-grid, .economics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 1.5rem 0;
}

.transition-card, .economics-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.transition-card h4, .economics-card h4 {
    margin-top: 0;
    color: #2c3e50;
}
</style> <div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-arch-programs"><a class="header" href="#understanding-arch-programs">Understanding Arch Programs</a></h1>
<p>This guide analyzes a simple Hello World program to introduce the core concepts of Arch program development. We‚Äôll break down each component of the program to understand how Arch programs work.</p>
<h2 id="program-overview"><a class="header" href="#program-overview">Program Overview</a></h2>
<p>The Hello World program is a simple smart contract that stores a greeting message for a given name. While simple, it demonstrates the key concepts of Arch program development including:</p>
<ul>
<li>Program structure and entrypoints</li>
<li>Account management</li>
<li>State updates</li>
<li>Bitcoin transaction handling</li>
<li>Fee management</li>
</ul>
<p>Let‚Äôs break down each part of the program.</p>
<h2 id="1-program-dependencies"><a class="header" href="#1-program-dependencies">1. Program Dependencies</a></h2>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    bitcoin::{self, absolute::LockTime, transaction::Version, Transaction},
    entrypoint,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    msg,
    program::{
        get_account_script_pubkey, get_bitcoin_block_height, next_account_info,
        set_transaction_to_sign,
    },
    program_error::ProgramError,
    pubkey::Pubkey,
    transaction_to_sign::TransactionToSign,
};
use borsh::{BorshDeserialize, BorshSerialize};</code></pre>
<p>The program starts by importing necessary dependencies:</p>
<ul>
<li><code>AccountInfo</code>: Provides access to account data and metadata</li>
<li><code>bitcoin</code>: Core Bitcoin types and functionality for transaction handling</li>
<li><code>entrypoint</code>: Macro for registering the program‚Äôs entry point</li>
<li><code>msg</code>: Logging functionality for debugging</li>
<li><code>borsh</code>: Serialization/deserialization for program data</li>
</ul>
<h2 id="2-program-entry-point"><a class="header" href="#2-program-entry-point">2. Program Entry Point</a></h2>
<pre><code class="language-rust ignore">entrypoint!(process_instruction);</code></pre>
<p>Every Arch program needs a single entry point that the runtime will call. The <code>entrypoint!</code> macro registers our <code>process_instruction</code> function as this entry point. This tells the Arch runtime which function to call when our program is invoked.</p>
<h2 id="3-program-parameters"><a class="header" href="#3-program-parameters">3. Program Parameters</a></h2>
<pre><code class="language-rust ignore">pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt;</code></pre>
<p>The entry point function takes three key parameters:</p>
<ul>
<li><code>program_id</code>: The public key of our program (unused in this example)</li>
<li><code>accounts</code>: Array of accounts the instruction will operate on</li>
<li><code>instruction_data</code>: Serialized instruction parameters</li>
</ul>
<p>These parameters provide everything our program needs to execute: the context (program_id), the accounts it can read/write, and the instruction-specific data.</p>
<h2 id="4-custom-error-handling"><a class="header" href="#4-custom-error-handling">4. Custom Error Handling</a></h2>
<p>Programs should define their own error types to provide clear and specific error messages. Here‚Äôs how to implement custom errors in your Arch program:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HelloWorldError {
    /// The provided name is too long (max 50 chars)
    NameTooLong,
    /// The provided name contains invalid characters
    InvalidName,
    /// Insufficient account balance for fees
    InsufficientFees,
    /// Invalid fee transaction format
    InvalidFeeTransaction,
}

impl From&lt;HelloWorldError&gt; for ProgramError {
    fn from(e: HelloWorldError) -&gt; Self {
        ProgramError::Custom(match e {
            HelloWorldError::NameTooLong =&gt; 1001,
            HelloWorldError::InvalidName =&gt; 1002,
            HelloWorldError::InsufficientFees =&gt; 1003,
            HelloWorldError::InvalidFeeTransaction =&gt; 1004,
        })
    }
}</code></pre>
<p>Using custom errors in your program:</p>
<pre><code class="language-rust ignore">fn validate_name(name: &amp;str) -&gt; Result&lt;(), HelloWorldError&gt; {
    if name.len() &gt; 50 {
        return Err(HelloWorldError::NameTooLong);
    }
    if !name.chars().all(|c| c.is_alphanumeric() || c.is_whitespace()) {
        return Err(HelloWorldError::InvalidName);
    }
    Ok(())
}

pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let params: HelloWorldParams = borsh::from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    
    validate_name(&amp;params.name)?;  // Custom error will be converted to ProgramError
    
    // ... rest of the implementation
}</code></pre>
<p>Best practices for error handling:</p>
<ol>
<li>Define descriptive error variants that clearly indicate what went wrong</li>
<li>Use unique error codes in the 1000+ range to avoid conflicts with system errors</li>
<li>Implement proper error conversion to <code>ProgramError</code></li>
<li>Add documentation comments for each error variant</li>
<li>Consider grouping related errors into separate enums if your program grows large</li>
</ol>
<h2 id="5-program-state"><a class="header" href="#5-program-state">5. Program State</a></h2>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct HelloWorldParams {
    /// The name to say hello to
    pub name: String,
    /// Raw Bitcoin transaction for fees
    pub tx_hex: Vec&lt;u8&gt;,
}</code></pre>
<p>This structure defines the data format our program expects. It includes:</p>
<ul>
<li><code>name</code>: The name to include in the greeting</li>
<li><code>tx_hex</code>: A serialized Bitcoin transaction for paying fees</li>
</ul>
<p>The <code>BorshSerialize</code> and <code>BorshDeserialize</code> traits allow us to convert this structure to and from bytes for storage and transmission.</p>
<h2 id="6-program-logic"><a class="header" href="#6-program-logic">6. Program Logic</a></h2>
<p>Let‚Äôs break down the main program logic into steps:</p>
<h3 id="account-validation"><a class="header" href="#account-validation">Account Validation</a></h3>
<pre><code class="language-rust ignore">if accounts.len() != 1 {
    return Err(ProgramError::Custom(501));
}

let account_iter = &amp;mut accounts.iter();
let account = next_account_info(account_iter)?;

assert!(account.is_writable);
assert!(account.is_signer);</code></pre>
<p>The program first performs several important validations:</p>
<ul>
<li>Checks that exactly one account is provided</li>
<li>Ensures the account is writable (can be modified)</li>
<li>Verifies the account is a signer (authorized to make changes)</li>
</ul>
<p>These checks are crucial for security and proper program execution.</p>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<pre><code class="language-rust ignore">let params: HelloWorldParams = borsh::from_slice(instruction_data).unwrap();
let new_data = format!("Hello {}", params.name);

let data_len = account.data.try_borrow().unwrap().len();
if new_data.as_bytes().len() &gt; data_len {
    account.realloc(new_data.len(), true)?;
}

account.data.try_borrow_mut().unwrap().copy_from_slice(new_data.as_bytes());</code></pre>
<p>The state management section:</p>
<ol>
<li>Deserializes the instruction parameters into our <code>HelloWorldParams</code> structure</li>
<li>Creates the greeting message</li>
<li>Checks if the account has enough space for our data</li>
<li>Reallocates space if needed</li>
<li>Stores the greeting in the account‚Äôs data</li>
</ol>
<h3 id="bitcoin-transaction-handling"><a class="header" href="#bitcoin-transaction-handling">Bitcoin Transaction Handling</a></h3>
<pre><code class="language-rust ignore">let fees_tx: Transaction = bitcoin::consensus::deserialize(&amp;params.tx_hex).unwrap();

let mut tx = Transaction {
    version: Version::TWO,
    lock_time: LockTime::ZERO,
    input: vec![],
    output: vec![],
};

add_state_transition(&amp;mut tx, account);
tx.input.push(fees_tx.input[0].clone());</code></pre>
<p>This section handles the Bitcoin transaction aspects:</p>
<ol>
<li>Deserializes the fee transaction provided by the user</li>
<li>Creates a new Bitcoin transaction for our state update</li>
<li>Adds the state transition to the transaction</li>
<li>Includes the fee input to pay for the transaction</li>
</ol>
<h3 id="transaction-signing"><a class="header" href="#transaction-signing">Transaction Signing</a></h3>
<pre><code class="language-rust ignore">let tx_to_sign = TransactionToSign {
    tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
    inputs_to_sign: &amp;[InputToSign {
        index: 0,
        signer: account.key.clone(),
    }],
};

set_transaction_to_sign(accounts, tx_to_sign)</code></pre>
<p>Finally, the program prepares the transaction for signing:</p>
<ol>
<li>Serializes the Bitcoin transaction</li>
<li>Creates a signing request specifying which inputs need to be signed</li>
<li>Submits the transaction to be signed by the Arch runtime</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand the basic structure of an Arch program, you can:</p>
<ul>
<li>Learn about more complex account management in the <a href="guides/../program/program.html">Program</a> documentation</li>
<li>Explore cross-program invocation for program composition</li>
<li>Study the Bitcoin transaction lifecycle in our <a href="https://docs.arch.network">docs</a></li>
<li>Build more complex programs using these fundamentals</li>
</ul>
<p>For practical examples, check out our other guides:</p>
<ul>
<li><a href="guides/./how-to-create-a-fungible-token.html">How to create a fungible token</a></li>
<li><a href="guides/./how-to-build-runes-swap.html">How to build a Runes swap</a></li>
</ul>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-first-arch-program"><a class="header" href="#writing-your-first-arch-program">Writing Your First Arch Program</a></h1>
<p>This guide will walk you through creating your first Arch program from scratch. We‚Äôll build a simple counter program that demonstrates the core concepts of Arch development while providing hands-on experience with the development workflow.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>Rust and Cargo installed</li>
<li><a href="guides/../getting-started/quick-start.html">CLI</a> installed and configured (see <a href="guides/../getting-started/quick-start.html">Quick Start Guide</a>)</li>
<li>A running validator node</li>
<li>Basic understanding of <a href="guides/../concepts/architecture.html">Arch concepts</a></li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<ol>
<li>Create a new project directory:</li>
</ol>
<pre><code class="language-bash">mkdir my-counter-program
cd my-counter-program
</code></pre>
<ol start="2">
<li>Initialize a new Rust project:</li>
</ol>
<pre><code class="language-bash">cargo init --lib
</code></pre>
<ol start="3">
<li>Add necessary dependencies to <code>Cargo.toml</code>:</li>
</ol>
<pre><code class="language-toml">[package]
name = "my-counter-program"
version = "0.1.0"
edition = "2021"

[dependencies]
arch-program = { git = "https://github.com/Arch-Network/arch-program" }
borsh = "0.10.3"

[lib]
crate-type = ["cdylib"]
</code></pre>
<h2 id="writing-the-program"><a class="header" href="#writing-the-program">Writing the Program</a></h2>
<p>Let‚Äôs create a simple program that:</p>
<ul>
<li>Stores a counter in an account</li>
<li>Can increment the counter</li>
<li>Can decrement the counter</li>
<li>Can reset the counter</li>
</ul>
<ol>
<li>Define our program‚Äôs state structure in <code>src/lib.rs</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_program::{
    account::AccountInfo,
    entrypoint,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    Increment,
    Decrement,
    Reset,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Implement the program logic:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>entrypoint!(process_instruction);

pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    // Get the account to store counter data
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;

    // Verify account is writable
    if !counter_account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }

    // Deserialize the instruction
    let instruction = CounterInstruction::try_from_slice(instruction_data)?;
    
    // Get current counter value
    let mut counter = match CounterAccount::try_from_slice(&amp;counter_account.data.borrow()) {
        Ok(data) =&gt; data,
        Err(_) =&gt; CounterAccount { count: 0 },
    };

    // Process the instruction
    match instruction {
        CounterInstruction::Increment =&gt; {
            counter.count = counter.count.checked_add(1).ok_or(ProgramError::Custom(1))?;
            msg!("Counter incremented to {}", counter.count);
        }
        CounterInstruction::Decrement =&gt; {
            counter.count = counter.count.checked_sub(1).ok_or(ProgramError::Custom(2))?;
            msg!("Counter decremented to {}", counter.count);
        }
        CounterInstruction::Reset =&gt; {
            counter.count = 0;
            msg!("Counter reset to 0");
        }
    }

    // Serialize and save the counter
    counter.serialize(&amp;mut &amp;mut counter_account.data.borrow_mut()[..])?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="building-the-program"><a class="header" href="#building-the-program">Building the Program</a></h2>
<ol>
<li>Build your program:</li>
</ol>
<pre><code class="language-bash">cargo build-sbf
</code></pre>
<p>This will create a compiled program at <code>target/deploy/my_counter_program.so</code></p>
<h2 id="deploying-the-program"><a class="header" href="#deploying-the-program">Deploying the Program</a></h2>
<ol>
<li>Deploy your program using the CLI:</li>
</ol>
<pre><code class="language-bash">cli deploy target/deploy/my_counter_program.so
</code></pre>
<p>Save the Program ID output - you‚Äôll need it to interact with your program.</p>
<h2 id="creating-a-counter-account"><a class="header" href="#creating-a-counter-account">Creating a Counter Account</a></h2>
<p>Before we can use our counter, we need to create an account to store its state:</p>
<pre><code class="language-bash">cli create-account &lt;PROGRAM_ID&gt; 8
</code></pre>
<p>Save the account address - you‚Äôll need it to interact with your counter.</p>
<h2 id="testing-your-program"><a class="header" href="#testing-your-program">Testing Your Program</a></h2>
<p>You can now interact with your program using the CLI:</p>
<ol>
<li>Increment the counter:</li>
</ol>
<pre><code class="language-bash">cli invoke &lt;PROGRAM_ID&gt; &lt;ACCOUNT_ADDRESS&gt; --data 00
</code></pre>
<ol start="2">
<li>Decrement the counter:</li>
</ol>
<pre><code class="language-bash">cli invoke &lt;PROGRAM_ID&gt; &lt;ACCOUNT_ADDRESS&gt; --data 01
</code></pre>
<ol start="3">
<li>Reset the counter:</li>
</ol>
<pre><code class="language-bash">cli invoke &lt;PROGRAM_ID&gt; &lt;ACCOUNT_ADDRESS&gt; --data 02
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you‚Äôve created your first program, you can:</p>
<ul>
<li>Add more features to the counter program</li>
<li>Learn about <a href="guides/../program/program.html">cross-program invocation</a></li>
<li>Explore more complex <a href="guides/./guides.html">Program Examples</a></li>
<li>Study the <a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a> guide for deeper insights</li>
</ul>
<!-- Internal -->
<pre><code class="language-bash"># Start the Arch Network validator
cli validator-start
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-examples"><a class="header" href="#program-examples">Program Examples</a></h1>
<p>In this section, we‚Äôll provide a few guides that can step through constructing an Arch <a href="guides/../program/program.html">program</a>, as well as deploying and interacting with your program.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/./how-to-create-a-fungible-token.html">Fungible Token</a></li>
<li><a href="guides/./how-to-write-oracle-program.html">Oracle Program</a></li>
<li><a href="guides/./how-to-build-runes-swap.html">Runes Swap</a></li>
<li><a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a></li>
</ul>
<hr />
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-create-a-fungible-token"><a class="header" href="#how-to-create-a-fungible-token">How to create a fungible token</a></h1>
<p>This guide walks through how to implement the Fungible Token Standard program, part of the Arch Program Library, or APL.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-create-a-fungible-token.html#description">Description</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#logic">Logic</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#implementation">Implementation</a></li>
</ul>
<hr />
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<p>The Fungible Token Standard program provides a consistent interface for implementing fungible tokens on Arch. As with all programs within the APL, this program is predeployed and is tested against the Arch runtime.</p>
<p>The source code can be found within the <a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/fungible-token-standard">arch-examples</a> repo.</p>
<h3 id="logic"><a class="header" href="#logic">Logic</a></h3>
<p>If you haven‚Äôt already read <a href="guides/./how-to-write-arch-program.html">How to write an Arch program</a>, we recommend starting there to get a basic understanding of the program anatomy before going further.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<ul>
<li><a href="guides/how-to-create-a-fungible-token.html#deploy">Deploy</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#mint">Mint</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#transfer">Transfer</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#balance-check">Balance check</a></li>
</ul>
<h4 id="deploy"><a class="header" href="#deploy">Deploy</a></h4>
<p>Although the Fungible Token Standard program is part of the APL, and is there predeployed by the validators, for local testing, we can deploy it ourselves. Move to <a href="guides/how-to-create-a-fungible-token.html#mint">Mint</a> if you‚Äôd like to skip this step.</p>
<p>To demonstrate a deploy, we‚Äôll reference: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/deploy.rs">deploy.rs</a></p>
<p>We make use of <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_deployment.rs#L1"><code>try_deploy_program</code></a>, a helper function from the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter">ebpf-counter</a> example to deploy our program.</p>
<pre><code class="language-rust ignore">pub const ELF_PATH: &amp;str = "./program/target/sbf-solana-solana/release/fungible-token-standard-program.so";

fn deploy_standard_program() {
    let program_pubkey =
        try_deploy_program(ELF_PATH, PROGRAM_FILE_PATH, "Fungible-Token-Standard").unwrap();

    println!(
        "Deployed Fungible token standard program account id {:?}!",
        program_pubkey.serialize()
    );
...
}</code></pre>
<h4 id="mint"><a class="header" href="#mint">Mint</a></h4>
<p>To mint tokens, we must supply a few pieces of information:</p>
<ul>
<li>Owner</li>
<li>Supply</li>
<li>Ticker</li>
<li>Decimals</li>
</ul>
<p>This data gets stored in the <code>InitializeMintInput</code> struct, which will be used to generate a new instance of the Fungible Token Standard.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeMintInput {
    owner: [u8; 32],
    supply: u64, // in lowest denomination
    ticker: String,
    decimals: u8,
}</code></pre>
<p>To demonstrate a mint, we‚Äôll reference: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/tests_mint.rs">tests_mint.rs</a></p>
<p>We initialize a new instance of <code>InitializeMintInput</code> and pass in the necessary data. In the below case, our owner account will create the token ‚ÄúSPONK,‚Äù with a total supply of 1,000,000, which will have only a single decimal, meaning it is divisible by 1.</p>
<pre><code class="language-rust ignore">// deploy.rs
let mint_input = InitializeMintInput::new(
    mint_account_pubkey.serialize(),
    1000000,
    "SPONK".to_string(),
    1,
);</code></pre>
<p>We then serialize <code>mint_input</code> so that we can pass it as <code>instruction_data</code> within an <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a> which then gets submitted to the deployed Fungible Token Standard program.</p>
<pre><code class="language-rust ignore">let mut instruction_data = vec![0u8];

mint_input
    .serialize(&amp;mut instruction_data)
    .expect("Couldnt serialize mint input");

let initialize_mint_instruction = Instruction {
    program_id: program_pubkey.clone(),
    accounts: vec![AccountMeta {
        pubkey: mint_account_pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
};</code></pre>
<p>Next, we build a transaction using <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L163"><code>build_transaction</code></a> and then submit the transaction with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L196"><code>build_and_send_block</code></a>, both helper function from the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter">ebpf-counter</a> example.</p>
<pre><code class="language-rust ignore">let transaction = build_transaction(
    vec![mint_account_keypair],
    vec![initialize_mint_instruction],
);

let block_transactions = build_and_send_block(vec![transaction]);</code></pre>
<p>We fetch the result of the transaction with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L207"><code>fetch_processed_transactions</code></a> helper function (<a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter">ebpf-counter</a>) and then obtain the mint details by passing the <a href="guides/../program/pubkey.html">Pubkey</a> of the token owner.</p>
<pre><code class="language-rust ignore">let processed_transactions = fetch_processed_transactions(block_transactions).unwrap();

assert!(matches!(
    processed_transactions[0].status,
    Status::Processed
));

let mint_details = get_mint_info(&amp;mint_account_pubkey).expect("Couldnt deserialize mint info");

println!("Mint account {:?}", mint_account_pubkey.serialize());</code></pre>
<h4 id="transfer"><a class="header" href="#transfer">Transfer</a></h4>
<p>To demonstrate a transfer, we‚Äôll reference: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/tests_transfer.rs">tests_transfer.rs</a></p>
<p>We obtain a <code>mint_account_pubkey</code>, made possible by using the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/helpers.rs#L38"><code>try_create_mint_account</code></a> helper function. We pass <code>true</code> as this is a one-time mint event and this will generate a new keypair and <a href="guides/../program/pubkey.html">Pubkey</a>.</p>
<p>This step will actually create a new token with the following details:</p>
<ul>
<li>Supply: 1,000,000</li>
<li>Ticker: ‚ÄúARCH‚Äù</li>
<li>Decimals: 2</li>
<li>Mint Price: 1000 sats</li>
</ul>
<pre><code class="language-rust ignore">let mint_account_pubkey = try_create_mint_account(true).unwrap();</code></pre>
<p>We then fetch the token mint details with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/helpers.rs#L173"><code>get_mint_info</code></a>.</p>
<pre><code class="language-rust ignore">let previous_mint_details = get_mint_info(&amp;mint_account_pubkey).unwrap();</code></pre>
<p>Now, let‚Äôs provision our two accounts: the sender and the receiver.</p>
<pre><code class="language-rust ignore">// sending account
let (first_account_owner_key_pair, first_account_owner_pubkey, _first_account_owner_address) =
        generate_new_keypair();

let first_balance_account_pubkey = create_balance_account(
        &amp;first_account_owner_pubkey,
        first_account_owner_key_pair,
        &amp;mint_account_pubkey,
        &amp;program_pubkey,
)
.unwrap();

// receiving account
let (second_account_owner_key_pair, second_account_owner_pubkey, _second_account_owner_address) =
    generate_new_keypair();

let second_balance_account_pubkey = create_balance_account(
    &amp;second_account_owner_pubkey,
    second_account_owner_key_pair,
    &amp;mint_account_pubkey,
    &amp;program_pubkey,
)
.unwrap();</code></pre>
<p>We then procure funds for the sending account. In this case, we‚Äôll mint 10 tokens.</p>
<pre><code class="language-rust ignore">let mint_amount = 10u64;

let mint_instruction = mint_request_instruction(
    &amp;mint_account_pubkey,
    &amp;program_pubkey,
    &amp;first_balance_account_pubkey,
    &amp;first_account_owner_pubkey,
    mint_amount,
)
.unwrap();</code></pre>
<p>We utilize the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/instruction.rs#L116"><code>transfer_request_instruction</code></a> helper function to generate a transfer <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a>.</p>
<pre><code class="language-rust ignore">let transfer_instruction = transfer_request_instruction(
    &amp;mint_account_pubkey,
    &amp;program_pubkey,
    &amp;first_balance_account_pubkey,
    &amp;first_account_owner_pubkey,
    &amp;second_balance_account_pubkey,
    mint_amount,
)
.unwrap();</code></pre>
<p>We build the transaction by passing in the newly created transfer <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a> as well as the keypair of the sending account, necessary for authorizing the fund transfer.</p>
<pre><code class="language-rust ignore">let transfer_transaction = build_transaction(
    vec![first_account_owner_key_pair],
    vec![transfer_instruction],
);</code></pre>
<p>Next, we then submit the transaction with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L196"><code>build_and_send_block</code></a> and then fetch the processed transaction to get the result.</p>
<pre><code class="language-rust ignore">let block_transactions = build_and_send_block(vec![transfer_transaction]);

let processed_transactions = fetch_processed_transactions(block_transactions).unwrap();

assert!(matches!(
    processed_transactions[0].status,
    Status::Processed
));</code></pre>
<h4 id="balance-check"><a class="header" href="#balance-check">Balance check</a></h4>
<p>In order to check the token balance of an account, we‚Äôll make use of the <code>get_balance_account</code> function and pass in the account we are looking to query the balance of; in the below example, we‚Äôll fetch the balances of both the sending and receiving accounts.</p>
<pre><code class="language-rust ignore">let resulting_sender_balance = get_balance_account(&amp;first_balance_account_pubkey).unwrap();

let resulting_receiver_balance = get_balance_account(&amp;second_balance_account_pubkey).unwrap();

assert_eq!(resulting_receiver_balance.current_balance, mint_amount);

assert_eq!(resulting_sender_balance.current_balance, 0);</code></pre>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-an-oracle-program"><a class="header" href="#how-to-write-an-oracle-program">How to write an oracle program</a></h1>
<p>This guide walks through the innerworkings of an oracle program as well as details how oracle data can be utilized by other programs on Arch Network.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#description">Description</a></li>
<li><a href="guides/how-to-write-oracle-program.html#flow">Flow</a></li>
<li><a href="guides/how-to-write-oracle-program.html#logic">Logic</a></li>
<li><a href="guides/how-to-write-oracle-program.html#implementation">Implementation</a></li>
</ul>
<hr />
<h3 id="description-1"><a class="header" href="#description-1">Description</a></h3>
<p>Two important aspects of understanding how this oracle example is implemented within Arch:</p>
<ol>
<li>The oracle is a program that updates an account which holds the data</li>
<li>No cross-program invocation occurs since only the account is updated and read from versus this being another program that gets interacted with from another program</li>
</ol>
<p>The source code can be found within the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<ul>
<li>Project deploys oracle program</li>
<li>Project creates state account that the oracle program will control in order to write state to it</li>
<li>Projects submit data to the oracle state account by submitting instructions to the oracle program</li>
<li>Programs include oracle state account alongside their program instructions in order to use this referenced data stored in the oracle state account within their program</li>
<li>Projects submit instructions to oracle program periodically to update oracle state account with fresh data</li>
</ul>
<h3 id="logic-1"><a class="header" href="#logic-1">Logic</a></h3>
<p>If you haven‚Äôt already read <a href="guides/./how-to-write-arch-program.html">How to write an Arch program</a>, we recommend starting there to get a basic understanding of the program anatomy before going further.</p>
<p>We‚Äôll look closely at the logic block contained within the <code>update_data</code> <a href="guides/how-to-write-oracle-program.html#logic">handler</a>.</p>
<pre><code class="language-rust ignore">pub fn update_data(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let oracle_account = next_account_info(account_iter)?;

    assert!(oracle_account.is_signer);
    assert_eq!(instruction_data.len(), 8);

    ...
}</code></pre>
<p>First, we‚Äôll iterate over the accounts that get passed into the function, which includes the newly created state account that will be responsible for managing the oracle‚Äôs data.</p>
<p>We then assert that the oracle state account has the appropriate authority to be written to and update what it stores within its data field. Additionally, we assert that the data we wish to update the account with is at least a certain number of bytes.</p>
<pre><code class="language-rust ignore">let data_len = oracle_account.data.try_borrow().unwrap().len();
if instruction_data.len() &gt; data_len {
    oracle_account.realloc(instruction_data.len(), true)?;
}</code></pre>
<p>Next, we calculate the length of the new data that we are looking to store in the account and reallocate memory to the account if the new data is larger than the data currently existing within the account. This step is important for ensuring that there is no remaining, stale data stored in the account before adding new data to it.</p>
<pre><code class="language-rust ignore">oracle_account
    .data
    .try_borrow_mut()
    .unwrap()
    .copy_from_slice(instruction_data);

msg!("updated");

Ok(())</code></pre>
<p>Lastly, we store the new data that is passed into the program via the instruction to the state account for management, thus marking the end of the oracle update process.</p>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<p>Let‚Äôs look at an example implementation of this oracle program. This includes:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#create-oracle-project">Create oracle project</a></li>
<li><a href="guides/how-to-write-oracle-program.html#deploy-program">Deploy program</a></li>
<li><a href="guides/how-to-write-oracle-program.html#create-a-state-account">Create a state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#update-the-state-account">Update the state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#read-from-the-state-account">Read from the state account</a></li>
</ul>
<h4 id="create-oracle-project"><a class="header" href="#create-oracle-project">Create oracle project</a></h4>
<p>First, we‚Äôll need to create a new project to hold our oracle logic.</p>
<pre><code class="language-bash"># Create a new directory for your oracle project
mkdir oracle
cd oracle

# Initialize a Rust project
cargo init --lib
</code></pre>
<blockquote>
<p>Note: The new CLI does not currently have a project creation command. We‚Äôll manually set up our project structure.</p>
</blockquote>
<p>You‚Äôll need to create and edit the following files:</p>
<ul>
<li><code>Cargo.toml</code> - Add dependencies for your oracle program</li>
<li><code>src/lib.rs</code> - Implement the oracle program logic</li>
</ul>
<p>Example program files can be found in the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h4 id="deploy-program"><a class="header" href="#deploy-program">Deploy program</a></h4>
<p>After the project is created, the program is written and the <code>Cargo.toml</code> is set with the proper dependencies, we can deploy the program.</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program
cli deploy target/deploy/oracle.so
</code></pre>
<p>During the deployment, a new account is created for the deployed program logic and set to be executable, marking it as a <a href="guides/../program/program.html">Program</a> rather than a data <a href="guides/../program/account.html">Account</a>.</p>
<h4 id="create-state-account"><a class="header" href="#create-state-account">Create state account</a></h4>
<p>From the deployment output, you should obtain the <code>program_id</code>. We can use this <code>program_id</code> to create a state account that is owned and updated by the program.</p>
<p>The oracle state account can then be read from by any program in order to retrieve the associated oracle data.</p>
<pre><code class="language-bash"># The new CLI may not have direct account creation functionality
# You'll need to use an RPC call to create the account

# For example, using curl:
curl -X POST http://localhost:9002 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"sendTransaction",
    "params":[{
      "signature":"your_signature",
      "message":{
        "accountKeys":["your_pubkey", "your_program_id"],
        "instructions":[{
          "programId":"system_program_id",
          "accounts":["your_pubkey", "new_account_pubkey"],
          "data":"encoded_create_account_data"
        }]
      }
    }]
  }'
</code></pre>
<blockquote>
<p>Note: The above is a simplified example. You‚Äôll need to properly construct, sign, and encode your transaction according to the Arch Network protocol.</p>
</blockquote>
<p>In this step, the account is created and ownership is transferred to the program. This allows the program to update the account‚Äôs data field which holds state for the program.</p>
<h4 id="update-the-state-account"><a class="header" href="#update-the-state-account">Update the state account</a></h4>
<p>Now that we have created an account and the oracle program has authority to update it, we now want to update the data that the account holds.</p>
<p>In order to update the data stored in the account, we simply need to make a transaction that includes the data that we wish to update the oracle state account to hold, and submit this within the context of an instruction.</p>
<p>As an example, below we have a sample rust program that we‚Äôll use to fetch the Bitcoin fees from the <a href="https://mempool.space">mempool.space</a> API and store this fee data in our oracle state account that was created during deployment.</p>
<blockquote>
<p>Note: The below is a rust program and is not an Arch program.</p>
<p>The call to update the oracle state account can be written in any programming language as it is simply an RPC call. For sake of continuity, we‚Äôre using rust along with methods from both the <code>program</code> and <code>sdk</code> crates.</p>
</blockquote>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client};

let mut old_feerate = 0;

let body: Value = reqwest::blocking::get("https://mempool.space/api/v1/fees/recommended").unwrap().json().unwrap();
let feerate = body.get("fastestFee").unwrap().as_u64().unwrap();

if old_feerate != feerate {
    let (txid, instruction_hash) = sign_and_send_instruction(
        Instruction {
            program_id: program_pubkey.clone(),
            accounts: vec![AccountMeta {
                pubkey: caller_pubkey.clone(),
                is_signer: true,
                is_writable: true
            }],
            data: feerate.to_le_bytes().to_vec()
        },
        vec![caller_keypair],
    ).expect("signing and sending a transaction should not fail");

    let processed_tx = get_processed_transaction(NODE1_ADDRESS, txid.clone()).expect("get processed transaction should not fail");
    println!("processed_tx {:?}", processed_tx);

    println!("{:?}", read_account_info(NODE1_ADDRESS, caller_pubkey.clone()));

    old_feerate = feerate;
}</code></pre>
<h4 id="read-from-the-state-account"><a class="header" href="#read-from-the-state-account">Read from the state account</a></h4>
<p>Below is an example of a different program (we‚Äôll call this app-program) that would like to access the oracle data.</p>
<p>Essentially, what happens here is that when we pass an instruction into our app-program, we must also include the oracle state account alongside any other account that we need for the app-program. In this way, the oracle state account is now in-scope and its data can be read from.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-first-bitcoin-runes-swap-application"><a class="header" href="#building-your-first-bitcoin-runes-swap-application">Building Your First Bitcoin Runes Swap Application</a></h1>
<p>Welcome to this hands-on tutorial! Today, we‚Äôre going to build a decentralized application that enables users to swap Bitcoin Runes tokens on the Arch Network. By the end of this lesson, you‚Äôll understand how to create a secure, trustless swap mechanism for Runes tokens.</p>
<h2 id="class-prerequisites"><a class="header" href="#class-prerequisites">Class Prerequisites</a></h2>
<p>Before we dive in, please ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch Network CLI installed</li>
</ul>
<h2 id="lesson-1-understanding-the-basics"><a class="header" href="#lesson-1-understanding-the-basics">Lesson 1: Understanding the Basics</a></h2>
<h3 id="what-are-runes"><a class="header" href="#what-are-runes">What are Runes?</a></h3>
<p>Before we write any code, let‚Äôs understand what we‚Äôre working with. Runes is a Bitcoin protocol for fungible tokens, similar to how BRC-20 works. Each Rune token has a unique identifier and can be transferred between Bitcoin addresses.</p>
<h3 id="what-are-we-building"><a class="header" href="#what-are-we-building">What are we building?</a></h3>
<p>We‚Äôre creating a swap program that will:</p>
<ol>
<li>Allow users to create swap offers (‚ÄúI want to trade X amount of Rune A for Y amount of Rune B‚Äù)</li>
<li>Enable other users to accept these offers</li>
<li>Let users cancel their offers if they change their mind</li>
<li>Ensure all swaps are atomic (they either complete fully or not at all)</li>
</ol>
<h2 id="lesson-2-setting-up-our-project"><a class="header" href="#lesson-2-setting-up-our-project">Lesson 2: Setting Up Our Project</a></h2>
<p>Let‚Äôs start by creating our project structure. Open your terminal and run:</p>
<pre><code class="language-bash"># Create a new directory for your project
mkdir runes-swap
cd runes-swap

# Initialize a new Rust project
cargo init --lib

# Your project structure should look like this:
# runes-swap/
# ‚îú‚îÄ‚îÄ Cargo.toml
# ‚îú‚îÄ‚îÄ src/
# ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
<h2 id="lesson-3-defining-our-data-structures"><a class="header" href="#lesson-3-defining-our-data-structures">Lesson 3: Defining Our Data Structures</a></h2>
<p>Now, let‚Äôs define the building blocks of our swap program. In programming, it‚Äôs crucial to plan our data structures before implementing functionality.</p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    entrypoint,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    utxo::UtxoMeta,
    borsh::{BorshDeserialize, BorshSerialize},
};

/// This structure represents a single swap offer in our system
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct SwapOffer {
    // Unique identifier for the offer
    pub offer_id: u64,
    // The public key of the person creating the offer
    pub maker: Pubkey,
    // The Rune ID they want to give
    pub rune_id_give: String,
    // Amount of Runes they want to give
    pub amount_give: u64,
    // The Rune ID they want to receive
    pub rune_id_want: String,
    // Amount of Runes they want to receive
    pub amount_want: u64,
    // When this offer expires (in block height)
    pub expiry: u64,
    // Current status of the offer
    pub status: OfferStatus,
}</code></pre>
<p>Let‚Äôs break down why we chose each field:</p>
<ul>
<li><code>offer_id</code>: Every offer needs a unique identifier so we can reference it later</li>
<li><code>maker</code>: We store who created the offer to ensure only they can cancel it</li>
<li><code>rune_id_give/want</code>: These identify which Runes are being swapped</li>
<li><code>amount_give/want</code>: The quantities of each Rune in the swap</li>
<li><code>expiry</code>: Offers shouldn‚Äôt live forever, so we add an expiration</li>
</ul>
<h2 id="lesson-4-implementing-the-swap-logic"><a class="header" href="#lesson-4-implementing-the-swap-logic">Lesson 4: Implementing the Swap Logic</a></h2>
<p>Now that we understand our data structures, let‚Äôs implement the core swap functionality. We‚Äôll start with creating an offer:</p>
<pre><code class="language-rust ignore">fn process_create_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all the accounts we need
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    // Step 2: Verify the maker has the Runes they want to swap
    if let SwapInstruction::CreateOffer { 
        rune_id_give, 
        amount_give,
        rune_id_want,
        amount_want,
        expiry 
    } = instruction {
        // Security check: Ensure the maker owns enough Runes
        verify_rune_ownership(maker, &amp;rune_id_give, amount_give)?;
        
        // Step 3: Create and store the offer
        let offer = SwapOffer {
            offer_id: get_next_offer_id(offer_account)?,
            maker: *maker.key,
            rune_id_give,
            amount_give,
            rune_id_want,
            amount_want,
            expiry,
            status: OfferStatus::Active,
        };
        
        store_offer(offer_account, &amp;offer)?;
    }

    Ok(())
}</code></pre>
<h3 id="understanding-the-create-offer-process"><a class="header" href="#understanding-the-create-offer-process">Understanding the Create Offer Process</a></h3>
<ol>
<li>First, we extract the accounts passed to our program</li>
<li>We verify that the maker actually owns the Runes they want to trade</li>
<li>We create a new <code>SwapOffer</code> with an Active status</li>
<li>Finally, we store this offer in the program‚Äôs state</li>
</ol>
<h2 id="lesson-5-testing-our-program"><a class="header" href="#lesson-5-testing-our-program">Lesson 5: Testing Our Program</a></h2>
<p>Testing is crucial in blockchain development because once deployed, your program can‚Äôt be easily changed. Let‚Äôs write comprehensive tests for our swap program.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::test_utils::{create_test_account, create_test_pubkey};

    /// Helper function to create a test offer
    fn create_test_offer() -&gt; SwapOffer {
        SwapOffer {
            offer_id: 1,
            maker: create_test_pubkey(),
            rune_id_give: "RUNE1".to_string(),
            amount_give: 100,
            rune_id_want: "RUNE2".to_string(),
            amount_want: 200,
            expiry: 1000,
            status: OfferStatus::Active,
        }
    }

    #[test]
    fn test_create_offer() {
        // Arrange: Set up our test accounts
        let maker = create_test_account();
        let offer_account = create_test_account();
        
        // Act: Create an offer
        let result = process_create_offer(
            &amp;[maker.clone(), offer_account.clone()],
            SwapInstruction::CreateOffer {
                rune_id_give: "RUNE1".to_string(),
                amount_give: 100,
                rune_id_want: "RUNE2".to_string(),
                amount_want: 200,
                expiry: 1000,
            },
        );
        
        // Assert: Check the result
        assert!(result.is_ok());
        // Add more assertions here to verify the offer was stored correctly
    }
}</code></pre>
<h3 id="understanding-our-test-structure"><a class="header" href="#understanding-our-test-structure">Understanding Our Test Structure</a></h3>
<p>We follow the ‚ÄúArrange-Act-Assert‚Äù pattern:</p>
<ol>
<li>Arrange: Set up the test environment and data</li>
<li>Act: Execute the functionality we‚Äôre testing</li>
<li>Assert: Verify the results match our expectations</li>
</ol>
<h2 id="lesson-6-implementing-offer-acceptance"><a class="header" href="#lesson-6-implementing-offer-acceptance">Lesson 6: Implementing Offer Acceptance</a></h2>
<p>Now let‚Äôs implement the logic for accepting an offer. This is where atomic swaps become crucial:</p>
<pre><code class="language-rust ignore">fn process_accept_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all required accounts
    let account_iter = &amp;mut accounts.iter();
    let taker = next_account_info(account_iter)?;
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::AcceptOffer { offer_id } = instruction {
        // Step 2: Load and validate the offer
        let mut offer = load_offer(offer_account)?;
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Step 3: Verify the taker has the required Runes
        verify_rune_ownership(taker, &amp;offer.rune_id_want, offer.amount_want)?;
        
        // Step 4: Perform the atomic swap
        // Transfer Runes from maker to taker
        transfer_runes(
            maker,
            taker,
            &amp;offer.rune_id_give,
            offer.amount_give,
        )?;
        
        // Transfer Runes from taker to maker
        transfer_runes(
            taker,
            maker,
            &amp;offer.rune_id_want,
            offer.amount_want,
        )?;
        
        // Step 5: Update offer status
        offer.status = OfferStatus::Completed;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h3 id="understanding-atomic-swaps"><a class="header" href="#understanding-atomic-swaps">Understanding Atomic Swaps</a></h3>
<p>An atomic swap ensures that either:</p>
<ul>
<li>Both transfers complete successfully, or</li>
<li>Neither transfer happens at all</li>
</ul>
<p>This is crucial for preventing partial swaps where one party could lose their tokens.</p>
<h2 id="lesson-7-implementing-offer-cancellation"><a class="header" href="#lesson-7-implementing-offer-cancellation">Lesson 7: Implementing Offer Cancellation</a></h2>
<p>Finally, let‚Äôs implement the ability to cancel offers:</p>
<pre><code class="language-rust ignore">fn process_cancel_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::CancelOffer { offer_id } = instruction {
        // Load the offer
        let mut offer = load_offer(offer_account)?;
        
        // Security checks
        require!(
            offer.maker == *maker.key,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Update offer status
        offer.status = OfferStatus::Cancelled;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h2 id="deploying-your-runes-swap-program"><a class="header" href="#deploying-your-runes-swap-program">Deploying Your Runes Swap Program</a></h2>
<p>After you‚Äôve written and tested your program, it‚Äôs time to deploy it to the Arch Network:</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program to the Arch Network
cli deploy target/deploy/runes_swap.so
</code></pre>
<p>Make sure you have a validator node running before deployment:</p>
<pre><code class="language-bash"># Start a local validator
cli validator-start
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Congratulations! You‚Äôve built a complete Runes swap program. This program demonstrates several important blockchain concepts:</p>
<ol>
<li>Atomic transactions</li>
<li>State management</li>
<li>Security checks</li>
<li>Program testing</li>
</ol>
<p>Remember to always:</p>
<ul>
<li>Test thoroughly before deployment</li>
<li>Consider edge cases</li>
<li>Implement proper error handling</li>
<li>Add detailed documentation</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>To further improve your program, consider adding:</p>
<ol>
<li>A UI for interacting with the swap program</li>
<li>More sophisticated offer matching</li>
<li>Order book functionality</li>
<li>Price oracle integration</li>
<li>Additional security features</li>
</ol>
<p>Questions? Feel free to ask in the comments below!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-bitcoin-lending-protocol"><a class="header" href="#how-to-build-a-bitcoin-lending-protocol">How to Build a Bitcoin Lending Protocol</a></h1>
<p>This guide walks through building a lending protocol for Bitcoin-based assets (BTC, Runes, Ordinals) on Arch Network. We‚Äôll create a decentralized lending platform similar to Aave, but specifically designed for Bitcoin-based assets.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch CLI installed</li>
</ul>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<h3 id="basic-user-flow"><a class="header" href="#basic-user-flow">Basic User Flow</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Depositing
        A[User wants to lend] --&gt;|1. Deposits BTC| B[Lending Pool]
        B --&gt;|2. Receives interest| A
    end

    subgraph Borrowing
        C[User needs loan] --&gt;|3. Provides collateral| B
        B --&gt;|4. Lends BTC| C
        C --&gt;|5. Repays loan + interest| B
    end

    style A fill:#b3e0ff
    style B fill:#98FB98
    style C fill:#b3e0ff
</pre>
<h3 id="safety-system"><a class="header" href="#safety-system">Safety System</a></h3>
<pre class="mermaid">flowchart LR
    subgraph &quot;Price Monitoring&quot;
        direction TB
        A[Price Oracle] --&gt;|1. Updates prices| B[Health Checker]
    end

    subgraph &quot;Health Check&quot;
        direction TB
        B --&gt;|2. Monitors positions| C[User Position]
        C --&gt;|3. If position unsafe| D[Liquidator]
    end

    style A fill:#FFB6C1
    style B fill:#FFB6C1
    style C fill:#b3e0ff
    style D fill:#FFB6C1
</pre>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<p>Let‚Äôs say Alice wants to borrow BTC and Bob wants to earn interest:</p>
<ol>
<li>
<p><strong>Bob (Lender)</strong></p>
<ul>
<li>Deposits 1 BTC into pool</li>
<li>Earns 3% APY interest</li>
</ul>
</li>
<li>
<p><strong>Alice (Borrower)</strong></p>
<ul>
<li>Provides 1.5 BTC as collateral</li>
<li>Borrows 1 BTC</li>
<li>Pays 5% APY interest</li>
</ul>
</li>
<li>
<p><strong>Safety System</strong></p>
<ul>
<li>Monitors BTC price</li>
<li>Checks if Alice‚Äôs collateral stays valuable enough</li>
<li>If BTC price drops too much, liquidates some collateral to protect Bob‚Äôs deposit</li>
</ul>
</li>
</ol>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>Our lending protocol consists of several key components:</p>
<h3 id="1-pool-accounts"><a class="header" href="#1-pool-accounts">1. Pool Accounts</a></h3>
<p>Pool accounts are the core of our lending protocol. They serve as liquidity pools where users can:</p>
<ul>
<li>Deposit Bitcoin-based assets (BTC, Runes, Ordinals)</li>
<li>Earn interest on deposits</li>
<li>Borrow against their collateral</li>
<li>Manage protocol parameters</li>
</ul>
<p>Each pool account maintains:</p>
<ul>
<li>Total deposits and borrows</li>
<li>Interest rates and utilization metrics</li>
<li>Collateral factors and liquidation thresholds</li>
<li>Asset-specific parameters</li>
</ul>
<p>The pool account manages both state and UTXOs:</p>
<ul>
<li><strong>State Management</strong>: Tracks deposits, withdrawals, and user positions</li>
<li><strong>UTXO Management</strong>:
<ul>
<li>Maintains a collection of UTXOs for the pool‚Äôs Bitcoin holdings</li>
<li>Manages UTXO creation for withdrawals</li>
<li>Handles UTXO consolidation for efficient liquidity management</li>
</ul>
</li>
</ul>
<h3 id="2-price-oracle"><a class="header" href="#2-price-oracle">2. Price Oracle</a></h3>
<p>Track asset prices for liquidation calculations</p>
<h3 id="3-user-positions"><a class="header" href="#3-user-positions">3. User Positions</a></h3>
<p>User positions track all user interactions with the lending pools:</p>
<ul>
<li>Active deposits and their earned interest</li>
<li>Outstanding borrows and accrued interest</li>
<li>Collateral positions and health factors</li>
<li>Liquidation thresholds and warnings</li>
</ul>
<p>Each user can have multiple positions across different pools, and the protocol tracks:</p>
<ul>
<li>Position health through real-time monitoring</li>
<li>Collateralization ratios</li>
<li>Interest accrual</li>
<li>Liquidation risks</li>
</ul>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct LendingPool {
    pub pool_pubkey: Pubkey,
    pub asset_type: AssetType, // BTC, Runes, Ordinals
    pub total_deposits: u64,
    pub total_borrows: u64,
    pub interest_rate: u64,
    pub utilization_rate: u64,
    pub liquidation_threshold: u64,
    pub collateral_factor: u64,
    pub utxos: Vec&lt;UtxoMeta&gt;,
    pub validator_signatures: Vec&lt;Signature&gt;,
    pub min_signatures_required: u32,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserPosition {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub deposited_amount: u64,
    pub borrowed_amount: u64,
    pub collateral_amount: u64,
    pub last_update: i64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct InterestRateModel {
    pub base_rate: u64,
    pub multiplier: u64,
    pub jump_multiplier: u64,
    pub optimal_utilization: u64,
}

// Additional helper structures for managing positions
#[derive(BorshSerialize, BorshDeserialize)]
pub struct PositionHealth {
    pub health_factor: u64,
    pub liquidation_price: u64,
    pub safe_borrow_limit: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PoolMetrics {
    pub total_value_locked: u64,
    pub available_liquidity: u64,
    pub utilization_rate: u64,
    pub supply_apy: u64,
    pub borrow_apy: u64,
}</code></pre>
<h2 id="custom-scoring-and-risk-management"><a class="header" href="#custom-scoring-and-risk-management">Custom Scoring and Risk Management</a></h2>
<h3 id="ltv-loan-to-value-scoring-system"><a class="header" href="#ltv-loan-to-value-scoring-system">LTV (Loan-to-Value) Scoring System</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Core_Factors[Core Factors]
        P1[Transaction History]
        P2[Asset Quality]
        P3[Market Volatility]
        P4[Position Size]
    end
    
    subgraph User_Metrics[User Metrics]
        P5[Account History]
        P6[Repayment Record]
        P7[Portfolio Health]
    end
    
    subgraph Market_Context[Market Context]
        P8[Market Conditions]
        P9[Price Impact]
        P10[Network Status]
    end
    
    Core_Factors --&gt; SC[Scoring Engine]
    User_Metrics --&gt; SC
    Market_Context --&gt; SC
    SC --&gt; WF[Weight Calculation]
    WF --&gt; NM[Risk Normalization]
    NM --&gt; LTV[Final LTV Ratio]
    
    style Core_Factors fill:#e1f3d8
    style User_Metrics fill:#fff7e6
    style Market_Context fill:#e6f3ff
    style SC fill:#f9f9f9
    style WF fill:#f9f9f9
    style NM fill:#f9f9f9
    style LTV fill:#d4edda
</pre>
<h3 id="health-score-monitoring"><a class="header" href="#health-score-monitoring">Health Score Monitoring</a></h3>
<pre class="mermaid">sequenceDiagram
    participant User
    participant HealthMonitor
    participant PriceOracle
    participant LiquidationEngine
    participant Market

    loop Every Block
        PriceOracle-&gt;&gt;HealthMonitor: Update Asset Prices
        HealthMonitor-&gt;&gt;HealthMonitor: Calculate Health Score
        
        alt Health Score &lt; Threshold
            HealthMonitor-&gt;&gt;LiquidationEngine: Trigger Liquidation
            LiquidationEngine-&gt;&gt;User: Lock Account
            LiquidationEngine-&gt;&gt;Market: List Assets
            Market--&gt;&gt;LiquidationEngine: Asset Sale Complete
            LiquidationEngine-&gt;&gt;User: Update Position
        else Health Score &gt;= Threshold
            HealthMonitor-&gt;&gt;User: Position Safe
        end
    end
</pre>
<h3 id="liquidation-process"><a class="header" href="#liquidation-process">Liquidation Process</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Monitoring
    Monitoring --&gt; Warning: Health Score Declining
    Warning --&gt; AtRisk: Below Warning Threshold
    AtRisk --&gt; Liquidation: Below Critical Threshold
    Liquidation --&gt; Step1: Lock Account
    Step1 --&gt; Step2: List Assets
    Step2 --&gt; Recovery: Asset Sale
    Recovery --&gt; [*]: Position Cleared
    
    Warning --&gt; Monitoring: Health Restored
    AtRisk --&gt; Warning: Health Improved
</pre>
<h3 id="custom-scoring-implementation"><a class="header" href="#custom-scoring-implementation">Custom Scoring Implementation</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserScore {
    pub historical_data_score: u64,
    pub asset_quality_score: u64,
    pub market_volatility_score: u64,
    pub position_size_score: u64,
    pub account_age_score: u64,
    pub liquidation_history_score: u64,
    pub repayment_history_score: u64,
    pub cross_margin_score: u64,
    pub portfolio_diversity_score: u64,
    pub market_condition_score: u64,
    pub collateral_quality_score: u64,
    pub platform_activity_score: u64,
    pub time_weighted_score: u64,
    pub price_impact_score: u64,
    pub network_status_score: u64,
}

pub fn calculate_ltv_ratio(score: &amp;UserScore) -&gt; Result&lt;u64&gt; {
    // Weighted calculation of LTV based on all scoring parameters
    let weighted_score = calculate_weighted_score(score)?;
    let normalized_score = normalize_score(weighted_score)?;
    
    // Convert normalized score to LTV ratio
    let ltv_ratio = convert_score_to_ltv(normalized_score)?;
    
    // Apply market condition adjustments
    let adjusted_ltv = apply_market_adjustments(ltv_ratio)?;
    
    Ok(adjusted_ltv)
}

pub fn monitor_health_score(
    ctx: Context&lt;HealthCheck&gt;,
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;()&gt; {
    let health_score = calculate_health_score(position, score)?;
    
    if health_score &lt; CRITICAL_THRESHOLD {
        trigger_full_liquidation(ctx, position)?;
        lock_account(ctx.accounts.user_account)?;
    } else if health_score &lt; WARNING_THRESHOLD {
        emit_warning(ctx.accounts.user_account)?;
    }
    
    Ok(())
}

pub fn trigger_full_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    position: &amp;UserPosition,
) -&gt; Result&lt;()&gt; {
    // Step 1: Lock the account
    lock_account(ctx.accounts.user_account)?;
    
    // Step 2: Calculate current position value
    let position_value = calculate_position_value(position)?;
    
    // Step 3: List assets on marketplace
    list_assets_for_liquidation(
        ctx.accounts.marketplace,
        position.assets,
        position_value,
    )?;
    
    // Step 4: Monitor recovery process
    start_recovery_monitoring(ctx.accounts.recovery_manager)?;
    
    Ok(())
}

## Health Score Calculation
The health score is calculated using a combination of factors:

```rust,ignore
pub fn calculate_health_score(
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;u64&gt; {
    // 1. Calculate base health ratio
    let base_health = calculate_base_health_ratio(
        position.collateral_value,
        position.borrowed_value,
    )?;
    
    // 2. Apply user score modifiers
    let score_adjusted_health = apply_score_modifiers(
        base_health,
        score,
    )?;
    
    // 3. Apply market condition adjustments
    let market_adjusted_health = apply_market_conditions(
        score_adjusted_health,
        &amp;position.asset_type,
    )?;
    
    // 4. Apply time-weighted factors
    let final_health_score = apply_time_weights(
        market_adjusted_health,
        position.last_update,
    )?;
    
    Ok(final_health_score)
}</code></pre>
<h3 id="liquidation-implementation"><a class="header" href="#liquidation-implementation">Liquidation Implementation</a></h3>
<p>The two-step liquidation process is implemented as follows:</p>
<pre><code class="language-rust ignore">pub struct LiquidationConfig {
    pub warning_threshold: u64,
    pub critical_threshold: u64,
    pub recovery_timeout: i64,
    pub minimum_recovery_value: u64,
}

pub fn handle_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    config: &amp;LiquidationConfig,
) -&gt; Result&lt;()&gt; {
    // Step 1: Asset Recovery
    let recovery_listing = create_recovery_listing(
        ctx.accounts.marketplace,
        ctx.accounts.user_position,
        config.minimum_recovery_value,
    )?;
    
    // Step 2: Monitor Recovery
    start_recovery_monitoring(
        recovery_listing,
        config.recovery_timeout,
    )?;
    
    // Lock account until recovery complete
    lock_user_account(ctx.accounts.user_account)?;
    
    Ok(())
}</code></pre>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="1-initialize-lending-pool"><a class="header" href="#1-initialize-lending-pool">1. Initialize Lending Pool</a></h3>
<p>First, we‚Äôll create a function to initialize a new lending pool:</p>
<pre><code class="language-rust ignore">pub fn initialize_lending_pool(
    ctx: Context&lt;InitializeLendingPool&gt;,
    asset_type: AssetType,
    initial_interest_rate: u64,
    liquidation_threshold: u64,
    collateral_factor: u64,
) -&gt; Result&lt;()&gt; {
    let lending_pool = &amp;mut ctx.accounts.lending_pool;
    
    lending_pool.pool_pubkey = ctx.accounts.pool.key();
    lending_pool.asset_type = asset_type;
    lending_pool.total_deposits = 0;
    lending_pool.total_borrows = 0;
    lending_pool.interest_rate = initial_interest_rate;
    lending_pool.utilization_rate = 0;
    lending_pool.liquidation_threshold = liquidation_threshold;
    lending_pool.collateral_factor = collateral_factor;
    
    Ok(())
}

// Initialize pool metrics
pub fn initialize_pool_metrics(
    ctx: Context&lt;InitializePoolMetrics&gt;,
) -&gt; Result&lt;()&gt; {
    let pool_metrics = &amp;mut ctx.accounts.pool_metrics;
    
    pool_metrics.total_value_locked = 0;
    pool_metrics.available_liquidity = 0;
    pool_metrics.utilization_rate = 0;
    pool_metrics.supply_apy = 0;
    pool_metrics.borrow_apy = 0;
    
    Ok(())
}</code></pre>
<h3 id="2-manage-user-positions"><a class="header" href="#2-manage-user-positions">2. Manage User Positions</a></h3>
<p>Functions to handle user position management:</p>
<pre><code class="language-rust ignore">pub fn create_user_position(
    ctx: Context&lt;CreateUserPosition&gt;,
    pool_pubkey: Pubkey,
) -&gt; Result&lt;()&gt; {
    let user_position = &amp;mut ctx.accounts.user_position;
    
    user_position.user_pubkey = ctx.accounts.user.key();
    user_position.pool_pubkey = pool_pubkey;
    user_position.deposited_amount = 0;
    user_position.borrowed_amount = 0;
    user_position.collateral_amount = 0;
    user_position.last_update = Clock::get()?.unix_timestamp;
    
    Ok(())
}

pub fn update_position_health(
    ctx: Context&lt;UpdatePositionHealth&gt;,
) -&gt; Result&lt;()&gt; {
    let position = &amp;ctx.accounts.user_position;
    let pool = &amp;ctx.accounts.lending_pool;
    let health = &amp;mut ctx.accounts.position_health;
    
    // Calculate health factor based on current prices and positions
    let collateral_value = calculate_collateral_value(
        position.collateral_amount,
        pool.asset_type,
    )?;
    
    let borrow_value = calculate_borrow_value(
        position.borrowed_amount,
        pool.asset_type,
    )?;
    
    health.health_factor = calculate_health_factor(
        collateral_value,
        borrow_value,
        pool.collateral_factor,
    )?;
    
    health.liquidation_price = calculate_liquidation_price(
        position.borrowed_amount,
        position.collateral_amount,
        pool.liquidation_threshold,
    )?;
    
    health.safe_borrow_limit = calculate_safe_borrow_limit(
        collateral_value,
        pool.collateral_factor,
    )?;
    
    Ok(())
}</code></pre>
<h3 id="3-pool-and-position-utilities"><a class="header" href="#3-pool-and-position-utilities">3. Pool and Position Utilities</a></h3>
<p>Helper functions for managing pools and positions:</p>
<pre><code class="language-rust ignore">// Calculate the utilization rate of a pool
pub fn calculate_utilization_rate(pool: &amp;LendingPool) -&gt; Result&lt;u64&gt; {
    if pool.total_deposits == 0 {
        return Ok(0);
    }
    
    Ok((pool.total_borrows * 10000) / pool.total_deposits)
}

// Calculate the health factor of a position
pub fn calculate_health_factor(
    collateral_value: u64,
    borrow_value: u64,
    collateral_factor: u64,
) -&gt; Result&lt;u64&gt; {
    if borrow_value == 0 {
        return Ok(u64::MAX);
    }
    
    Ok((collateral_value * collateral_factor) / (borrow_value * 10000))
}

// Update pool metrics
pub fn update_pool_metrics(
    pool: &amp;LendingPool,
    metrics: &amp;mut PoolMetrics,
) -&gt; Result&lt;()&gt; {
    metrics.total_value_locked = pool.total_deposits;
    metrics.available_liquidity = pool.total_deposits.saturating_sub(pool.total_borrows);
    metrics.utilization_rate = calculate_utilization_rate(pool)?;
    
    // Update APY rates based on utilization
    let (supply_apy, borrow_apy) = calculate_apy_rates(
        metrics.utilization_rate,
        pool.interest_rate,
    )?;
    
    metrics.supply_apy = supply_apy;
    metrics.borrow_apy = borrow_apy;
    
    Ok(())
}</code></pre>
<h3 id="4-deposit-assets"><a class="header" href="#4-deposit-assets">4. Deposit Assets</a></h3>
<p>Create a deposit function to allow users to provide liquidity:</p>
<pre><code class="language-rust ignore">pub fn deposit(
    ctx: Context&lt;Deposit&gt;,
    amount: u64,
    btc_txid: [u8; 32],
    vout: u32,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;
    
    // Verify the UTXO belongs to the user
    require!(
        validate_utxo_ownership(
            &amp;UtxoMeta {
                txid: btc_txid,
                vout,
                amount,
            },
            &amp;ctx.accounts.user.key()
        )?,
        ErrorCode::InvalidUTXO
    );

    // Create deposit account to hold the UTXO
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            btc_txid,
            vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.user.clone(), ctx.accounts.pool.clone()]
    )?;

    // Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update utilization metrics
    update_utilization_rate(pool)?;
    
    Ok(())
}</code></pre>
<h3 id="5-borrow-assets"><a class="header" href="#5-borrow-assets">5. Borrow Assets</a></h3>
<p>Implement borrowing functionality:</p>
<pre><code class="language-rust ignore">pub fn borrow(
    ctx: Context&lt;Borrow&gt;,
    amount: u64,
    collateral_utxo: UtxoMeta,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let borrower_position = &amp;mut ctx.accounts.user_position;

    // Verify collateral UTXO ownership
    require!(
        validate_utxo_ownership(
            &amp;collateral_utxo,
            &amp;ctx.accounts.borrower.key()
        )?,
        ErrorCode::InvalidCollateral
    );

    // Check collateral requirements
    require!(
        is_collateral_sufficient(borrower_position, pool, amount)?,
        ErrorCode::InsufficientCollateral
    );

    // Create collateral account
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            collateral_utxo.txid,
            collateral_utxo.vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.borrower.clone(), ctx.accounts.pool.clone()]
    )?;

    // Create borrow UTXO for user
    let mut btc_tx = Transaction::new();
    add_state_transition(&amp;mut btc_tx, ctx.accounts.pool);

    // Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;[InputToSign {
                index: 0,
                signer: pool.pool_pubkey
            }]
        }
    );

    // Update states
    pool.total_borrows = pool.total_borrows
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    borrower_position.borrowed_amount = borrower_position.borrowed_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;

    update_utilization_rate(pool)?;
    update_interest_rate(pool)?;

    Ok(())
}</code></pre>
<h3 id="6-liquidation-logic"><a class="header" href="#6-liquidation-logic">6. Liquidation Logic</a></h3>
<p>Implement liquidation for underwater positions:</p>
<pre><code class="language-rust ignore">pub fn liquidate(
    ctx: Context&lt;Liquidate&gt;,
    repay_amount: u64,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let liquidated_position = &amp;mut ctx.accounts.liquidated_position;
    
    // Check if position is liquidatable
    require!(
        is_position_liquidatable(liquidated_position, pool)?,
        ErrorCode::PositionNotLiquidatable
    );
    
    // Calculate liquidation bonus
    let bonus = calculate_liquidation_bonus(repay_amount, pool.liquidation_threshold)?;
    
    // Process liquidation
    process_liquidation(
        pool,
        liquidated_position,
        repay_amount,
        bonus,
    )?;
    
    Ok(())
}</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Create comprehensive tests for your lending protocol:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_initialize_lending_pool() {
        // Test pool initialization
    }

    #[test]
    fn test_deposit() {
        // Test deposit functionality
    }

    #[test]
    fn test_borrow() {
        // Test borrowing
    }

    #[test]
    fn test_liquidation() {
        // Test liquidation scenarios
    }
}</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<ol>
<li><strong>Collateral Safety</strong>: Implement strict collateral requirements and regular position health checks</li>
<li><strong>Price Oracle Security</strong>: Use reliable price feeds and implement safeguards against price manipulation</li>
<li><strong>Interest Rate Model</strong>: Ensure the model can handle extreme market conditions</li>
<li><strong>Access Control</strong>: Implement proper permission checks for all sensitive operations</li>
<li><strong>Liquidation Thresholds</strong>: Set appropriate thresholds to maintain protocol solvency</li>
</ol>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ol>
<li>
<p>Implement additional features:</p>
<ul>
<li>Flash loans</li>
<li>Multiple collateral types</li>
<li>Governance mechanisms</li>
</ul>
</li>
<li>
<p>Deploy and test on testnet:</p>
<ul>
<li>Monitor pool performance</li>
<li>Test liquidation scenarios</li>
<li>Validate interest rate model</li>
</ul>
</li>
<li>
<p>Security audit:</p>
<ul>
<li>Contract review</li>
<li>Economic model analysis</li>
<li>Risk assessment</li>
</ul>
</li>
</ol>
<h2 id="process-descriptions"><a class="header" href="#process-descriptions">Process Descriptions</a></h2>
<h3 id="1-pool-initialization-process"><a class="header" href="#1-pool-initialization-process">1. Pool Initialization Process</a></h3>
<p>The pool initialization process involves several steps:</p>
<pre class="mermaid">%%{init: {
  'theme': 'base',
  'themeVariables': { 'fontSize': '16px'},
  'flowchart': {
    'curve': 'basis',
    'nodeSpacing': 50,
    'rankSpacing': 50,
    'animation': {
      'sequence': true,
      'duration': 1000,
      'ease': 'linear',
      'diagramUpdate': 200
    }
  }
}}%%
graph LR
    A[Admin] --&gt;|Create Pool| B[Initialize Pool Account]
    B --&gt;|Set Parameters| C[Configure Pool]
    C --&gt;|Initialize Metrics| D[Create Pool Metrics]
    D --&gt;|Enable Oracle| E[Connect Price Feed]
    E --&gt;|Activate| F[Pool Active]

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef active fill:#4a9eff,color:white,stroke:#3182ce,opacity:0;
    classDef complete fill:#98FB98,stroke:#333;

</pre>
<ol>
<li>Admin creates a new pool account</li>
<li>Pool parameters are set (interest rates, thresholds)</li>
<li>Pool metrics are initialized</li>
<li>Price oracle connection is established</li>
<li>Pool is activated for user operations</li>
</ol>
<h3 id="2-deposit-and-borrow-flow"><a class="header" href="#2-deposit-and-borrow-flow">2. Deposit and Borrow Flow</a></h3>
<p>The lending and borrowing process follows this sequence:</p>
<pre class="mermaid">graph TD
    A[User] --&gt;|Deposit Assets| B[Lending Pool]
    B --&gt;|Create Position| C[User Position]
    C --&gt;|Calculate Capacity| D[Borrow Limit]
    D --&gt;|Enable Borrowing| E[Borrow Assets]
    E --&gt;|Update Metrics| F[Pool Metrics]
    F --&gt;|Adjust Rates| G[Interest Rates]
</pre>
<p>Key steps:</p>
<ol>
<li>User deposits assets into the pool</li>
<li>System creates or updates user position</li>
<li>Calculates borrowing capacity based on collateral</li>
<li>Enables borrowing up to the limit</li>
<li>Updates pool metrics and interest rates</li>
</ol>
<h3 id="3-health-monitoring-system"><a class="header" href="#3-health-monitoring-system">3. Health Monitoring System</a></h3>
<p>Continuous health monitoring process:</p>
<pre class="mermaid">graph TD
    A[Price Oracle] --&gt;|Update Prices| B[Position Valuation]
    B --&gt;|Calculate Ratios| C[Health Check]
    C --&gt;|Evaluate| D{Health Factor}
    D --&gt;|&gt;1| E[Healthy]
    D --&gt;|&lt;1| F[At Risk]
    F --&gt;|&lt;Threshold| G[Liquidatable]
    G --&gt;|Notify| H[Liquidators]
</pre>
<p>The system:</p>
<ol>
<li>Continuously monitors asset prices</li>
<li>Updates position valuations</li>
<li>Calculates health factors</li>
<li>Triggers liquidations when necessary</li>
</ol>
<h3 id="withdrawal-process"><a class="header" href="#withdrawal-process">Withdrawal Process</a></h3>
<p>The withdrawal process in our lending protocol involves two key components:</p>
<ol>
<li>State management through program accounts</li>
<li>Actual BTC transfer through UTXOs</li>
</ol>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct WithdrawRequest {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub amount: u64,
    pub recipient_btc_address: String,
}

pub fn process_withdrawal(
    ctx: Context&lt;ProcessWithdraw&gt;,
    request: WithdrawRequest,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;

    // 1. Validate user position
    require!(
        user_position.deposited_amount &gt;= request.amount,
        ErrorCode::InsufficientBalance
    );

    // 2. Check pool liquidity
    require!(
        pool.available_liquidity() &gt;= request.amount,
        ErrorCode::InsufficientLiquidity
    );

    // 3. Find available UTXOs from pool
    let selected_utxos = select_utxos_for_withdrawal(
        &amp;pool.utxos,
        request.amount
    )?;

    // 4. Create Bitcoin withdrawal transaction
    let mut btc_tx = Transaction::new();
    
    // Add inputs from selected UTXOs
    for utxo in selected_utxos {
        btc_tx.input.push(TxIn {
            previous_output: OutPoint::new(utxo.txid, utxo.vout),
            script_sig: Script::new(),
            sequence: Sequence::MAX,
            witness: Witness::new(),
        });
    }

    // Add withdrawal output to user's address
    let recipient_script = Address::from_str(&amp;request.recipient_btc_address)?
        .script_pubkey();
    btc_tx.output.push(TxOut {
        value: request.amount,
        script_pubkey: recipient_script,
    });

    // Add change output back to pool if needed
    let total_input = selected_utxos.iter()
        .map(|utxo| utxo.amount)
        .sum::&lt;u64&gt;();
    if total_input &gt; request.amount {
        btc_tx.output.push(TxOut {
            value: total_input - request.amount,
            script_pubkey: get_account_script_pubkey(&amp;pool.pool_pubkey),
        });
    }

    // 5. Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;selected_utxos.iter()
                .enumerate()
                .map(|(i, _)| InputToSign {
                    index: i as u32,
                    signer: pool.pool_pubkey,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        }
    );

    // 6. Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 7. Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 8. Remove spent UTXOs from pool
    pool.utxos.retain(|utxo| !selected_utxos.contains(utxo));

    Ok(())
}

fn select_utxos_for_withdrawal(
    pool_utxos: &amp;[UtxoMeta],
    amount: u64,
) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;&gt; {
    let mut selected = Vec::new();
    let mut total_selected = 0;

    for utxo in pool_utxos {
        if total_selected &gt;= amount {
            break;
        }
        
        // Verify UTXO is still valid and unspent
        validate_utxo(utxo)?;
        
        selected.push(utxo.clone());
        total_selected += utxo.amount;
    }

    require!(
        total_selected &gt;= amount,
        ErrorCode::InsufficientUtxos
    );

    Ok(selected)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-the-arch-program-library-apl"><a class="header" href="#introduction-to-the-arch-program-library-apl">Introduction to the Arch Program Library (APL)</a></h1>
<p>The Arch Program Library (APL) is a collection of on-chain programs targeting the Arch Network blockchain. These programs serve as fundamental building blocks for developing decentralized applications (dApps) on Arch Network. The APL programs are thoroughly tested, audited, and deployed to the mainnet, providing developers with reliable and secure components for their applications.</p>
<h2 id="available-programs"><a class="header" href="#available-programs">Available Programs</a></h2>
<p>The APL currently includes the following core programs:</p>
<h3 id="token-program"><a class="header" href="#token-program">Token Program</a></h3>
<p>The foundation for creating and managing fungible tokens on Arch Network. It provides a robust implementation for:</p>
<ul>
<li>Token creation and management</li>
<li>Account management</li>
<li>Transfer operations</li>
<li>Delegation capabilities</li>
<li>Multisignature support</li>
</ul>
<h3 id="associated-token-account-program"><a class="header" href="#associated-token-account-program">Associated Token Account Program</a></h3>
<p>A program that standardizes the creation and management of token accounts:</p>
<ul>
<li>Deterministic account address derivation</li>
<li>Simplified account management</li>
<li>Reduced transaction complexity</li>
</ul>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>The APL is designed with the following principles:</p>
<ol>
<li>
<p><strong>Security First</strong></p>
<ul>
<li>Comprehensive security audits</li>
<li>Battle-tested implementations</li>
<li>Conservative upgrade approach</li>
</ul>
</li>
<li>
<p><strong>Composability</strong></p>
<ul>
<li>Programs designed to work together</li>
<li>Standardized interfaces</li>
<li>Clear dependencies</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Optimized for Arch Network‚Äôs architecture</li>
<li>Efficient resource utilization</li>
<li>Scalable implementations</li>
</ul>
</li>
<li>
<p><strong>Developer Experience</strong></p>
<ul>
<li>Clear documentation</li>
<li>Example implementations</li>
<li>Testing utilities</li>
</ul>
</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To start building with APL:</p>
<ol>
<li>Familiarize yourself with the <a href="apl/../concepts/architecture.html">Arch Network architecture</a></li>
<li>Review the documentation for your program of interest</li>
<li>Check out the example implementations</li>
<li>Use the testing utilities to validate your integration</li>
</ol>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>The APL is an open-source project and welcomes contributions from the community. To contribute:</p>
<ol>
<li>Review the contribution guidelines</li>
<li>Join the developer community</li>
<li>Submit proposals for new features</li>
<li>Help improve documentation</li>
<li>Report and fix bugs</li>
</ol>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>For support with APL:</p>
<ul>
<li>Join the developer community</li>
<li>Check the FAQ and troubleshooting guides</li>
<li>Submit issues on GitHub</li>
<li>Participate in developer forums</li>
</ul>
<h2 id="future-development"><a class="header" href="#future-development">Future Development</a></h2>
<p>The APL is continuously evolving with new programs and improvements being added. Some areas of ongoing development include:</p>
<ul>
<li>Advanced token standards</li>
<li>DeFi primitives (including AMM and Swap functionality)</li>
<li>Cross-chain bridges</li>
<li>Privacy-preserving features</li>
</ul>
<p>Stay connected with the community to learn about new developments and opportunities to contribute to the ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-program-1"><a class="header" href="#token-program-1">Token Program</a></h1>
<p>The APL Token Program is the foundation for creating and managing fungible tokens on the Arch Network. This documentation provides a comprehensive guide for developers implementing token functionality in their applications.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The Token Program enables:</p>
<ul>
<li>Creation and management of fungible tokens (mints)</li>
<li>Token account management</li>
<li>Token transfers and delegations</li>
<li>Multisignature authorities</li>
<li>Account freezing and thawing</li>
</ul>
<h2 id="program-id"><a class="header" href="#program-id">Program ID</a></h2>
<pre><code>apl-token00000000000000000000000
</code></pre>
<h2 id="account-types"><a class="header" href="#account-types">Account Types</a></h2>
<h3 id="mint-account"><a class="header" href="#mint-account">Mint Account</a></h3>
<p>The central record for a token type, containing:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to mint new tokens</td></tr>
<tr><td><code>supply</code></td><td><code>u64</code></td><td>Total number of tokens in circulation</td></tr>
<tr><td><code>decimals</code></td><td><code>u8</code></td><td>Number of decimal places</td></tr>
<tr><td><code>is_initialized</code></td><td><code>bool</code></td><td>Has this mint been initialized</td></tr>
<tr><td><code>freeze_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to freeze token accounts</td></tr>
</tbody></table>
</div>
<h3 id="token-account"><a class="header" href="#token-account">Token Account</a></h3>
<p>Holds token balances for a specific mint:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint</code></td><td><code>Pubkey</code></td><td>The token mint this account holds</td></tr>
<tr><td><code>owner</code></td><td><code>Pubkey</code></td><td>Owner of this account</td></tr>
<tr><td><code>amount</code></td><td><code>u64</code></td><td>Number of tokens held</td></tr>
<tr><td><code>delegate</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional delegate authority</td></tr>
<tr><td><code>state</code></td><td><code>AccountState</code></td><td>Account state (Uninitialized/Initialized/Frozen)</td></tr>
<tr><td><code>delegated_amount</code></td><td><code>u64</code></td><td>Amount delegated</td></tr>
<tr><td><code>close_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to close the account</td></tr>
</tbody></table>
</div>
<h3 id="multisig-account"><a class="header" href="#multisig-account">Multisig Account</a></h3>
<p>Enables shared authority over token operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>m</code></td><td><code>u8</code></td><td>Number of required signers</td></tr>
<tr><td><code>n</code></td><td><code>u8</code></td><td>Number of valid signers</td></tr>
<tr><td><code>is_initialized</code></td><td><code>bool</code></td><td>Has this multisig been initialized</td></tr>
<tr><td><code>signers</code></td><td><code>[Pubkey; MAX_SIGNERS]</code></td><td>Array of valid signer addresses</td></tr>
</tbody></table>
</div>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<h3 id="token-creation-and-initialization"><a class="header" href="#token-creation-and-initialization">Token Creation and Initialization</a></h3>
<h4 id="initializemint"><a class="header" href="#initializemint">InitializeMint</a></h4>
<p>Creates a new token type.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InitializeMint {
    pub decimals: u8,
    pub mint_authority: Pubkey,
    pub freeze_authority: COption&lt;Pubkey&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The mint to initialize</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mint = Keypair::new();
let mint_authority = Keypair::new();
let decimals = 9;

let instruction = initialize_mint(
    &amp;mint.pubkey(),
    &amp;mint_authority.pubkey(),
    None, // No freeze authority
    decimals,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="initializeaccount"><a class="header" href="#initializeaccount">InitializeAccount</a></h4>
<p>Creates a new account to hold tokens.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The account to initialize</li>
<li><code>[]</code> The mint this account is for</li>
<li><code>[]</code> The owner of the new account</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account = Keypair::new();
let owner = Keypair::new();

let instruction = initialize_account(
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="initializemultisig"><a class="header" href="#initializemultisig">InitializeMultisig</a></h4>
<p>Creates a new multisignature authority.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InitializeMultisig {
    pub m: u8, // Number of required signers
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The multisig to initialize</li>
<li><code>[]</code> The signer accounts (1 to 11)</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let multisig = Keypair::new();
let signers = vec![signer1.pubkey(), signer2.pubkey(), signer3.pubkey()];
let min_signers = 2;

let instruction = initialize_multisig(
    &amp;multisig.pubkey(),
    &amp;signers,
    min_signers,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h3>
<h4 id="mintto"><a class="header" href="#mintto">MintTo</a></h4>
<p>Creates new tokens in an account.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MintTo {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The mint</li>
<li><code>[writable]</code> The account to mint to</li>
<li><code>[signer]</code> The mint authority</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount = 1_000_000_000; // 1 token with 9 decimals

let instruction = mint_to(
    &amp;mint.pubkey(),
    &amp;destination.pubkey(),
    &amp;mint_authority.pubkey(),
    amount,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="transfer-1"><a class="header" href="#transfer-1">Transfer</a></h4>
<p>Moves tokens between accounts.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Transfer {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[writable]</code> Destination account</li>
<li><code>[signer]</code> Owner/delegate authority</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount = 50_000_000; // 0.05 tokens with 9 decimals

let instruction = transfer(
    &amp;source.pubkey(),
    &amp;destination.pubkey(),
    &amp;owner.pubkey(),
    amount,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="burn"><a class="header" href="#burn">Burn</a></h4>
<p>Removes tokens from circulation.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Burn {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The account to burn from</li>
<li><code>[writable]</code> The token mint</li>
<li><code>[signer]</code> The owner/delegate</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount = 1_000_000_000; // 1 token with 9 decimals

let instruction = burn(
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
    amount,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="delegation"><a class="header" href="#delegation">Delegation</a></h3>
<h4 id="approve"><a class="header" href="#approve">Approve</a></h4>
<p>Delegates authority over tokens.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Approve {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[]</code> Delegate</li>
<li><code>[signer]</code> Source account owner</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let amount = 5_000_000_000; // 5 tokens with 9 decimals

let instruction = approve(
    &amp;source.pubkey(),
    &amp;delegate.pubkey(),
    &amp;owner.pubkey(),
    amount,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="revoke"><a class="header" href="#revoke">Revoke</a></h4>
<p>Removes delegated authority.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[signer]</code> Source account owner</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = revoke(
    &amp;source.pubkey(),
    &amp;owner.pubkey(),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="account-management"><a class="header" href="#account-management">Account Management</a></h3>
<h4 id="setauthority"><a class="header" href="#setauthority">SetAuthority</a></h4>
<p>Changes an authority on a mint or account.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SetAuthority {
    pub authority_type: AuthorityType,
    pub new_authority: COption&lt;Pubkey&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Mint/account to change</li>
<li><code>[signer]</code> Current authority</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = set_authority(
    &amp;mint.pubkey(),
    &amp;current_authority.pubkey(),
    Some(&amp;new_authority.pubkey()),
    AuthorityType::MintTokens,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="closeaccount"><a class="header" href="#closeaccount">CloseAccount</a></h4>
<p>Closes a token account with zero balance.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Account to close</li>
<li><code>[writable]</code> Destination for rent funds</li>
<li><code>[signer]</code> Account owner</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = close_account(
    &amp;account.pubkey(),
    &amp;destination.pubkey(),
    &amp;owner.pubkey(),
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The program defines specific error types for common failure cases:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenError {
    NotRentExempt,           // Account balance too low
    InsufficientFunds,       // Not enough tokens
    InvalidMint,             // Invalid mint account
    MintMismatch,           // Mint doesn't match
    OwnerMismatch,          // Wrong account owner
    FixedSupply,            // Mint authority disabled
    AlreadyInUse,           // Account already initialized
    InvalidNumberOfProvidedSigners,
    InvalidNumberOfRequiredSigners,
    UninitializedState,     // Account not initialized
    NativeNotSupported,     // Instruction not for native tokens
    NonNativeHasBalance,    // Non-native account with balance
    InvalidInstruction,     // Invalid instruction data
    InvalidState,           // Account in invalid state
    Overflow,               // Operation overflowed
    AuthorityTypeNotSupported,
    MintCannotFreeze,       // Mint has no freeze authority
    AccountFrozen,          // Account is frozen
    // ... other errors
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account states before operations</li>
<li>Validate mint associations</li>
</ul>
</li>
<li>
<p><strong>Authority Management</strong></p>
<ul>
<li>Use multisig for sensitive operations</li>
<li>Carefully manage mint/freeze authorities</li>
<li>Have clear authority transfer procedures</li>
</ul>
</li>
<li>
<p><strong>Operation Safety</strong></p>
<ul>
<li>Use checked math operations</li>
<li>Handle frozen accounts appropriately</li>
<li>Implement proper error handling</li>
</ul>
</li>
</ol>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ol>
<li>
<p><strong>Transaction Optimization</strong></p>
<ul>
<li>Combine related operations in one transaction</li>
<li>Minimize account lookups</li>
<li>Pre-allocate accounts when possible</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close unused accounts</li>
<li>Maintain rent-exempt balances</li>
<li>Use Associated Token Accounts when appropriate</li>
</ul>
</li>
</ol>
<h2 id="common-scenarios"><a class="header" href="#common-scenarios">Common Scenarios</a></h2>
<h3 id="creating-a-new-token"><a class="header" href="#creating-a-new-token">Creating a New Token</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Create mint account
let mint = Keypair::new();
let mint_rent = get_minimum_balance_for_rent_exemption(Mint::LEN)?;

let create_mint_account = system_instruction::create_account(
    &amp;payer.pubkey(),
    &amp;mint.pubkey(),
    mint_rent,
    Mint::LEN as u64,
    &amp;token_program_id,
);

// 2. Initialize mint
let init_mint = initialize_mint(
    &amp;mint.pubkey(),
    &amp;mint_authority.pubkey(),
    Some(&amp;freeze_authority.pubkey()),
    9, // decimals
)?;

// 3. Create token account
let account = Keypair::new();
let account_rent = get_minimum_balance_for_rent_exemption(Account::LEN)?;

let create_account = system_instruction::create_account(
    &amp;payer.pubkey(),
    &amp;account.pubkey(),
    account_rent,
    Account::LEN as u64,
    &amp;token_program_id,
);

// 4. Initialize token account
let init_account = initialize_account(
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
)?;

// 5. Combine into a single transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[
        create_mint_account,
        init_mint,
        create_account,
        init_account,
    ],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer, &amp;mint, &amp;account],
    recent_blockhash,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-a-token-transfer"><a class="header" href="#implementing-a-token-transfer">Implementing a Token Transfer</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Get token accounts
let source = get_associated_token_address(&amp;source_owner, &amp;mint);
let destination = get_associated_token_address(&amp;destination_owner, &amp;mint);

// 2. Create transfer instruction
let transfer = transfer(
    &amp;source,
    &amp;destination,
    &amp;source_owner,
    amount,
)?;

// 3. Send transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[transfer],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer, &amp;source_owner],
    recent_blockhash,
);
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>The Token Program includes comprehensive tests. When implementing token functionality, you should test:</p>
<ol>
<li>
<p><strong>Basic Operations</strong></p>
<ul>
<li>Mint initialization</li>
<li>Account creation</li>
<li>Token transfers</li>
<li>Balance checks</li>
</ul>
</li>
<li>
<p><strong>Authority Controls</strong></p>
<ul>
<li>Authority validation</li>
<li>Multisig operations</li>
<li>Authority transfers</li>
</ul>
</li>
<li>
<p><strong>Error Cases</strong></p>
<ul>
<li>Insufficient funds</li>
<li>Invalid authorities</li>
<li>Account state violations</li>
</ul>
</li>
</ol>
<p>Example test:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn test_transfer() {
        let program_id = token_program_id();
        let mint = Keypair::new();
        let source = Keypair::new();
        let destination = Keypair::new();
        let owner = Keypair::new();
        
        // Initialize mint and accounts
        // ... setup code ...
        
        // Test transfer
        let amount = 100;
        let result = transfer(
            &amp;source.pubkey(),
            &amp;destination.pubkey(),
            &amp;owner.pubkey(),
            amount,
        );
        
        assert!(result.is_ok());
        // Verify balances
        // ... verification code ...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-token-account-program-1"><a class="header" href="#associated-token-account-program-1">Associated Token Account Program</a></h1>
<p>The Associated Token Account (ATA) Program is a utility program in the Arch Program Library (APL) that standardizes the creation and management of token accounts. It provides a deterministic way to find and create token accounts for any wallet address and token mint combination.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The Associated Token Account Program enables:</p>
<ul>
<li>Deterministic derivation of token account addresses</li>
<li>Automatic token account creation</li>
<li>Standardized account management</li>
<li>Simplified token operations</li>
</ul>
<h2 id="program-id-1"><a class="header" href="#program-id-1">Program ID</a></h2>
<pre><code>associated-token-account00000000
</code></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="associated-token-accounts"><a class="header" href="#associated-token-accounts">Associated Token Accounts</a></h3>
<p>An Associated Token Account is a Program Derived Address (PDA) that is deterministically derived from:</p>
<ul>
<li>The wallet owner‚Äôs public key</li>
<li>The token mint address</li>
</ul>
<p>This ensures that:</p>
<ol>
<li>Each wallet can have exactly one associated token account per token mint</li>
<li>The account address can be derived by anyone who knows the wallet and mint addresses</li>
<li>The account ownership and permissions are standardized</li>
</ol>
<h3 id="account-structure"><a class="header" href="#account-structure">Account Structure</a></h3>
<p>The Associated Token Account follows the standard Token Account structure but with additional guarantees about its address derivation and ownership.</p>
<h2 id="instructions-1"><a class="header" href="#instructions-1">Instructions</a></h2>
<h3 id="create-associated-token-account"><a class="header" href="#create-associated-token-account">Create Associated Token Account</a></h3>
<p>Creates a new associated token account for a wallet and token mint combination.</p>
<p>Required accounts:</p>
<ul>
<li><code>[signer]</code> Funding account (pays for account creation)</li>
<li><code>[writable]</code> New associated token account</li>
<li><code>[]</code> Wallet address (account owner)</li>
<li><code>[]</code> Token mint</li>
<li><code>[]</code> System program</li>
<li><code>[]</code> Token program</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let associated_token_address = get_associated_token_address(
    &amp;wallet_address,
    &amp;token_mint
);

let create_ata_instruction = create_associated_token_account(
    &amp;payer.pubkey(),      // Funding account
    &amp;wallet_address,      // Wallet address
    &amp;token_mint,         // Token mint
);
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="account-management-1"><a class="header" href="#account-management-1">Account Management</a></h3>
<ol>
<li>
<p><strong>Creation</strong></p>
<ul>
<li>Always check if an associated token account exists before creating one</li>
<li>Use the standard creation instruction to ensure proper initialization</li>
<li>Handle account creation costs appropriately</li>
</ul>
</li>
<li>
<p><strong>Usage</strong></p>
<ul>
<li>Use associated token accounts as the default choice for user wallets</li>
<li>Derive addresses deterministically rather than storing them</li>
<li>Verify account ownership and mint before operations</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h3>
<ol>
<li>
<p><strong>Address Derivation</strong></p>
<ul>
<li>Always use the official derivation function</li>
<li>Verify derived addresses match expected patterns</li>
<li>Handle creation failure cases gracefully</li>
</ul>
</li>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Verify account ownership</li>
<li>Check token mint association</li>
<li>Validate account state before operations</li>
</ul>
</li>
</ol>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="creating-an-associated-token-account"><a class="header" href="#creating-an-associated-token-account">Creating an Associated Token Account</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Derive the associated token account address
let associated_token_address = get_associated_token_address(
    &amp;wallet_address,
    &amp;token_mint
);

// Create the account if it doesn't exist
if get_account_info(&amp;associated_token_address).is_none() {
    let create_ata_instruction = create_associated_token_account(
        &amp;payer.pubkey(),
        &amp;wallet_address,
        &amp;token_mint
    );
    
    let transaction = Transaction::new_signed_with_payer(
        &amp;[create_ata_instruction],
        Some(&amp;payer.pubkey()),
        &amp;[&amp;payer],
        recent_blockhash
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-associated-token-accounts-in-transfers"><a class="header" href="#using-associated-token-accounts-in-transfers">Using Associated Token Accounts in Transfers</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get associated token accounts for source and destination
let source_ata = get_associated_token_address(
    &amp;source_wallet,
    &amp;token_mint
);

let destination_ata = get_associated_token_address(
    &amp;destination_wallet,
    &amp;token_mint
);

// Create transfer instruction using ATAs
let transfer_instruction = transfer(
    &amp;source_ata,
    &amp;destination_ata,
    &amp;source_wallet,
    amount
);
<span class="boring">}</span></code></pre></pre>
<h2 id="common-scenarios-1"><a class="header" href="#common-scenarios-1">Common Scenarios</a></h2>
<h3 id="token-distribution"><a class="header" href="#token-distribution">Token Distribution</a></h3>
<p>When airdropping or distributing tokens:</p>
<ol>
<li>Derive the recipient‚Äôs associated token account address</li>
<li>Create the account if it doesn‚Äôt exist</li>
<li>Transfer tokens to the associated account</li>
</ol>
<h3 id="wallet-integration"><a class="header" href="#wallet-integration">Wallet Integration</a></h3>
<p>When integrating with user wallets:</p>
<ol>
<li>Use associated token accounts by default</li>
<li>Create accounts on-demand when users acquire new tokens</li>
<li>Display token balances from associated accounts</li>
</ol>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Common error cases to handle:</p>
<ul>
<li>Account already exists</li>
<li>Insufficient funds for account creation</li>
<li>Invalid mint association</li>
<li>Invalid owner</li>
<li>Account creation failure</li>
</ul>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<ul>
<li><a href="apl/./token-program.html">Token Program</a> - The main token program that works with ATAs</li>
<li><a href="apl/../program/program.html">Programs</a> - Understanding Arch programs</li>
<li><a href="apl/../program/accounts.html">Accounts</a> - Account model in Arch</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h1>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<pre class="mermaid">graph TB
    subgraph &quot;Arch Network&quot;
        VM[Arch VM&lt;br/&gt;eBPF-based]
        BTC[Bitcoin Integration]
        
        subgraph &quot;Validator Network&quot;
            L[Leader Node]
            V1[Validator Node 1]
            V2[Validator Node 2]
            V3[Validator Node ...]
            B[Bootnode]
        end
        
        VM --&gt; BTC
        L --&gt; V1
        L --&gt; V2
        L --&gt; V3
        B --&gt; V1
        B --&gt; V2
        B --&gt; V3
    end
</pre>
<h3 id="arch-vm"><a class="header" href="#arch-vm">Arch VM</a></h3>
<p>The Arch Virtual Machine (VM) is built on eBPF technology, providing a secure and efficient environment for executing programs.</p>
<p>Key features:</p>
<ul>
<li>üîÑ Manages program execution</li>
<li>‚ö° Handles state transitions</li>
<li>üéØ Ensures deterministic computation</li>
<li>üîó Provides syscalls for Bitcoin UTXO operations</li>
</ul>
<h3 id="bitcoin-integration"><a class="header" href="#bitcoin-integration">Bitcoin Integration</a></h3>
<p>Arch Network interacts directly with Bitcoin through:</p>
<ul>
<li>üíº Native UTXO management</li>
<li>‚úÖ Transaction validation</li>
<li>üîê Multi-signature coordination</li>
<li>üìù State commitment to Bitcoin</li>
</ul>
<h3 id="validator-network"><a class="header" href="#validator-network">Validator Network</a></h3>
<p>The validator network consists of multiple node types that work together:</p>
<h4 id="node-types"><a class="header" href="#node-types">Node Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Node Type</th><th>Primary Responsibilities</th></tr></thead><tbody>
<tr><td><strong>Leader Node</strong></td><td>‚Ä¢ Coordinates transaction signing<br/>‚Ä¢ Submits signed transactions to Bitcoin<br/>‚Ä¢ Manages validator communication</td></tr>
<tr><td><strong>Validator Nodes</strong></td><td>‚Ä¢ Execute programs in the Arch VM<br/>‚Ä¢ Validate transactions<br/>‚Ä¢ Participate in multi-signature operations<br/>‚Ä¢ Maintain network state</td></tr>
<tr><td><strong>Bootnode</strong></td><td>‚Ä¢ Handles initial network discovery<br/>‚Ä¢ Similar to Bitcoin DNS seeds<br/>‚Ä¢ Helps new nodes join the network</td></tr>
</tbody></table>
</div>
<h2 id="transaction-flow"><a class="header" href="#transaction-flow">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;L: 4. Sign Results
    L-&gt;&gt;B: 5. Submit to Bitcoin
</pre>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Arch Network implements a robust multi-layered security model that directly leverages Bitcoin‚Äôs security guarantees:</p>
<h3 id="1-utxo-security"><a class="header" href="#1-utxo-security">1. UTXO Security</a></h3>
<ul>
<li>
<p>üîí <strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for secure ownership proofs</li>
<li>Double-spend prevention through UTXO consumption tracking</li>
</ul>
</li>
<li>
<p>üîó <strong>State Management</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Atomic state transitions with rollback capability</li>
<li>Cross-validator state consistency checks</li>
</ul>
</li>
</ul>
<h3 id="2-transaction-security"><a class="header" href="#2-transaction-security">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">pub struct SecurityParams {
    pub min_confirmations: u32,    // Required Bitcoin confirmations
    pub signature_threshold: u32,   // Multi-sig threshold
    pub timelock_blocks: u32,      // Timelock requirement
    pub max_witness_size: usize    // Maximum witness data size
}</code></pre>
<ul>
<li>üìù <strong>Multi-signature Validation</strong>
<ul>
<li>ROAST protocol for distributed signing</li>
<li>Threshold signature scheme (t-of-n)</li>
<li>Malicious signer detection and removal</li>
<li>Binding factor verification for signature shares</li>
</ul>
</li>
</ul>
<h3 id="3-network-security"><a class="header" href="#3-network-security">3. Network Security</a></h3>
<ul>
<li>
<p>üåê <strong>Validator Selection</strong></p>
<pre><code class="language-rust ignore">pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32
}</code></pre>
<ul>
<li>Stake-weighted validator participation</li>
<li>Dynamic threshold adjustment</li>
<li>Automatic malicious node detection</li>
</ul>
</li>
<li>
<p>üõ°Ô∏è <strong>State Protection</strong></p>
<ul>
<li>Multi-stage transaction verification</li>
<li>Bitcoin-based finality guarantees</li>
<li>State root commitment to Bitcoin</li>
<li>Mandatory signature verification for all state changes</li>
</ul>
</li>
</ul>
<h3 id="4-best-practices"><a class="header" href="#4-best-practices">4. Best Practices</a></h3>
<ul>
<li>
<p>‚úÖ <strong>UTXO Management</strong></p>
<ul>
<li>Minimum 6 confirmations for finality</li>
<li>Comprehensive UTXO validation</li>
<li>Double-spend monitoring</li>
<li>Reorg handling for UTXO invalidation</li>
</ul>
</li>
<li>
<p>üîç <strong>Transaction Processing</strong></p>
<ul>
<li>Full signature verification</li>
<li>Input/output validation</li>
<li>Proper error handling</li>
<li>Network partition handling</li>
</ul>
</li>
</ul>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-architecture"><a class="header" href="#network-architecture">Network Architecture</a></h1>
<p>Arch Network operates as a distributed system with different types of nodes working together to provide secure and efficient program execution on Bitcoin. This document details the network‚Äôs architecture and how different components interact.</p>
<h2 id="network-overview"><a class="header" href="#network-overview">Network Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph Core[&quot;Core Components&quot;]
        direction TB
        BN[Bitcoin Network]
        Boot[Bootnode]
    end

    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[MultiSig\nAggregation]
    end
    
    subgraph Validators[&quot;Validator Network&quot;]
        direction TB
        V1[Validator 1]
        V2[Validator 2]
        V3[Validator 3]
        VN[Validator N]
    end

    BN --&gt; LN[Leader Node]
    Boot --&gt; LN
    
    LN --&gt; TC
    LN --&gt; MS
    
    LN --&gt; V1
    LN --&gt; V2
    LN --&gt; V3
    LN --&gt; VN

    %% Styling
    classDef core fill:#e1f5fe,stroke:#01579b
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validators fill:#f3e5f5,stroke:#4a148c
    
    class BN,Boot core
    class TC,MS leader
    class V1,V2,V3,VN validators
</pre>
<h2 id="node-types-1"><a class="header" href="#node-types-1">Node Types</a></h2>
<h3 id="1-bootnode"><a class="header" href="#1-bootnode">1. Bootnode</a></h3>
<p>The bootnode serves as the network‚Äôs entry point, similar to DNS seeds in Bitcoin:</p>
<ul>
<li>Handles initial network discovery</li>
<li>Maintains whitelist of valid validators</li>
<li>Coordinates peer connections</li>
<li>Manages network topology</li>
</ul>
<pre class="mermaid">flowchart LR
    subgraph Bootnode[&quot;Bootnode Services&quot;]
        direction TB
        PR[Peer Registry]
        WL[Validator Whitelist]
    end

    NN[New Node]
    VN[Validator Network]

    %% Connections
    NN &lt;--&gt; PR
    PR &lt;--&gt; VN
    WL -.-&gt; PR

    %% Styling
    classDef bootnode fill:#e1f5fe,stroke:#01579b
    classDef external fill:#f5f5f5,stroke:#333
    classDef connection stroke-width:2px
    
    class PR,WL bootnode
    class NN,VN external
</pre>
<p>Configuration:</p>
<pre><code class="language-bash">cargo run -p bootnode -- \
    --network-mode localnet \
    --p2p-bind-port 19001 \
    --leader-peer-id "&lt;LEADER_ID&gt;" \
    --validator-whitelist "&lt;VALIDATOR_IDS&gt;"
</code></pre>
<h3 id="2-leader-node"><a class="header" href="#2-leader-node">2. Leader Node</a></h3>
<p>The leader node coordinates transaction processing and Bitcoin integration:</p>
<pre class="mermaid">flowchart TB
    %% Main Components
    BN[Bitcoin Network]
    LN[Leader Node]
    VN[Validator Network]
    PE[Program Execution]
    
    %% Leader Node Services
    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[Multi-sig\nAggregation]
    end
    
    %% Connections
    BN &lt;--&gt; LN
    LN --&gt; Leader
    TC --&gt; VN
    MS --&gt; VN
    VN --&gt; PE
    
    %% Styling
    classDef bitcoin fill:#f7931a,stroke:#c16c07,color:white
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validator fill:#f3e5f5,stroke:#4a148c
    classDef execution fill:#e8f5e9,stroke:#1b5e20
    
    class BN bitcoin
    class LN,TC,MS leader
    class VN validator
    class PE execution
</pre>
<p>Key responsibilities:</p>
<ul>
<li>Transaction coordination</li>
<li>Multi-signature aggregation</li>
<li>Bitcoin transaction submission</li>
<li>Network state management</li>
</ul>
<h3 id="3-validator-nodes"><a class="header" href="#3-validator-nodes">3. Validator Nodes</a></h3>
<p>Validator nodes form the core of the network‚Äôs computation and validation:</p>
<pre class="mermaid">flowchart TB
    subgraph ValidatorNode[&quot;Validator Node&quot;]
        direction TB
        
        subgraph Execution[&quot;Execution Layer&quot;]
            direction LR
            VM[&quot;Arch VM\nExecution&quot;]
            SV[&quot;State\nValidation&quot;]
        end
        
        NP[&quot;Network Protocol&quot;]
        P2P[&quot;P2P Network&quot;]
        
        %% Connections within validator
        VM --&gt; NP
        SV --&gt; NP
        NP --&gt; P2P
    end
    
    %% Styling
    classDef validator fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef execution fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
    classDef network fill:#e3f2fd,stroke:#0d47a1,stroke-width:2px
    
    class ValidatorNode validator
    class VM,SV execution
    class NP,P2P network
</pre>
<p>Types:</p>
<ol>
<li>
<p><strong>Full Validator</strong></p>
<ul>
<li>Participates in consensus</li>
<li>Executes programs</li>
<li>Maintains full state</li>
</ul>
</li>
<li>
<p><strong>Lightweight Validator</strong></p>
<ul>
<li>Local development use</li>
<li>Single-node operation</li>
<li>Simulated environment</li>
</ul>
</li>
</ol>
<h2 id="network-communication"><a class="header" href="#network-communication">Network Communication</a></h2>
<h3 id="p2p-protocol"><a class="header" href="#p2p-protocol">P2P Protocol</a></h3>
<p>The network uses libp2p for peer-to-peer communication:</p>
<pre><code class="language-rust ignore">pub const ENABLED_PROTOCOLS: [&amp;str; 2] = [
    ArchNetworkProtocol::STREAM_PROTOCOL,
    ArchNetworkProtocol::VALIDATOR_PROTOCOL,
];

// Protocol versions
pub const PROTOCOL_VERSION: &amp;str = "/arch/1.0.0";
pub const VALIDATOR_VERSION: &amp;str = "/arch/validator/1.0.0";</code></pre>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<ol>
<li>
<p><strong>Network Messages</strong></p>
<pre><code class="language-rust ignore">pub enum NetworkMessage {
    Discovery(DiscoveryMessage),
    State(StateMessage),
    Transaction(TransactionMessage),
}</code></pre>
</li>
<li>
<p><strong>ROAST Protocol Messages</strong></p>
<pre><code class="language-rust ignore">pub enum RoastMessage {
    KeyGeneration(KeyGenMessage),
    Signing(SigningMessage),
    Aggregation(AggregationMessage),
}</code></pre>
</li>
</ol>
<h2 id="network-modes"><a class="header" href="#network-modes">Network Modes</a></h2>
<h3 id="1-devnet"><a class="header" href="#1-devnet">1. Devnet</a></h3>
<ul>
<li>Local development environment</li>
<li>Single validator setup</li>
<li>Simulated Bitcoin interactions</li>
<li>Fast block confirmation</li>
</ul>
<h3 id="2-testnet"><a class="header" href="#2-testnet">2. Testnet</a></h3>
<ul>
<li>Test environment with multiple validators</li>
<li>Bitcoin testnet integration</li>
<li>Real network conditions</li>
<li>Test transaction processing</li>
</ul>
<h3 id="3-mainnet"><a class="header" href="#3-mainnet">3. Mainnet</a></h3>
<ul>
<li>Production network</li>
<li>Full security model</li>
<li>Bitcoin mainnet integration</li>
<li>Live transaction processing</li>
</ul>
<h2 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h2>
<h3 id="1-validator-selection"><a class="header" href="#1-validator-selection">1. Validator Selection</a></h3>
<pre><code class="language-rust ignore">pub struct ValidatorInfo {
    pub peer_id: PeerId,
    pub pubkey: Pubkey,
    pub stake: u64,
}

pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32,
}</code></pre>
<h3 id="2-transaction-security-1"><a class="header" href="#2-transaction-security-1">2. Transaction Security</a></h3>
<ul>
<li>Multi-signature validation using ROAST protocol</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Double-spend prevention</li>
</ul>
<h3 id="3-state-protection"><a class="header" href="#3-state-protection">3. State Protection</a></h3>
<pre><code class="language-rust ignore">pub struct StateUpdate {
    pub block_height: u64,
    pub state_root: Hash,
    pub bitcoin_height: u64,
    pub signatures: Vec&lt;Signature&gt;,
}</code></pre>
<h2 id="monitoring-and-telemetry"><a class="header" href="#monitoring-and-telemetry">Monitoring and Telemetry</a></h2>
<h3 id="1-node-metrics"><a class="header" href="#1-node-metrics">1. Node Metrics</a></h3>
<pre><code class="language-rust ignore">pub struct NodeMetrics {
    pub peer_id: PeerId,
    pub network_mode: ArchNetworkMode,
    pub bitcoin_block_height: u64,
    pub arch_block_height: u64,
    pub peers_connected: u32,
    pub transactions_processed: u64,
    pub program_count: u32,
}</code></pre>
<h3 id="2-network-health"><a class="header" href="#2-network-health">2. Network Health</a></h3>
<pre><code class="language-rust ignore">pub struct NetworkHealth {
    pub validator_count: u32,
    pub active_validators: u32,
    pub network_tps: f64,
    pub average_block_time: Duration,
    pub fork_count: u32,
}</code></pre>
<h3 id="3-monitoring-endpoints"><a class="header" href="#3-monitoring-endpoints">3. Monitoring Endpoints</a></h3>
<ul>
<li><code>/metrics</code> - Prometheus metrics</li>
<li><code>/health</code> - Node health check</li>
<li><code>/peers</code> - Connected peers</li>
<li><code>/status</code> - Network status</li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="1-node-operation"><a class="header" href="#1-node-operation">1. Node Operation</a></h3>
<ul>
<li>Secure key management</li>
<li>Regular state verification</li>
<li>Proper shutdown procedures</li>
<li>Log management</li>
</ul>
<h3 id="2-network-participation"><a class="header" href="#2-network-participation">2. Network Participation</a></h3>
<ul>
<li>Maintain node availability</li>
<li>Monitor Bitcoin integration</li>
<li>Handle network upgrades</li>
<li>Backup critical data</li>
</ul>
<h3 id="3-development-setup"><a class="header" href="#3-development-setup">3. Development Setup</a></h3>
<ul>
<li>Use lightweight validator for testing</li>
<li>Monitor resource usage</li>
<li>Handle network modes properly</li>
<li>Implement proper error handling</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-integration-1"><a class="header" href="#bitcoin-integration-1">Bitcoin Integration</a></h1>
<p>Arch Network provides direct integration with Bitcoin, enabling programs to interact with Bitcoin‚Äôs UTXO model while maintaining Bitcoin‚Äôs security guarantees. This document details how Arch Network integrates with Bitcoin.</p>
<h2 id="architecture-overview-2"><a class="header" href="#architecture-overview-2">Architecture Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph BN[Bitcoin Network]
        BNode[Bitcoin Node]
    end

    subgraph TC[Titan Client]
        TCNode[Titan Client]
    end

    subgraph AN[Arch Network]
        LN[Leader Node\nBitcoin Integration]
        subgraph VN[Validator Network]
            P1[Program 1]
            PN[Program N]
        end
    end

    BNode &lt;--&gt; TCNode
    TCNode &lt;--&gt; LN
    LN &lt;--&gt; VN
    P1 --- PN
</pre>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<h3 id="1-utxo-management"><a class="header" href="#1-utxo-management">1. UTXO Management</a></h3>
<p>Arch Network manages Bitcoin UTXOs through a specialized system:</p>
<pre class="mermaid">flowchart LR
    subgraph UTXO[Bitcoin UTXO]
        TxID[TransactionID]
        OutIdx[OutputIndex]
    end

    subgraph Account[Arch Account]
        Meta[UTXOMeta]
        State[ProgramState]
    end

    TxID --&gt; Meta
    OutIdx --&gt; Meta
    Meta --- State
</pre>
<pre><code class="language-rust ignore">// UTXO Metadata Structure
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Transaction ID
    pub vout: u32,       // Output index
    pub amount: u64,     // Amount in satoshis
    pub script_pubkey: Vec&lt;u8&gt;, // Output script
    pub confirmation_height: Option&lt;u32&gt;, // Block height of confirmation
}

// UTXO Account State
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: Vec&lt;u8&gt;,
    pub is_frozen: bool,
}</code></pre>
<p>Key operations:</p>
<pre><code class="language-rust ignore">// UTXO Operations
pub trait UtxoOperations {
    fn create_utxo(meta: UtxoMeta, owner: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn spend_utxo(utxo: &amp;UtxoMeta, signature: &amp;Signature) -&gt; Result&lt;()&gt;;
    fn freeze_utxo(utxo: &amp;UtxoMeta, authority: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn delegate_utxo(utxo: &amp;UtxoMeta, delegate: &amp;Pubkey) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="2-bitcoin-rpc-integration"><a class="header" href="#2-bitcoin-rpc-integration">2. Bitcoin RPC Integration</a></h3>
<pre class="mermaid">flowchart LR
    AP[Arch\nProgram]
    RPC[Bitcoin RPC\nInterface]
    BN[Bitcoin\nNode]
    Config[Configuration]
    Network[Bitcoin\nNetwork]

    AP --&gt; RPC
    RPC --&gt; BN
    AP --&gt; Config
    Config --&gt; RPC
    BN --&gt; Network

    style AP fill:#f9f9f9,stroke:#333,stroke-width:2px
    style RPC fill:#f9f9f9,stroke:#333,stroke-width:2px
    style BN fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Config fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Network fill:#f9f9f9,stroke:#333,stroke-width:2px
</pre>
<p>Programs can interact with Bitcoin through RPC calls:</p>
<pre><code class="language-rust ignore">// Bitcoin RPC Configuration
pub struct BitcoinRpcConfig {
    pub endpoint: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub wallet: Option&lt;String&gt;,
    pub network: BitcoinNetwork,
    pub timeout: Duration,
}

// RPC Interface
pub trait BitcoinRpc {
    fn get_block_count(&amp;self) -&gt; Result&lt;u64&gt;;
    fn get_block_hash(&amp;self, height: u64) -&gt; Result&lt;BlockHash&gt;;
    fn get_transaction(&amp;self, txid: &amp;Txid) -&gt; Result&lt;Transaction&gt;;
    fn send_raw_transaction(&amp;self, tx: &amp;[u8]) -&gt; Result&lt;Txid&gt;;
    fn verify_utxo(&amp;self, utxo: &amp;UtxoMeta) -&gt; Result&lt;bool&gt;;
}</code></pre>
<h2 id="transaction-flow-1"><a class="header" href="#transaction-flow-1">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Program
    participant Leader
    participant Validator
    participant Bitcoin

    Program-&gt;&gt;Leader: Create UTXO
    Leader-&gt;&gt;Validator: Validate
    Validator-&gt;&gt;Leader: Sign
    Leader-&gt;&gt;Bitcoin: Submit TX
    Bitcoin--&gt;&gt;Program: Confirmation
</pre>
<h3 id="1-transaction-creation"><a class="header" href="#1-transaction-creation">1. Transaction Creation</a></h3>
<pre><code class="language-rust ignore">// Create new UTXO transaction
pub struct UtxoCreation {
    pub amount: u64,
    pub owner: Pubkey,
    pub metadata: Option&lt;Vec&lt;u8&gt;&gt;,
}

impl UtxoCreation {
    pub fn new(amount: u64, owner: Pubkey) -&gt; Self {
        Self {
            amount,
            owner,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: Vec&lt;u8&gt;) -&gt; Self {
        self.metadata = Some(metadata);
        self
    }
}</code></pre>
<h3 id="2-transaction-validation"><a class="header" href="#2-transaction-validation">2. Transaction Validation</a></h3>
<pre><code class="language-rust ignore">// Validation rules
pub trait TransactionValidation {
    fn validate_inputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_outputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_signatures(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_script(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="3-state-management"><a class="header" href="#3-state-management">3. State Management</a></h3>
<pre><code class="language-rust ignore">// State transition
pub struct StateTransition {
    pub previous_state: Hash,
    pub next_state: Hash,
    pub utxos_created: Vec&lt;UtxoMeta&gt;,
    pub utxos_spent: Vec&lt;UtxoMeta&gt;,
    pub bitcoin_height: u64,
}</code></pre>
<h2 id="security-model-2"><a class="header" href="#security-model-2">Security Model</a></h2>
<h3 id="1-utxo-security-1"><a class="header" href="#1-utxo-security-1">1. UTXO Security</a></h3>
<ul>
<li>Ownership verification through public key cryptography</li>
<li>Double-spend prevention through UTXO consumption</li>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature requirements</li>
</ul>
<h3 id="2-transaction-security-2"><a class="header" href="#2-transaction-security-2">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">// Transaction security parameters
pub struct SecurityParams {
    pub min_confirmations: u32,
    pub signature_threshold: u32,
    pub timelock_blocks: u32,
    pub max_witness_size: usize,
}</code></pre>
<h3 id="3-network-security-1"><a class="header" href="#3-network-security-1">3. Network Security</a></h3>
<ul>
<li>Multi-signature validation</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Cross-validator consistency</li>
</ul>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<h3 id="1-bitcoin-errors"><a class="header" href="#1-bitcoin-errors">1. Bitcoin Errors</a></h3>
<pre><code class="language-rust ignore">pub enum BitcoinError {
    ConnectionFailed(String),
    InvalidTransaction(String),
    InsufficientFunds(u64),
    InvalidUtxo(UtxoMeta),
    RpcError(String),
}</code></pre>
<h3 id="2-utxo-errors"><a class="header" href="#2-utxo-errors">2. UTXO Errors</a></h3>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound(UtxoMeta),
    AlreadySpent(UtxoMeta),
    InvalidOwner(Pubkey),
    InvalidSignature(Signature),
    InvalidState(Hash),
}</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="1-utxo-management-1"><a class="header" href="#1-utxo-management-1">1. UTXO Management</a></h3>
<ul>
<li>Always verify UTXO ownership</li>
<li>Wait for sufficient confirmations</li>
<li>Handle reorganizations gracefully</li>
<li>Implement proper error handling</li>
</ul>
<h3 id="2-transaction-processing"><a class="header" href="#2-transaction-processing">2. Transaction Processing</a></h3>
<ul>
<li>Validate all inputs and outputs</li>
<li>Check signature thresholds</li>
<li>Maintain proper state transitions</li>
<li>Monitor Bitcoin network status</li>
</ul>
<h3 id="3-security-considerations"><a class="header" href="#3-security-considerations">3. Security Considerations</a></h3>
<ul>
<li>Protect private keys</li>
<li>Validate all signatures</li>
<li>Monitor for double-spend attempts</li>
<li>Handle network partitions</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="roast-and-frost-consensus"><a class="header" href="#roast-and-frost-consensus">ROAST and FROST Consensus</a></h1>
<p>This section explores Arch‚Äôs consensus mechanism, which combines ROAST (Robust Asynchronous Schnorr Threshold Signatures) and FROST (Flexible Round-Optimized Schnorr Threshold Signatures) to create a secure, efficient, and highly scalable approach to distributed consensus that‚Äôs perfectly suited for Bitcoin-based smart contracts.</p>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p>The consensus mechanism implementation has made significant progress, particularly in the core cryptographic components:</p>
<ol>
<li>
<p><strong>Implemented Components</strong></p>
<ul>
<li>Complete Distributed Key Generation (DKG) protocol using FROST-secp256k1</li>
<li>Two-round DKG process with package handling</li>
<li>Network message protocol for DKG coordination</li>
<li>State management and status tracking</li>
<li>Integration with network layer</li>
<li>Error handling and recovery mechanisms</li>
</ul>
</li>
<li>
<p><strong>In Progress</strong></p>
<ul>
<li>Additional ROAST protocol components</li>
<li>Advanced state management features</li>
<li>Performance optimizations</li>
<li>Extended monitoring and telemetry</li>
</ul>
</li>
</ol>
<p>The subsequent sections describe both the implemented features and the complete protocol design.</p>
<h2 id="core-implementation-details"><a class="header" href="#core-implementation-details">Core Implementation Details</a></h2>
<h3 id="distributed-key-generation-dkg"><a class="header" href="#distributed-key-generation-dkg">Distributed Key Generation (DKG)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Core DKG message types for network coordination
pub enum DKGMessage {
    StartDKG { message: String },
    Round1Package { package: round1::Package },
    Round2Package { package: round2::Package },
    DKGStatus(DKGStatusMessage),
}

// DKG state management
pub enum DKGStatus {
    Pending(String),
    Ongoing(String),
    Failed(String, String),
    Finished(String),
    NetworkCompleted(String),
}
<span class="boring">}</span></code></pre></pre>
<p>The DKG implementation provides:</p>
<ul>
<li>Two-round key generation protocol</li>
<li>Secure package exchange between validators</li>
<li>State tracking and synchronization</li>
<li>Failure recovery and error handling</li>
</ul>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>Arch‚Äôs consensus mechanism combines ROAST and FROST to provide a robust, Bitcoin-native consensus solution. Validators participate in a threshold signature scheme where blocks are produced by designated leaders and finalized through collective signing. The system maintains both safety and liveness through careful economic incentives and cryptographic guarantees, while ensuring complete compatibility with Bitcoin‚Äôs Schnorr signature scheme.</p>
<h2 id="block-production-process"><a class="header" href="#block-production-process">Block Production Process</a></h2>
<h3 id="1-leader-selection"><a class="header" href="#1-leader-selection">1. Leader Selection</a></h3>
<pre class="mermaid">graph TD
    A[Epoch Start] --&gt; B[Calculate Leader Schedule]
    B --&gt; C[Distribute Schedule to Validators]
    C --&gt; D[Leaders Prepare for Slots]
    D --&gt; E[Next Leader Takes Turn]
    E --&gt; F[Block Production]
    F --&gt; G[Block Distribution]
    G --&gt; E
</pre>
<p>The block production process begins with leader selection:</p>
<ul>
<li>Each epoch (fixed time period) has a predetermined leader schedule</li>
<li>Leaders are selected based on their stake weight</li>
<li>The schedule is deterministic and known to all validators</li>
<li>Multiple backup leaders are selected for fault tolerance</li>
</ul>
<h3 id="2-transaction-collection-and-verification"><a class="header" href="#2-transaction-collection-and-verification">2. Transaction Collection and Verification</a></h3>
<pre class="mermaid">graph LR
    A[Transaction Pool] --&gt; B[Leader]
    C[Mempool] --&gt; B
    B --&gt; D[Transaction Verification]
    D --&gt; E[Block Formation]
    E --&gt; F[Block Proposal]
</pre>
<p>When a validator becomes the leader:</p>
<ol>
<li>Collects pending transactions from the mempool</li>
<li>Verifies transaction signatures and validity</li>
<li>Orders transactions based on priority and fees</li>
<li>Prepares them for inclusion in the next block</li>
</ol>
<h3 id="3-block-formation"><a class="header" href="#3-block-formation">3. Block Formation</a></h3>
<pre class="mermaid">sequenceDiagram
    participant L as Leader
    participant B as Block
    participant V as Validators
    L-&gt;&gt;B: Create Block Header
    L-&gt;&gt;B: Add Transactions
    L-&gt;&gt;B: Add State Updates
    L-&gt;&gt;B: Sign Block
    L-&gt;&gt;V: Broadcast Block
</pre>
<p>The block structure includes:</p>
<ul>
<li>Previous block reference</li>
<li>Timestamp</li>
<li>Transaction merkle root</li>
<li>UTXO state updates</li>
<li>Leader‚Äôs signature</li>
</ul>
<h2 id="consensus-process"><a class="header" href="#consensus-process">Consensus Process</a></h2>
<h3 id="1-block-validation"><a class="header" href="#1-block-validation">1. Block Validation</a></h3>
<pre class="mermaid">graph TD
    A[Receive Block] --&gt; B[Verify Leader]
    B --&gt; C[Verify Signatures]
    C --&gt; D[Execute Transactions]
    D --&gt; E[Verify UTXO States]
    E --&gt; F[Vote Decision]
</pre>
<p>When validators receive a new block:</p>
<ol>
<li>Verify the block producer is the designated leader</li>
<li>Validate all transaction signatures</li>
<li>Execute transactions and verify UTXO states</li>
<li>Check for any consensus rule violations</li>
</ol>
<h3 id="2-utxo-based-state-management"><a class="header" href="#2-utxo-based-state-management">2. UTXO-Based State Management</a></h3>
<pre class="mermaid">graph TD
    A[Transaction] --&gt; B[UTXO Validation]
    B --&gt; C[State Update]
    C --&gt; D[Bitcoin Transaction]
    D --&gt; E[Validator Signatures]
    
    B --&gt; F[Ownership Verification]
    B --&gt; G[Double-spend Check]
    B --&gt; H[Confirmation Check]
    
    C --&gt; I[Account Updates]
    C --&gt; J[Program State]
    C --&gt; K[UTXO Set Changes]
</pre>
<p>Arch‚Äôs unique approach to state management leverages Bitcoin‚Äôs UTXO model while extending it for smart contract functionality:</p>
<h4 id="utxo-state-tracking"><a class="header" href="#utxo-state-tracking">UTXO State Tracking</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UtxoState {
    pub meta: UtxoMeta,          // UTXO identification
    pub status: UtxoStatus,      // Current UTXO status
    pub owner: Pubkey,           // UTXO owner
    pub created_at: i64,         // Creation timestamp
    pub spent_at: Option&lt;i64&gt;,   // Spend timestamp if spent
}

pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="state-transition-process"><a class="header" href="#state-transition-process">State Transition Process</a></h4>
<ol>
<li>
<p><strong>UTXO Validation</strong></p>
<ul>
<li>Verify UTXO existence on Bitcoin</li>
<li>Check confirmation requirements (typically 6+)</li>
<li>Validate ownership and spending conditions</li>
<li>Prevent double-spending attempts</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Atomic account data modifications</li>
<li>Program state transitions</li>
<li>UTXO set updates</li>
<li>Cross-validator state consistency</li>
</ul>
</li>
<li>
<p><strong>Bitcoin Integration</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature aggregation</li>
<li>Transaction finality through Bitcoin confirmations</li>
<li>Reorg handling and state rollbacks</li>
</ul>
</li>
</ol>
<h4 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h4>
<ul>
<li>
<p><strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for ownership proofs</li>
<li>Threshold signature requirements</li>
</ul>
</li>
<li>
<p><strong>Double-spend Prevention</strong></p>
<ul>
<li>UTXO consumption tracking</li>
<li>Cross-validator consistency checks</li>
<li>Bitcoin-based finality guarantees</li>
</ul>
</li>
<li>
<p><strong>State Protection</strong></p>
<ul>
<li>Atomic state transitions</li>
<li>Rollback capability for reorgs</li>
<li>State root commitments</li>
<li>Multi-stage verification</li>
</ul>
</li>
</ul>
<h4 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h4>
<ul>
<li>UTXO caching for frequent access</li>
<li>Batch processing of state updates</li>
<li>Parallel transaction validation</li>
<li>Efficient UTXO lookup mechanisms</li>
</ul>
<p>This UTXO-based approach provides several advantages:</p>
<ol>
<li>Direct compatibility with Bitcoin‚Äôs security model</li>
<li>Natural support for atomic operations</li>
<li>Clear ownership and state transition rules</li>
<li>Built-in protection against double-spending</li>
<li>Simplified state verification and rollback</li>
</ol>
<h3 id="3-frost-signing-process"><a class="header" href="#3-frost-signing-process">3. FROST Signing Process</a></h3>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant C as Consensus
    V1-&gt;&gt;C: Share 1
    V2-&gt;&gt;C: Share 2
    V3-&gt;&gt;C: Share 3
    C-&gt;&gt;C: Aggregate Shares
    C-&gt;&gt;All: Final Signature
</pre>
<p>The FROST signing process involves:</p>
<ol>
<li>Each validator generates their partial signature</li>
<li>Signatures are shared among the threshold group</li>
<li>Partial signatures are aggregated into a final signature</li>
<li>The aggregated signature is verified against the group public key</li>
</ol>
<h3 id="4-roast-enhancement-layer"><a class="header" href="#4-roast-enhancement-layer">4. ROAST Enhancement Layer</a></h3>
<pre class="mermaid">graph TD
    A[Block Proposal] --&gt; B[FROST Signing]
    B --&gt; C[ROAST Protocol]
    C --&gt; D[Asynchronous Consensus]
    D --&gt; E[Block Finalization]
    E --&gt; F[Chain Extension]
</pre>
<p>ROAST transforms FROST into a production-ready consensus mechanism by adding several crucial enhancements:</p>
<h4 id="asynchronous-operation-guarantees"><a class="header" href="#asynchronous-operation-guarantees">Asynchronous Operation Guarantees</a></h4>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant N as Network
    
    Note over V1,N: Validator 1 experiences delay
    V2-&gt;&gt;N: Sign Share (t=1)
    V3-&gt;&gt;N: Sign Share (t=1)
    V1-&gt;&gt;N: Sign Share (t=3)
    Note over N: Protocol continues despite delay
    N-&gt;&gt;V1: Aggregate &amp; Finalize
    N-&gt;&gt;V2: Aggregate &amp; Finalize
    N-&gt;&gt;V3: Aggregate &amp; Finalize
</pre>
<p>Unlike traditional consensus mechanisms that require strict synchronization:</p>
<ul>
<li>Validators can participate in signing rounds without tight timing constraints</li>
<li>The protocol progresses even when some validators are temporarily delayed</li>
<li>Network partitions and varying message delivery times are handled gracefully</li>
<li>No assumptions about network synchrony are required for safety</li>
</ul>
<h4 id="byzantine-fault-tolerance"><a class="header" href="#byzantine-fault-tolerance">Byzantine Fault Tolerance</a></h4>
<pre class="mermaid">graph TD
    A[Validator Set] --&gt; B[Honest Majority]
    A --&gt; C[Byzantine Nodes]
    B --&gt; D[Valid Signatures]
    C --&gt; E[Detection System]
    E --&gt; F[Isolation]
    F --&gt; G[Protocol Progress]
</pre>
<p>ROAST maintains safety and liveness even in the presence of malicious actors:</p>
<ul>
<li>Tolerates up to f Byzantine validators where f &lt; n/3</li>
<li>Malicious behavior is detected and isolated</li>
<li>Signature shares from Byzantine validators can be identified and excluded</li>
<li>The protocol remains secure even if Byzantine validators:
<ul>
<li>Submit invalid signature shares</li>
<li>Attempt to sign conflicting blocks</li>
<li>Try to delay or prevent consensus</li>
<li>Collude with other malicious validators</li>
</ul>
</li>
</ul>
<h4 id="leader-rotation-mechanism"><a class="header" href="#leader-rotation-mechanism">Leader Rotation Mechanism</a></h4>
<pre class="mermaid">sequenceDiagram
    participant VS as Validator Set
    participant L1 as Leader 1
    participant L2 as Leader 2
    participant L3 as Leader 3
    
    Note over VS: Round r
    VS-&gt;&gt;L1: Select Leader
    Note over L1: Leader Timeout/Failure
    VS-&gt;&gt;L2: Backup Leader Takes Over
    Note over L2: Successful Block
    Note over VS: Round r+1
    VS-&gt;&gt;L3: New Leader Selection
</pre>
<p>ROAST implements a robust leader rotation system that:</p>
<ul>
<li>Deterministically selects leaders based on stake weight and randomness</li>
<li>Automatically rotates leaders to prevent centralization</li>
<li>Provides backup leaders in case of primary leader failure</li>
<li>Ensures fair distribution of block production opportunities</li>
<li>Maintains progress even when leaders fail or misbehave</li>
</ul>
<h4 id="liveness-guarantees"><a class="header" href="#liveness-guarantees">Liveness Guarantees</a></h4>
<pre class="mermaid">graph TD
    A[Network State] --&gt; B{Leader Active?}
    B --&gt;|Yes| C[Normal Operation]
    B --&gt;|No| D[Backup Leader]
    C --&gt; E[Progress]
    D --&gt; E
    E --&gt; F{Sufficient Signatures?}
    F --&gt;|Yes| G[Block Finalization]
    F --&gt;|No| H[Continue Collection]
    H --&gt; F
</pre>
<p>ROAST ensures the network continues to make progress through several mechanisms:</p>
<ol>
<li>
<p><strong>View Synchronization</strong></p>
<ul>
<li>Validators maintain a consistent view of network state</li>
<li>Recovery procedures for missed blocks or state updates</li>
<li>Automatic resynchronization after network partitions</li>
</ul>
</li>
<li>
<p><strong>Failure Recovery</strong></p>
<ul>
<li>Automatic detection of failed validators</li>
<li>Seamless transition to backup leaders</li>
<li>Recovery from temporary network failures</li>
<li>Rejoining procedures for validators that fall behind</li>
</ul>
</li>
<li>
<p><strong>Progress Conditions</strong></p>
<ul>
<li>Guaranteed block finalization when sufficient honest validators participate</li>
<li>No single validator can prevent progress</li>
<li>Continued operation during validator churn</li>
<li>Resilient to temporary network issues</li>
</ul>
</li>
<li>
<p><strong>Deadlock Prevention</strong></p>
<ul>
<li>No waiting for specific validators</li>
<li>Timeout mechanisms for unresponsive participants</li>
<li>Alternative paths for consensus when optimal path fails</li>
<li>Dynamic adjustment of protocol parameters</li>
</ul>
</li>
</ol>
<p>These enhancements make ROAST particularly well-suited for production environments where:</p>
<ul>
<li>Network conditions are unpredictable</li>
<li>Validators may join or leave the network</li>
<li>Malicious actors may attempt to disrupt consensus</li>
<li>High availability and reliability are required</li>
</ul>
<h2 id="fork-resolution"><a class="header" href="#fork-resolution">Fork Resolution</a></h2>
<pre class="mermaid">graph TD
    A[Fork Detection] --&gt; B[Weight Calculation]
    B --&gt; C[Heaviest Chain]
    C --&gt; D[Switch Decision]
    D --&gt; E[Chain Reorganization]
</pre>
<p>When forks occur:</p>
<ol>
<li>Validators identify competing chains</li>
<li>Calculate the weight of each fork based on stake</li>
<li>Apply the heaviest-chain rule</li>
<li>Coordinate chain reorganization if needed</li>
</ol>
<h2 id="understanding-frost"><a class="header" href="#understanding-frost">Understanding FROST</a></h2>
<p>FROST is a threshold signature scheme that enables a group of participants to collectively generate Schnorr signatures. This foundational protocol is crucial for Arch‚Äôs consensus mechanism because it provides a way to achieve distributed agreement while maintaining compatibility with Bitcoin‚Äôs native signature scheme.</p>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<ul>
<li><strong>Distributed Key Generation</strong>: Validators collectively participate in a process that generates a shared public key while keeping individual private key shares separate and secure.</li>
<li><strong>Threshold Signatures</strong>: The system requires a specific number of validators (t-of-n) to cooperate in order to produce valid signatures, balancing security with fault tolerance.</li>
<li><strong>Share Management</strong>: Each validator maintains their own private key share, contributing to the system‚Äôs security through distribution of trust.</li>
<li><strong>Signature Aggregation</strong>: Multiple partial signatures are combined into a single Schnorr signature that‚Äôs indistinguishable from a standard single-signer signature.</li>
</ul>
<h3 id="benefits-of-frost"><a class="header" href="#benefits-of-frost">Benefits of FROST</a></h3>
<ol>
<li>
<p><strong>Enhanced Security</strong></p>
<ul>
<li>No single validator can compromise the system</li>
<li>Distributed trust model eliminates single points of failure</li>
<li>Cryptographic guarantees of signature validity</li>
</ul>
</li>
<li>
<p><strong>Bitcoin Compatibility</strong></p>
<ul>
<li>Native integration with Bitcoin‚Äôs Schnorr signature scheme</li>
<li>No additional on-chain overhead</li>
<li>Seamless interaction with Bitcoin‚Äôs transaction validation</li>
</ul>
</li>
<li>
<p><strong>Efficiency</strong></p>
<ul>
<li>Constant-size signatures regardless of validator count</li>
<li>Optimized communication patterns</li>
<li>Reduced blockchain space usage</li>
</ul>
</li>
</ol>
<h2 id="roast-enhancing-frost-for-production"><a class="header" href="#roast-enhancing-frost-for-production">ROAST: Enhancing FROST for Production</a></h2>
<p>While FROST provides the cryptographic foundation, ROAST adds crucial properties needed for real-world deployment in adversarial environments. ROAST transforms FROST from a theoretical protocol into a production-ready consensus mechanism.</p>
<h3 id="key-enhancements"><a class="header" href="#key-enhancements">Key Enhancements</a></h3>
<ol>
<li>
<p><strong>Asynchronous Operation</strong></p>
<ul>
<li>Validators can participate without strict timing requirements</li>
<li>Resilient to network delays and partitions</li>
<li>Maintains liveness in real-world conditions</li>
</ul>
</li>
<li>
<p><strong>Robustness Against Attacks</strong></p>
<ul>
<li>Continues operating even with malicious participants</li>
<li>Detects and handles various forms of validator misbehavior</li>
<li>Provides provable security guarantees</li>
</ul>
</li>
<li>
<p><strong>Leader Selection</strong></p>
<ul>
<li>Efficient and fair leader rotation mechanism</li>
<li>Prevents centralization of power</li>
<li>Maintains system progress even if leaders fail</li>
</ul>
</li>
<li>
<p><strong>Liveness Guarantees</strong></p>
<ul>
<li>Ensures forward progress under adverse conditions</li>
<li>Handles validator churn gracefully</li>
<li>Recovers automatically from temporary failures</li>
</ul>
</li>
</ol>
<h2 id="archs-novel-implementation"><a class="header" href="#archs-novel-implementation">Arch‚Äôs Novel Implementation</a></h2>
<p>Arch‚Äôs implementation of ROAST/FROST represents a significant innovation in the blockchain space, particularly for Bitcoin-based smart contract platforms.</p>
<h3 id="unique-features"><a class="header" href="#unique-features">Unique Features</a></h3>
<ol>
<li>
<p><strong>Bitcoin-Native Design</strong></p>
<ul>
<li>Optimized for Bitcoin‚Äôs specific constraints and capabilities</li>
<li>Leverages Bitcoin‚Äôs security model</li>
<li>Minimizes on-chain footprint</li>
</ul>
</li>
<li>
<p><strong>Smart Contract Integration</strong></p>
<ul>
<li>Seamless combination with programmable logic</li>
<li>Maintains Bitcoin‚Äôs security guarantees</li>
<li>Enables complex decentralized applications</li>
</ul>
</li>
<li>
<p><strong>Scalable State Management</strong></p>
<ul>
<li>Efficient handling of state transitions</li>
<li>Parallel transaction processing where possible</li>
<li>Optimized validator resource usage</li>
</ul>
</li>
<li>
<p><strong>Economic Security</strong></p>
<ul>
<li>Carefully designed incentive structure</li>
<li>Slashing conditions for misbehavior</li>
<li>Aligned validator and network interests</li>
</ul>
</li>
</ol>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li><strong>Throughput</strong>: High transaction processing capacity without sacrificing decentralization</li>
<li><strong>Latency</strong>: Optimized confirmation times while maintaining security</li>
<li><strong>Resource Usage</strong>: Efficient use of network and computational resources</li>
<li><strong>Scalability</strong>: Linear scaling with validator count for most operations</li>
</ul>
<h2 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h2>
<h3 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h3>
<ul>
<li><strong>Byzantine Validators</strong>: System remains secure with up to f Byzantine validators (where f &lt; n/3)</li>
<li><strong>Network Adversaries</strong>: Resilient against various network-level attacks</li>
<li><strong>Cryptographic Security</strong>: Based on well-studied cryptographic assumptions</li>
</ul>
<h3 id="security-properties-1"><a class="header" href="#security-properties-1">Security Properties</a></h3>
<ol>
<li>
<p><strong>Safety</strong></p>
<ul>
<li>No conflicting transactions can be confirmed</li>
<li>Cryptographic guarantees of transaction finality</li>
<li>Protection against double-spending</li>
</ul>
</li>
<li>
<p><strong>Liveness</strong></p>
<ul>
<li>System continues to make progress</li>
<li>Recovers from temporary failures</li>
<li>Handles validator set changes</li>
</ul>
</li>
<li>
<p><strong>Fault Tolerance</strong></p>
<ul>
<li>Continues operating with partial validator failures</li>
<li>Graceful degradation under attack</li>
<li>Automatic recovery mechanisms</li>
</ul>
</li>
</ol>
<h2 id="future-directions"><a class="header" href="#future-directions">Future Directions</a></h2>
<p>The ROAST/FROST consensus mechanism in Arch provides a solid foundation for future enhancements:</p>
<ol>
<li>
<p><strong>Scalability Improvements</strong></p>
<ul>
<li>Research into further optimization of signature aggregation</li>
<li>Investigation of layer-2 scaling solutions</li>
<li>Exploration of parallel processing techniques</li>
</ul>
</li>
<li>
<p><strong>Security Enhancements</strong></p>
<ul>
<li>Ongoing cryptographic research</li>
<li>Additional protection against emerging threats</li>
<li>Enhanced monitoring and detection systems</li>
</ul>
</li>
<li>
<p><strong>Feature Extensions</strong></p>
<ul>
<li>Support for more complex smart contract patterns</li>
<li>Enhanced cross-chain interoperability</li>
<li>Advanced state management techniques</li>
</ul>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<h3 id="academic-papers-and-research"><a class="header" href="#academic-papers-and-research">Academic Papers and Research</a></h3>
<h4 id="frost-flexible-round-optimized-schnorr-threshold-signatures"><a class="header" href="#frost-flexible-round-optimized-schnorr-threshold-signatures">FROST (Flexible Round-Optimized Schnorr Threshold Signatures)</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2020/852.pdf">FROST: Flexible Round-Optimized Schnorr Threshold Signatures</a> - The original FROST paper by Chelsea Komlo and Ian Goldberg</li>
<li><a href="https://eprint.iacr.org/2021/1110.pdf">Two-Round Threshold Schnorr Signatures with FROST</a> - An optimized two-round variant of FROST</li>
<li><a href="https://github.com/ZcashFoundation/frost">Implementing FROST</a> - Reference implementation by the Zcash Foundation</li>
</ul>
<h4 id="roast-robust-asynchronous-schnorr-threshold-signatures"><a class="header" href="#roast-robust-asynchronous-schnorr-threshold-signatures">ROAST (Robust Asynchronous Schnorr Threshold Signatures)</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2022/550.pdf">ROAST: Robust Asynchronous Schnorr Threshold Signatures</a> - The foundational ROAST paper</li>
<li><a href="https://medium.com/blockstream/implementing-threshold-signatures-for-bitcoin-8d3b63831325">Practical Threshold Signatures for Bitcoin</a> - Implementation insights for Bitcoin-based threshold signatures</li>
</ul>
<h4 id="threshold-cryptography-and-consensus"><a class="header" href="#threshold-cryptography-and-consensus">Threshold Cryptography and Consensus</a></h4>
<ul>
<li><a href="https://arxiv.org/pdf/1904.04098.pdf">A Survey of Distributed Consensus Protocols for Blockchain Networks</a> - Comprehensive overview of consensus mechanisms</li>
<li><a href="https://eprint.iacr.org/2019/1157.pdf">Threshold Signatures: The Future of Consensus?</a> - Analysis of threshold signatures in consensus protocols</li>
<li><a href="https://eprint.iacr.org/2018/068.pdf">Schnorr Multi-Signatures and Applications</a> - Foundational work on Schnorr multi-signatures</li>
</ul>
<h3 id="technical-resources"><a class="header" href="#technical-resources">Technical Resources</a></h3>
<h4 id="implementation-guides"><a class="header" href="#implementation-guides">Implementation Guides</a></h4>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP 340: Schnorr Signatures for secp256k1</a> - Bitcoin Improvement Proposal for Schnorr signatures</li>
<li><a href="https://tlu.tarilabs.com/cryptography/threshold-signatures">Implementing Threshold Signatures</a> - Technical guide on threshold signature implementation</li>
<li><a href="https://github.com/ZcashFoundation/redjubjub">Multi-Party Computation for Distributed Key Generation</a> - Reference implementation of distributed key generation</li>
</ul>
<h4 id="security-analysis"><a class="header" href="#security-analysis">Security Analysis</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2019/114.pdf">Security Analysis of Threshold Signature Schemes</a> - Comprehensive security analysis</li>
<li><a href="https://eprint.iacr.org/2021/1559.pdf">Formal Verification of FROST</a> - Formal security proofs for FROST</li>
<li><a href="https://arxiv.org/pdf/1908.01738.pdf">Byzantine Fault Tolerance in Distributed Systems</a> - Analysis of BFT in consensus protocols</li>
</ul>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><a href="https://frost.zfnd.org">FROST Working Group</a> - Community working group on FROST implementation</li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/">Bitcoin Dev Mailing List</a> - Discussions on threshold signatures in Bitcoin</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The combination of ROAST and FROST in Arch represents a significant advancement in Bitcoin-based smart contract platforms. This consensus mechanism enables sophisticated applications while maintaining the security and decentralization principles that make Bitcoin valuable. Through careful design and implementation, Arch has created a system that is not just theoretically sound but practically deployable and scalable for real-world applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program"><a class="header" href="#program">Program</a></h1>
<p>A program is a special kind of <a href="program/./accounts.html">account</a> that contains executable <a href="https://ebpf.io">eBPF</a> bytecode, denoted by the <code>Account.is_executable: true</code> field. This allows an account to receive arbitrary <a href="program/./instructions-and-messages.html#instructions">instruction</a> data via a <a href="program/./transaction.html">transaction</a> to be processed by the runtime.</p>
<p>Every program is stateless, meaning that it can only read/write data to other accounts and that it <strong>cannot</strong> write to its own account; this, in-part, is how parallelized execution is made possible (see <a href="program/program.html#4-state">State</a> for more info).</p>
<blockquote>
<p>üí° Additionally, programs can send instructions to other programs which, in turn, receive instructions and thus extend program composability further. This is known as cross-program invocation (CPI) and will be detailed in future sections.</p>
</blockquote>
<h3 id="components"><a class="header" href="#components">Components:</a></h3>
<h4 id="1-entrypoint"><a class="header" href="#1-entrypoint">1. <a href="program/./entrypoint.html">Entrypoint</a></a></h4>
<p>Every Arch program includes a single entrypoint used to invoke the program. A <a href="program/./entrypoint.html#handler-function">handler function</a>, often named <code>process_instruction</code>, is then used to handle the data passed into the entrypoint.</p>
<p><em>These parameters are required for every <a href="program/./instructions-and-messages.html#instructions">instruction</a> to be processed.</em>_</p>
<pre><code class="language-rust ignore">use arch_program::entrypoint;
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    // Program logic here
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<h4 id="2-instruction"><a class="header" href="#2-instruction">2. <a href="program/./instructions-and-messages.html#instructions">Instruction</a></a></h4>
<p>The <code>instruction_data</code> is deserialized after being passed into the entrypoint. From there, if there are multiple instructions, a <code>match</code> statement can be utilized to point the logic flow to the appropriate handler function previously defined within the program which can continue processing the instruction.</p>
<h4 id="3-process-instruction"><a class="header" href="#3-process-instruction">3. Process Instruction</a></h4>
<p>If a program has multiple instructions, a corresponding <a href="program/./entrypoint.html#handler-function">handler function</a> should be defined to include the specific logic unique to the instruction.</p>
<h4 id="4-state"><a class="header" href="#4-state">4. State</a></h4>
<p>Since programs are stateless, a ‚Äúdata‚Äù <a href="program/./accounts.html">account</a> is needed to hold state for a user. This is a non-executable account that holds program data.</p>
<p>If a program receives instruction that results in a user‚Äôs state being altered, the program would manage this user‚Äôs state via a mapping within the program‚Äôs logic. This mapping would link the user‚Äôs <a href="program/./pubkey.html">pubkey</a> with a data <a href="program/./accounts.html">account</a> where the state would live for that specific program.</p>
<p>The program will likely include a struct to define the structure of its state and make it easier to work with. The deserialization of account data occurs during program invocation. After an update is made, state data gets re-serialized into a byte array and stored within the <code>data</code> field of the <a href="program/./accounts.html">account</a>.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-unspent-transaction-output"><a class="header" href="#utxo-unspent-transaction-output">UTXO (Unspent Transaction Output)</a></h1>
<p>UTXOs (Unspent Transaction Outputs) are fundamental to Bitcoin‚Äôs transaction model and serve as the foundation for state management in Arch Network. Unlike account-based systems that track balances, UTXOs represent discrete ‚Äúcoins‚Äù that must be consumed entirely in transactions.</p>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="what-is-a-utxo"><a class="header" href="#what-is-a-utxo">What is a UTXO?</a></h3>
<ul>
<li>A UTXO represents an unspent output from a previous transaction</li>
<li>Each UTXO is uniquely identified by a transaction ID (txid) and output index (vout)</li>
<li>UTXOs are immutable - they can only be created or spent, never modified</li>
<li>Once spent, a UTXO cannot be reused (prevents double-spending)</li>
</ul>
<h3 id="role-in-arch-network"><a class="header" href="#role-in-arch-network">Role in Arch Network</a></h3>
<ul>
<li>UTXOs anchor program state to Bitcoin‚Äôs security model</li>
<li>They provide deterministic state transitions</li>
<li>Enable atomic operations across the network</li>
<li>Allow for provable ownership and state validation</li>
</ul>
<h2 id="utxo-structure"><a class="header" href="#utxo-structure">UTXO Structure</a></h2>
<p>The <code>UtxoMeta</code> struct encapsulates the core UTXO identification data:</p>
<pre><code class="language-rust ignore">use arch_program::utxo::UtxoMeta;
use bitcoin::Txid;

#[derive(Debug, Clone, PartialEq)]
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Bitcoin transaction ID (32 bytes)
    pub vout: u32,       // Output index in the transaction
}

impl UtxoMeta {
    /// Creates a new UTXO metadata instance
    pub fn new(txid: [u8; 32], vout: u32) -&gt; Self {
        Self { txid, vout }
    }

    /// Deserializes UTXO metadata from a byte slice
    /// Format: [txid(32 bytes)][vout(4 bytes)]
    pub fn from_slice(data: &amp;[u8]) -&gt; Self {
        let mut txid = [0u8; 32];
        txid.copy_from_slice(&amp;data[0..32]);
        let vout = u32::from_le_bytes([
            data[32], data[33], data[34], data[35]
        ]);
        Self { txid, vout }
    }
}</code></pre>
<h2 id="utxo-lifecycle"><a class="header" href="#utxo-lifecycle">UTXO Lifecycle</a></h2>
<h3 id="1-creation-process"><a class="header" href="#1-creation-process">1. Creation Process</a></h3>
<h4 id="creating-a-utxo-with-bitcoin-rpc"><a class="header" href="#creating-a-utxo-with-bitcoin-rpc">Creating a UTXO with Bitcoin RPC</a></h4>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client as RpcClient, RpcApi};
use bitcoin::{Amount, Address};
use arch_program::pubkey::Pubkey;

// Initialize Bitcoin RPC client
let rpc = RpcClient::new(
    "http://localhost:18443",  // Bitcoin node RPC endpoint
    Auth::UserPass(
        "user".to_string(),
        "pass".to_string()
    )
).expect("Failed to create RPC client");

// Generate a new account address
let account_address = Pubkey::new_unique();
let btc_address = Address::from_pubkey(&amp;account_address);

// Create UTXO by sending Bitcoin
// Parameters explained:
// - address: Destination Bitcoin address
// - amount: Amount in satoshis (3000 sats = 0.00003 BTC)
// - comment: Optional transaction comment
// - replaceable: Whether the tx can be replaced (RBF)
let txid = rpc.send_to_address(
    &amp;btc_address,
    Amount::from_sat(3000),
    Some("Create Arch UTXO"),  // Comment
    None,                      // Comment_to
    Some(true),               // Replaceable
    None,                     // Fee rate
    None,                     // Fee estimate mode
    None                      // Avoid reuse
)?;

// Wait for confirmation (recommended)
rpc.wait_for_confirmation(&amp;txid, 1)?;</code></pre>
<h4 id="creating-an-arch-account-with-utxo"><a class="header" href="#creating-an-arch-account-with-utxo">Creating an Arch Account with UTXO</a></h4>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction::SystemInstruction,
    pubkey::Pubkey,
    transaction::Transaction,
};

// Create new program account backed by UTXO
let account_pubkey = Pubkey::new_unique();
let instruction = SystemInstruction::new_create_account_instruction(
    txid.try_into().unwrap(),
    0,  // vout index
    account_pubkey,
    // Additional parameters like:
    // - space: Amount of space to allocate
    // - owner: Program that owns the account
);

// Build and sign transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[instruction],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer],
    recent_blockhash
);</code></pre>
<h3 id="2-validation--usage"><a class="header" href="#2-validation--usage">2. Validation &amp; Usage</a></h3>
<p>Programs must implement proper UTXO validation:</p>
<pre><code class="language-rust ignore">fn validate_utxo(utxo: &amp;UtxoMeta) -&gt; Result&lt;(), ProgramError&gt; {
    // 1. Verify UTXO exists on Bitcoin
    let btc_tx = rpc.get_transaction(&amp;utxo.txid)?;
    
    // 2. Check confirmation count
    if btc_tx.confirmations &lt; MIN_CONFIRMATIONS {
        return Err(ProgramError::InsufficientConfirmations);
    }
    
    // 3. Verify output index exists
    if utxo.vout as usize &gt;= btc_tx.vout.len() {
        return Err(ProgramError::InvalidVout);
    }
    
    // 4. Verify UTXO is unspent
    if is_spent(utxo) {
        return Err(ProgramError::UtxoAlreadySpent);
    }
    
    Ok(())
}</code></pre>
<h3 id="3-state-management-1"><a class="header" href="#3-state-management-1">3. State Management</a></h3>
<pre><code class="language-rust ignore">// Example UTXO state tracking
#[derive(Debug)]
pub struct UtxoState {
    pub meta: UtxoMeta,
    pub status: UtxoStatus,
    pub owner: Pubkey,
    pub created_at: i64,
    pub spent_at: Option&lt;i64&gt;,
}

#[derive(Debug)]
pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li>
<p><strong>Validation</strong></p>
<ul>
<li>Always verify UTXO existence on Bitcoin</li>
<li>Check for sufficient confirmations (recommended: 6+)</li>
<li>Validate ownership and spending conditions</li>
<li>Handle Bitcoin reorgs that might invalidate UTXOs</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Implement robust UTXO tracking</li>
<li>Handle edge cases (reorgs, conflicting txs)</li>
<li>Consider implementing UTXO caching for performance</li>
<li>Maintain accurate UTXO sets for your program</li>
</ul>
</li>
<li>
<p><strong>Security</strong></p>
<ul>
<li>Never trust client-provided UTXO data without verification</li>
<li>Implement proper access controls</li>
<li>Consider timelock constraints for sensitive operations</li>
<li>Monitor for suspicious UTXO patterns</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Batch UTXO operations when possible</li>
<li>Implement efficient UTXO lookup mechanisms</li>
<li>Consider UTXO consolidation strategies</li>
<li>Cache frequently accessed UTXO data</li>
</ul>
</li>
</ol>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>Common UTXO-related errors to handle:</p>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound,                    // UTXO doesn't exist
    AlreadySpent,               // UTXO was already consumed
    InsufficientConfirmations,  // Not enough confirmations
    InvalidOwner,               // Unauthorized attempt to spend
    Reorged,                    // UTXO invalidated by reorg
    InvalidVout,                // Output index doesn't exist
    SerializationError,         // Data serialization failed
}</code></pre>
<h2 id="related-topics-1"><a class="header" href="#related-topics-1">Related Topics</a></h2>
<ul>
<li><a href="program/account.html">Account Model</a> - How UTXOs relate to Arch accounts</li>
<li><a href="program/program.html">Program State</a> - Using UTXOs for program state</li>
<li><a href="program/../system-program/system-program.html">System Program</a> - Core UTXO operations</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-guide"><a class="header" href="#account-guide">Account Guide</a></h1>
<blockquote>
<p><strong>Navigation</strong>: <a href="program/../SUMMARY.html#reference">Reference</a> ‚Üí <a href="program/./program.html">Program</a> ‚Üí Account Guide</p>
<p>For the core account structure and data types, see <a href="program/./account.html">Account Structure</a>.</p>
</blockquote>
<p>Accounts are the fundamental building blocks for state management and program interaction in Arch Network. They serve as containers for both program code and state data, bridging the gap between Bitcoin‚Äôs UTXO model and modern programmable state machines.</p>
<blockquote>
<p><strong>Note</strong>: For detailed documentation on core system functions used to interact with accounts (like <code>invoke</code>, <code>new_create_account_instruction</code>, <code>add_state_transition</code>, and <code>set_transaction_to_sign</code>), see <a href="program/./system-functions.html">System Functions</a>.</p>
</blockquote>
<pre class="mermaid">flowchart TD
    A[Account] --&gt; B[Program Account]
    A --&gt; C[Data Account]
    A --&gt; D[Native Account]
    B --&gt; E[Executable Code]
    C --&gt; F[Program State]
    C --&gt; G[UTXOs]
    D --&gt; H[System Operations]

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#f5f5f5,stroke:#666
    style C fill:#f5f5f5,stroke:#666
    style D fill:#f5f5f5,stroke:#666
</pre>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<h3 id="account-fundamentals"><a class="header" href="#account-fundamentals">Account Fundamentals</a></h3>
<p>Every account in Arch Network is uniquely identified by a public key (pubkey) and contains four essential components:</p>
<pre><code class="language-rust ignore">pub struct Account {
    /// The program that owns this account
    pub owner: Pubkey,
    /// Number of lamports assigned to this account
    pub lamports: u64,
    /// Data held in this account
    pub data: Vec&lt;u8&gt;,
    /// Whether this account can process instructions
    pub executable: bool,
}</code></pre>
<h4 id="component-details"><a class="header" href="#component-details">Component Details:</a></h4>
<ol>
<li>
<p><strong>Owner (Pubkey)</strong></p>
<ul>
<li>Controls account modifications</li>
<li>Determines which program can modify data</li>
<li>Can be transferred to new programs</li>
<li>Required for all accounts</li>
</ul>
</li>
<li>
<p><strong>Lamports (u64)</strong></p>
<ul>
<li>Native token balance</li>
<li>Used for:
<ul>
<li>Transaction fees</li>
<li>Rent payments</li>
<li>State storage costs</li>
<li>Program execution fees</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Data (Vec<u8>)</strong></p>
<ul>
<li>Flexible byte array for state storage</li>
<li>Common uses:
<ul>
<li>Program code (if executable)</li>
<li>Program state</li>
<li>UTXO metadata</li>
<li>Configuration data</li>
</ul>
</li>
<li>Size determined at creation</li>
</ul>
</li>
<li>
<p><strong>Executable Flag (bool)</strong></p>
<ul>
<li>Determines if account contains program code</li>
<li>Immutable after deployment</li>
<li>Controls instruction processing capability</li>
</ul>
</li>
</ol>
<pre class="mermaid">flowchart LR
    A[Account Creation] --&gt; B[Initial State]
    B --&gt; C[Runtime Operations]
    C --&gt; D[State Updates]
    D --&gt; E[Account Closure]
    
    subgraph Lifecycle
        A -. Initialize .-&gt; B
        B -. Process Instructions .-&gt; C
        C -. Modify State .-&gt; D
        D -. Cleanup .-&gt; E
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#9ff,stroke:#333,stroke-width:2px
    style Lifecycle fill:#f5f5f5,stroke:#666,stroke-width:1px
</pre>
<h2 id="account-types--use-cases"><a class="header" href="#account-types--use-cases">Account Types &amp; Use Cases</a></h2>
<h3 id="1-program-accounts"><a class="header" href="#1-program-accounts">1. Program Accounts</a></h3>
<p>Program accounts contain executable code and form the backbone of Arch Network‚Äôs programmable functionality.</p>
<pre><code class="language-rust ignore">// Example program account creation
let program_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(program_data.len()),
    space: program_data.len() as u64,
    owner: bpf_loader::id(),  // BPF Loader owns program accounts
    executable: true,
    data: program_data,
};</code></pre>
<p>Key characteristics:</p>
<ul>
<li>Immutable after deployment</li>
<li>Owned by BPF loader</li>
<li>Contains verified program code</li>
<li>Processes instructions</li>
</ul>
<h3 id="2-data-accounts"><a class="header" href="#2-data-accounts">2. Data Accounts</a></h3>
<p>Data accounts store program state and user data. They‚Äôre highly flexible and can be structured to meet various needs.</p>
<pre><code class="language-rust ignore">// Example data structure for a game account
#[derive(BorshSerialize, BorshDeserialize)]
pub struct GameAccount {
    pub player: Pubkey,
    pub score: u64,
    pub level: u8,
    pub achievements: Vec&lt;Achievement&gt;,
    pub last_played: i64,
}

// Creating a data account
let game_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;GameAccount&gt;()),
    space: size_of::&lt;GameAccount&gt;() as u64,
    owner: game_program::id(),
    executable: false,
    data: Vec::new(),  // Will be initialized by program
};</code></pre>
<p>Common use cases:</p>
<ul>
<li>Player profiles</li>
<li>Game state</li>
<li>DeFi positions</li>
<li>NFT metadata</li>
<li>Configuration settings</li>
</ul>
<h3 id="3-utxo-accounts"><a class="header" href="#3-utxo-accounts">3. UTXO Accounts</a></h3>
<p>Special data accounts that bridge Bitcoin UTXOs with Arch Network state.</p>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: UtxoState,
    pub created_at: i64,
    pub last_updated: i64,
    pub constraints: Vec&lt;UtxoConstraint&gt;,
}

// Example UTXO account creation
let utxo_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;UtxoAccount&gt;()),
    space: size_of::&lt;UtxoAccount&gt;() as u64,
    owner: utxo_program::id(),
    executable: false,
    data: Vec::new(),
};</code></pre>
<h2 id="account-interactions"><a class="header" href="#account-interactions">Account Interactions</a></h2>
<p>Account interactions in Arch Network are facilitated through a set of core system functions. These functions handle everything from account creation to state transitions and are documented in detail in <a href="program/./system-functions.html">System Functions</a>. Below are common patterns for account interactions:</p>
<h3 id="1-creation-patterns"><a class="header" href="#1-creation-patterns">1. Creation Patterns</a></h3>
<pre><code class="language-rust ignore">// 1. Basic account creation
pub fn create_basic_account(
    payer: &amp;Keypair,
    space: u64,
    owner: &amp;Pubkey,
) -&gt; Result&lt;Keypair, Error&gt; {
    let account = Keypair::new();
    let rent = banks_client.get_rent().await?;
    let lamports = rent.minimum_balance(space as usize);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;account.pubkey(),
        lamports,
        space,
        owner,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[ix],
        Some(&amp;payer.pubkey()),
        &amp;[payer, &amp;account],
        recent_blockhash,
    );
    
    banks_client.process_transaction(tx).await?;
    Ok(account)
}

// 2. PDA (Program Derived Address) creation
pub fn create_pda_account(
    program_id: &amp;Pubkey,
    seeds: &amp;[&amp;[u8]],
    space: u64,
) -&gt; Result&lt;Pubkey, Error&gt; {
    let (pda, bump) = Pubkey::find_program_address(seeds, program_id);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;pda,
        lamports,
        space,
        program_id,
    );
    
    // Include the bump seed for deterministic address
    let seeds_with_bump = &amp;[&amp;seeds[..], &amp;[&amp;[bump]]].concat();
    let signer_seeds = &amp;[&amp;seeds_with_bump[..]];
    
    invoke_signed(&amp;ix, &amp;[payer, pda], signer_seeds)?;
    Ok(pda)
}</code></pre>
<h3 id="2-state-management"><a class="header" href="#2-state-management">2. State Management</a></h3>
<pre><code class="language-rust ignore">// Example of managing account state
pub trait AccountState: Sized {
    fn try_from_slice(data: &amp;[u8]) -&gt; Result&lt;Self, Error&gt;;
    fn try_serialize(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
    
    fn load(account: &amp;AccountInfo) -&gt; Result&lt;Self, Error&gt; {
        Self::try_from_slice(&amp;account.data.borrow())
    }
    
    fn save(&amp;self, account: &amp;AccountInfo) -&gt; Result&lt;(), Error&gt; {
        let data = self.try_serialize()?;
        let mut account_data = account.data.borrow_mut();
        account_data[..data.len()].copy_from_slice(&amp;data);
        Ok(())
    }
}

// Implementation example
impl AccountState for GameAccount {
    fn update_score(&amp;mut self, new_score: u64) -&gt; Result&lt;(), Error&gt; {
        self.score = new_score;
        self.last_played = Clock::get()?.unix_timestamp;
        Ok(())
    }
}</code></pre>
<h3 id="3-cross-program-invocation-cpi"><a class="header" href="#3-cross-program-invocation-cpi">3. Cross-Program Invocation (CPI)</a></h3>
<pre><code class="language-rust ignore">// Example of one program calling another
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    // Deserialize accounts
    let account_info_iter = &amp;mut accounts.iter();
    let source_info = next_account_info(account_info_iter)?;
    let dest_info = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;
    
    // Create CPI context
    let cpi_accounts = Transfer {
        from: source_info.clone(),
        to: dest_info.clone(),
    };
    let cpi_program = system_program.clone();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    
    // Perform cross-program invocation
    transfer(cpi_ctx, amount)?;
    
    Ok(())
}</code></pre>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<h3 id="1-access-control"><a class="header" href="#1-access-control">1. Access Control</a></h3>
<pre><code class="language-rust ignore">fn verify_account_access(
    account: &amp;AccountInfo,
    expected_owner: &amp;Pubkey,
    writable: bool,
) -&gt; ProgramResult {
    // Check account ownership
    if account.owner != expected_owner {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Verify write permission if needed
    if writable &amp;&amp; !account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Additional checks...
    Ok(())
}</code></pre>
<h3 id="2-data-validation"><a class="header" href="#2-data-validation">2. Data Validation</a></h3>
<pre><code class="language-rust ignore">fn validate_account_data&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    validate_fn: impl Fn(&amp;T) -&gt; bool,
) -&gt; ProgramResult {
    // Load and validate account data
    let data = T::load(account)?;
    if !validate_fn(&amp;data) {
        return Err(ProgramError::InvalidAccountData);
    }
    Ok(())
}</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-account-management"><a class="header" href="#1-account-management">1. Account Management</a></h3>
<ul>
<li>Always validate account ownership before modifications</li>
<li>Use PDAs for deterministic addresses</li>
<li>Implement proper error handling</li>
<li>Close unused accounts to reclaim rent</li>
</ul>
<h3 id="2-data-safety"><a class="header" href="#2-data-safety">2. Data Safety</a></h3>
<ul>
<li>Validate all input data</li>
<li>Use proper serialization</li>
<li>Handle account size limits</li>
<li>Implement atomic operations</li>
</ul>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<ul>
<li>Minimize account creations</li>
<li>Batch operations when possible</li>
<li>Use appropriate data structures</li>
<li>Cache frequently accessed data</li>
</ul>
<h3 id="4-upgrades"><a class="header" href="#4-upgrades">4. Upgrades</a></h3>
<ul>
<li>Plan for version management</li>
<li>Implement migration strategies</li>
<li>Use flexible data structures</li>
<li>Document state changes</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="1-account-initialization"><a class="header" href="#1-account-initialization">1. Account Initialization</a></h3>
<pre><code class="language-rust ignore">pub fn initialize_account&lt;T: AccountState&gt;(
    program_id: &amp;Pubkey,
    account: &amp;AccountInfo,
    initial_state: T,
) -&gt; ProgramResult {
    // Verify account is uninitialized
    if !account.data_is_empty() {
        return Err(ProgramError::AccountAlreadyInitialized);
    }
    
    // Set account owner
    account.set_owner(program_id)?;
    
    // Initialize state
    initial_state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="2-account-updates"><a class="header" href="#2-account-updates">2. Account Updates</a></h3>
<pre><code class="language-rust ignore">pub fn update_account&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    update_fn: impl FnOnce(&amp;mut T) -&gt; ProgramResult,
) -&gt; ProgramResult {
    // Load current state
    let mut state = T::load(account)?;
    
    // Apply update
    update_fn(&amp;mut state)?;
    
    // Save updated state
    state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="3-account-closure"><a class="header" href="#3-account-closure">3. Account Closure</a></h3>
<pre><code class="language-rust ignore">pub fn close_account(
    account: &amp;AccountInfo,
    destination: &amp;AccountInfo,
) -&gt; ProgramResult {
    // Transfer lamports
    let dest_starting_lamports = destination.lamports();
    **destination.lamports.borrow_mut() = dest_starting_lamports
        .checked_add(account.lamports())
        .ok_or(ProgramError::Overflow)?;
    **account.lamports.borrow_mut() = 0;
    
    // Clear data
    account.data.borrow_mut().fill(0);
    
    Ok(())
}</code></pre>
<h2 id="related-topics-2"><a class="header" href="#related-topics-2">Related Topics</a></h2>
<ul>
<li><a href="program/./utxo.html">UTXOs</a> - How UTXOs integrate with accounts</li>
<li><a href="program/./program.html">Programs</a> - Programs that own and modify accounts</li>
<li><a href="program/./instructions-and-messages.html">Instructions</a> - How to interact with accounts</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructions-and-messages"><a class="header" href="#instructions-and-messages">Instructions and Messages</a></h1>
<p>Instructions and messages are fundamental components of Arch‚Äôs transaction processing system that enable communication between clients and <a href="program/./program.html">programs</a>. They form the basis for all state changes and interactions within the Arch network.</p>
<h3 id="instructions-2"><a class="header" href="#instructions-2">Instructions</a></h3>
<p>An instruction is the basic unit of program execution in Arch. It contains all the information needed for a <a href="program/./program.html">program</a> to execute a specific operation. Instructions are processed atomically, meaning they either complete entirely or have no effect.</p>
<h4 id="structure"><a class="header" href="#structure">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Instruction {
    /// Program ID that executes this instruction
    pub program_id: Pubkey,
    /// Accounts required for this instruction
    pub accounts: Vec&lt;AccountMeta&gt;,
    /// Instruction data
    pub data: Vec&lt;u8&gt;,
}</code></pre>
<h4 id="components-1"><a class="header" href="#components-1">Components:</a></h4>
<ol>
<li><strong>Program ID</strong>: The <a href="program/./pubkey.html">pubkey</a> of the <a href="program/./program.html">program</a> that will process the instruction</li>
<li><strong>Accounts</strong>: List of accounts required for the instruction, with their metadata</li>
<li><strong>Instruction Data</strong>: Custom data specific to the instruction, typically serialized using Borsh or another format</li>
</ol>
<h4 id="account-metadata"><a class="header" href="#account-metadata">Account Metadata</a></h4>
<pre><code class="language-rust ignore">pub struct AccountMeta {
    pub pubkey: Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
}</code></pre>
<ul>
<li><code>pubkey</code>: The account‚Äôs public key</li>
<li><code>is_signer</code>: Whether the account must sign the transaction</li>
<li><code>is_writable</code>: Whether the account‚Äôs data can be modified</li>
</ul>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>A message is a collection of instructions that form a <a href="program/./transaction.html">transaction</a>. Messages ensure atomic execution of multiple instructions, meaning either all instructions succeed or none take effect.</p>
<h4 id="structure-1"><a class="header" href="#structure-1">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Message {
    /// List of account keys referenced by the instructions
    pub account_keys: Vec&lt;Pubkey&gt;,
    /// Recent blockhash
    pub recent_blockhash: Hash,
    /// List of instructions to execute
    pub instructions: Vec&lt;CompiledInstruction&gt;,
}</code></pre>
<h4 id="components-2"><a class="header" href="#components-2">Components:</a></h4>
<ol>
<li><strong>Account Keys</strong>: All unique accounts referenced across instructions</li>
<li><strong>Recent Blockhash</strong>: Used for transaction uniqueness and timeout</li>
<li><strong>Instructions</strong>: List of instructions to execute in sequence</li>
</ol>
<h3 id="instruction-processing-flow"><a class="header" href="#instruction-processing-flow">Instruction Processing Flow:</a></h3>
<ol>
<li>
<p>Client creates an instruction with:</p>
<ul>
<li><a href="program/./program.html">Program</a> ID to execute the instruction</li>
<li>Required accounts with appropriate permissions</li>
<li>Instruction-specific data (serialized parameters)</li>
</ul>
</li>
<li>
<p>Instruction(s) are bundled into a message:</p>
<ul>
<li>Multiple instructions can be atomic</li>
<li>Account permissions are consolidated</li>
<li>Blockhash is included for uniqueness</li>
</ul>
</li>
<li>
<p>Message is signed to create a <a href="program/./transaction.html">transaction</a>:</p>
<ul>
<li>All required signers must sign</li>
<li>Transaction size limits apply</li>
<li>Fees are calculated</li>
</ul>
</li>
<li>
<p>Transaction is sent to the network:</p>
<ul>
<li>Validated by validators</li>
<li>Processed in parallel when possible</li>
<li>Results are confirmed</li>
</ul>
</li>
<li>
<p>Program processes the instruction:</p>
<ul>
<li>Deserializes instruction data</li>
<li>Validates accounts and permissions</li>
<li>Executes operation</li>
<li>Updates account state</li>
</ul>
</li>
</ol>
<h3 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices:</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account permissions</li>
<li>Validate account relationships</li>
</ul>
</li>
<li>
<p><strong>Data Serialization</strong></p>
<ul>
<li>Use consistent serialization format (preferably Borsh)</li>
<li>Include version information</li>
<li>Handle errors gracefully</li>
<li>Validate data lengths</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Return specific error types</li>
<li>Provide clear error messages</li>
<li>Handle all edge cases</li>
<li>Implement proper cleanup</li>
</ul>
</li>
</ol>
<h3 id="cross-program-invocation-cpi"><a class="header" href="#cross-program-invocation-cpi">Cross-Program Invocation (CPI)</a></h3>
<p>Instructions can invoke other <a href="program/./program.html">programs</a> through CPI, enabling composability:</p>
<ol>
<li>
<p>Create new instruction for target program:</p>
<ul>
<li>Specify program ID</li>
<li>Include required accounts</li>
<li>Prepare instruction data</li>
</ul>
</li>
<li>
<p>Pass required accounts:</p>
<ul>
<li>Include all necessary accounts</li>
<li>Set proper permissions</li>
<li>Handle PDA derivation</li>
</ul>
</li>
<li>
<p>Invoke using <code>invoke</code> or <code>invoke_signed</code>:</p>
<ul>
<li>For regular accounts: <code>invoke</code></li>
<li>For PDAs: <code>invoke_signed</code></li>
<li>Handle return values</li>
</ul>
</li>
<li>
<p>Handle results:</p>
<ul>
<li>Check return status</li>
<li>Process any returned data</li>
<li>Handle errors appropriately</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-4"><a class="header" href="#security-considerations-4">Security Considerations:</a></h3>
<ol>
<li>
<p><strong>Account Verification</strong></p>
<ul>
<li>Verify all account permissions</li>
<li>Check ownership and signatures</li>
<li>Validate account relationships</li>
<li>Prevent privilege escalation</li>
</ul>
</li>
<li>
<p><strong>Data Validation</strong></p>
<ul>
<li>Sanitize all input data</li>
<li>Check buffer lengths</li>
<li>Validate numerical ranges</li>
<li>Prevent integer overflow</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Maintain atomic operations</li>
<li>Handle partial failures</li>
<li>Prevent race conditions</li>
<li>Ensure consistent state</li>
</ul>
</li>
</ol>
<h3 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns:</a></h3>
<ol>
<li>
<p><strong>Initialization</strong></p>
<ul>
<li>Create necessary accounts</li>
<li>Set initial state</li>
<li>Assign proper ownership</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Validate permissions</li>
<li>Update account data</li>
<li>Maintain invariants</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close accounts when done</li>
<li>Manage PDAs properly</li>
</ul>
</li>
</ol>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscalls"><a class="header" href="#syscalls">Syscalls</a></h1>
<p>A syscall is a function that can be used to obtain information from the underlying virtual machine.</p>
<pre><code class="language-rust ignore">// Used for cross-program invocation (CPI)

// Invokes a cross-program call
define_syscall!(fn sol_invoke_signed_rust(instruction_addr: *const u8, account_infos_addr: *const u8, account_infos_len: u64) -&gt; u64);

// Sets the data to be returned for the cross-program invocation
define_syscall!(fn sol_set_return_data(data: *const u8, length: u64));

// Returns the cross-program invocation data
define_syscall!(fn sol_get_return_data(data: *mut u8, length: u64, program_id: *mut Pubkey) -&gt; u64);

// Arch

// Validates and sets up transaction for being signed
define_syscall!(fn arch_set_transaction_to_sign(transaction_to_sign: *const TransactionToSign));

// Retrieves raw Bitcoin transaction from RPC and copies into memory buffer
define_syscall!(fn arch_get_bitcoin_tx(data: *mut u8, length: u64, txid: &amp;[u8; 32]) -&gt; u64);

// Retrieves the multi-sig public key and copies into memory buffer
define_syscall!(fn arch_get_network_xonly_pubkey(data: *mut u8) -&gt; u64);

// Validates ownership of a Bitcoin UTXO against a public key
define_syscall!(fn arch_validate_utxo_ownership(utxo: *const UtxoMeta, owner: *const Pubkey) -&gt; u64);

// Generates a Bitcoin script public key and copies into memory buffer
define_syscall!(fn arch_get_account_script_pubkey(script: *mut u8, pubkey: *const Pubkey) -&gt; u64);

// Retrieves the latest Bitcoin block height
define_syscall!(fn arch_get_bitcoin_block_height() -&gt; u64);

// logs

// Prints the hexidecimal representation of a string slice to stdout
define_syscall!(fn sol_log_(message: *const u8, len: u64));

// Prints 64-bit values represented as hexadecimal to stdout
define_syscall!(fn sol_log_64_(arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64));

// Prints the hexidecimal representation of a public key to stdout
define_syscall!(fn sol_log_pubkey(pubkey_addr: *const u8));

// Prints the base64 representation of a data array to stdout
define_syscall!(fn sol_log_data(data: *const u8, data_len: u64));</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/syscalls/definitions.rs">syscalls/definition.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Let‚Äôs introduce the nodes that comprise the Arch Network stack in greater detail.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Bootnode</a></p>
<div style="display: flex; align-items: flex-start; gap: 20px;">
<div>
The bootnode works similarly to DNS seeds in Bitcoin whereby the server handles the first connection to nodes joining the Arch Network.
</div>
<img src="concepts/../images/bootnode.png" alt="Bootnode" style="width: 200px; flex-shrink: 0;" />
</div>
<p><a href="https://github.com/Arch-Network/arch-node">Leader</a></p>
<p>All signing is coordinated by the leader. Ultimately, the leader submits signed Bitcoin transactions to the Bitcoin network following program execution.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Validator</a></p>
<p>This node represents a generic node operated by another party. It performs the validator role and has a share in the network‚Äôs distributed signing key. The leader node passes transactions to validator nodes to validate and sign. After enough signatures have been collected (a threshold has been met), the leader can then submit a fully signed Bitcoin transaction to the Bitcoin network.</p>
<p>The validator node also runs the <a href="https://ebpf.io/">eBPF</a> virtual machine and executes the transactions asynchronously alongside the other validator nodes in the network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a></p>
<p>This validator is a lightweight server that only serves as an RPC for developers to get up and running quickly with the least amount of overhead. It simulates a single-node blockchain environment that is meant for efficient, rapid development.</p>
<blockquote>
<p>Note: the <a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a> node uses the same image as the <a href="https://github.com/Arch-Network/arch-node">Validator</a> node though operates singularly for maximum efficiency. You can start a lightweight validator using the <code>cli validator start</code> command.</p>
</blockquote>
<p>More can be read about the Arch Network architecture in our <a href="https://docs.arch.network">docs</a>.</p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">RPC</a></h1>
<p>Interact with Arch nodes directly with the JSON RPC API via the HTTP methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-methods"><a class="header" href="#http-methods">HTTP Methods</a></h1>
<p>Interact with Arch nodes directly with the JSON RPC API via this list of available HTTP methods.</p>
<blockquote>
<p>Note: For client-side needs, use the <a href="https://www.npmjs.com/package/@saturnbtcio/arch-sdk">@saturnbtcio/arch-sdk</a> library as an interface for the RPC methods to interact with an Arch node. Alternatively, the new Arch Network CLI tool provides convenient commands to interact with the network.</p>
</blockquote>
<h3 id="endpoint"><a class="header" href="#endpoint">Endpoint</a></h3>
<p>Default port: <code>9002</code></p>
<ul>
<li>http://localhost:9002</li>
</ul>
<h3 id="request-format"><a class="header" href="#request-format">Request Format:</a></h3>
<p>To make a JSON-RPC request, send an HTTP <code>POST</code> request with a <code>Content-Type: application/json</code> header.</p>
<p>The JSON request data should contain 4 fields:</p>
<ul>
<li><code>jsonrpc: &lt;string&gt;</code> - set to ‚Äú2.0.‚Äù</li>
<li><code>id: &lt;number&gt;</code> - a unique client-generated identifying integer.</li>
<li><code>method: &lt;string&gt;</code> - a string containing the method to be invoked.</li>
<li><code>params: &lt;array&gt;</code> - a JSON array of ordered parameter values.</li>
</ul>
<h3 id="response-format"><a class="header" href="#response-format">Response Format:</a></h3>
<p>The response output will be a JSON object with the following fields:</p>
<ul>
<li><code>jsonrpc: &lt;string&gt;</code> - matching the value set in the request.</li>
<li><code>id: &lt;number&gt;</code> - matching the value set in the request.</li>
<li><code>result: &lt;array|boolean|number|object|string&gt;</code> - requested data, success confirmation or boolean flag.</li>
</ul>
<h3 id="cli-alternative"><a class="header" href="#cli-alternative">CLI Alternative</a></h3>
<p>Many of these RPC methods can be accessed through the Arch Network CLI tool with simpler commands:</p>
<pre><code class="language-bash"># Start a local validator
cli validator start

# Deploy a program
cli deploy &lt;ELF_PATH&gt;

# Show program information
cli show &lt;PROGRAM_ADDRESS&gt;

# Confirm transaction status
cli confirm &lt;TX_ID&gt;

# Get block information
cli get-block &lt;BLOCK_HASH&gt;

# Get current block height
cli get-block-height

# Log program messages in a transaction
cli log-program-messages &lt;TX_ID&gt;

# Get group key
cli get-group-key &lt;PUBKEY&gt;

# Change account owner
cli change-owner &lt;ACCOUNT_ADDRESS&gt; &lt;NEW_OWNER&gt;
</code></pre>
<p>For more details on the CLI tool, download the latest version from the <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network CLI releases page</a>.</p>
<!-- External -->
<!-- Note: The main Arch Network repository is not yet publicly accessible. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="processed-transaction"><a class="header" href="#processed-transaction">Processed Transaction</a></h1>
<p>A processed transaction is a custom data type that contains a <a href="sdk/./runtime-transaction.html">runtime transaction</a>, a status, denoting the result of executing this runtime transaction, as well as a collection of Bitcoin transaction IDs.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Deserialize, Serialize, BorshDeserialize, BorshSerialize)]
pub enum Status {
    Processing,
    Processed,
}

#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct ProcessedTransaction {
    pub runtime_transaction: RuntimeTransaction,
    pub status: Status,
    pub bitcoin_txids: Vec&lt;String&gt;,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/processed_transaction.rs">processed_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-program"><a class="header" href="#system-program">System Program</a></h1>
<p>The Arch System Program is Arch‚Äôs core program. This program contains a set of variants that can be thought-of as native functionality that can be used within any Arch program.</p>
<p>The System Program creates new accounts, assigns accounts to owning programs, marks accounts as executable, and writes data to the accounts.</p>
<p>In order to make calls to the System Program, the following mapping can help you point to the correct functionality.</p>
<div class="table-wrapper"><table><thead><tr><th>index</th><th>method</th></tr></thead><tbody>
<tr><td>0</td><td>CreateAccount</td></tr>
<tr><td>1</td><td>WriteBytes</td></tr>
<tr><td>2</td><td>MakeExecutable</td></tr>
<tr><td>3</td><td>AssignOwnership</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="createaccount"><a class="header" href="#createaccount"><code>CreateAccount</code></a></h1>
<p><strong>Index:</strong> <code>0</code></p>
<p>Create a new account.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![0]</code>, the correct index for making a call to <code>SystemProgram::CreateAccount</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![0];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="makeexecutable"><a class="header" href="#makeexecutable"><code>MakeExecutable</code></a></h1>
<p><strong>Index:</strong> <code>2</code></p>
<p>Sets the account as executable, marking it as a program.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![2]</code>, the correct index for making a call to <code>SystemProgram::MakeExecutable</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![2];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<p>We can proceed to confirm that the program is executable with <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L368">read_account_info</a> which returns an <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L358">AccountInfoResult</a> that gets parsed to obtain the <code>is_executable</code> value.</p>
<pre><code class="language-rust ignore">assert!(
    read_account_info("node_url", program_pubkey)
        .unwrap()
        .is_executable
);</code></pre>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h3 id="bitcoin-mempool-and-blockchain-explorer"><a class="header" href="#bitcoin-mempool-and-blockchain-explorer">Bitcoin mempool and blockchain explorer</a></h3>
<ul>
<li><a href="https://mempool.dev.aws.archnetwork.xyz">mempool.space - Arch Regtest</a>
<ul>
<li>Bitcoin mempool and block explorer. This <a href="https://mempool.space">mempool.space</a> instance monitors the regtest Bitcoin blockchain being used to run and validate all examples in this repo.</li>
</ul>
</li>
<li><a href="https://docs.solanalabs.com/cli/install">Solana CLI</a></li>
<li><a href="https://solana.com/developers/guides/getstarted/setup-local-development">Solana Local Development Guide</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
