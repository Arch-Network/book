<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Arch Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for the Arch Network - A Bitcoin-native computation environment">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="getting-started/quick-start.html">üöÄ Quick Start Guide</a></li><li class="chapter-item "><a href="getting-started/bitcoin-and-titan-setup.html">üèóÔ∏è Validator Setup</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="getting-started/requirements.html">System Requirements</a></li><li class="chapter-item "><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html">Setup Options</a></li><li class="chapter-item "><a href="getting-started/validator-staking.html">Running Your Node</a></li></ol></li><li class="chapter-item "><li class="part-title">Program Development</li><li class="chapter-item "><a href="guides/understanding-arch-programs.html">Understanding Arch Programs</a></li><li class="chapter-item "><a href="getting-started/setting-up-a-project.html">Setting Up a Project</a></li><li class="chapter-item "><a href="guides/writing-your-first-program.html">Writing Your First Program</a></li><li class="chapter-item "><a href="guides/testing-guide.html">Testing Your Program</a></li><li class="chapter-item "><a href="guides/guides.html">Program Examples</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li><li class="chapter-item "><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li><li class="chapter-item "><a href="guides/how-to-build-runes-swap.html">Runes Swap</a></li><li class="chapter-item "><a href="guides/how-to-build-lending-protocol.html">Lending Protocol</a></li></ol></li><li class="chapter-item "><li class="part-title">Arch Program Library (APL)</li><li class="chapter-item "><a href="apl/introduction.html">Introduction</a></li><li class="chapter-item "><a href="apl/token-program.html">Token Program</a></li><li class="chapter-item "><a href="apl/associated-token-account.html">Associated Token Account Program</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="concepts/architecture.html">Architecture Overview</a></li><li class="chapter-item "><a href="concepts/network-architecture.html">Network Architecture</a></li><li class="chapter-item "><a href="concepts/bitcoin-integration.html">Bitcoin Integration</a></li><li class="chapter-item "><a href="concepts/consensus.html">ROAST and FROST Consensus</a></li><li class="chapter-item "><a href="program/program.html">Programs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="program/utxo.html">UTXOs</a></li><li class="chapter-item "><a href="program/accounts.html">Accounts</a></li><li class="chapter-item "><a href="program/instructions-and-messages.html">Instructions</a></li><li class="chapter-item "><a href="program/syscall.html">System Calls</a></li></ol></li><li class="chapter-item "><a href="concepts/nodes.html">Node Operation</a></li><li class="chapter-item affix "><li class="part-title">SDK Reference</li><li class="chapter-item "><a href="sdk/sdk.html">SDK Overview</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/runtime-transaction.html">Runtime Transaction</a></li><li class="chapter-item "><a href="sdk/processed-transaction.html">Processed Transaction</a></li><li class="chapter-item "><a href="sdk/signature.html">Signature</a></li></ol></li><li class="chapter-item "><li class="part-title">Reference</li><li class="chapter-item "><a href="rpc/rpc.html">API Reference</a></li><li class="chapter-item "><a href="system-program/system-program.html">System Program</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="system-program/create-account.html">Account Creation</a></li><li class="chapter-item "><a href="system-program/make-executable.html">Program Deployment</a></li></ol></li><li class="chapter-item "><li class="part-title">Resources</li><li class="chapter-item "><a href="reference/troubleshooting.html">Troubleshooting</a></li><li class="chapter-item "><a href="getting-started/faq.html">FAQ</a></li><li class="chapter-item "><a href="getting-started/resources.html">External Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Arch Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arch-network/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-arch-network"><a class="header" href="#welcome-to-arch-network">Welcome to Arch Network</a></h1>
<div class="info">
This documentation is actively maintained. If you find any issues or have suggestions for improvements, please visit our <a href="https://github.com/arch-network/docs">GitHub repository</a>.
</div>
<div style="float: right; margin: 0 0 20px 20px; max-width: 40%;">
    <img src="images/coders.png" alt="Developer coding" style="width: 100%; height: auto;">
</div>
<h2 id="what-is-arch-network"><a class="header" href="#what-is-arch-network">What is Arch Network?</a></h2>
<p>Arch Network is a computation environment that enhances Bitcoin‚Äôs capabilities by enabling complex operations on Bitcoin UTXOs through its specialized virtual machine. Unlike Layer 2 solutions, Arch Network provides a native computation layer that works directly with Bitcoin‚Äôs security model.</p>
<h2 id="choose-your-path-"><a class="header" href="#choose-your-path-">Choose Your Path üëã</a></h2>
<div class="path-selector">
    <div class="path-option">
        <h3 id="-deploy-first"><a class="header" href="#-deploy-first">üöÄ Deploy First</a></h3>
        <p>Get your first smart contract running on Arch Network as quickly as possible</p>
        <ul>
            <li>Download CLI and deploy a program in 15 minutes</li>
            <li>Use our pre-configured development environment</li>
            <li>Perfect for developers wanting to try Arch Network</li>
        </ul>
        <a href="getting-started/quick-start.html" class="button">Start Building ‚Üí</a>
    </div>
</div>
<h3 id="-run-a-validator"><a class="header" href="#-run-a-validator">üèóÔ∏è Run a Validator</a></h3>
<p>Set up and run your own validator node on the Arch Network</p>
<ul>
<li>Set up Bitcoin Core and Titan</li>
<li>Configure and run a validator node</li>
<li>Perfect for those wanting to participate in network security</li>
</ul>
<p><a href="getting-started/bitcoin-and-titan-setup.html">Start Running ‚Üí</a></p>
<div class="network-selector">
    <h3 id="network-options"><a class="header" href="#network-options">Network Options</a></h3>
    <div class="network-grid">
        <div class="network-option">
            <h4 id="-regtest"><a class="header" href="#-regtest">üîß Regtest</a></h4>
            <p>Local development environment with instant block confirmation. Perfect for development and testing.</p>
        </div>
        <div class="network-option">
            <h4 id="-testnet"><a class="header" href="#-testnet">üß™ Testnet</a></h4>
            <p>Test network with real Bitcoin testnet integration. For testing in a live environment.</p>
        </div>
    </div>
</div>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<div class="feature-grid">
<div class="feature">
    <h4 id="bitcoin-native"><a class="header" href="#bitcoin-native">Bitcoin-Native</a></h4>
    <p>Direct <a href="concepts/bitcoin-integration.html">integration with Bitcoin</a> through UTXO management</p>
</div>
<div class="feature">
    <h4 id="computation-environment"><a class="header" href="#computation-environment">Computation Environment</a></h4>
    <p>Execute complex programs within the <a href="concepts/architecture.html">Arch VM</a></p>
</div>
<div class="feature">
    <h4 id="program-development"><a class="header" href="#program-development">Program Development</a></h4>
    <p>Write <a href="program/program.html">programs in Rust</a> to interact with <a href="program/utxo.html">Bitcoin UTXOs</a></p>
</div>
<div class="feature">
    <h4 id="security"><a class="header" href="#security">Security</a></h4>
    <p>Leverages Bitcoin's proven security guarantees through <a href="concepts/network-architecture.html#security-model">multi-signature validation</a></p>
</div>
<div class="feature">
    <h4 id="developer-tools"><a class="header" href="#developer-tools">Developer Tools</a></h4>
    <p>Complete development environment with <a href="getting-started/environment-setup.html">CLI tools</a> and explorer</p>
</div>
</div>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<div class="prerequisites-box">
Before you begin, ensure you have:
<ul>
<li>Node.js v19+ (<a href="getting-started/requirements.html">installation guide</a>)</li>
<li>Rust (latest stable)</li>
<li>Docker for local development</li>
<li>Basic understanding of <a href="program/utxo.html">Bitcoin UTXOs</a></li>
</ul>
</div>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<h3 id="how-arch-works"><a class="header" href="#how-arch-works">How Arch Works</a></h3>
<div class="architecture-overview">
Arch Network consists of three main components:
<ol>
<li><strong>Network Layer</strong></li>
</ol>
<ul>
<li><a href="concepts/network-architecture.html">Network Architecture</a>
<ul>
<li><a href="concepts/network-architecture.html#1-bootnode">Bootnode</a>: Network discovery and peer management</li>
<li><a href="concepts/network-architecture.html#2-leader-node">Leader Node</a>: Transaction coordination</li>
<li><a href="concepts/network-architecture.html#3-validator-nodes">Validator Nodes</a>: Program execution</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Bitcoin Integration</strong></li>
</ol>
<ul>
<li><a href="concepts/bitcoin-integration.html#1-utxo-management">UTXO Management</a>
<ul>
<li>Transaction tracking</li>
<li>State anchoring</li>
<li>Ownership validation</li>
</ul>
</li>
<li><a href="concepts/bitcoin-integration.html#2-bitcoin-rpc-integration">RPC Integration</a>
<ul>
<li>Bitcoin node communication</li>
<li>Transaction submission</li>
<li>Network synchronization</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Computation Layer</strong></li>
</ol>
<ul>
<li><a href="program/program.html">Programs</a>
<ul>
<li><a href="program/instructions-and-messages.html">Instructions</a></li>
<li><a href="program/accounts.html">Accounts</a></li>
<li><a href="program/syscall.html">System Calls</a></li>
</ul>
</li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a>
<ul>
<li>Message validation</li>
<li>State updates</li>
<li>UTXO management</li>
</ul>
</li>
</ul>
</div>
<h3 id="-reference-documentation"><a class="header" href="#-reference-documentation">üõ† Reference Documentation</a></h3>
<div class="reference-grid">
Technical documentation:
<ul>
<li><a href="rpc/rpc.html">API Reference</a>
<ul>
<li><a href="rpc/rpc.html">RPC API Reference</a></li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a></li>
</ul>
</li>
<li><a href="guides/writing-your-first-program.html">Program Examples</a>
<ul>
<li><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li>
</ul>
</li>
<li><a href="system-program/system-program.html">System Program</a>
<ul>
<li><a href="system-program/create-account.html">Account Creation</a></li>
<li><a href="system-program/make-executable.html">Program Deployment</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="need-help"><a class="header" href="#need-help">Need Help?</a></h2>
<div class="help-box">
<ul>
<li><a href="https://discord.gg/archnetwork">Join our Discord</a></li>
<li><a href="concepts/architecture.html">Read the Architecture Overview</a></li>
<li><a href="guides/writing-your-first-program.html">View Example Programs</a></li>
<li><a href="concepts/network-architecture.html#monitoring-and-telemetry">Check Network Status</a></li>
<li><a href="rpc/rpc.html">API Reference</a></li>
</ul>
</div>
<div class="tip">
üí° <strong>Pro Tip:</strong> Use the search function (press 's' or '/' on your keyboard) to quickly find what you're looking for in the documentation.
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-quick-start-guide"><a class="header" href="#-quick-start-guide">üöÄ Quick Start Guide</a></h1>
<p>Welcome to Arch Network! Let‚Äôs get your first program running in under 15 minutes.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting, ensure you have the following tools installed:</p>
<ul>
<li><strong>Git</strong> (v2.0 or later)</li>
<li><strong>Rust</strong> (v1.70 or later) - <a href="https://rustup.rs/">Install Rust</a></li>
<li><strong>Solana CLI</strong> (v2.0 or later) - <a href="https://docs.solana.com/cli/install-solana-cli-tools">Install Solana</a></li>
<li><strong>Arch Network CLI</strong> - Download from <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network Releases</a></li>
</ul>
<blockquote>
<p>‚ö†Ô∏è <strong>Important</strong>: Arch Network now requires Solana CLI 2.x. Please ensure you have version 2.0 or later installed.</p>
</blockquote>
<p>Verify your installation:</p>
<pre><code class="language-bash">git --version
rustc --version
solana --version  # Should show 2.x.x or later
arch-cli --version
</code></pre>
<blockquote>
<p>üí° Note: If you encounter any issues during installation, join our <a href="https://discord.gg/archnetwork">Discord</a> for support.</p>
</blockquote>
<h2 id="-quick-start-project"><a class="header" href="#-quick-start-project">üöÄ Quick Start Project</a></h2>
<h3 id="1-clone-example-project"><a class="header" href="#1-clone-example-project">1. Clone Example Project</a></h3>
<pre><code class="language-bash"># Get the starter example
git clone https://github.com/Arch-Network/arch-examples
cd arch-examples/examples/helloworld
</code></pre>
<h3 id="2-start-local-validator"><a class="header" href="#2-start-local-validator">2. Start Local Validator</a></h3>
<p>Choose one of the following network modes:</p>
<h4 id="option-a-testnet-recommended-for-testing"><a class="header" href="#option-a-testnet-recommended-for-testing">Option A: Testnet (Recommended for Testing)</a></h4>
<pre><code class="language-bash">arch-cli validator-start \
    --network-mode testnet \
    --data-dir ./.arch_data \
    --rpc-bind-ip 127.0.0.1 \
    --rpc-bind-port 9002 \
    --titan-endpoint https://titan-public-http.test.arch.network \
    --titan-socket-endpoint titan-public-tcp.test.arch.network:3030
</code></pre>
<h4 id="option-b-local-development-regtest"><a class="header" href="#option-b-local-development-regtest">Option B: Local Development (Regtest)</a></h4>
<p><strong>Prerequisites:</strong></p>
<ul>
<li><strong>Docker</strong>: Required on all platforms - <a href="https://docs.docker.com/engine/install/">Install Docker</a></li>
<li><strong>Docker Management</strong> (optional but recommended):
<ul>
<li><strong>macOS</strong>: <a href="https://orbstack.dev/">OrbStack</a> (recommended) or <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></li>
<li><strong>Linux</strong>: <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> (optional GUI)</li>
</ul>
</li>
</ul>
<pre><code class="language-bash"># Use the orchestrate command for full local devnet
arch-cli orchestrate start
</code></pre>
<p>This starts a complete local development environment with:</p>
<ul>
<li>Bitcoin Core (regtest mode)</li>
<li>Titan indexer</li>
<li>Local validator</li>
</ul>
<h4 id="option-c-devnet-full-local-stack"><a class="header" href="#option-c-devnet-full-local-stack">Option C: Devnet (Full Local Stack)</a></h4>
<p>For devnet, you‚Äôll need to run your own Bitcoin regtest node and Titan indexer:</p>
<pre><code class="language-bash"># 1. Start Bitcoin Core in regtest mode
bitcoind -regtest -port=18444 -rpcport=18443 \
    -rpcuser=bitcoin -rpcpassword=bitcoinpass \
    -fallbackfee=0.001

# 2. First-time setup (only needed once)
# Create a wallet called "testwallet"
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass createwallet testwallet

# Generate an address and mine the first 100 blocks to it
ADDRESS=$(bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass getnewaddress)
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass generatetoaddress 100 $ADDRESS

# 3. Clone and build Titan indexer (if not already done)
git clone https://github.com/saturnbtc/Titan.git
cd Titan

# 4. Start Titan indexer pointing to your Bitcoin node
cargo run --bin titan -- \
    --bitcoin-rpc-url http://127.0.0.1:18443 \
    --bitcoin-rpc-username bitcoin \
    --bitcoin-rpc-password bitcoinpass \
    --chain regtest \
    --index-addresses \
    --index-bitcoin-transactions \
    --enable-tcp-subscriptions \
    --main-loop-interval 0 \
    --http-listen 127.0.0.1:3030

# 5. Start validator pointing to your local Titan (in a new terminal)
arch-cli validator-start \
    --network-mode devnet \
    --data-dir ./.arch_data \
    --rpc-bind-ip 127.0.0.1 \
    --rpc-bind-port 9002 \
    --titan-endpoint http://127.0.0.1:3030 \
    --titan-socket-endpoint 127.0.0.1:3030
</code></pre>
<blockquote>
<p>üí° <strong>Note</strong>: This option requires you to build and run Bitcoin Core and Titan yourself. For easier local development, use Option B (orchestrate start) instead.</p>
</blockquote>
<blockquote>
<p>‚ö†Ô∏è <strong>First-time setup</strong>: The wallet creation and block generation steps are only needed the first time you start bitcoind in regtest mode.</p>
</blockquote>
<h3 id="3-create-and-fund-account"><a class="header" href="#3-create-and-fund-account">3. Create and Fund Account</a></h3>
<p>Create a new account with the faucet:</p>
<pre><code class="language-bash"># Create account and fund with 1 ARCH (1 billion lamports)
arch-cli account create --keypair-path ./my-account.json --airdrop 1000000000

# Or create account first, then fund separately
arch-cli account create --keypair-path ./my-account.json
arch-cli account airdrop --keypair-path ./my-account.json --amount 1000000000
</code></pre>
<h3 id="4-build-and-deploy-your-program"><a class="header" href="#4-build-and-deploy-your-program">4. Build and Deploy Your Program</a></h3>
<pre><code class="language-bash"># Navigate to the program directory
cd program

# Build the program using Solana's BPF compiler
cargo build-sbf

# Deploy to the validator
arch-cli deploy ./target/deploy/&lt;program_name&gt;.so --generate-if-missing --fund-authority

# Note: Save your program ID for later use
export PROGRAM_ID=&lt;DEPLOYED_PROGRAM_ADDRESS&gt;
</code></pre>
<h3 id="5-test-your-deployment"><a class="header" href="#5-test-your-deployment">5. Test Your Deployment</a></h3>
<pre><code class="language-bash"># Verify program deployment
arch-cli show $PROGRAM_ID

# Check transaction status
arch-cli tx confirm &lt;TX_ID&gt;

# Get current block height
arch-cli get-block-height

# Get latest block information
arch-cli get-block &lt;BLOCK_HASH&gt;
</code></pre>
<h2 id="-available-cli-commands"><a class="header" href="#-available-cli-commands">üîß Available CLI Commands</a></h2>
<h3 id="validator-management"><a class="header" href="#validator-management">Validator Management</a></h3>
<pre><code class="language-bash"># Start local validator
arch-cli validator-start [OPTIONS]

# Orchestrate full local devnet
arch-cli orchestrate start     # Start bitcoind + titan + validator
arch-cli orchestrate stop      # Stop all services
arch-cli orchestrate reset     # Reset entire environment
</code></pre>
<h3 id="account-operations"><a class="header" href="#account-operations">Account Operations</a></h3>
<pre><code class="language-bash"># Create new account
arch-cli account create --keypair-path &lt;PATH&gt; [--airdrop &lt;AMOUNT&gt;]

# Fund existing account
arch-cli account airdrop --keypair-path &lt;PATH&gt; --amount &lt;LAMPORTS&gt;

# Change account owner
arch-cli account change-owner &lt;ACCOUNT&gt; &lt;NEW_OWNER&gt; &lt;PAYER_KEYPAIR&gt;

# Assign UTXO to account
arch-cli account assign-utxo &lt;ACCOUNT_PUBKEY&gt;
</code></pre>
<h3 id="program-deployment"><a class="header" href="#program-deployment">Program Deployment</a></h3>
<pre><code class="language-bash"># Deploy program
arch-cli deploy &lt;ELF_PATH&gt; [--generate-if-missing] [--fund-authority]

# Show account/program info
arch-cli show &lt;ADDRESS&gt;
</code></pre>
<h3 id="transaction-operations"><a class="header" href="#transaction-operations">Transaction Operations</a></h3>
<pre><code class="language-bash"># Confirm transaction status
arch-cli tx confirm &lt;TX_ID&gt;

# Get transaction details
arch-cli tx get &lt;TX_ID&gt;

# View program logs from transaction
arch-cli tx log-program-messages &lt;TX_ID&gt;
</code></pre>
<h3 id="block-and-network-info"><a class="header" href="#block-and-network-info">Block and Network Info</a></h3>
<pre><code class="language-bash"># Get block by hash
arch-cli get-block &lt;BLOCK_HASH&gt;

# Get current block height
arch-cli get-block-height

# Get group key
arch-cli get-group-key &lt;PUBKEY&gt;
</code></pre>
<h3 id="configuration-profiles"><a class="header" href="#configuration-profiles">Configuration Profiles</a></h3>
<pre><code class="language-bash"># Create configuration profile
arch-cli config create-profile &lt;NAME&gt; \
    --bitcoin-node-endpoint &lt;URL&gt; \
    --bitcoin-node-username &lt;USER&gt; \
    --bitcoin-node-password &lt;PASS&gt; \
    --bitcoin-network &lt;mainnet|testnet|regtest&gt; \
    --arch-node-url &lt;URL&gt;

# List profiles
arch-cli config list-profiles

# Update profile
arch-cli config update-profile &lt;NAME&gt; [OPTIONS]

# Delete profile
arch-cli config delete-profile &lt;NAME&gt;
</code></pre>
<h2 id="-network-modes"><a class="header" href="#-network-modes">üåê Network Modes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Network Mode</th><th>Description</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>localnet</code></td><td>Local development with regtest Bitcoin</td><td>Local development and testing</td></tr>
<tr><td><code>devnet</code></td><td>Development network</td><td>Development and integration testing</td></tr>
<tr><td><code>testnet</code></td><td>Test network with Bitcoin testnet</td><td>Pre-production testing</td></tr>
<tr><td><code>mainnet</code></td><td>Main production network</td><td>Production use (use with caution)</td></tr>
</tbody></table>
</div>
<h2 id="-validator-configuration"><a class="header" href="#-validator-configuration">‚öôÔ∏è Validator Configuration</a></h2>
<h3 id="key-parameters"><a class="header" href="#key-parameters">Key Parameters</a></h3>
<pre><code class="language-bash"># Basic configuration
--data-dir ./.arch_data                    # Data directory
--network-mode testnet                     # Network mode
--rpc-bind-ip 127.0.0.1                   # RPC bind IP
--rpc-bind-port 9002                      # RPC port

# Titan integration (for testnet/mainnet)
--titan-endpoint &lt;URL&gt;                     # Titan HTTP endpoint
--titan-socket-endpoint &lt;HOST:PORT&gt;        # Titan TCP endpoint

# Performance tuning
--max-tx-pool-size 10000                  # Transaction pool size
--full-snapshot-reccurence 100            # Snapshot frequency
--max-snapshots 5                         # Max snapshots to keep

# Security
--private-key-password &lt;PASSWORD&gt;         # Key encryption password
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>You can also use environment variables instead of command-line flags:</p>
<pre><code class="language-bash">export ARCH_NETWORK_MODE=testnet
export ARCH_RPC_BIND_PORT=9002
export ARCH_DATA_DIR=./.arch_data
export ARCH_TITAN_ENDPOINT=https://titan-public-http.test.arch.network
</code></pre>
<h2 id="-next-steps"><a class="header" href="#-next-steps">üéÆ Next Steps</a></h2>
<p>Congratulations! You‚Äôve successfully deployed your first program. Here‚Äôs what you can explore next:</p>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<ul>
<li><strong><a href="getting-started/../guides/understanding-arch-programs.html">Program Development Guide</a></strong> - Learn about program architecture</li>
<li><strong><a href="getting-started/../guides/writing-your-first-program.html">Writing Your First Program</a></strong> - Detailed program development</li>
<li><strong><a href="getting-started/../guides/testing-guide.html">Testing Guide</a></strong> - Testing strategies and tools</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<ul>
<li><strong><a href="getting-started/../guides/how-to-create-a-fungible-token.html">Fungible Token</a></strong> - Create your own token</li>
<li><strong><a href="getting-started/../guides/how-to-write-oracle-program.html">Oracle Program</a></strong> - Build price oracles</li>
<li><strong><a href="getting-started/../guides/how-to-build-runes-swap.html">Runes Swap</a></strong> - Create a DEX for Bitcoin Runes</li>
</ul>
<h3 id="production"><a class="header" href="#production">Production</a></h3>
<ul>
<li><strong><a href="getting-started/bitcoin-and-titan-setup.html">Validator Setup</a></strong> - Run a production validator</li>
<li><strong><a href="getting-started/../concepts/network-architecture.html">Network Configuration</a></strong> - Understanding network topology</li>
<li><strong><a href="getting-started/../concepts/bitcoin-integration.html#security-model">Security Best Practices</a></strong> - Production security</li>
</ul>
<h2 id="-need-help"><a class="header" href="#-need-help">üÜò Need Help?</a></h2>
<ul>
<li><strong><a href="https://discord.gg/archnetwork">Discord Community</a></strong> - Real-time support and discussion</li>
<li><strong><a href="getting-started/../reference/troubleshooting.html">Troubleshooting Guide</a></strong> - Common issues and solutions</li>
<li><strong><a href="getting-started/faq.html">FAQ</a></strong> - Frequently asked questions</li>
<li><strong><a href="getting-started/../rpc/rpc.html">API Reference</a></strong> - Complete RPC documentation</li>
</ul>
<h2 id="-system-requirements"><a class="header" href="#-system-requirements">üìä System Requirements</a></h2>
<h3 id="minimum-requirements"><a class="header" href="#minimum-requirements">Minimum Requirements</a></h3>
<ul>
<li><strong>CPU</strong>: 4+ cores</li>
<li><strong>RAM</strong>: 8GB</li>
<li><strong>Storage</strong>: 100GB SSD</li>
<li><strong>Network</strong>: 100 Mbps</li>
</ul>
<h3 id="recommended-for-production"><a class="header" href="#recommended-for-production">Recommended for Production</a></h3>
<ul>
<li><strong>CPU</strong>: 8+ cores</li>
<li><strong>RAM</strong>: 16GB+</li>
<li><strong>Storage</strong>: 500GB+ NVMe SSD</li>
<li><strong>Network</strong>: 1 Gbps</li>
</ul>
<h2 id="-common-commands-quick-reference"><a class="header" href="#-common-commands-quick-reference">üîç Common Commands Quick Reference</a></h2>
<pre><code class="language-bash"># Full local development setup
arch-cli orchestrate start

# Deploy and test a program
arch-cli deploy ./target/deploy/program.so --generate-if-missing
arch-cli show &lt;PROGRAM_ADDRESS&gt;
arch-cli tx confirm &lt;TX_ID&gt;

# Account management
arch-cli account create --keypair-path ./account.json --airdrop 1000000000
arch-cli show &lt;ACCOUNT_ADDRESS&gt;

# Network information
arch-cli get-block-height
arch-cli get-block &lt;BLOCK_HASH&gt;

# Stop local environment
arch-cli orchestrate stop
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-validator-setup"><a class="header" href="#-validator-setup">üèóÔ∏è Validator Setup</a></h1>
<p>Welcome to the validator setup guide! This guide will walk you through setting up a full Arch Network validator node. You can choose between an automated setup or manual configuration depending on your needs.</p>
<h2 id="-what-youll-build"><a class="header" href="#-what-youll-build">üéØ What You‚Äôll Build</a></h2>
<pre class="mermaid">graph TD
    A[Bitcoin Core] --&gt;|Blockchain Data| B[Titan Indexer]
    B --&gt;|Efficient Queries| C[Validator Node]
    C --&gt;|Participate in| D[Arch Network]
    D --&gt;|Secure| E[Bitcoin Network]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef bitcoin fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    classDef titan fill:#4a90e2,stroke:#357abd,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef arch fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    class A,E bitcoin
    class B titan
    class C validator
    class D arch
</pre>
<h2 id="-component-architecture"><a class="header" href="#-component-architecture">üéØ Component Architecture</a></h2>
<pre class="mermaid">graph TD
    A[Your dApp] --&gt;|Interacts with| B[Local Validator]
    B --&gt;|Queries| C[Titan]
    C --&gt;|Reads| D[Bitcoin Core]
    D --&gt;|Manages| E[Local Blockchain]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef dapp fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef titan fill:#4a90e2,stroke:#357abd,stroke-width:2px,rx:10px,ry:10px
    classDef bitcoin fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    classDef blockchain fill:#a4b0be,stroke:#747d8c,stroke-width:2px,rx:10px,ry:10px
    class A dapp
    class B validator
    class C titan
    class D bitcoin
    class E blockchain
    linkStyle default stroke:#a4b0be,stroke-width:2px
</pre>
<h2 id="-understanding-your-role"><a class="header" href="#-understanding-your-role">üí° Understanding Your Role</a></h2>
<p>As a validator, you will:</p>
<ul>
<li>Execute smart contracts and validate transactions</li>
<li>Participate in network consensus</li>
<li>Help secure the Bitcoin integration</li>
<li>Earn rewards for your contribution</li>
</ul>
<h2 id="-system-requirements-1"><a class="header" href="#-system-requirements-1">üìã System Requirements</a></h2>
<ul>
<li><strong>CPU</strong>: 4+ cores recommended</li>
<li><strong>RAM</strong>: 16GB+ recommended</li>
<li><strong>Storage</strong>: 100GB+ SSD for regtest, 500GB+ for testnet/mainnet</li>
<li><strong>Network</strong>: Stable internet connection (10+ Mbps)</li>
<li><strong>OS</strong>: Linux (Ubuntu 20.04+) or macOS (12.0+)</li>
</ul>
<h2 id="-setup-options"><a class="header" href="#-setup-options">üöÄ Setup Options</a></h2>
<p>Choose your preferred setup method:</p>
<h3 id="option-a-automated-setup-recommended"><a class="header" href="#option-a-automated-setup-recommended">Option A: Automated Setup (Recommended)</a></h3>
<p>The easiest way to get started using the CLI orchestrate command.</p>
<p><strong>Prerequisites:</strong></p>
<ul>
<li><strong>Docker</strong>: Required on all platforms - <a href="https://docs.docker.com/engine/install/">Install Docker</a></li>
<li><strong>Docker Management</strong> (optional but recommended):
<ul>
<li><strong>macOS</strong>: <a href="https://orbstack.dev/">OrbStack</a> (recommended) or <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></li>
<li><strong>Linux</strong>: <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> (optional GUI)</li>
</ul>
</li>
<li><strong>Arch Network CLI</strong> - Download from <a href="https://github.com/Arch-Network/arch-node/releases/latest">releases</a></li>
</ul>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash"># 1. Download and install the Arch CLI
# (Download the appropriate binary for your platform from the releases page)

# 2. Start the complete validator stack
arch-cli orchestrate start
</code></pre>
<p>This automatically starts:</p>
<ul>
<li>Bitcoin Core (regtest mode)</li>
<li>Titan indexer</li>
<li>Local validator</li>
<li>All necessary networking and configuration</li>
</ul>
<p><strong>Service URLs:</strong></p>
<ul>
<li>Bitcoin Core RPC: <code>http://127.0.0.1:18443</code></li>
<li>Titan API: <code>http://127.0.0.1:3030</code></li>
<li>Validator RPC: <code>http://127.0.0.1:9002</code></li>
</ul>
<p><strong>Management Commands:</strong></p>
<pre><code class="language-bash"># Stop all services
arch-cli orchestrate stop

# Check validator status specifically
arch-cli orchestrate validator-status

# Reset all data (removes all data)
arch-cli orchestrate reset
</code></pre>
<h3 id="option-b-manual-setup-advanced"><a class="header" href="#option-b-manual-setup-advanced">Option B: Manual Setup (Advanced)</a></h3>
<p>For developers who want full control over their environment.</p>
<h4 id="step-1-bitcoin-core-setup"><a class="header" href="#step-1-bitcoin-core-setup">Step 1: Bitcoin Core Setup</a></h4>
<p><strong>Install and Start Bitcoin Core:</strong></p>
<pre><code class="language-bash"># Install Bitcoin Core (if not already installed)
# macOS: brew install bitcoin
# Linux: Download from https://bitcoin.org/en/download

# Start Bitcoin Core in regtest mode
bitcoind -regtest -port=18444 -rpcport=18443 \
    -rpcuser=bitcoin -rpcpassword=bitcoinpass \
    -fallbackfee=0.001

# First-time setup (only needed once)
# Create a wallet called "testwallet"
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass createwallet testwallet

# Generate an address and mine the first 100 blocks to it
ADDRESS=$(bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass getnewaddress)
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass generatetoaddress 100 $ADDRESS
</code></pre>
<h4 id="step-2-titan-indexer-setup"><a class="header" href="#step-2-titan-indexer-setup">Step 2: Titan Indexer Setup</a></h4>
<p><strong>Clone and Build Titan:</strong></p>
<pre><code class="language-bash"># Clone Titan repository
git clone https://github.com/saturnbtc/Titan.git
cd Titan

# Build Titan
cargo build --release
</code></pre>
<p><strong>Start Titan:</strong></p>
<pre><code class="language-bash"># Start Titan indexer
cargo run --bin titan -- \
    --bitcoin-rpc-url http://127.0.0.1:18443 \
    --bitcoin-rpc-username bitcoin \
    --bitcoin-rpc-password bitcoinpass \
    --chain regtest \
    --index-addresses \
    --index-bitcoin-transactions \
    --enable-tcp-subscriptions \
    --main-loop-interval 0 \
    --http-listen 127.0.0.1:3030
</code></pre>
<h4 id="step-3-validator-setup"><a class="header" href="#step-3-validator-setup">Step 3: Validator Setup</a></h4>
<p><strong>Start Validator:</strong></p>
<pre><code class="language-bash"># Using the CLI (recommended)
arch-cli validator-start

# OR using the binary directly
./local_validator \
    --rpc-bind-ip 127.0.0.1 \
    --rpc-bind-port 9002 \
    --titan-endpoint http://127.0.0.1:3030
</code></pre>
<h2 id="-process-management"><a class="header" href="#-process-management">üîÑ Process Management</a></h2>
<h3 id="for-automated-setup"><a class="header" href="#for-automated-setup">For Automated Setup</a></h3>
<p>The orchestrate command handles all process management automatically using Docker containers.</p>
<h3 id="for-manual-setup"><a class="header" href="#for-manual-setup">For Manual Setup</a></h3>
<p>You may want to use a process manager to keep services running:</p>
<p><strong>Using tmux (recommended):</strong></p>
<pre><code class="language-bash"># Create a new tmux session
tmux new -s arch-validator

# Split into three panes
# Ctrl+b then " to split horizontally
# Ctrl+b then % to split vertically
# Use arrow keys to navigate between panes

# Start each service in a separate pane:
# Pane 1: bitcoind
# Pane 2: Titan
# Pane 3: Validator
</code></pre>
<p><strong>Using systemd (Linux):</strong></p>
<pre><code class="language-bash"># Create service files for each component
sudo tee /etc/systemd/system/bitcoind.service &gt; /dev/null &lt;&lt;EOF
[Unit]
Description=Bitcoin Core Daemon
After=network.target

[Service]
ExecStart=/usr/local/bin/bitcoind -regtest -port=18444 -rpcport=18443 -rpcuser=bitcoin -rpcpassword=bitcoinpass -fallbackfee=0.001
User=bitcoin
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# Enable and start services
sudo systemctl enable bitcoind
sudo systemctl start bitcoind
</code></pre>
<h2 id="-verification"><a class="header" href="#-verification">‚úÖ Verification</a></h2>
<h3 id="check-service-status"><a class="header" href="#check-service-status">Check Service Status</a></h3>
<p><strong>Automated Setup:</strong></p>
<pre><code class="language-bash">arch-cli orchestrate validator-status
</code></pre>
<p><strong>Manual Setup:</strong></p>
<pre><code class="language-bash"># Check Bitcoin Core
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass getblockchaininfo

# Check Titan
curl http://127.0.0.1:3030/status

# Check Validator
curl -X POST -H 'Content-Type: application/json' \
    -d '{"jsonrpc":"2.0","id":1,"method":"is_node_ready"}' \
    http://127.0.0.1:9002
</code></pre>
<h3 id="test-transaction-flow"><a class="header" href="#test-transaction-flow">Test Transaction Flow</a></h3>
<pre><code class="language-bash"># Deploy a simple program using the CLI
arch-cli deploy ./target/deploy/

# Check transaction status
arch-cli tx confirm &lt;TX_ID&gt;

# Get transaction details
arch-cli tx get &lt;TX_ID&gt;
</code></pre>
<h2 id="-troubleshooting"><a class="header" href="#-troubleshooting">üîç Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Docker/Orchestrate Issues:</strong></p>
<pre><code class="language-bash"># Check Docker is running
docker ps

# Check validator status
arch-cli orchestrate validator-status

# Reset everything
arch-cli orchestrate stop
arch-cli orchestrate reset
arch-cli orchestrate start
</code></pre>
<p><strong>Manual Setup Issues:</strong></p>
<pre><code class="language-bash"># Check if ports are in use
lsof -i :18443  # Bitcoin RPC
lsof -i :3030   # Titan API  
lsof -i :9002   # Validator RPC

# Check service logs
tail -f ~/.bitcoin/regtest/debug.log  # Bitcoin Core logs
</code></pre>
<p><strong>Connectivity Issues:</strong></p>
<ul>
<li>Ensure all services start in order: Bitcoin ‚Üí Titan ‚Üí Validator</li>
<li>Verify Bitcoin Core is fully synced before starting Titan</li>
<li>Check firewall settings aren‚Äôt blocking required ports</li>
<li>Confirm RPC credentials match across all services</li>
</ul>
<h2 id="-network-configurations"><a class="header" href="#-network-configurations">üåê Network Configurations</a></h2>
<h3 id="regtest-development"><a class="header" href="#regtest-development">Regtest (Development)</a></h3>
<ul>
<li><strong>Purpose</strong>: Local development and testing</li>
<li><strong>Bitcoin Network</strong>: Local regtest blockchain</li>
<li><strong>Data</strong>: Minimal, starts fresh each time</li>
<li><strong>Use Case</strong>: Development, testing, learning</li>
</ul>
<h3 id="testnet-testing"><a class="header" href="#testnet-testing">Testnet (Testing)</a></h3>
<pre><code class="language-bash"># For testnet, modify your configuration:
arch-cli orchestrate start --network testnet
# OR manually configure with testnet parameters
</code></pre>
<h3 id="mainnet-production"><a class="header" href="#mainnet-production">Mainnet (Production)</a></h3>
<pre><code class="language-bash"># For mainnet (when available):
arch-cli orchestrate start --network mainnet
# Requires significant storage and bandwidth
</code></pre>
<h2 id="-next-steps-1"><a class="header" href="#-next-steps-1">üìö Next Steps</a></h2>
<p>Once your validator is running:</p>
<ol>
<li><strong>Deploy Your First Program</strong>: Follow the <a href="getting-started/./quick-start.html">Quick Start Guide</a></li>
<li><strong>Explore RPC Methods</strong>: Check the <a href="getting-started/../rpc/rpc.html">RPC API Reference</a></li>
<li><strong>Build Advanced Programs</strong>: See <a href="getting-started/../guides/understanding-arch-programs.html">Program Development</a></li>
<li><strong>Join the Community</strong>: Connect on <a href="https://discord.gg/archnetwork">Discord</a></li>
</ol>
<h2 id="-congratulations"><a class="header" href="#-congratulations">üéâ Congratulations!</a></h2>
<p>You now have a complete Arch Network validator node running! You‚Äôre ready to:</p>
<ul>
<li>Deploy and test smart contracts</li>
<li>Participate in network consensus</li>
<li>Explore Bitcoin-native applications</li>
<li>Build the future of Bitcoin programmability</li>
</ul>
<p>For additional help, join our <a href="https://discord.gg/archnetwork">Discord community</a> or visit our <a href="https://github.com/Arch-Network">GitHub repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h1>
<p>Welcome to the Arch Network development guide. This page contains all the requirements and setup instructions needed to start developing with Arch Network.</p>
<h2 id="system-requirements-1"><a class="header" href="#system-requirements-1">System Requirements</a></h2>
<h3 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Minimum</th><th>Recommended</th></tr></thead><tbody>
<tr><td>CPU</td><td>4+ cores</td><td>8+ cores</td></tr>
<tr><td>RAM</td><td>16GB</td><td>32GB</td></tr>
<tr><td>Storage</td><td>100GB SSD</td><td>500GB+ SSD</td></tr>
<tr><td>Network</td><td>100Mbps</td><td>1Gbps+</td></tr>
</tbody></table>
</div>
<h3 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Minimum Version</th><th>Description</th></tr></thead><tbody>
<tr><td>Operating System</td><td>Ubuntu 20.04+ / macOS 12.0+</td><td>Latest LTS recommended</td></tr>
<tr><td>Git</td><td>Latest</td><td>Version control</td></tr>
<tr><td>Rust</td><td>Latest stable</td><td>Core development language</td></tr>
<tr><td>Solana CLI</td><td>v2.0+</td><td>Program compilation tools</td></tr>
<tr><td>Arch Network CLI</td><td>Latest</td><td>Development toolkit</td></tr>
</tbody></table>
</div>
<h2 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h2>
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<pre><code class="language-bash"># Install Rust using rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env  # Add Rust to your current shell session

# Verify installation
rustc --version
cargo --version
</code></pre>
<h3 id="2-install-build-tools"><a class="header" href="#2-install-build-tools">2. Install Build Tools</a></h3>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<pre><code class="language-bash">xcode-select --install  # Install Command Line Tools
</code></pre>
<h4 id="linux-debianubuntu"><a class="header" href="#linux-debianubuntu">Linux (Debian/Ubuntu)</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y build-essential gcc-multilib jq
</code></pre>
<h3 id="3-install-solana-cli"><a class="header" href="#3-install-solana-cli">3. Install Solana CLI</a></h3>
<pre><code class="language-bash">sh -c "$(curl -sSfL https://release.solana.com/stable/install)"

# Verify installation (should show 2.x.x or later)
solana --version
</code></pre>
<h3 id="4-install-arch-network-cli"><a class="header" href="#4-install-arch-network-cli">4. Install Arch Network CLI</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos---apple-silicon"><a class="header" href="#macos---apple-silicon">macOS - Apple Silicon</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="macos---intel"><a class="header" href="#macos---intel">macOS - Intel</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---x86_64"><a class="header" href="#linux---x86_64">Linux - x86_64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---arm64"><a class="header" href="#linux---arm64">Linux - ARM64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
</div>
<p>Verify installation:</p>
<pre><code class="language-bash">cli --version
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="solana-installation-issues"><a class="header" href="#solana-installation-issues">Solana Installation Issues</a></h3>
<p>If you installed Rust through Homebrew and encounter <code>cargo-build-sbf</code> issues:</p>
<ol>
<li>Remove existing Rust installation:</li>
</ol>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<ol start="2">
<li>Perform clean Rust installation:</li>
</ol>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<ol start="3">
<li>Reinstall Solana:</li>
</ol>
<pre><code class="language-bash">sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
</code></pre>
<h2 id="need-help-1"><a class="header" href="#need-help-1">Need Help?</a></h2>
<ul>
<li>Check our <a href="getting-started/troubleshooting.html">Troubleshooting Guide</a></li>
<li>Join our <a href="https://discord.com/channels/1241112027963986001/1270921925991989268">Discord dev-chat</a></li>
<li>Review the <a href="https://github.com/arch-network/arch-node/releases">Arch Network CLI documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-local-validator-with-bitcoin-testnet4"><a class="header" href="#configuring-local-validator-with-bitcoin-testnet4">Configuring Local Validator with Bitcoin Testnet4</a></h1>
<p>This guide covers how to configure your Arch Network local validator to connect to Bitcoin testnet4, which provides access to additional tools and features for development and testing, including ordinals and runes functionality.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Bitcoin testnet4 is the latest Bitcoin test network that provides:</p>
<ul>
<li><strong>Ordinals Support</strong>: Create and test Bitcoin ordinal inscriptions</li>
<li><strong>Runes Protocol</strong>: Test BRC-20 and rune token functionality</li>
<li><strong>Enhanced Tooling</strong>: Access to advanced Bitcoin testing tools</li>
<li><strong>Real Network Conditions</strong>: More realistic testing environment than regtest</li>
</ul>
<p><strong>When to Use This Setup:</strong></p>
<ul>
<li>Testing ordinals/runes integration</li>
<li>Developing Bitcoin-native features</li>
<li>Testing with external Bitcoin services</li>
<li>Preparing for mainnet deployment</li>
</ul>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li><strong>Arch Network CLI</strong> installed - <a href="https://github.com/Arch-Network/arch-node/releases/latest">Download Latest</a></li>
<li><strong>Docker</strong> installed and running - <a href="https://docs.docker.com/get-docker/">Install Docker</a></li>
<li><strong>Bitcoin Core</strong> (optional, for advanced users) - <a href="https://bitcoin.org/en/download">Install Guide</a></li>
</ul>
<h2 id="quick-start-recommended"><a class="header" href="#quick-start-recommended">Quick Start (Recommended)</a></h2>
<p>The easiest way to run a local validator with testnet4 connectivity:</p>
<pre><code class="language-bash"># Start validator connected to hosted testnet4 infrastructure
arch-cli validator-start --network-mode testnet
</code></pre>
<p>This connects to Arch‚Äôs hosted testnet4 infrastructure including:</p>
<ul>
<li>Bitcoin testnet4 node</li>
<li>Titan indexer</li>
<li>Network coordination services</li>
</ul>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="basic-testnet4-configuration"><a class="header" href="#basic-testnet4-configuration">Basic Testnet4 Configuration</a></h3>
<pre><code class="language-bash">arch-cli validator-start \
  --network-mode testnet \
  --data-dir ./.arch_data \
  --rpc-bind-ip 127.0.0.1 \
  --rpc-bind-port 9002 \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h3 id="custom-network-configuration"><a class="header" href="#custom-network-configuration">Custom Network Configuration</a></h3>
<p>If you want to run your own Bitcoin testnet4 node:</p>
<pre><code class="language-bash"># Start your Bitcoin testnet4 node
bitcoind \
  -testnet4 \
  -server \
  -rpcuser=bitcoin \
  -rpcpassword=bitcoinpass \
  -rpcbind=0.0.0.0 \
  -rpcallowip=0.0.0.0/0 \
  -fallbackfee=0.00001 \
  -zmqpubrawblock=tcp://0.0.0.0:28332 \
  -zmqpubrawtx=tcp://0.0.0.0:28333

# Start validator with custom Bitcoin node
arch-cli validator-start \
  --network-mode testnet \
  --bitcoin-rpc-endpoint http://localhost:48332 \
  --bitcoin-rpc-username bitcoin \
  --bitcoin-rpc-password bitcoinpass
</code></pre>
<h2 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration Parameters</a></h2>
<h3 id="core-settings"><a class="header" href="#core-settings">Core Settings</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--network-mode</code></td><td>Network to connect to (<code>regtest</code>, <code>testnet</code>, <code>mainnet</code>)</td><td><code>regtest</code></td></tr>
<tr><td><code>--data-dir</code></td><td>Directory for validator data storage</td><td><code>./.arch_data</code></td></tr>
<tr><td><code>--rpc-bind-ip</code></td><td>IP address for RPC server</td><td><code>127.0.0.1</code></td></tr>
<tr><td><code>--rpc-bind-port</code></td><td>Port for RPC server</td><td><code>9002</code></td></tr>
</tbody></table>
</div>
<h3 id="bitcoin-integration"><a class="header" href="#bitcoin-integration">Bitcoin Integration</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--bitcoin-rpc-endpoint</code></td><td>Bitcoin node RPC URL</td><td>Uses hosted node</td></tr>
<tr><td><code>--bitcoin-rpc-username</code></td><td>Bitcoin RPC username</td><td>-</td></tr>
<tr><td><code>--bitcoin-rpc-password</code></td><td>Bitcoin RPC password</td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="titan-indexer"><a class="header" href="#titan-indexer">Titan Indexer</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--titan-endpoint</code></td><td>Titan HTTP endpoint</td><td>Hosted endpoint</td></tr>
<tr><td><code>--titan-socket-endpoint</code></td><td>Titan WebSocket endpoint</td><td>Hosted endpoint</td></tr>
</tbody></table>
</div>
<h2 id="advanced-setup-standalone-binary"><a class="header" href="#advanced-setup-standalone-binary">Advanced Setup: Standalone Binary</a></h2>
<p>For advanced users who want more control over the validator process:</p>
<h3 id="download-and-setup"><a class="header" href="#download-and-setup">Download and Setup</a></h3>
<ol>
<li>
<p><strong>Download Required Files</strong>:</p>
<pre><code class="language-bash"># Create working directory
mkdir arch-testnet4-validator
cd arch-testnet4-validator

# Download validator binary and system program
wget https://github.com/Arch-Network/arch-node/releases/latest/download/local_validator
wget https://github.com/Arch-Network/arch-node/releases/latest/download/system_program.so

# Create required directory structure
mkdir ebpf
mv system_program.so ebpf/
chmod +x local_validator
</code></pre>
</li>
<li>
<p><strong>Verify Directory Structure</strong>:</p>
<pre><code>arch-testnet4-validator/
‚îú‚îÄ‚îÄ ebpf/
‚îÇ   ‚îî‚îÄ‚îÄ system_program.so
‚îî‚îÄ‚îÄ local_validator
</code></pre>
</li>
</ol>
<h3 id="run-standalone-validator"><a class="header" href="#run-standalone-validator">Run Standalone Validator</a></h3>
<pre><code class="language-bash">RUST_LOG=info ./local_validator \
  --network-mode testnet \
  --rpc-bind-ip 127.0.0.1 \
  --rpc-bind-port 9002 \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h2 id="testing-your-setup"><a class="header" href="#testing-your-setup">Testing Your Setup</a></h2>
<h3 id="health-check"><a class="header" href="#health-check">Health Check</a></h3>
<p>Verify your validator is running correctly:</p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' http://localhost:9002/
</code></pre>
<p><strong>Expected Response:</strong></p>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
}
</code></pre>
<h3 id="deploy-test-program"><a class="header" href="#deploy-test-program">Deploy Test Program</a></h3>
<p>Test program deployment to verify everything works:</p>
<pre><code class="language-bash"># Using CLI (automatic endpoint detection)
arch-cli deploy --network-mode testnet

# Using CLI with explicit endpoint
arch-cli deploy --network-mode testnet --rpc-url http://localhost:9002
</code></pre>
<h3 id="check-validator-status"><a class="header" href="#check-validator-status">Check Validator Status</a></h3>
<pre><code class="language-bash">arch-cli validator-status --rpc-url http://localhost:9002
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<h4 id="1-connection-refused"><a class="header" href="#1-connection-refused">1. Connection Refused</a></h4>
<pre><code class="language-bash"># Check if validator is running
curl -X POST http://localhost:9002/ \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"is_node_ready","params":[]}'
</code></pre>
<h4 id="2-reset-validator-state"><a class="header" href="#2-reset-validator-state">2. Reset Validator State</a></h4>
<pre><code class="language-bash"># Stop validator first (Ctrl+C or docker stop)
rm -rf .arch_data

# Restart validator
arch-cli validator-start --network-mode testnet
</code></pre>
<h4 id="3-view-logs"><a class="header" href="#3-view-logs">3. View Logs</a></h4>
<p><strong>Docker Logs:</strong></p>
<pre><code class="language-bash"># Find container name
docker ps

# View logs
docker logs -f &lt;container_name&gt;
</code></pre>
<p><strong>Standalone Binary Logs:</strong></p>
<pre><code class="language-bash"># Redirect logs to file
RUST_LOG=info ./local_validator \
  --network-mode testnet \
  [other options] &gt; validator.log 2&gt;&amp;1

# Monitor logs in another terminal
tail -f validator.log
</code></pre>
<h4 id="4-network-connectivity-issues"><a class="header" href="#4-network-connectivity-issues">4. Network Connectivity Issues</a></h4>
<pre><code class="language-bash"># Test connection to Titan endpoint
curl -I https://titan-node.test.aws.archnetwork.xyz

# Test WebSocket endpoint (requires wscat)
wscat -c wss://titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="1-development-cycle"><a class="header" href="#1-development-cycle">1. Development Cycle</a></h3>
<pre><code class="language-bash"># Start validator
arch-cli validator-start --network-mode testnet

# Build your program
cd your-program
cargo build-sbf

# Deploy and test
arch-cli deploy --network-mode testnet
arch-cli invoke [program-id] [account] --data [instruction-data]
</code></pre>
<h3 id="2-reset-between-tests"><a class="header" href="#2-reset-between-tests">2. Reset Between Tests</a></h3>
<pre><code class="language-bash"># Quick reset
arch-cli orchestrate reset

# Full reset (if needed)
rm -rf .arch_data
arch-cli validator-start --network-mode testnet
</code></pre>
<h3 id="3-working-with-testnet4-features"><a class="header" href="#3-working-with-testnet4-features">3. Working with Testnet4 Features</a></h3>
<p><strong>Ordinals Testing:</strong></p>
<pre><code class="language-bash"># Your program can interact with ordinal inscriptions
# Use the Bitcoin testnet4 ordinals APIs
</code></pre>
<p><strong>Runes Integration:</strong></p>
<pre><code class="language-bash"># Test rune token operations
# Integrate with runes protocol via Bitcoin transactions
</code></pre>
<h2 id="production-considerations"><a class="header" href="#production-considerations">Production Considerations</a></h2>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ul>
<li><strong>Never expose RPC ports</strong> publicly in production</li>
<li><strong>Use strong credentials</strong> for Bitcoin RPC connections</li>
<li><strong>Monitor validator health</strong> continuously</li>
</ul>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ul>
<li><strong>Allocate sufficient resources</strong> (4+ GB RAM recommended)</li>
<li><strong>Use SSD storage</strong> for data directory</li>
<li><strong>Monitor disk usage</strong> (logs can grow large)</li>
</ul>
<h3 id="networking"><a class="header" href="#networking">Networking</a></h3>
<ul>
<li><strong>Configure firewalls</strong> appropriately</li>
<li><strong>Use SSL/TLS</strong> for external connections</li>
<li><strong>Monitor network latency</strong> to Bitcoin and Titan nodes</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ol>
<li><strong>Deploy Your First Program</strong>: Follow the <a href="guides/./writing-your-first-program.html">Writing Your First Program</a> guide</li>
<li><strong>Test Thoroughly</strong>: Use the <a href="guides/./testing-guide.html">Testing Guide</a> for comprehensive testing</li>
<li><strong>Explore Examples</strong>: Check out <a href="guides/./guides.html">advanced examples</a> for complex scenarios</li>
<li><strong>Join the Community</strong>: Get help on <a href="https://discord.gg/archnetwork">Discord</a> if you run into issues</li>
</ol>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><a href="guides/../rpc/rpc.html">Arch Network CLI Reference</a></li>
<li><a href="https://mempool.space/testnet4">Bitcoin Testnet4 Faucet</a></li>
<li><a href="https://docs.ordinals.com/">Ordinals Documentation</a></li>
<li><a href="https://runes.com/">Runes Protocol Guide</a></li>
</ul>
<p><strong>Need Help?</strong> Join our <a href="https://discord.gg/archnetwork">Discord community</a> or file issues on our <a href="https://github.com/Arch-Network/arch-node/issues">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-your-node"><a class="header" href="#running-your-node">Running Your Node</a></h1>
<blockquote>
<p>‚ö†Ô∏è <strong>Mainnet Status</strong>: Arch Network mainnet has not launched yet. This guide currently covers testnet operations. ARCH token staking and mainnet validator operations will be available when mainnet launches. More details coming soon.</p>
<p>üîí <strong>Validator Pool Status</strong>: The staking validator pool is currently closed membership. When mainnet launches, the validator pool will initially be limited to approved participants and will be opened to the public at some point in the future.</p>
</blockquote>
<p>This guide will walk you through the process of operating an Arch Network validator node on testnet, including future staking mechanisms and network participation. When mainnet launches, validator operators will be an integral part of the network‚Äôs security and computation infrastructure.</p>
<div class="toc">
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<div class="toc-list">
<a href="getting-started/validator-staking.html#prerequisites" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">01</span>
        <span class="toc-text">Prerequisites</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#validator-responsibilities" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">02</span>
        <span class="toc-text">Validator Responsibilities</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#setup-and-configuration" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">03</span>
        <span class="toc-text">Setup & Configuration</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#monitoring-and-maintenance" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">04</span>
        <span class="toc-text">Monitoring & Maintenance</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
</div>
</div>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<div class="requirement-grid">
<div class="requirement-card">
<h3 id="-system-requirements-2"><a class="header" href="#-system-requirements-2">üñ•Ô∏è System Requirements</a></h3>
<table>
<tr><th>Component</th><th>Minimum</th><th>Recommended</th></tr>
<tr><td>CPU</td><td>4+ cores</td><td>8+ cores</td></tr>
<tr><td>RAM</td><td>16GB</td><td>32GB</td></tr>
<tr><td>Storage</td><td>100GB SSD</td><td>500GB+ SSD</td></tr>
<tr><td>Network</td><td>100Mbps</td><td>1Gbps+</td></tr>
<tr><td>OS</td><td>Ubuntu 20.04+ / macOS 12.0+</td><td>Latest LTS</td></tr>
</table>
</div>
<div class="requirement-card">
<h3 id="-arch-tokens-future-mainnet"><a class="header" href="#-arch-tokens-future-mainnet">üîë ARCH Tokens (Future Mainnet)</a></h3>
<p><strong>‚ö†Ô∏è Not yet available:</strong> ARCH token staking will be available for approved validators when mainnet launches. The staking validator pool is currently closed membership.</p>
<ul>
<li>Minimum stake amounts (TBD)</li>
<li>Lockup periods (TBD)</li>
<li>Commission rates (TBD)</li>
<li>Application process for validator pool membership (TBD)</li>
</ul>
<p><strong>Current Testnet:</strong> No ARCH tokens required - use the faucet for test tokens.</p>
<p>More details about mainnet staking and validator pool access will be announced closer to mainnet launch.</p>
</div>
</div>
<h2 id="validator-responsibilities"><a class="header" href="#validator-responsibilities">Validator Responsibilities</a></h2>
<div class="responsibility-grid">
<div class="responsibility-card">
<h3 id="-transaction-processing"><a class="header" href="#-transaction-processing">üîÑ Transaction Processing</a></h3>
<ul>
<li>Execute programs in Arch VM</li>
<li>Validate transaction signatures</li>
<li>Process Bitcoin-related transactions</li>
<li>Maintain transaction history</li>
</ul>
</div>
<div class="responsibility-card">
<h3 id="-consensus-participation"><a class="header" href="#-consensus-participation">ü§ù Consensus Participation</a></h3>
<ul>
<li>Participate in ROAST protocol</li>
<li>Contribute to threshold signing</li>
<li>Coordinate transaction finality</li>
<li>Verify state transitions</li>
</ul>
</div>
<div class="responsibility-card">
<h3 id="-state-management"><a class="header" href="#-state-management">üìä State Management</a></h3>
<ul>
<li>Track UTXO states</li>
<li>Validate Bitcoin operations</li>
<li>Maintain state consistency</li>
<li>Verify network state</li>
</ul>
</div>
</div>
<h2 id="setup--configuration"><a class="header" href="#setup--configuration">Setup &amp; Configuration</a></h2>
<h3 id="1-install-arch-network-cli"><a class="header" href="#1-install-arch-network-cli">1. Install Arch Network CLI</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos---apple-silicon-1"><a class="header" href="#macos---apple-silicon-1">macOS - Apple Silicon</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="macos---intel-1"><a class="header" href="#macos---intel-1">macOS - Intel</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---x86_64-1"><a class="header" href="#linux---x86_64-1">Linux - x86_64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---arm64-1"><a class="header" href="#linux---arm64-1">Linux - ARM64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
</div>
<p>Verify installation:</p>
<pre><code class="language-bash">cli --version
</code></pre>
<h3 id="2-configure-bitcoin-node-access"><a class="header" href="#2-configure-bitcoin-node-access">2. Configure Bitcoin Node Access</a></h3>
<div class="network-select">
<div class="network-option">
<h4 id="-remote-node-recommended"><a class="header" href="#-remote-node-recommended">üì° Remote Node (Recommended)</a></h4>
<p><strong>Regtest/Development:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint bitcoin-node.dev.aws.archnetwork.xyz \
--bitcoin-rpc-port 18443 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testwallet
</code></pre>
<p><strong>Testnet:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint bitcoin-node.test.aws.archnetwork.xyz \
--bitcoin-rpc-port 49332 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testwallet
</code></pre>
</div>
<div class="network-option">
<h4 id="-local-node"><a class="header" href="#-local-node">üñ•Ô∏è Local Node</a></h4>
<p>For advanced users who want full control. See our <a href="getting-started/bitcoin-and-titan-setup.html">Bitcoin Node Setup Guide</a>.</p>
<p><strong>Local Regtest Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 18443 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet regtest
</code></pre>
<p><strong>Local Testnet Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 18332 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testnet
</code></pre>
<p><strong>Local Mainnet Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 8332 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet mainnet
</code></pre>
</div>
</div>
<h3 id="3-start-your-validator"><a class="header" href="#3-start-your-validator">3. Start Your Validator</a></h3>
<blockquote>
<p>‚ö†Ô∏è <strong>Current Status</strong>: Mainnet is not yet available. Use testnet for current operations.</p>
</blockquote>
<p><strong>For Testnet (Currently Available):</strong></p>
<pre><code class="language-bash">cli validator-start \
  --network-mode testnet \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<p><strong>For Mainnet (Future):</strong></p>
<pre><code class="language-bash"># Mainnet configuration will be available when mainnet launches
cli validator-start \
  --network-mode mainnet \
  --titan-endpoint &lt;mainnet-endpoint-tbd&gt; \
  --titan-socket-endpoint &lt;mainnet-socket-tbd&gt;
</code></pre>
<h2 id="monitoring--maintenance"><a class="header" href="#monitoring--maintenance">Monitoring &amp; Maintenance</a></h2>
<div class="monitoring-grid">
<div class="monitoring-card">
<h3 id="-health-checks"><a class="header" href="#-health-checks">üìä Health Checks</a></h3>
<pre><code class="language-bash"># Node status
arch-cli validator status

# Performance metrics
arch-cli validator metrics
</code></pre>
</div>
<div class="monitoring-card">
<h3 id="-sync-management"><a class="header" href="#-sync-management">üîÑ Sync Management</a></h3>
<pre><code class="language-bash"># Check sync status
arch-cli validator sync-status

# Force resync if needed
arch-cli validator resync
</code></pre>
</div>
</div>
<h2 id="understanding-staking-in-arch-network-future"><a class="header" href="#understanding-staking-in-arch-network-future">Understanding Staking in Arch Network (Future)</a></h2>
<blockquote>
<p>‚ö†Ô∏è <strong>Note</strong>: The staking mechanisms described below are planned for mainnet launch and are not currently available. Current testnet operations do not require ARCH token staking.</p>
</blockquote>
<div class="staking-explanation">
<h3 id="-what-will-staking-be"><a class="header" href="#-what-will-staking-be">üîê What will Staking be?</a></h3>
<p>Staking in Arch Network will be fundamentally different from traditional Proof of Stake systems. Instead of using staking for consensus, Arch Network will use staked validators to participate in the ROAST protocol for secure Bitcoin transaction signing.</p>
<pre class="mermaid">flowchart TB
    subgraph Staking[&quot;Staking Process&quot;]
        direction TB
        V[Validator Node] --&gt;|1. Stakes ARCH| N[Network]
        N --&gt;|2. Assigns Share| DKG[Distributed Key]
        DKG --&gt;|3. Participates in| ROAST[ROAST Protocol]
    end

    subgraph Validation[&quot;Transaction Validation&quot;]
        direction TB
        TX[Transaction] --&gt;|1. Submitted| L[Leader]
        L --&gt;|2. Distributes| VS[Validator Set]
        VS --&gt;|3. Execute &amp; Sign| R[Results]
        R --&gt;|4. Aggregate| BTC[Bitcoin Network]
    end

    style Staking fill:#f3e5f5,stroke:#4a148c
    style Validation fill:#e8f5e9,stroke:#1b5e20
</pre>
<h3 id="-solana-vs-arch-network-validator-comparison"><a class="header" href="#-solana-vs-arch-network-validator-comparison">ü§î Solana vs. Arch Network: Validator Comparison</a></h3>
<div class="comparison-table">
<table>
<tr><th>Feature</th><th>Solana</th><th>Arch Network</th></tr>
<tr>
  <td><b>Consensus Role</b></td>
  <td>Validators vote on blocks and produce blocks when selected as leader</td>
  <td>Validators execute transactions and sign Bitcoin transactions using threshold signatures</td>
</tr>
<tr>
  <td><b>Economic Model</b></td>
  <td>Block rewards + transaction fees</td>
  <td>Transaction fees + commission from Bitcoin operations</td>
</tr>
<tr>
  <td><b>Selection Mechanism</b></td>
  <td>Stake-weighted leader selection</td>
  <td>Stake-weighted participation in threshold signing committee</td>
</tr>
<tr>
  <td><b>Performance Metrics</b></td>
  <td>Vote signing speed, block production, uptime</td>
  <td>Transaction execution correctness, signing participation, uptime</td>
</tr>
<tr>
  <td><b>Slashing Conditions</b></td>
  <td>Double signing, unavailability</td>
  <td>Malicious signing, transaction manipulation attempts</td>
</tr>
<tr>
  <td><b>Hardware Requirements</b></td>
  <td>High-end CPU, 128GB+ RAM, 2TB+ NVMe</td>
  <td>4+ CPU cores, 16GB+ RAM, 100GB+ SSD</td>
</tr>
</table>
</div>
<h3 id="-from-solana-to-arch-operational-transition-guide"><a class="header" href="#-from-solana-to-arch-operational-transition-guide">üöÄ From Solana to Arch: Operational Transition Guide</a></h3>
<p>If you‚Äôre an experienced Solana validator operator, here‚Äôs what you need to know about running an Arch Network validator:</p>
<div class="transition-grid">
<div class="transition-card">
<h4 id="-technical-setup"><a class="header" href="#-technical-setup">‚öôÔ∏è Technical Setup</a></h4>
<ul>
<li><b>Lower Hardware Requirements:</b> Arch Network requires less powerful hardware than Solana</li>
<li><b>Bitcoin RPC Access:</b> Validators need Bitcoin node access (remote or local)</li>
<li><b>Key Management:</b> Different key structure focusing on distributed key generation</li>
<li><b>Monitoring:</b> Focus on signing participation rather than block production</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-economic-considerations"><a class="header" href="#-economic-considerations">üí∞ Economic Considerations</a></h4>
<ul>
<li><b>Staking Return Model:</b> Fee-based with transaction execution rewards</li>
<li><b>Reward Distribution:</b> Based on stake proportion and signing participation</li>
<li><b>Commission Structure:</b> Set during validator configuration</li>
<li><b>Lockup Periods:</b> Network-defined based on security requirements</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-operational-differences"><a class="header" href="#-operational-differences">üîÑ Operational Differences</a></h4>
<ul>
<li><b>Signing vs. Voting:</b> Focus on correct transaction execution and signing</li>
<li><b>Performance Metrics:</b> Measured by signing participation and availability</li>
<li><b>Updates:</b> Less frequent than Solana's rapid release cycle</li>
<li><b>Network Bandwidth:</b> Lower requirements due to different architecture</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-onboarding-process-future-mainnet"><a class="header" href="#-onboarding-process-future-mainnet">üõ£Ô∏è Onboarding Process (Future Mainnet)</a></h4>
<ul>
<li><b>Application:</b> Apply for validator pool membership (initially closed membership)</li>
<li><b>Approval:</b> Await approval for validator participation</li>
<li><b>Registration:</b> Complete validator registration through the network portal (TBD)</li>
<li><b>Stake Deposit:</b> Transfer ARCH tokens to the validator staking contract (TBD)</li>
<li><b>Configuration:</b> Set up your validator with proper Bitcoin node access</li>
<li><b>Key Generation:</b> Participate in distributed key generation ceremony</li>
<li><b>Activation:</b> Begin participation after stake activation period</li>
</ul>
<p><strong>Note:</strong> The validator pool will initially be limited to approved participants and will open to the public in the future.</p>
<h4 id="-current-testnet-onboarding"><a class="header" href="#-current-testnet-onboarding">üß™ Current Testnet Onboarding</a></h4>
<ul>
<li><b>No Registration Required:</b> Simply start a testnet validator</li>
<li><b>No Stake Required:</b> Testnet operation is free</li>
<li><b>Configuration:</b> Set up your validator with testnet endpoints</li>
<li><b>Testing:</b> Deploy programs and test functionality</li>
<li><b>Immediate Participation:</b> Begin testing immediately</li>
</ul>
</div>
</div>
<h3 id="-staking-economics-future-mainnet"><a class="header" href="#-staking-economics-future-mainnet">üìä Staking Economics (Future Mainnet)</a></h3>
<div class="economics-grid">
<div class="economics-card">
<h4 id="validator-requirements-planned"><a class="header" href="#validator-requirements-planned">Validator Requirements (Planned)</a></h4>
<ul>
<li><b>Minimum Stake:</b> TBD - Details will be announced before mainnet launch</li>
<li><b>Lockup Period:</b> Network-defined based on security requirements (TBD)</li>
<li><b>Uptime Requirement:</b> High availability expected for signing participation</li>
<li><b>Performance Bonding:</b> Stake will act as bond for correct behavior</li>
</ul>
</div>
<div class="economics-card">
<h4 id="reward-structure-planned"><a class="header" href="#reward-structure-planned">Reward Structure (Planned)</a></h4>
<ul>
<li><b>Base Rewards:</b> From transaction fees distributed proportionally to stake</li>
<li><b>Signing Rewards:</b> Additional rewards for participating in threshold signing</li>
<li><b>Commission:</b> Set percentage of rewards retained by validator</li>
<li><b>Distribution Frequency:</b> Continuous as transactions are processed</li>
</ul>
</div>
</div>
<div class="economics-card">
<h4 id="current-testnet-operations"><a class="header" href="#current-testnet-operations">Current Testnet Operations</a></h4>
<ul>
<li><b>Open Access:</b> Anyone can run a testnet validator</li>
<li><b>No Staking Required:</b> Testnet validators operate without ARCH token requirements</li>
<li><b>Test Tokens:</b> Use the faucet to get test tokens for transactions</li>
<li><b>No Rewards:</b> Testnet operation is for testing and development only</li>
<li><b>Free Operation:</b> No costs beyond infrastructure for testnet participation</li>
</ul>
</div>
<div class="economics-card">
<h4 id="validator-types-comparison"><a class="header" href="#validator-types-comparison">Validator Types Comparison</a></h4>
<table>
<tr><th>Validator Type</th><th>Access</th><th>Staking</th><th>Rewards</th></tr>
<tr>
  <td><b>Testnet Validators</b></td>
  <td>Open to all</td>
  <td>No staking required</td>
  <td>No rewards (testing only)</td>
</tr>
<tr>
  <td><b>Mainnet Staking Validators</b></td>
  <td>Closed membership initially</td>
  <td>ARCH tokens required (TBD)</td>
  <td>Transaction fees + signing rewards</td>
</tr>
</table>
</div>
<h3 id="-roast-protocol-integration"><a class="header" href="#-roast-protocol-integration">üîÑ ROAST Protocol Integration</a></h3>
<p>The ROAST (Robust Asynchronous Schnorr Threshold) protocol enables validators to collectively sign Bitcoin transactions:</p>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;L: 4. Sign Results
    L-&gt;&gt;B: 5. Submit to Bitcoin
</pre>
<h3 id="-security-model"><a class="header" href="#-security-model">üõ°Ô∏è Security Model</a></h3>
<pre class="mermaid">flowchart LR
    subgraph Security[&quot;Security Layers&quot;]
        direction TB
        UTXO[UTXO Validation] --&gt;|Verifies| Own[Ownership]
        Own --&gt;|Ensures| State[State Consistency]
        State --&gt;|Commits to| BTC[Bitcoin]
    end

    subgraph Threshold[&quot;Threshold Signing&quot;]
        direction TB
        Val[Validators] --&gt;|t-of-n| Sign[Signature]
        Sign --&gt;|ROAST| Agg[Aggregation]
        Agg --&gt;|Submit| Final[Final Transaction]
    end

    style Security fill:#e1f5fe,stroke:#01579b
    style Threshold fill:#fff3e0,stroke:#e65100
</pre>
<div class="staking-card">
<h4 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h4>
<ul>
<li>Distributed key generation for secure signing</li>
<li>Threshold signature scheme (t-of-n) for fault tolerance</li>
<li>Bitcoin-based finality guarantees</li>
<li>Automatic malicious node detection</li>
</ul>
</div>
</div>
<style>
.requirement-grid, .responsibility-grid, .monitoring-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.requirement-card, .responsibility-card, .monitoring-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.requirement-card h3, .responsibility-card h3, .monitoring-card h3 {
    margin-top: 0;
    color: #2c3e50;
}

.platform-select, .network-select {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
    margin: 1.5rem 0;
}

.platform-option, .network-option {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
    width: 100%;
    border-collapse: collapse;
}

th, td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    background: #f1f3f5;
}

.staking-explanation {
    background: #ffffff;
    border-radius: 8px;
    padding: 2rem;
    margin: 2rem 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.staking-explanation h3 {
    color: #2c3e50;
    margin-top: 2rem;
}

.staking-explanation h3:first-child {
    margin-top: 0;
}

.staking-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    margin-top: 2rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.staking-card h4 {
    margin-top: 0;
    color: #2c3e50;
}

.comparison-table {
    overflow-x: auto;
    margin: 1.5rem 0;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
}

.comparison-table th {
    background: #f1f3f5;
    padding: 0.75rem;
    text-align: left;
}

.comparison-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #ddd;
}

.transition-grid, .economics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 1.5rem 0;
}

.transition-card, .economics-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.transition-card h4, .economics-card h4 {
    margin-top: 0;
    color: #2c3e50;
}
</style> <div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-arch-programs"><a class="header" href="#understanding-arch-programs">Understanding Arch Programs</a></h1>
<p>This comprehensive guide walks you through building Arch Network programs by examining a complete, working example. We‚Äôll build a ‚ÄúHello World‚Äù program that demonstrates all the essential concepts you need to start developing on Arch Network.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You‚Äôll Learn</a></h2>
<p>By the end of this guide, you‚Äôll understand:</p>
<ul>
<li>Program structure and architecture</li>
<li>Account management and state handling</li>
<li>Bitcoin transaction integration</li>
<li>Error handling best practices</li>
<li>Testing and deployment patterns</li>
</ul>
<h2 id="complete-example-hello-world-program"><a class="header" href="#complete-example-hello-world-program">Complete Example: Hello World Program</a></h2>
<p>Let‚Äôs build a complete program that stores personalized greetings and demonstrates key Arch Network concepts.</p>
<h3 id="1-project-setup"><a class="header" href="#1-project-setup">1. Project Setup</a></h3>
<p>First, create your program with the correct dependencies:</p>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "hello_world_program"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = { path = "../../program" }
borsh = { version = "1.5.1", features = ["derive"] }

[lib]
crate-type = ["cdylib", "lib"]

[workspace]
</code></pre>
<h3 id="2-program-dependencies-and-imports"><a class="header" href="#2-program-dependencies-and-imports">2. Program Dependencies and Imports</a></h3>
<p><strong>src/lib.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_program::{
    account::AccountInfo,
    bitcoin::{self, absolute::LockTime, transaction::Version, Transaction},
    entrypoint,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    msg,
    program::{next_account_info, set_transaction_to_sign},
    program_error::ProgramError,
    pubkey::Pubkey,
    transaction_to_sign::TransactionToSign,
};
use borsh::{BorshDeserialize, BorshSerialize};
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Dependencies Explained:</strong></p>
<ul>
<li><code>AccountInfo</code>: Access to account data and metadata</li>
<li><code>bitcoin</code>: Bitcoin transaction types and functionality</li>
<li><code>entrypoint</code>: Macro for registering program entry point</li>
<li><code>helper::add_state_transition</code>: Manages Bitcoin state transitions</li>
<li><code>msg</code>: Logging for debugging and monitoring</li>
<li><code>borsh</code>: Efficient serialization for program data</li>
</ul>
<h3 id="3-program-data-structures"><a class="header" href="#3-program-data-structures">3. Program Data Structures</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Parameters sent to our Hello World program
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct HelloWorldParams {
    /// The name to include in the greeting
    pub name: String,
    /// Bitcoin transaction for paying fees
    pub tx_hex: Vec&lt;u8&gt;,
}

/// State stored in the account
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct GreetingAccount {
    /// The greeting message
    pub message: String,
    /// Who was greeted
    pub name: String,
    /// When this greeting was created (block height)
    pub created_at: u64,
    /// How many times this account has been updated
    pub update_count: u32,
}

impl GreetingAccount {
    pub const MAX_SIZE: usize = 4 + 50 + 4 + 50 + 8 + 4; // Borsh overhead + data
    
    pub fn new(name: String, message: String, block_height: u64) -&gt; Self {
        Self {
            message,
            name,
            created_at: block_height,
            update_count: 1,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-custom-error-handling"><a class="header" href="#4-custom-error-handling">4. Custom Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Custom errors for our Hello World program
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HelloWorldError {
    /// The provided name is too long (max 50 chars)
    NameTooLong,
    /// The provided name is empty
    NameEmpty,
    /// The provided name contains invalid characters
    InvalidCharacters,
    /// Account data is corrupted
    InvalidAccountData,
    /// Insufficient fees provided
    InsufficientFees,
}

impl From&lt;HelloWorldError&gt; for ProgramError {
    fn from(e: HelloWorldError) -&gt; Self {
        ProgramError::Custom(match e {
            HelloWorldError::NameTooLong =&gt; 1001,
            HelloWorldError::NameEmpty =&gt; 1002,
            HelloWorldError::InvalidCharacters =&gt; 1003,
            HelloWorldError::InvalidAccountData =&gt; 1004,
            HelloWorldError::InsufficientFees =&gt; 1005,
        })
    }
}

/// Validates the provided name
fn validate_name(name: &amp;str) -&gt; Result&lt;(), HelloWorldError&gt; {
    if name.is_empty() {
        return Err(HelloWorldError::NameEmpty);
    }
    
    if name.len() &gt; 50 {
        return Err(HelloWorldError::NameTooLong);
    }
    
    if !name.chars().all(|c| c.is_alphanumeric() || c.is_whitespace() || c == '-' || c == '_') {
        return Err(HelloWorldError::InvalidCharacters);
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-program-entry-point-and-logic"><a class="header" href="#5-program-entry-point-and-logic">5. Program Entry Point and Logic</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register our program's entry point
entrypoint!(process_instruction);

/// Main program entry point
pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    msg!("Hello World program invoked");

    // Parse instruction data
    let params: HelloWorldParams = borsh::from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    
    // Validate input
    validate_name(&amp;params.name)?;
    
    msg!("Processing greeting for: {}", params.name);

    // Validate accounts
    if accounts.len() != 1 {
        msg!("Expected 1 account, got {}", accounts.len());
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    let account_iter = &amp;mut accounts.iter();
    let greeting_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !greeting_account.is_writable {
        msg!("Account must be writable");
        return Err(ProgramError::InvalidAccountData);
    }

    if !greeting_account.is_signer {
        msg!("Account must be a signer");
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Process the greeting
    process_greeting(greeting_account, &amp;params)?;
    
    // Handle Bitcoin transaction
    handle_bitcoin_transaction(greeting_account, &amp;params.tx_hex)?;

    msg!("Hello World program completed successfully");
    Ok(())
}

/// Processes the greeting and updates account state
fn process_greeting(
    account: &amp;AccountInfo,
    params: &amp;HelloWorldParams,
) -&gt; Result&lt;(), ProgramError&gt; {
    let current_data_len = account.data.borrow().len();
    
    // Check if account is initialized
    let mut greeting_data = if current_data_len == 0 {
        msg!("Initializing new greeting account");
        GreetingAccount::new(
            params.name.clone(),
            format!("Hello, {}! Welcome to Arch Network!", params.name),
            0, // We'll get actual block height in a real implementation
        )
    } else {
        // Update existing account
        let existing_data = GreetingAccount::try_from_slice(&amp;account.data.borrow())
            .map_err(|_| HelloWorldError::InvalidAccountData)?;
        
        msg!("Updating greeting for existing account");
        GreetingAccount {
            message: format!("Hello again, {}! Visit count: {}", 
                           params.name, existing_data.update_count + 1),
            name: params.name.clone(),
            created_at: existing_data.created_at,
            update_count: existing_data.update_count + 1,
        }
    };

    // Serialize the new data
    let serialized_data = borsh::to_vec(&amp;greeting_data)
        .map_err(|_| ProgramError::InvalidAccountData)?;

    // Ensure account has enough space
    if serialized_data.len() &gt; current_data_len {
        msg!("Reallocating account space from {} to {} bytes", 
             current_data_len, serialized_data.len());
        account.realloc(serialized_data.len(), true)?;
    }

    // Write the data
    account.data.borrow_mut().copy_from_slice(&amp;serialized_data);
    
    msg!("Greeting stored: {}", greeting_data.message);
    Ok(())
}

/// Handles Bitcoin transaction for state transition
fn handle_bitcoin_transaction(
    account: &amp;AccountInfo,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    if tx_hex.is_empty() {
        return Err(HelloWorldError::InsufficientFees.into());
    }

    // Deserialize the fee transaction
    let fees_tx: Transaction = bitcoin::consensus::deserialize(tx_hex)
        .map_err(|_| HelloWorldError::InsufficientFees)?;

    msg!("Processing Bitcoin transaction with {} inputs", fees_tx.input.len());

    // Create state transition transaction
    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };

    // Add state transition for our account
    add_state_transition(&amp;mut tx, account);
    
    // Add fee input
    if !fees_tx.input.is_empty() {
        tx.input.push(fees_tx.input[0].clone());
    }

    // Prepare transaction for signing
    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;[InputToSign {
            index: 0,
            signer: account.key.clone(),
        }],
    };

    msg!("Submitting transaction for signing");
    set_transaction_to_sign(&amp;[account.clone()], tx_to_sign)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="program-architecture-breakdown"><a class="header" href="#program-architecture-breakdown">Program Architecture Breakdown</a></h2>
<h3 id="1-entrypoint-pattern"><a class="header" href="#1-entrypoint-pattern">1. <strong>Entrypoint Pattern</strong></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>entrypoint!(process_instruction);
<span class="boring">}</span></code></pre></pre>
<p>Every Arch program needs exactly one entry point. The <code>entrypoint!</code> macro registers your <code>process_instruction</code> function as the program‚Äôs main entry point.</p>
<h3 id="2-function-signature"><a class="header" href="#2-function-signature">2. <strong>Function Signature</strong></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>Parameters explained:</strong></p>
<ul>
<li><code>program_id</code>: Your program‚Äôs public key (often unused in simple programs)</li>
<li><code>accounts</code>: Array of accounts this instruction will read/write</li>
<li><code>instruction_data</code>: Serialized parameters for your specific instruction</li>
</ul>
<h3 id="3-account-validation"><a class="header" href="#3-account-validation">3. <strong>Account Validation</strong></a></h3>
<p>Always validate accounts before use:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check account count
if accounts.len() != expected_count {
    return Err(ProgramError::NotEnoughAccountKeys);
}

// Check permissions
if !account.is_writable {
    return Err(ProgramError::InvalidAccountData);
}

if !account.is_signer {
    return Err(ProgramError::MissingRequiredSignature);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-state-management"><a class="header" href="#4-state-management">4. <strong>State Management</strong></a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read existing state
let data = MyState::try_from_slice(&amp;account.data.borrow())?;

// Modify state
let new_data = MyState { /* updated fields */ };

// Serialize and store
let serialized = borsh::to_vec(&amp;new_data)?;
account.data.borrow_mut().copy_from_slice(&amp;serialized);
<span class="boring">}</span></code></pre></pre>
<h3 id="5-bitcoin-integration"><a class="header" href="#5-bitcoin-integration">5. <strong>Bitcoin Integration</strong></a></h3>
<p>Every state change must be committed to Bitcoin:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Bitcoin transaction
let mut tx = Transaction { /* ... */ };

// Add state transition
add_state_transition(&amp;mut tx, account);

// Submit for signing
set_transaction_to_sign(accounts, TransactionToSign { /* ... */ })?;
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-your-program"><a class="header" href="#testing-your-program">Testing Your Program</a></h2>
<p>Create comprehensive tests for your program:</p>
<p><strong>tests/integration_test.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::helper::sign_and_send_instruction;
use arch_test_sdk::{
    get_balance_bitcoin, initialize_client, Account, Balance
};

#[test]
fn test_hello_world_basic() {
    let (client, _boot_info) = initialize_client();
    
    let program_pubkey = deploy_program();
    let user_account = Account::new();
    
    // Test initial greeting
    let params = HelloWorldParams {
        name: "Alice".to_string(),
        tx_hex: create_fee_transaction(),
    };
    
    let result = send_hello_instruction(&amp;client, &amp;program_pubkey, &amp;user_account, params);
    assert!(result.is_ok());
    
    // Verify state was stored correctly
    let account_data = client.read_account_info(user_account.pubkey()).unwrap();
    let greeting = GreetingAccount::try_from_slice(&amp;account_data.data).unwrap();
    
    assert_eq!(greeting.name, "Alice");
    assert!(greeting.message.contains("Hello, Alice"));
    assert_eq!(greeting.update_count, 1);
}

#[test]
fn test_error_handling() {
    // Test name too long
    let params = HelloWorldParams {
        name: "A".repeat(100), // Too long
        tx_hex: create_fee_transaction(),
    };
    
    let result = send_hello_instruction(&amp;client, &amp;program_pubkey, &amp;user_account, params);
    assert!(result.is_err());
    
    // Test empty name
    let params = HelloWorldParams {
        name: "".to_string(),
        tx_hex: create_fee_transaction(),
    };
    
    let result = send_hello_instruction(&amp;client, &amp;program_pubkey, &amp;user_account, params);
    assert!(result.is_err());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-error-handling"><a class="header" href="#1-error-handling">1. <strong>Error Handling</strong></a></h3>
<ul>
<li>Define custom error types for better debugging</li>
<li>Use descriptive error messages with <code>msg!</code></li>
<li>Validate all inputs before processing</li>
<li>Handle both program logic and Bitcoin transaction errors</li>
</ul>
<h3 id="2-account-management"><a class="header" href="#2-account-management">2. <strong>Account Management</strong></a></h3>
<ul>
<li>Always check account permissions (<code>is_signer</code>, <code>is_writable</code>)</li>
<li>Validate account ownership when needed</li>
<li>Use <code>realloc</code> when data size changes</li>
<li>Consider account rent and minimum balances</li>
</ul>
<h3 id="3-state-design"><a class="header" href="#3-state-design">3. <strong>State Design</strong></a></h3>
<ul>
<li>Keep state structures simple and well-defined</li>
<li>Use Borsh for efficient serialization</li>
<li>Consider data size limits</li>
<li>Plan for state evolution</li>
</ul>
<h3 id="4-bitcoin-integration"><a class="header" href="#4-bitcoin-integration">4. <strong>Bitcoin Integration</strong></a></h3>
<ul>
<li>Always include fee transactions</li>
<li>Validate transaction structure</li>
<li>Use proper input/output management</li>
<li>Handle signing requirements correctly</li>
</ul>
<h3 id="5-security"><a class="header" href="#5-security">5. <strong>Security</strong></a></h3>
<ul>
<li>Validate all input parameters</li>
<li>Check account ownership and permissions</li>
<li>Prevent reentrancy attacks</li>
<li>Use safe arithmetic operations</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="program-derived-addresses-pdas"><a class="header" href="#program-derived-addresses-pdas">Program-Derived Addresses (PDAs)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (pda, bump) = Pubkey::find_program_address(
    &amp;[b"greeting", user.key.as_ref()],
    program_id
);
<span class="boring">}</span></code></pre></pre>
<h3 id="cross-program-invocation-cpi"><a class="header" href="#cross-program-invocation-cpi">Cross-Program Invocation (CPI)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = system_instruction::create_account(/* ... */);
invoke(&amp;instruction, &amp;[account1, account2, system_program])?;
<span class="boring">}</span></code></pre></pre>
<h3 id="multiple-instructions"><a class="header" href="#multiple-instructions">Multiple Instructions</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match MyInstruction::try_from_slice(instruction_data)? {
    MyInstruction::Initialize { .. } =&gt; process_initialize(accounts)?,
    MyInstruction::Update { .. } =&gt; process_update(accounts)?,
    MyInstruction::Close =&gt; process_close(accounts)?,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you understand the fundamentals:</p>
<ol>
<li><strong>Explore Advanced Examples</strong>: Check out the <a href="guides/../apl/token-program.html">token program</a> and <a href="guides/./how-to-write-oracle-program.html">oracle implementation</a></li>
<li><strong>Learn Testing</strong>: Set up comprehensive test suites for your programs</li>
<li><strong>Understand PDAs</strong>: Master program-derived addresses for complex state management</li>
<li><strong>Study CPI</strong>: Learn cross-program invocation for composable programs</li>
<li><strong>Deploy and Monitor</strong>: Learn deployment and monitoring best practices</li>
</ol>
<h2 id="additional-resources-1"><a class="header" href="#additional-resources-1">Additional Resources</a></h2>
<ul>
<li><a href="https://github.com/Arch-Network/arch-examples">Program Examples Repository</a></li>
<li><a href="guides/../apl/token-program.html">APL Token Implementation</a></li>
<li><a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration Guide</a></li>
<li><a href="guides/../rpc/rpc.html">RPC API Reference</a></li>
</ul>
<p>The complete code for this example is available in the <a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/helloworld">Hello World example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-an-arch-network-project"><a class="header" href="#setting-up-an-arch-network-project">Setting up an Arch Network Project</a></h1>
<p>This guide walks you through creating your first Arch Network project. You‚Äôll learn how to set up, build, and deploy a ‚ÄúHello World‚Äù program to the Arch Network using the Arch Network CLI tool.</p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>Before starting, ensure you have the following dependencies installed:</p>
<ul>
<li>Arch Network CLI (Latest)</li>
<li>Solana CLI (Latest stable version)</li>
<li>Cargo (v1.81.0 or later)</li>
<li>Rust (Latest stable version)</li>
<li>Bitcoin Core and Titan: Required for local validation</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<h3 id="1-clone-the-example-repository"><a class="header" href="#1-clone-the-example-repository">1. Clone the Example Repository</a></h3>
<p>Start by cloning the Arch Network examples repository:</p>
<pre><code class="language-bash"># Clone the examples repository
git clone https://github.com/Arch-Network/arch-examples.git

# Navigate to the Hello World example
cd arch-examples/examples/helloworld
</code></pre>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<p>After cloning, you‚Äôll see the following project structure:</p>
<p>The helloworld folder should look like this:</p>
<pre><code class="language-ignore">
helloworld/
‚îú‚îÄ‚îÄ Cargo.toml              # Workspace configuration
‚îú‚îÄ‚îÄ program/                # Program directory containing on-chain code
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.lock
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml         # Program dependencies
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs         # Program logic
‚îî‚îÄ‚îÄ src/                   # Client-side code
    ‚îî‚îÄ‚îÄ lib.rs             # Client interface
</code></pre>
<h3 id="2-build-the-program"><a class="header" href="#2-build-the-program">2. Build the program</a></h3>
<p>Build the program using the Solana BPF compiler:</p>
<pre><code class="language-bash"># Navigate to the program directory
cd program

# Build the program using Solana's BPF compiler
cargo build-sbf
</code></pre>
<p>This command compiles your Rust code into a format that can be deployed to the Arch Network.</p>
<h3 id="3-start-the-local-validator"><a class="header" href="#3-start-the-local-validator">3. Start the local validator</a></h3>
<p>Start a local validator for testing:</p>
<pre><code class="language-bash"># Start the Arch Network validator
arch-cli validator-start
</code></pre>
<blockquote>
<p>Important: Ensure Bitcoin Core and Titan are properly configured and running before starting the validator. See the setup guide for details.</p>
</blockquote>
<h3 id="4-deploy-the-program"><a class="header" href="#4-deploy-the-program">4. Deploy the program</a></h3>
<p>Deploy your compiled program to the local Arch Network:</p>
<pre><code class="language-bash"># Deploy the program
arch-cli deploy ./target/deploy/
</code></pre>
<h3 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h3>
<p>Common issues and solutions:</p>
<ul>
<li>
<p>If cargo build-sbf fails:</p>
<ul>
<li>Ensure you have the latest version of Rust and Cargo</li>
<li>Check that all dependencies are properly installed</li>
</ul>
</li>
<li>
<p>If validator fails to start:</p>
<ul>
<li>Verify Bitcoin Core and Titan are running</li>
<li>Check the logs for specific error messages</li>
</ul>
</li>
</ul>
<h2 id="additional-cli-commands"><a class="header" href="#additional-cli-commands">Additional CLI Commands</a></h2>
<p>For more advanced operations, the Arch Network CLI provides additional commands:</p>
<pre><code class="language-bash"># Show program information
arch-cli show &lt;PROGRAM_ADDRESS&gt;

# Confirm transaction status
arch-cli confirm &lt;TX_ID&gt;

# Get block information
arch-cli get-block &lt;BLOCK_HASH&gt;

# Get block height
arch-cli get-block-height
</code></pre>
<p>For a complete list of available commands, refer to the <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network CLI documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-first-arch-program"><a class="header" href="#writing-your-first-arch-program">Writing Your First Arch Program</a></h1>
<p>This comprehensive guide walks you through creating your first Arch program from scratch. We‚Äôll build a feature-rich counter program that demonstrates the complete development workflow and all essential concepts you need for building production-ready Arch Network applications.</p>
<h2 id="what-youll-build"><a class="header" href="#what-youll-build">What You‚Äôll Build</a></h2>
<p>By the end of this guide, you‚Äôll have created a complete counter program that:</p>
<ul>
<li>Manages state in program accounts</li>
<li>Handles multiple instruction types</li>
<li>Integrates with Bitcoin transactions</li>
<li>Includes comprehensive error handling</li>
<li>Provides extensive testing coverage</li>
<li>Follows security best practices</li>
</ul>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li><strong>Rust 1.70+</strong> and Cargo installed (<a href="https://rustup.rs/">Install Rust</a>)</li>
<li><strong>Solana CLI 2.0+</strong> - <a href="https://docs.solana.com/cli/install-solana-cli-tools">Install Guide</a></li>
<li><strong>Arch Network CLI</strong> - <a href="https://github.com/Arch-Network/arch-node/releases/latest">Download Latest</a></li>
<li><strong>Running validator</strong> (see <a href="guides/../getting-started/bitcoin-and-titan-setup.html">Validator Setup Guide</a>)</li>
<li><strong>Basic Rust knowledge</strong> and understanding of <a href="guides/../concepts/architecture.html">Arch concepts</a></li>
</ul>
<h2 id="step-1-project-setup"><a class="header" href="#step-1-project-setup">Step 1: Project Setup</a></h2>
<h3 id="11-create-project-structure"><a class="header" href="#11-create-project-structure">1.1 Create Project Structure</a></h3>
<pre><code class="language-bash"># Create project directory
mkdir my-counter-program
cd my-counter-program

# Create program directory
mkdir program
cd program

# Initialize Rust library
cargo init --lib
</code></pre>
<h3 id="12-configure-dependencies"><a class="header" href="#12-configure-dependencies">1.2 Configure Dependencies</a></h3>
<p>Create a proper <code>Cargo.toml</code>:</p>
<p><strong>program/Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "my_counter_program"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = "0.5.4"
borsh = { version = "1.5.1", features = ["derive"] }

[lib]
crate-type = ["cdylib", "lib"]

[workspace]
</code></pre>
<h3 id="13-project-structure"><a class="header" href="#13-project-structure">1.3 Project Structure</a></h3>
<p>Your project should look like this:</p>
<pre><code>my-counter-program/
‚îú‚îÄ‚îÄ program/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ client/          # We'll add this later
‚îî‚îÄ‚îÄ tests/           # We'll add this later
</code></pre>
<h2 id="step-2-define-program-data-structures"><a class="header" href="#step-2-define-program-data-structures">Step 2: Define Program Data Structures</a></h2>
<p>Create comprehensive data structures for your program:</p>
<p><strong>program/src/lib.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_program::{
    account::AccountInfo,
    bitcoin::{self, absolute::LockTime, transaction::Version, Transaction},
    entrypoint,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    msg,
    program::{next_account_info, set_transaction_to_sign},
    program_error::ProgramError,
    pubkey::Pubkey,
    transaction_to_sign::TransactionToSign,
};
use borsh::{BorshDeserialize, BorshSerialize};

/// Counter program state stored in accounts
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct CounterAccount {
    /// Current counter value
    pub count: i64,
    /// Who created this counter
    pub authority: Pubkey,
    /// When this counter was created (block height)
    pub created_at: u64,
    /// When this counter was last updated
    pub updated_at: u64,
    /// Total number of operations performed
    pub operation_count: u64,
    /// Whether the counter is frozen
    pub is_frozen: bool,
}

impl CounterAccount {
    pub const SIZE: usize = 8 + 32 + 8 + 8 + 8 + 1; // i64 + Pubkey + u64 + u64 + u64 + bool
    
    pub fn new(authority: Pubkey, block_height: u64) -&gt; Self {
        Self {
            count: 0,
            authority,
            created_at: block_height,
            updated_at: block_height,
            operation_count: 0,
            is_frozen: false,
        }
    }
}

/// Instructions that can be performed on the counter
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub enum CounterInstruction {
    /// Initialize a new counter
    /// Accounts:
    /// 0. [writable, signer] Counter account to initialize
    Initialize,
    
    /// Increment the counter by a specified amount
    /// Accounts:
    /// 0. [writable] Counter account to increment
    /// 1. [signer] Authority or allowed user
    Increment { amount: u32 },
    
    /// Decrement the counter by a specified amount
    /// Accounts:
    /// 0. [writable] Counter account to decrement
    /// 1. [signer] Authority or allowed user
    Decrement { amount: u32 },
    
    /// Reset the counter to zero
    /// Accounts:
    /// 0. [writable] Counter account to reset
    /// 1. [signer] Authority only
    Reset,
    
    /// Freeze the counter to prevent modifications
    /// Accounts:
    /// 0. [writable] Counter account to freeze
    /// 1. [signer] Authority only
    Freeze,
    
    /// Unfreeze the counter to allow modifications
    /// Accounts:
    /// 0. [writable] Counter account to unfreeze
    /// 1. [signer] Authority only
    Unfreeze,
}

/// Parameters for counter operations that require Bitcoin transactions
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct CounterParams {
    /// The instruction to execute
    pub instruction: CounterInstruction,
    /// Bitcoin transaction for fees
    pub tx_hex: Vec&lt;u8&gt;,
}

/// Custom errors for the counter program
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CounterError {
    /// Counter is frozen and cannot be modified
    CounterFrozen,
    /// Only the authority can perform this operation
    UnauthorizedAccess,
    /// Counter overflow occurred
    Overflow,
    /// Counter underflow occurred
    Underflow,
    /// Invalid instruction data
    InvalidInstruction,
    /// Counter account not initialized
    UninitializedAccount,
    /// Invalid account provided
    InvalidAccount,
    /// Insufficient fees provided
    InsufficientFees,
}

impl From&lt;CounterError&gt; for ProgramError {
    fn from(e: CounterError) -&gt; Self {
        ProgramError::Custom(match e {
            CounterError::CounterFrozen =&gt; 1001,
            CounterError::UnauthorizedAccess =&gt; 1002,
            CounterError::Overflow =&gt; 1003,
            CounterError::Underflow =&gt; 1004,
            CounterError::InvalidInstruction =&gt; 1005,
            CounterError::UninitializedAccount =&gt; 1006,
            CounterError::InvalidAccount =&gt; 1007,
            CounterError::InsufficientFees =&gt; 1008,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-3-implement-program-logic"><a class="header" href="#step-3-implement-program-logic">Step 3: Implement Program Logic</a></h2>
<p>Add the complete program implementation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register program entrypoint
entrypoint!(process_instruction);

/// Main program entrypoint
pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    msg!("Counter program invoked");

    // Parse instruction data
    let params: CounterParams = borsh::from_slice(instruction_data)
        .map_err(|_| CounterError::InvalidInstruction)?;

    msg!("Processing instruction: {:?}", params.instruction);

    // Dispatch to appropriate handler
    match params.instruction {
        CounterInstruction::Initialize =&gt; {
            process_initialize(accounts, &amp;params.tx_hex)
        }
        CounterInstruction::Increment { amount } =&gt; {
            process_increment(accounts, amount, &amp;params.tx_hex)
        }
        CounterInstruction::Decrement { amount } =&gt; {
            process_decrement(accounts, amount, &amp;params.tx_hex)
        }
        CounterInstruction::Reset =&gt; {
            process_reset(accounts, &amp;params.tx_hex)
        }
        CounterInstruction::Freeze =&gt; {
            process_freeze(accounts, &amp;params.tx_hex)
        }
        CounterInstruction::Unfreeze =&gt; {
            process_unfreeze(accounts, &amp;params.tx_hex)
        }
    }
}

/// Initialize a new counter account
fn process_initialize(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !counter_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Check if account is already initialized
    if counter_account.data.borrow().len() &gt;= CounterAccount::SIZE {
        let existing_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow());
        if existing_data.is_ok() {
            msg!("Counter account already initialized");
            return Err(CounterError::InvalidAccount.into());
        }
    }

    // Initialize counter account
    let counter_data = CounterAccount::new(*counter_account.key, 0); // TODO: Get actual block height
    
    // Ensure account has enough space
    if counter_account.data.borrow().len() &lt; CounterAccount::SIZE {
        counter_account.realloc(CounterAccount::SIZE, true)?;
    }

    // Serialize and store data
    let serialized_data = borsh::to_vec(&amp;counter_data)
        .map_err(|_| ProgramError::InvalidAccountData)?;
    
    counter_account.data.borrow_mut()[..serialized_data.len()]
        .copy_from_slice(&amp;serialized_data);

    msg!("Counter initialized with authority: {}", counter_account.key);

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Increment the counter
fn process_increment(
    accounts: &amp;[AccountInfo],
    amount: u32,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter).unwrap_or(counter_account);

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check if counter is frozen
    if counter_data.is_frozen {
        return Err(CounterError::CounterFrozen.into());
    }

    // Perform increment with overflow protection
    let new_count = counter_data.count
        .checked_add(amount as i64)
        .ok_or(CounterError::Overflow)?;

    // Update counter data
    counter_data.count = new_count;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter incremented by {} to {}", amount, new_count);

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Decrement the counter
fn process_decrement(
    accounts: &amp;[AccountInfo],
    amount: u32,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter).unwrap_or(counter_account);

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check if counter is frozen
    if counter_data.is_frozen {
        return Err(CounterError::CounterFrozen.into());
    }

    // Perform decrement with underflow protection
    let new_count = counter_data.count
        .checked_sub(amount as i64)
        .ok_or(CounterError::Underflow)?;

    // Update counter data
    counter_data.count = new_count;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter decremented by {} to {}", amount, new_count);

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Reset the counter to zero
fn process_reset(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check authority
    if counter_data.authority != *authority_account.key {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Check if counter is frozen
    if counter_data.is_frozen {
        return Err(CounterError::CounterFrozen.into());
    }

    // Reset counter
    counter_data.count = 0;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter reset to 0");

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Freeze the counter
fn process_freeze(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check authority
    if counter_data.authority != *authority_account.key {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Freeze counter
    counter_data.is_frozen = true;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter frozen");

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Unfreeze the counter
fn process_unfreeze(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check authority
    if counter_data.authority != *authority_account.key {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Unfreeze counter
    counter_data.is_frozen = false;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter unfrozen");

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Helper function to save counter data
fn save_counter_data(
    counter_account: &amp;AccountInfo,
    counter_data: &amp;CounterAccount,
) -&gt; Result&lt;(), ProgramError&gt; {
    let serialized_data = borsh::to_vec(counter_data)
        .map_err(|_| ProgramError::InvalidAccountData)?;
    
    counter_account.data.borrow_mut()[..serialized_data.len()]
        .copy_from_slice(&amp;serialized_data);
    
    Ok(())
}

/// Handle Bitcoin transaction for state changes
fn handle_bitcoin_transaction(
    account: &amp;AccountInfo,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    if tx_hex.is_empty() {
        return Err(CounterError::InsufficientFees.into());
    }

    // Deserialize the fee transaction
    let fees_tx: Transaction = bitcoin::consensus::deserialize(tx_hex)
        .map_err(|_| CounterError::InsufficientFees)?;

    msg!("Processing Bitcoin transaction with {} inputs", fees_tx.input.len());

    // Create state transition transaction
    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };

    // Add state transition for our account
    add_state_transition(&amp;mut tx, account);
    
    // Add fee input
    if !fees_tx.input.is_empty() {
        tx.input.push(fees_tx.input[0].clone());
    }

    // Prepare transaction for signing
    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;[InputToSign {
            index: 0,
            signer: account.key.clone(),
        }],
    };

    msg!("Submitting transaction for signing");
    set_transaction_to_sign(&amp;[account.clone()], tx_to_sign)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-build-your-program"><a class="header" href="#step-4-build-your-program">Step 4: Build Your Program</a></h2>
<p>Build your program using the Solana toolchain:</p>
<pre><code class="language-bash">cd program

# Build the program
cargo build-sbf

# Verify the build output
ls target/deploy/
</code></pre>
<p>You should see <code>my_counter_program.so</code> in the <code>target/deploy/</code> directory.</p>
<h2 id="step-5-deploy-your-program"><a class="header" href="#step-5-deploy-your-program">Step 5: Deploy Your Program</a></h2>
<p>Deploy your program to the Arch Network:</p>
<pre><code class="language-bash"># Deploy to testnet (recommended for testing)
arch-cli deploy ./target/deploy/ --network-mode testnet

# Or deploy to local network for development
arch-cli deploy ./target/deploy/ --network-mode regtest
</code></pre>
<p><strong>Save the Program ID</strong> from the output - you‚Äôll need it for testing!</p>
<h2 id="step-6-create-a-client-for-testing"><a class="header" href="#step-6-create-a-client-for-testing">Step 6: Create a Client for Testing</a></h2>
<p>Create a client to interact with your program:</p>
<p><strong>client/Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "counter_client"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_sdk = "0.5.4"
my_counter_program = { path = "../program" }
borsh = "1.5.1"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<p><strong>client/src/main.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use arch_sdk::{
    instruction::Instruction,
    message::ArchMessage,
    pubkey::Pubkey,
    signer::{create_account, Keypair},
    transaction::Transaction,
};
use my_counter_program::{CounterInstruction, CounterParams, CounterAccount};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Your program ID (replace with actual deployed program ID)
    let program_id = Pubkey::from_str("YOUR_PROGRAM_ID_HERE")?;
    
    // Create a new account for the counter
    let counter_keypair = Keypair::new();
    
    // Create fee transaction (simplified)
    let fee_tx = create_fee_transaction();
    
    // Test initialize instruction
    test_initialize(&amp;program_id, &amp;counter_keypair, &amp;fee_tx)?;
    
    // Test increment instruction
    test_increment(&amp;program_id, &amp;counter_keypair, &amp;fee_tx, 5)?;
    
    // Test decrement instruction
    test_decrement(&amp;program_id, &amp;counter_keypair, &amp;fee_tx, 2)?;
    
    // Test reset instruction
    test_reset(&amp;program_id, &amp;counter_keypair, &amp;fee_tx)?;
    
    println!("All tests completed successfully!");
    Ok(())
}

fn test_initialize(
    program_id: &amp;Pubkey,
    counter_keypair: &amp;Keypair,
    fee_tx: &amp;[u8],
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let params = CounterParams {
        instruction: CounterInstruction::Initialize,
        tx_hex: fee_tx.to_vec(),
    };
    
    let instruction = Instruction {
        program_id: *program_id,
        accounts: vec![
            AccountMeta::new(counter_keypair.pubkey(), true),
        ],
        data: borsh::to_vec(&amp;params)?,
    };
    
    // Send transaction (implementation depends on your client setup)
    send_transaction(&amp;instruction, &amp;[counter_keypair])?;
    
    println!("Counter initialized successfully");
    Ok(())
}

// Add similar functions for other operations...</code></pre></pre>
<h2 id="step-7-comprehensive-testing"><a class="header" href="#step-7-comprehensive-testing">Step 7: Comprehensive Testing</a></h2>
<p>Create extensive tests for your program:</p>
<p><strong>tests/integration_tests.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use my_counter_program::*;
use arch_test_sdk::*;

#[tokio::test]
async fn test_counter_full_workflow() {
    let (client, _boot_info) = initialize_client();
    
    // Deploy program
    let program_id = deploy_counter_program(&amp;client).await;
    
    // Create test account
    let user_keypair = Keypair::new();
    fund_account(&amp;client, &amp;user_keypair.pubkey(), 1000).await;
    
    // Test initialization
    let counter_account = test_initialize(&amp;client, &amp;program_id, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 0, false).await;
    
    // Test increment
    test_increment(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair, 10).await;
    verify_counter_state(&amp;client, &amp;counter_account, 10, false).await;
    
    // Test decrement
    test_decrement(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair, 3).await;
    verify_counter_state(&amp;client, &amp;counter_account, 7, false).await;
    
    // Test freeze
    test_freeze(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 7, true).await;
    
    // Test operations while frozen (should fail)
    let result = test_increment(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair, 1).await;
    assert!(result.is_err(), "Increment should fail when counter is frozen");
    
    // Test unfreeze
    test_unfreeze(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 7, false).await;
    
    // Test reset
    test_reset(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 0, false).await;
}

#[tokio::test]
async fn test_error_conditions() {
    // Test overflow protection
    // Test underflow protection
    // Test unauthorized access
    // Test invalid instructions
    // TODO: Implement comprehensive error testing
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-8-best-practices-implementation"><a class="header" href="#step-8-best-practices-implementation">Step 8: Best Practices Implementation</a></h2>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li><strong>Input Validation</strong>: Always validate all inputs</li>
<li><strong>Overflow Protection</strong>: Use checked arithmetic operations</li>
<li><strong>Access Control</strong>: Verify account ownership and permissions</li>
<li><strong>State Validation</strong>: Ensure account state is valid before operations</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ol>
<li><strong>Efficient Serialization</strong>: Use Borsh for optimal performance</li>
<li><strong>Minimal Account Size</strong>: Keep state structures compact</li>
<li><strong>Transaction Batching</strong>: Group related operations when possible</li>
</ol>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<ol>
<li><strong>Custom Error Types</strong>: Define specific errors for better debugging</li>
<li><strong>Comprehensive Logging</strong>: Use <code>msg!</code> for important state changes</li>
<li><strong>Graceful Failures</strong>: Handle edge cases appropriately</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you‚Äôve built your first program:</p>
<ol>
<li><strong>Enhance the Counter</strong>: Add features like access control lists, multiple counters per account, or counter metadata</li>
<li><strong>Explore Advanced Patterns</strong>: Learn about <a href="guides/../program/accounts.html">Program Derived Addresses</a> and <a href="guides/../program/instructions-and-messages.html">Cross-Program Invocation</a></li>
<li><strong>Build Complex Programs</strong>: Try the <a href="guides/./how-to-create-a-fungible-token.html">Token Program</a> or <a href="guides/./how-to-write-oracle-program.html">Oracle Program</a> guides</li>
<li><strong>Deploy to Mainnet</strong>: When ready, deploy your programs to mainnet (when available)</li>
</ol>
<h2 id="additional-resources-2"><a class="header" href="#additional-resources-2">Additional Resources</a></h2>
<ul>
<li><a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a> - Deep dive into program architecture</li>
<li><a href="guides/./testing-guide.html">Testing Guide</a> - Comprehensive testing strategies</li>
<li><a href="https://github.com/Arch-Network/arch-examples">Program Examples</a> - More example programs</li>
<li><a href="guides/../rpc/rpc.html">API Reference</a> - Complete RPC documentation</li>
</ul>
<p><strong>Congratulations!</strong> You‚Äôve successfully built, deployed, and tested your first Arch Network program. You now have the foundation to build more complex applications on the Arch Network.</p>
<pre><code class="language-bash"># Start the Arch Network validator
arch-cli validator-start
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehensive-testing-guide-for-arch-network-programs"><a class="header" href="#comprehensive-testing-guide-for-arch-network-programs">Comprehensive Testing Guide for Arch Network Programs</a></h1>
<p>This guide provides complete coverage of testing strategies, tools, and best practices for building robust and reliable Arch Network programs. Proper testing is essential for ensuring your programs work correctly and securely before deployment.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Testing Arch programs involves multiple layers:</p>
<ul>
<li><strong>Unit Tests</strong>: Individual function and logic testing</li>
<li><strong>Integration Tests</strong>: Cross-component functionality testing</li>
<li><strong>End-to-End Tests</strong>: Full program workflow testing</li>
<li><strong>Security Tests</strong>: Vulnerability and attack vector testing</li>
<li><strong>Performance Tests</strong>: Load and efficiency testing</li>
</ul>
<h2 id="project-setup-for-testing"><a class="header" href="#project-setup-for-testing">Project Setup for Testing</a></h2>
<h3 id="test-directory-structure"><a class="header" href="#test-directory-structure">Test Directory Structure</a></h3>
<pre><code>my-program/
‚îú‚îÄ‚îÄ program/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ integration.rs
‚îÇ   ‚îú‚îÄ‚îÄ security.rs
‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îÇ       ‚îî‚îÄ‚îÄ mod.rs
‚îî‚îÄ‚îÄ Cargo.toml (workspace)
</code></pre>
<h3 id="test-dependencies-configuration"><a class="header" href="#test-dependencies-configuration">Test Dependencies Configuration</a></h3>
<p><strong>Cargo.toml (workspace root)</strong></p>
<pre><code class="language-toml">[workspace]
members = ["program", "tests"]

[workspace.dependencies]
arch_program = "0.5.4"
arch_sdk = "0.5.4"
borsh = { version = "1.5.1", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<p><strong>tests/Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "program-tests"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = { workspace = true }
arch_sdk = { workspace = true }
borsh = { workspace = true }
tokio = { workspace = true }

# Test utilities
proptest = "1.0"
rstest = "0.18"
serial_test = "3.0"

# Your program dependency
my_program = { path = "../program" }

[[bin]]
name = "test-runner"
path = "src/main.rs"
</code></pre>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<h3 id="basic-unit-tests"><a class="header" href="#basic-unit-tests">Basic Unit Tests</a></h3>
<p>Unit tests go directly in your program‚Äôs <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::{
        account::AccountInfo,
        program_error::ProgramError,
        pubkey::Pubkey,
    };

    #[test]
    fn test_counter_account_serialization() {
        let counter = CounterAccount::new(Pubkey::new_unique(), 100);
        
        // Test serialization
        let serialized = borsh::to_vec(&amp;counter).unwrap();
        let deserialized: CounterAccount = borsh::from_slice(&amp;serialized).unwrap();
        
        assert_eq!(counter, deserialized);
    }

    #[test]
    fn test_instruction_parsing() {
        let instruction = CounterInstruction::Increment { amount: 5 };
        let params = CounterParams {
            instruction,
            tx_hex: vec![0x01, 0x02, 0x03],
        };
        
        let serialized = borsh::to_vec(&amp;params).unwrap();
        let parsed: CounterParams = borsh::from_slice(&amp;serialized).unwrap();
        
        match parsed.instruction {
            CounterInstruction::Increment { amount } =&gt; assert_eq!(amount, 5),
            _ =&gt; panic!("Wrong instruction type"),
        }
    }

    #[test]
    fn test_error_codes() {
        let error: ProgramError = CounterError::CounterFrozen.into();
        assert_eq!(error, ProgramError::Custom(1001));
    }

    #[test]
    fn test_overflow_protection() {
        let mut counter = CounterAccount::new(Pubkey::new_unique(), 100);
        counter.count = i64::MAX;
        
        // This should detect overflow
        let result = counter.count.checked_add(1);
        assert!(result.is_none());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-unit-testing"><a class="header" href="#advanced-unit-testing">Advanced Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod advanced_tests {
    use super::*;
    use proptest::prelude::*;

    // Property-based testing
    proptest! {
        #[test]
        fn test_counter_operations_never_panic(
            initial_value in i32::MIN..i32::MAX,
            operation_value in 1u32..1000u32
        ) {
            let mut counter = CounterAccount::new(Pubkey::new_unique(), 100);
            counter.count = initial_value as i64;

            // These operations should never panic
            let _ = counter.count.checked_add(operation_value as i64);
            let _ = counter.count.checked_sub(operation_value as i64);
        }
    }

    // Parameterized tests
    use rstest::rstest;

    #[rstest]
    #[case(CounterInstruction::Increment { amount: 1 })]
    #[case(CounterInstruction::Decrement { amount: 1 })]
    #[case(CounterInstruction::Reset)]
    #[case(CounterInstruction::Freeze)]
    #[case(CounterInstruction::Unfreeze)]
    fn test_instruction_serialization(#[case] instruction: CounterInstruction) {
        let params = CounterParams {
            instruction: instruction.clone(),
            tx_hex: vec![],
        };
        
        let serialized = borsh::to_vec(&amp;params).unwrap();
        let deserialized: CounterParams = borsh::from_slice(&amp;serialized).unwrap();
        
        assert_eq!(params.instruction, deserialized.instruction);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h3>
<p><strong>tests/common/mod.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::{
    client::ArchClient,
    instruction::Instruction,
    pubkey::Pubkey,
    signer::Keypair,
    transaction::Transaction,
};
use std::sync::Once;

static INIT: Once = Once::new();

pub struct TestEnvironment {
    pub client: ArchClient,
    pub payer: Keypair,
    pub program_id: Pubkey,
}

impl TestEnvironment {
    pub async fn new() -&gt; Self {
        INIT.call_once(|| {
            env_logger::init();
        });

        let client = ArchClient::new("http://localhost:9001").unwrap();
        let payer = Keypair::new();
        
        // Fund the payer
        let airdrop_signature = client
            .request_airdrop(&amp;payer.pubkey(), 10_000_000)
            .await
            .unwrap();
        
        client.confirm_transaction(&amp;airdrop_signature).await.unwrap();

        // Deploy program
        let program_id = deploy_test_program(&amp;client, &amp;payer).await;

        TestEnvironment {
            client,
            payer,
            program_id,
        }
    }

    pub async fn create_funded_account(&amp;self) -&gt; Keypair {
        let account = Keypair::new();
        let signature = self.client
            .request_airdrop(&amp;account.pubkey(), 1_000_000)
            .await
            .unwrap();
        
        self.client.confirm_transaction(&amp;signature).await.unwrap();
        account
    }
}

async fn deploy_test_program(client: &amp;ArchClient, payer: &amp;Keypair) -&gt; Pubkey {
    let program_data = include_bytes!("../../program/target/deploy/my_counter_program.so");
    
    let program_id = client
        .deploy_program(payer, program_data)
        .await
        .unwrap();
    
    program_id
}

// Helper functions for test data
pub fn create_counter_initialize_instruction(
    program_id: &amp;Pubkey,
    counter_account: &amp;Pubkey,
    authority: &amp;Pubkey,
) -&gt; Instruction {
    use my_program::{CounterInstruction, CounterParams};
    
    let params = CounterParams {
        instruction: CounterInstruction::Initialize,
        tx_hex: create_test_fee_transaction(),
    };
    
    Instruction {
        program_id: *program_id,
        accounts: vec![
            AccountMeta::new(*counter_account, true),
            AccountMeta::new_readonly(*authority, true),
        ],
        data: borsh::to_vec(&amp;params).unwrap(),
    }
}

pub fn create_test_fee_transaction() -&gt; Vec&lt;u8&gt; {
    // Return a minimal valid Bitcoin transaction for testing
    vec![
        0x02, 0x00, 0x00, 0x00, // version
        0x01, // input count
        // ... simplified test transaction data
    ]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="complete-integration-tests"><a class="header" href="#complete-integration-tests">Complete Integration Tests</a></h3>
<p><strong>tests/integration.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::prelude::*;
use my_program::*;
use serial_test::serial;

mod common;
use common::*;

#[tokio::test]
#[serial]
async fn test_complete_counter_workflow() {
    let env = TestEnvironment::new().await;
    
    // Create counter account
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Test 1: Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Initialize should succeed");
    
    // Verify initial state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 0);
    assert_eq!(counter_state.authority, user.pubkey());
    assert!(!counter_state.is_frozen);
    
    // Test 2: Increment counter
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        10,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Increment should succeed");
    
    // Verify incremented state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 10);
    assert_eq!(counter_state.operation_count, 1);
    
    // Test 3: Freeze counter
    let freeze_ix = create_counter_freeze_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[freeze_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Freeze should succeed");
    
    // Test 4: Try to increment frozen counter (should fail)
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        5,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Increment should fail when frozen");
    
    // Test 5: Unfreeze and increment
    let unfreeze_ix = create_counter_unfreeze_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        5,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[unfreeze_ix, increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Unfreeze and increment should succeed");
    
    // Final verification
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 15);
    assert!(!counter_state.is_frozen);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-testing"><a class="header" href="#security-testing">Security Testing</a></h2>
<p><strong>tests/security.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::prelude::*;
use my_program::*;
use serial_test::serial;

mod common;
use common::*;

#[tokio::test]
#[serial]
async fn test_unauthorized_access() {
    let env = TestEnvironment::new().await;
    
    // Create counter with user1 as authority
    let counter_keypair = Keypair::new();
    let user1 = env.create_funded_account().await;
    let user2 = env.create_funded_account().await;
    
    // Initialize counter with user1 as authority
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user1.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user1],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Try to reset counter with user2 (should fail)
    let reset_ix = create_counter_reset_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user2.pubkey(), // Wrong authority
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[reset_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user2],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Reset should fail with wrong authority");
}

#[tokio::test]
#[serial]
async fn test_overflow_protection() {
    let env = TestEnvironment::new().await;
    
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Try to increment by maximum value (should fail due to overflow protection)
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        u32::MAX, // This should cause overflow
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Large increment should fail due to overflow protection");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p><strong>tests/performance.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::prelude::*;
use my_program::*;
use std::time::Instant;
use tokio::time::{sleep, Duration};

mod common;
use common::*;

#[tokio::test]
async fn test_transaction_throughput() {
    let env = TestEnvironment::new().await;
    
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Benchmark multiple increments
    let start_time = Instant::now();
    let num_operations = 100;
    
    for i in 0..num_operations {
        let increment_ix = create_counter_increment_instruction(
            &amp;env.program_id,
            &amp;counter_keypair.pubkey(),
            &amp;user.pubkey(),
            1,
        );
        
        let tx = Transaction::new_signed_with_payer(
            &amp;[increment_ix],
            Some(&amp;env.payer.pubkey()),
            &amp;[&amp;env.payer, &amp;user],
            env.client.get_latest_blockhash().await.unwrap(),
        );
        
        env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
        
        if i % 10 == 0 {
            println!("Completed {} operations", i + 1);
        }
        
        // Small delay to avoid overwhelming the network
        sleep(Duration::from_millis(10)).await;
    }
    
    let elapsed = start_time.elapsed();
    let ops_per_second = num_operations as f64 / elapsed.as_secs_f64();
    
    println!("Completed {} operations in {:?}", num_operations, elapsed);
    println!("Throughput: {:.2} operations/second", ops_per_second);
    
    // Verify final state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, num_operations);
    assert_eq!(counter_state.operation_count, num_operations as u64);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-execution"><a class="header" href="#test-execution">Test Execution</a></h2>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test

# Run specific test categories
cargo test --test integration
cargo test --test security
cargo test --test performance

# Run with logs
RUST_LOG=debug cargo test

# Run tests in sequence (for tests that modify shared state)
cargo test -- --test-threads=1
</code></pre>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<p><strong>.github/workflows/test.yml</strong></p>
<pre><code class="language-yaml">name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      bitcoind:
        image: ruimarinho/bitcoin-core:22
        options: &gt;-
          --health-cmd "bitcoin-cli -regtest getblockchaininfo"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 18443:18443
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        
    - name: Install Solana CLI
      run: |
        sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
        echo "$HOME/.local/share/solana/install/active_release/bin" &gt;&gt; $GITHUB_PATH
        
    - name: Start local validator
      run: |
        solana-test-validator --detach
        
    - name: Build program
      run: |
        cargo build-sbf
        
    - name: Run tests
      run: |
        cargo test
        
    - name: Run integration tests
      run: |
        cargo test --test integration
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-test-organization"><a class="header" href="#1-test-organization">1. Test Organization</a></h3>
<ul>
<li>Separate unit, integration, and security tests</li>
<li>Use common test utilities to reduce duplication</li>
<li>Group related tests into modules</li>
</ul>
<h3 id="2-test-data-management"><a class="header" href="#2-test-data-management">2. Test Data Management</a></h3>
<ul>
<li>Use deterministic test data when possible</li>
<li>Clean up test accounts and state</li>
<li>Use property-based testing for edge cases</li>
</ul>
<h3 id="3-error-testing"><a class="header" href="#3-error-testing">3. Error Testing</a></h3>
<ul>
<li>Test all error conditions explicitly</li>
<li>Verify correct error codes are returned</li>
<li>Test permission and access control</li>
</ul>
<h3 id="4-performance-considerations"><a class="header" href="#4-performance-considerations">4. Performance Considerations</a></h3>
<ul>
<li>Monitor transaction costs in tests</li>
<li>Test with realistic data sizes</li>
<li>Benchmark critical operations</li>
</ul>
<h3 id="5-security-focus"><a class="header" href="#5-security-focus">5. Security Focus</a></h3>
<ul>
<li>Test privilege escalation attempts</li>
<li>Verify input validation</li>
<li>Test resource exhaustion scenarios</li>
</ul>
<h2 id="debugging-tests"><a class="header" href="#debugging-tests">Debugging Tests</a></h2>
<h3 id="logging-and-diagnostics"><a class="header" href="#logging-and-diagnostics">Logging and Diagnostics</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod debug_tests {
    use super::*;
    use arch_program::msg;
    
    #[test]
    fn test_with_logging() {
        env_logger::init();
        
        // Your test code with msg! calls will now show logs
        msg!("Debug: Testing counter initialization");
        
        // ... test code ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-helpers-for-debugging"><a class="header" href="#test-helpers-for-debugging">Test Helpers for Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn debug_account_state(client: &amp;ArchClient, account: &amp;Pubkey) -&gt; CounterAccount {
    let account_data = client.get_account(account).unwrap().unwrap();
    let state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    
    println!("Account: {}", account);
    println!("Count: {}", state.count);
    println!("Authority: {}", state.authority);
    println!("Frozen: {}", state.is_frozen);
    println!("Operations: {}", state.operation_count);
    
    state
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Comprehensive testing is crucial for Arch Network program development. This guide provides:</p>
<ul>
<li><strong>Complete test setup</strong> with proper dependencies and project structure</li>
<li><strong>Multi-layer testing strategy</strong> covering unit, integration, security, and performance</li>
<li><strong>Real working examples</strong> that you can adapt for your programs</li>
<li><strong>Best practices</strong> for maintainable and effective test suites</li>
<li><strong>CI/CD integration</strong> for automated testing</li>
</ul>
<p>Remember to test early, test often, and test thoroughly. Your users depend on your programs being secure and reliable!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arch-network-development-guides"><a class="header" href="#arch-network-development-guides">Arch Network Development Guides</a></h1>
<p>This section provides comprehensive guides for building, testing, and deploying Arch Network programs. Whether you‚Äôre just starting out or building complex applications, these guides will help you develop robust and efficient programs.</p>
<h2 id="getting-started-guides"><a class="header" href="#getting-started-guides">Getting Started Guides</a></h2>
<h3 id="understanding-arch-programs-1"><a class="header" href="#understanding-arch-programs-1"><a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a></a></h3>
<p>Learn the fundamental concepts, architecture, and development patterns for Arch Network programs. This guide covers the complete foundation you need before building your first program.</p>
<p><strong>Covers:</strong> Program structure, Bitcoin integration, state management, error handling, and development best practices.</p>
<h3 id="writing-your-first-program"><a class="header" href="#writing-your-first-program"><a href="guides/./writing-your-first-program.html">Writing Your First Program</a></a></h3>
<p>A comprehensive step-by-step tutorial for creating, deploying, and testing a complete counter program with advanced features.</p>
<p><strong>Covers:</strong> Project setup, program logic, Bitcoin transactions, security patterns, and comprehensive testing.</p>
<h3 id="comprehensive-testing-guide"><a class="header" href="#comprehensive-testing-guide"><a href="guides/./testing-guide.html">Comprehensive Testing Guide</a></a></h3>
<p>Master testing strategies for Arch Network programs with unit tests, integration tests, security tests, and performance testing.</p>
<p><strong>Covers:</strong> Test environment setup, multi-layer testing, security testing, CI/CD integration, and debugging techniques.</p>
<h2 id="configuration--setup"><a class="header" href="#configuration--setup">Configuration &amp; Setup</a></h2>
<h3 id="local-validator-with-bitcoin-testnet4"><a class="header" href="#local-validator-with-bitcoin-testnet4"><a href="guides/./how-to-configure-local-validator-bitcoin-testnet4.html">Local Validator with Bitcoin Testnet4</a></a></h3>
<p>Configure your development environment to work with Bitcoin testnet4 for testing ordinals, runes, and advanced Bitcoin features.</p>
<p><strong>Covers:</strong> Testnet4 setup, validator configuration, ordinals support, runes protocol, and production considerations.</p>
<h2 id="program-examples--tutorials"><a class="header" href="#program-examples--tutorials">Program Examples &amp; Tutorials</a></h2>
<h3 id="fungible-token-program"><a class="header" href="#fungible-token-program"><a href="guides/./how-to-create-a-fungible-token.html">Fungible Token Program</a></a></h3>
<p>Build a complete fungible token implementation compatible with standard token interfaces.</p>
<p><strong>What you‚Äôll build:</strong> Token minting, transfers, allowances, and metadata management.</p>
<h3 id="oracle-program"><a class="header" href="#oracle-program"><a href="guides/./how-to-write-oracle-program.html">Oracle Program</a></a></h3>
<p>Create a price oracle program that fetches and stores external data on-chain.</p>
<p><strong>What you‚Äôll build:</strong> Price feeds, data validation, timestamp management, and trusted data sources.</p>
<h3 id="runes-swap-program"><a class="header" href="#runes-swap-program"><a href="guides/./how-to-build-runes-swap.html">Runes Swap Program</a></a></h3>
<p>Implement a decentralized exchange for trading Bitcoin runes and ordinals.</p>
<p><strong>What you‚Äôll build:</strong> AMM functionality, liquidity pools, runes integration, and swap mechanisms.</p>
<h3 id="lending-protocol"><a class="header" href="#lending-protocol"><a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a></a></h3>
<p>Build a complete DeFi lending platform with collateralized loans and interest rates.</p>
<p><strong>What you‚Äôll build:</strong> Collateral management, loan origination, interest calculations, and liquidation mechanisms.</p>
<h2 id="recommended-learning-path"><a class="header" href="#recommended-learning-path">Recommended Learning Path</a></h2>
<h3 id="for-beginners"><a class="header" href="#for-beginners">For Beginners</a></h3>
<ol>
<li><strong><a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a></strong> - Learn the fundamentals</li>
<li><strong><a href="guides/./writing-your-first-program.html">Writing Your First Program</a></strong> - Build your first complete program</li>
<li><strong><a href="guides/./testing-guide.html">Testing Guide</a></strong> - Learn to test thoroughly</li>
<li><strong><a href="guides/./how-to-create-a-fungible-token.html">Fungible Token</a></strong> - Build a practical program</li>
</ol>
<h3 id="for-intermediate-developers"><a class="header" href="#for-intermediate-developers">For Intermediate Developers</a></h3>
<ol>
<li><strong><a href="guides/./how-to-write-oracle-program.html">Oracle Program</a></strong> - External data integration</li>
<li><strong><a href="guides/./how-to-configure-local-validator-bitcoin-testnet4.html">Local Validator Setup</a></strong> - Advanced testing environments</li>
<li><strong><a href="guides/./how-to-build-runes-swap.html">Runes Swap</a></strong> - Bitcoin-native features</li>
</ol>
<h3 id="for-advanced-developers"><a class="header" href="#for-advanced-developers">For Advanced Developers</a></h3>
<ol>
<li><strong><a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a></strong> - Complex DeFi mechanics</li>
<li><strong>All testing guides</strong> - Production-ready development practices</li>
</ol>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Guide</th><th>Difficulty</th><th>Time</th><th>Key Concepts</th></tr></thead><tbody>
<tr><td>Understanding Arch Programs</td><td>Beginner</td><td>30 min</td><td>Architecture, concepts</td></tr>
<tr><td>Writing Your First Program</td><td>Beginner</td><td>2-3 hours</td><td>Complete development cycle</td></tr>
<tr><td>Testing Guide</td><td>Intermediate</td><td>1-2 hours</td><td>Testing strategies</td></tr>
<tr><td>Testnet4 Setup</td><td>Intermediate</td><td>30 min</td><td>Advanced configuration</td></tr>
<tr><td>Fungible Token</td><td>Intermediate</td><td>3-4 hours</td><td>Token standards</td></tr>
<tr><td>Oracle Program</td><td>Intermediate</td><td>2-3 hours</td><td>External data</td></tr>
<tr><td>Runes Swap</td><td>Advanced</td><td>4-6 hours</td><td>DEX mechanics</td></tr>
<tr><td>Lending Protocol</td><td>Advanced</td><td>6-8 hours</td><td>DeFi protocols</td></tr>
</tbody></table>
</div>
<h2 id="development-tips"><a class="header" href="#development-tips">Development Tips</a></h2>
<h3 id="before-you-start"><a class="header" href="#before-you-start">Before You Start</a></h3>
<ul>
<li><strong>Set up your environment</strong> following the <a href="guides/../getting-started/quick-start.html">Quick Start Guide</a></li>
<li><strong>Understand Bitcoin basics</strong> if you‚Äôre new to Bitcoin development</li>
<li><strong>Review Rust fundamentals</strong> if you‚Äôre not familiar with Rust</li>
</ul>
<h3 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h3>
<ul>
<li><strong>Start simple</strong> - Begin with basic programs before building complex systems</li>
<li><strong>Test thoroughly</strong> - Use the comprehensive testing strategies from our guides</li>
<li><strong>Follow security patterns</strong> - Always validate inputs and handle errors gracefully</li>
<li><strong>Document your code</strong> - Future you (and your team) will thank you</li>
</ul>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<ul>
<li><strong>Join our <a href="https://discord.gg/archnetwork">Discord</a></strong> for real-time support</li>
<li><strong>Check the <a href="guides/../rpc/rpc.html">API Reference</a></strong> for detailed documentation</li>
<li><strong>Review <a href="guides/../concepts/architecture.html">Core Concepts</a></strong> for architectural guidance</li>
<li><strong>File issues</strong> on <a href="https://github.com/Arch-Network/arch-node/issues">GitHub</a> for bugs</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Found an issue or want to improve these guides? We welcome contributions!</p>
<ul>
<li><strong>Report bugs</strong> or unclear instructions</li>
<li><strong>Suggest improvements</strong> to existing guides</li>
<li><strong>Propose new guides</strong> for topics we haven‚Äôt covered</li>
<li><strong>Share your programs</strong> as examples for the community</li>
</ul>
<h2 id="whats-next"><a class="header" href="#whats-next">What‚Äôs Next?</a></h2>
<p>Choose your path based on your experience level and goals:</p>
<ul>
<li><strong>New to Arch?</strong> Start with <a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a></li>
<li><strong>Ready to code?</strong> Jump into <a href="guides/./writing-your-first-program.html">Writing Your First Program</a></li>
<li><strong>Building tokens?</strong> Check out the <a href="guides/./how-to-create-a-fungible-token.html">Fungible Token</a> guide</li>
<li><strong>Interested in DeFi?</strong> Try the <a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a> guide</li>
</ul>
<p>Happy building! üöÄ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-apl-tokens-on-arch-network"><a class="header" href="#using-apl-tokens-on-arch-network">Using APL Tokens on Arch Network</a></h1>
<p>This guide shows you how to work with fungible tokens on Arch Network using the built-in <strong>APL (Arch Program Library) Token Program</strong>. APL tokens are based on Solana‚Äôs SPL token standard and provide a robust foundation for creating and managing tokens on Arch Network.</p>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You‚Äôll Learn</a></h2>
<p>By the end of this guide, you‚Äôll understand how to:</p>
<ul>
<li><strong>Create token mints</strong> using the APL token program</li>
<li><strong>Initialize token accounts</strong> for holding tokens</li>
<li><strong>Mint tokens</strong> to accounts</li>
<li><strong>Transfer tokens</strong> between accounts</li>
<li><strong>Approve delegations</strong> for spending tokens</li>
<li><strong>Burn tokens</strong> and manage token lifecycle</li>
</ul>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The APL Token Program is Arch Network‚Äôs native token standard, providing:</p>
<ul>
<li><strong>SPL Token Compatibility</strong>: Based on Solana‚Äôs proven token standard</li>
<li><strong>Bitcoin Integration</strong>: All operations are recorded on Bitcoin</li>
<li><strong>Comprehensive Features</strong>: Minting, transferring, burning, delegation, freezing</li>
<li><strong>Multisig Support</strong>: Multiple signature authorities for enhanced security</li>
</ul>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li><strong>Rust 1.70+</strong> and Cargo installed (<a href="https://rustup.rs/">Install Rust</a>)</li>
<li><strong>Solana CLI 2.0+</strong> - <a href="https://docs.solana.com/cli/install-solana-cli-tools">Install Guide</a></li>
<li><strong>Arch Network CLI</strong> - <a href="https://github.com/Arch-Network/arch-node/releases/latest">Download Latest</a></li>
<li><strong>Running validator</strong> (see <a href="guides/./how-to-configure-local-validator-bitcoin-testnet4.html">Validator Setup Guide</a>)</li>
<li><strong>Basic familiarity</strong> with Arch Network program development</li>
</ul>
<h2 id="apl-token-program-id"><a class="header" href="#apl-token-program-id">APL Token Program ID</a></h2>
<p>The APL Token Program has a fixed program ID:</p>
<pre><code class="language-text">apl-token00000000000000000000000
</code></pre>
<h2 id="step-1-project-setup-1"><a class="header" href="#step-1-project-setup-1">Step 1: Project Setup</a></h2>
<h3 id="11-create-project-structure-1"><a class="header" href="#11-create-project-structure-1">1.1 Create Project Structure</a></h3>
<pre><code class="language-bash"># Create project directory
mkdir arch-token-example
cd arch-token-example

# Initialize Rust project
cargo init --bin
</code></pre>
<h3 id="12-configure-dependencies-1"><a class="header" href="#12-configure-dependencies-1">1.2 Configure Dependencies</a></h3>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "arch_token_example"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_sdk = "0.5.4"
arch_program = "0.5.4"
arch_test_sdk = "0.5.4"
apl-token = { git = "https://github.com/Arch-Network/arch-network", branch = "dev", features = ["no-entrypoint"] }
apl-associated-token-account = { git = "https://github.com/Arch-Network/arch-network", branch = "dev", features = ["no-entrypoint"] }
borsh = { version = "1.5.1", features = ["derive"] }
bitcoincore-rpc = "0.18.0"
bitcoin = { version = "0.32.3", features = ["serde", "rand"] }
hex = "0.4.3"
log = "0.4"
env_logger = "0.10"

[dev-dependencies]
serial_test = "3.1.1"
</code></pre>
<h2 id="step-2-basic-token-operations"><a class="header" href="#step-2-basic-token-operations">Step 2: Basic Token Operations</a></h2>
<h3 id="21-initialize-a-token-mint"><a class="header" href="#21-initialize-a-token-mint">2.1 Initialize a Token Mint</a></h3>
<p>First, let‚Äôs create a new token mint:</p>
<p><strong>src/main.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use apl_token::state::Mint;
use arch_program::{program_pack::Pack, sanitized::ArchMessage};
use arch_sdk::{build_and_sign_transaction, generate_new_keypair, ArchRpcClient, Status};
use arch_test_sdk::{
    constants::{BITCOIN_NETWORK, NODE1_ADDRESS},
    helper::{create_and_fund_account_with_faucet, send_transactions_and_wait},
};

fn main() {
    env_logger::init();
    
    let client = ArchRpcClient::new(NODE1_ADDRESS);

    // Create authority keypair (this will be the mint authority)
    let (authority_keypair, authority_pubkey, _) = generate_new_keypair(BITCOIN_NETWORK);
    create_and_fund_account_with_faucet(&amp;authority_keypair, BITCOIN_NETWORK);

    // Create mint account
    let (token_mint_keypair, token_mint_pubkey, _) = generate_new_keypair(BITCOIN_NETWORK);

    // Create the mint account
    let create_account_instruction = arch_program::system_instruction::create_account(
        &amp;authority_pubkey,
        &amp;token_mint_pubkey,
        arch_program::account::MIN_ACCOUNT_LAMPORTS,
        Mint::LEN as u64,
        &amp;apl_token::id(),
    );

    // Initialize the mint
    let initialize_mint_instruction = apl_token::instruction::initialize_mint(
        &amp;apl_token::id(),
        &amp;token_mint_pubkey,
        &amp;authority_pubkey,
        None, // No freeze authority
        9,    // 9 decimals (like USDC)
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[create_account_instruction, initialize_mint_instruction],
            Some(authority_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![authority_keypair, token_mint_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);

    println!("Token mint created: {}", token_mint_pubkey);
}</code></pre></pre>
<h3 id="22-create-token-accounts"><a class="header" href="#22-create-token-accounts">2.2 Create Token Accounts</a></h3>
<p>Token accounts hold tokens for specific owners:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize_token_account(
    client: &amp;ArchRpcClient,
    token_mint_pubkey: arch_program::pubkey::Pubkey,
    owner_keypair: bitcoin::key::Keypair,
) -&gt; (bitcoin::key::Keypair, arch_program::pubkey::Pubkey) {
    let owner_pubkey = arch_program::pubkey::Pubkey::from_slice(
        &amp;owner_keypair.x_only_public_key().0.serialize()
    );

    let (token_account_keypair, token_account_pubkey, _) = generate_new_keypair(BITCOIN_NETWORK);

    // Create the account
    let create_account_instruction = arch_program::system_instruction::create_account(
        &amp;owner_pubkey,
        &amp;token_account_pubkey,
        arch_program::account::MIN_ACCOUNT_LAMPORTS,
        apl_token::state::Account::LEN as u64,
        &amp;apl_token::id(),
    );

    // Initialize the token account
    let initialize_account_instruction = apl_token::instruction::initialize_account(
        &amp;apl_token::id(),
        &amp;token_account_pubkey,
        &amp;token_mint_pubkey,
        &amp;owner_pubkey,
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[create_account_instruction, initialize_account_instruction],
            Some(owner_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![owner_keypair, token_account_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);

    (token_account_keypair, token_account_pubkey)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="23-mint-tokens"><a class="header" href="#23-mint-tokens">2.3 Mint Tokens</a></h3>
<p>Mint new tokens to a token account:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mint_tokens(
    client: &amp;ArchRpcClient,
    mint_pubkey: &amp;arch_program::pubkey::Pubkey,
    account_pubkey: &amp;arch_program::pubkey::Pubkey,
    authority_pubkey: &amp;arch_program::pubkey::Pubkey,
    authority_keypair: bitcoin::key::Keypair,
    amount: u64,
) {
    let mint_instruction = apl_token::instruction::mint_to(
        &amp;apl_token::id(),
        mint_pubkey,
        account_pubkey,
        authority_pubkey,
        &amp;[], // No additional signers for single authority
        amount,
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[mint_instruction],
            Some(*authority_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![authority_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);
    
    println!("Minted {} tokens", amount);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="24-transfer-tokens"><a class="header" href="#24-transfer-tokens">2.4 Transfer Tokens</a></h3>
<p>Transfer tokens between accounts:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer_tokens(
    client: &amp;ArchRpcClient,
    source_account: &amp;arch_program::pubkey::Pubkey,
    destination_account: &amp;arch_program::pubkey::Pubkey,
    owner_pubkey: &amp;arch_program::pubkey::Pubkey,
    owner_keypair: bitcoin::key::Keypair,
    amount: u64,
) {
    let transfer_instruction = apl_token::instruction::transfer(
        &amp;apl_token::id(),
        source_account,
        destination_account,
        owner_pubkey,
        &amp;[owner_pubkey], // Owner must sign
        amount,
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[transfer_instruction],
            Some(*owner_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![owner_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);
    
    println!("Transferred {} tokens", amount);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-3-advanced-token-operations"><a class="header" href="#step-3-advanced-token-operations">Step 3: Advanced Token Operations</a></h2>
<h3 id="31-approve-delegations"><a class="header" href="#31-approve-delegations">3.1 Approve Delegations</a></h3>
<p>Allow another account to spend tokens on your behalf:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn approve_delegate(
    client: &amp;ArchRpcClient,
    source_account: &amp;arch_program::pubkey::Pubkey,
    delegate_account: &amp;arch_program::pubkey::Pubkey,
    owner_pubkey: &amp;arch_program::pubkey::Pubkey,
    owner_keypair: bitcoin::key::Keypair,
    amount: u64,
) {
    let approve_instruction = apl_token::instruction::approve(
        &amp;apl_token::id(),
        source_account,
        delegate_account,
        owner_pubkey,
        &amp;[owner_pubkey],
        amount,
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[approve_instruction],
            Some(*owner_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![owner_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);
    
    println!("Approved {} tokens for delegation", amount);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="32-burn-tokens"><a class="header" href="#32-burn-tokens">3.2 Burn Tokens</a></h3>
<p>Remove tokens from circulation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn burn_tokens(
    client: &amp;ArchRpcClient,
    account_pubkey: &amp;arch_program::pubkey::Pubkey,
    mint_pubkey: &amp;arch_program::pubkey::Pubkey,
    owner_pubkey: &amp;arch_program::pubkey::Pubkey,
    owner_keypair: bitcoin::key::Keypair,
    amount: u64,
) {
    let burn_instruction = apl_token::instruction::burn(
        &amp;apl_token::id(),
        account_pubkey,
        mint_pubkey,
        owner_pubkey,
        &amp;[owner_pubkey],
        amount,
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[burn_instruction],
            Some(*owner_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![owner_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);
    
    println!("Burned {} tokens", amount);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="33-freeze-and-thaw-accounts"><a class="header" href="#33-freeze-and-thaw-accounts">3.3 Freeze and Thaw Accounts</a></h3>
<p>If you set a freeze authority when creating the mint, you can freeze/thaw accounts:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn freeze_account(
    client: &amp;ArchRpcClient,
    account_pubkey: &amp;arch_program::pubkey::Pubkey,
    mint_pubkey: &amp;arch_program::pubkey::Pubkey,
    freeze_authority_pubkey: &amp;arch_program::pubkey::Pubkey,
    freeze_authority_keypair: bitcoin::key::Keypair,
) {
    let freeze_instruction = apl_token::instruction::freeze_account(
        &amp;apl_token::id(),
        account_pubkey,
        mint_pubkey,
        freeze_authority_pubkey,
        &amp;[freeze_authority_pubkey],
    ).unwrap();

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[freeze_instruction],
            Some(*freeze_authority_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![freeze_authority_keypair],
        BITCOIN_NETWORK,
    );

    let processed_transactions = send_transactions_and_wait(vec![transaction]);
    assert_eq!(processed_transactions[0].status, Status::Processed);
    
    println!("Account frozen");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-complete-example"><a class="header" href="#step-4-complete-example">Step 4: Complete Example</a></h2>
<p>Here‚Äôs a complete example that demonstrates the full token lifecycle:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use apl_token::state::{Mint, Account, AccountState};
use arch_program::{program_pack::Pack, sanitized::ArchMessage};
use arch_sdk::{build_and_sign_transaction, generate_new_keypair, ArchRpcClient, Status};
use arch_test_sdk::{
    constants::{BITCOIN_NETWORK, NODE1_ADDRESS},
    helper::{create_and_fund_account_with_faucet, read_account_info, send_transactions_and_wait},
};

fn main() {
    env_logger::init();
    
    let client = ArchRpcClient::new(NODE1_ADDRESS);

    // 1. Create authority and mint
    let (authority_keypair, authority_pubkey, _) = generate_new_keypair(BITCOIN_NETWORK);
    create_and_fund_account_with_faucet(&amp;authority_keypair, BITCOIN_NETWORK);

    let (_, token_mint_pubkey) = create_token_mint(&amp;client, authority_pubkey, authority_keypair);
    
    // 2. Create token accounts for two users
    let (user1_keypair, user1_pubkey, _) = generate_new_keypair(BITCOIN_NETWORK);
    create_and_fund_account_with_faucet(&amp;user1_keypair, BITCOIN_NETWORK);
    
    let (user2_keypair, user2_pubkey, _) = generate_new_keypair(BITCOIN_NETWORK);
    create_and_fund_account_with_faucet(&amp;user2_keypair, BITCOIN_NETWORK);

    let (_, user1_token_account) = create_token_account(&amp;client, token_mint_pubkey, user1_keypair);
    let (_, user2_token_account) = create_token_account(&amp;client, token_mint_pubkey, user2_keypair);

    // 3. Mint tokens to user1
    mint_tokens(&amp;client, &amp;token_mint_pubkey, &amp;user1_token_account, &amp;authority_pubkey, authority_keypair, 1000);

    // 4. Check balance
    let account_info = read_account_info(user1_token_account);
    let account_data = Account::unpack(&amp;account_info.data).unwrap();
    println!("User1 balance: {}", account_data.amount);

    // 5. Transfer tokens from user1 to user2
    transfer_tokens(&amp;client, &amp;user1_token_account, &amp;user2_token_account, &amp;user1_pubkey, user1_keypair, 500);

    // 6. Check both balances
    let user1_info = read_account_info(user1_token_account);
    let user1_data = Account::unpack(&amp;user1_info.data).unwrap();
    println!("User1 balance after transfer: {}", user1_data.amount);

    let user2_info = read_account_info(user2_token_account);
    let user2_data = Account::unpack(&amp;user2_info.data).unwrap();
    println!("User2 balance after transfer: {}", user2_data.amount);

    println!("Token operations completed successfully!");
}</code></pre></pre>
<h2 id="running-the-example"><a class="header" href="#running-the-example">Running the Example</a></h2>
<pre><code class="language-bash"># First, ensure your validator is running
arch-cli orchestrate validator-status

# Then run the example code
cargo run
</code></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="account-types"><a class="header" href="#account-types">Account Types</a></h3>
<ol>
<li><strong>Mint Account</strong>: Stores token metadata and authorities</li>
<li><strong>Token Account</strong>: Holds token balances for specific owners</li>
<li><strong>Multisig Account</strong>: Enables shared authority over operations</li>
</ol>
<h3 id="authority-types"><a class="header" href="#authority-types">Authority Types</a></h3>
<ul>
<li><strong>Mint Authority</strong>: Can mint new tokens</li>
<li><strong>Freeze Authority</strong>: Can freeze/thaw token accounts</li>
<li><strong>Owner</strong>: Controls token account operations</li>
<li><strong>Delegate</strong>: Can spend approved amounts on behalf of owner</li>
</ul>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<p>All token operations are recorded on Bitcoin, providing:</p>
<ul>
<li><strong>Immutable History</strong>: All transfers are permanently recorded</li>
<li><strong>Transparency</strong>: Public verification of all operations</li>
<li><strong>Security</strong>: Bitcoin‚Äôs security model protects token state</li>
</ul>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Create comprehensive tests for your token operations:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;

    #[test]
    #[serial]
    fn test_complete_token_lifecycle() {
        // Test mint creation, token accounts, minting, transfers, etc.
        // See examples/token/src/lib.rs for comprehensive test examples
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>Explore <strong>Associated Token Accounts</strong> for simplified account management</li>
<li>Implement <strong>Multisig authorities</strong> for enhanced security</li>
<li>Study the complete examples in <code>examples/token/src/lib.rs</code></li>
<li>Review the <strong>APL Token Program documentation</strong> for advanced features</li>
</ul>
<p>The APL Token Program provides a robust, battle-tested foundation for tokenization on Arch Network, leveraging the security and transparency of Bitcoin while maintaining compatibility with proven SPL token patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-an-oracle-program"><a class="header" href="#how-to-write-an-oracle-program">How to write an oracle program</a></h1>
<p>This guide walks through the innerworkings of an oracle program as well as details how oracle data can be utilized by other programs on Arch Network.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#description">Description</a></li>
<li><a href="guides/how-to-write-oracle-program.html#flow">Flow</a></li>
<li><a href="guides/how-to-write-oracle-program.html#logic">Logic</a></li>
<li><a href="guides/how-to-write-oracle-program.html#implementation">Implementation</a></li>
</ul>
<hr />
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<p>Two important aspects of understanding how this oracle example is implemented within Arch:</p>
<ol>
<li>The oracle is a program that updates an account which holds the data</li>
<li>No cross-program invocation occurs since only the account is updated and read from versus this being another program that gets interacted with from another program</li>
</ol>
<p>The source code can be found within the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<ul>
<li>Project deploys oracle program</li>
<li>Project creates state account that the oracle program will control in order to write state to it</li>
<li>Projects submit data to the oracle state account by submitting instructions to the oracle program</li>
<li>Programs include oracle state account alongside their program instructions in order to use this referenced data stored in the oracle state account within their program</li>
<li>Projects submit instructions to oracle program periodically to update oracle state account with fresh data</li>
</ul>
<h3 id="logic"><a class="header" href="#logic">Logic</a></h3>
<p>If you haven‚Äôt already read <a href="guides/./writing-your-first-program.html">How to write an Arch program</a>, we recommend starting there to get a basic understanding of the program anatomy before going further.</p>
<p>We‚Äôll look closely at the logic block contained within the <code>update_data</code> <a href="guides/how-to-write-oracle-program.html#logic">handler</a>.</p>
<pre><code class="language-rust ignore">pub fn update_data(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let oracle_account = next_account_info(account_iter)?;

    assert!(oracle_account.is_signer);
    assert_eq!(instruction_data.len(), 8);

    ...
}</code></pre>
<p>First, we‚Äôll iterate over the accounts that get passed into the function, which includes the newly created state account that will be responsible for managing the oracle‚Äôs data.</p>
<p>We then assert that the oracle state account has the appropriate authority to be written to and update what it stores within its data field. Additionally, we assert that the data we wish to update the account with is at least a certain number of bytes.</p>
<pre><code class="language-rust ignore">let data_len = oracle_account.data.try_borrow().unwrap().len();
if instruction_data.len() &gt; data_len {
    oracle_account.realloc(instruction_data.len(), true)?;
}</code></pre>
<p>Next, we calculate the length of the new data that we are looking to store in the account and reallocate memory to the account if the new data is larger than the data currently existing within the account. This step is important for ensuring that there is no remaining, stale data stored in the account before adding new data to it.</p>
<pre><code class="language-rust ignore">oracle_account
    .data
    .try_borrow_mut()
    .unwrap()
    .copy_from_slice(instruction_data);

msg!("updated");

Ok(())</code></pre>
<p>Lastly, we store the new data that is passed into the program via the instruction to the state account for management, thus marking the end of the oracle update process.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Let‚Äôs look at an example implementation of this oracle program. This includes:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#create-oracle-project">Create oracle project</a></li>
<li><a href="guides/how-to-write-oracle-program.html#deploy-program">Deploy program</a></li>
<li><a href="guides/how-to-write-oracle-program.html#create-a-state-account">Create a state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#update-the-state-account">Update the state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#read-from-the-state-account">Read from the state account</a></li>
</ul>
<h4 id="create-oracle-project"><a class="header" href="#create-oracle-project">Create oracle project</a></h4>
<p>First, we‚Äôll need to create a new project to hold our oracle logic.</p>
<pre><code class="language-bash"># Create a new directory for your oracle project
mkdir oracle
cd oracle

# Initialize a Rust project
cargo init --lib
</code></pre>
<blockquote>
<p>Note: The new CLI does not currently have a project creation command. We‚Äôll manually set up our project structure.</p>
</blockquote>
<p>You‚Äôll need to create and edit the following files:</p>
<ul>
<li><code>Cargo.toml</code> - Add dependencies for your oracle program</li>
<li><code>src/lib.rs</code> - Implement the oracle program logic</li>
</ul>
<p>Example program files can be found in the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h4 id="deploy-program"><a class="header" href="#deploy-program">Deploy program</a></h4>
<p>After the project is created, the program is written and the <code>Cargo.toml</code> is set with the proper dependencies, we can deploy the program.</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program
arch-cli deploy target/deploy/oracle.so
</code></pre>
<p>During the deployment, a new account is created for the deployed program logic and set to be executable, marking it as a <a href="guides/../program/program.html">Program</a> rather than a data <a href="guides/../program/account.html">Account</a>.</p>
<h4 id="create-state-account"><a class="header" href="#create-state-account">Create state account</a></h4>
<p>From the deployment output, you should obtain the <code>program_id</code>. We can use this <code>program_id</code> to create a state account that is owned and updated by the program.</p>
<p>The oracle state account can then be read from by any program in order to retrieve the associated oracle data.</p>
<pre><code class="language-bash"># The new CLI may not have direct account creation functionality
# You'll need to use an RPC call to create the account

# For example, using curl:
curl -X POST http://localhost:9002 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"sendTransaction",
    "params":[{
      "signature":"your_signature",
      "message":{
        "accountKeys":["your_pubkey", "your_program_id"],
        "instructions":[{
          "programId":"system_program_id",
          "accounts":["your_pubkey", "new_account_pubkey"],
          "data":"encoded_create_account_data"
        }]
      }
    }]
  }'
</code></pre>
<blockquote>
<p>Note: The above is a simplified example. You‚Äôll need to properly construct, sign, and encode your transaction according to the Arch Network protocol.</p>
</blockquote>
<p>In this step, the account is created and ownership is transferred to the program. This allows the program to update the account‚Äôs data field which holds state for the program.</p>
<h4 id="update-the-state-account"><a class="header" href="#update-the-state-account">Update the state account</a></h4>
<p>Now that we have created an account and the oracle program has authority to update it, we now want to update the data that the account holds.</p>
<p>In order to update the data stored in the account, we simply need to make a transaction that includes the data that we wish to update the oracle state account to hold, and submit this within the context of an instruction.</p>
<p>As an example, below we have a sample rust program that we‚Äôll use to fetch the Bitcoin fees from the <a href="https://mempool.space">mempool.space</a> API and store this fee data in our oracle state account that was created during deployment.</p>
<blockquote>
<p>Note: The below is a rust program and is not an Arch program.</p>
<p>The call to update the oracle state account can be written in any programming language as it is simply an RPC call. For sake of continuity, we‚Äôre using rust along with methods from both the <code>program</code> and <code>sdk</code> crates.</p>
</blockquote>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client};

let mut old_feerate = 0;

let body: Value = reqwest::blocking::get("https://mempool.space/api/v1/fees/recommended").unwrap().json().unwrap();
let feerate = body.get("fastestFee").unwrap().as_u64().unwrap();

if old_feerate != feerate {
    let (txid, instruction_hash) = sign_and_send_instruction(
        Instruction {
            program_id: program_pubkey.clone(),
            accounts: vec![AccountMeta {
                pubkey: caller_pubkey.clone(),
                is_signer: true,
                is_writable: true
            }],
            data: feerate.to_le_bytes().to_vec()
        },
        vec![caller_keypair],
    ).expect("signing and sending a transaction should not fail");

    let processed_tx = get_processed_transaction(NODE1_ADDRESS, txid.clone()).expect("get processed transaction should not fail");
    println!("processed_tx {:?}", processed_tx);

    println!("{:?}", read_account_info(NODE1_ADDRESS, caller_pubkey.clone()));

    old_feerate = feerate;
}</code></pre>
<h4 id="read-from-the-state-account"><a class="header" href="#read-from-the-state-account">Read from the state account</a></h4>
<p>Below is an example of a different program (we‚Äôll call this app-program) that would like to access the oracle data.</p>
<p>Essentially, what happens here is that when we pass an instruction into our app-program, we must also include the oracle state account alongside any other account that we need for the app-program. In this way, the oracle state account is now in-scope and its data can be read from.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-first-bitcoin-runes-swap-application"><a class="header" href="#building-your-first-bitcoin-runes-swap-application">Building Your First Bitcoin Runes Swap Application</a></h1>
<p>Welcome to this hands-on tutorial! Today, we‚Äôre going to build a decentralized application that enables users to swap Bitcoin Runes tokens on the Arch Network. By the end of this lesson, you‚Äôll understand how to create a secure, trustless swap mechanism for Runes tokens.</p>
<h2 id="class-prerequisites"><a class="header" href="#class-prerequisites">Class Prerequisites</a></h2>
<p>Before we dive in, please ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch Network CLI installed</li>
</ul>
<h2 id="lesson-1-understanding-the-basics"><a class="header" href="#lesson-1-understanding-the-basics">Lesson 1: Understanding the Basics</a></h2>
<h3 id="what-are-runes"><a class="header" href="#what-are-runes">What are Runes?</a></h3>
<p>Before we write any code, let‚Äôs understand what we‚Äôre working with. Runes is a Bitcoin protocol for fungible tokens, similar to how BRC-20 works. Each Rune token has a unique identifier and can be transferred between Bitcoin addresses.</p>
<h3 id="what-are-we-building"><a class="header" href="#what-are-we-building">What are we building?</a></h3>
<p>We‚Äôre creating a swap program that will:</p>
<ol>
<li>Allow users to create swap offers (‚ÄúI want to trade X amount of Rune A for Y amount of Rune B‚Äù)</li>
<li>Enable other users to accept these offers</li>
<li>Let users cancel their offers if they change their mind</li>
<li>Ensure all swaps are atomic (they either complete fully or not at all)</li>
</ol>
<h2 id="lesson-2-setting-up-our-project"><a class="header" href="#lesson-2-setting-up-our-project">Lesson 2: Setting Up Our Project</a></h2>
<p>Let‚Äôs start by creating our project structure. Open your terminal and run:</p>
<pre><code class="language-bash"># Create a new directory for your project
mkdir runes-swap
cd runes-swap

# Initialize a new Rust project
cargo init --lib

# Your project structure should look like this:
# runes-swap/
# ‚îú‚îÄ‚îÄ Cargo.toml
# ‚îú‚îÄ‚îÄ src/
# ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
<h2 id="lesson-3-defining-our-data-structures"><a class="header" href="#lesson-3-defining-our-data-structures">Lesson 3: Defining Our Data Structures</a></h2>
<p>Now, let‚Äôs define the building blocks of our swap program. In programming, it‚Äôs crucial to plan our data structures before implementing functionality.</p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    entrypoint,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    utxo::UtxoMeta,
    borsh::{BorshDeserialize, BorshSerialize},
};

/// This structure represents a single swap offer in our system
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct SwapOffer {
    // Unique identifier for the offer
    pub offer_id: u64,
    // The public key of the person creating the offer
    pub maker: Pubkey,
    // The Rune ID they want to give
    pub rune_id_give: String,
    // Amount of Runes they want to give
    pub amount_give: u64,
    // The Rune ID they want to receive
    pub rune_id_want: String,
    // Amount of Runes they want to receive
    pub amount_want: u64,
    // When this offer expires (in block height)
    pub expiry: u64,
    // Current status of the offer
    pub status: OfferStatus,
}</code></pre>
<p>Let‚Äôs break down why we chose each field:</p>
<ul>
<li><code>offer_id</code>: Every offer needs a unique identifier so we can reference it later</li>
<li><code>maker</code>: We store who created the offer to ensure only they can cancel it</li>
<li><code>rune_id_give/want</code>: These identify which Runes are being swapped</li>
<li><code>amount_give/want</code>: The quantities of each Rune in the swap</li>
<li><code>expiry</code>: Offers shouldn‚Äôt live forever, so we add an expiration</li>
</ul>
<h2 id="lesson-4-implementing-the-swap-logic"><a class="header" href="#lesson-4-implementing-the-swap-logic">Lesson 4: Implementing the Swap Logic</a></h2>
<p>Now that we understand our data structures, let‚Äôs implement the core swap functionality. We‚Äôll start with creating an offer:</p>
<pre><code class="language-rust ignore">fn process_create_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all the accounts we need
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    // Step 2: Verify the maker has the Runes they want to swap
    if let SwapInstruction::CreateOffer { 
        rune_id_give, 
        amount_give,
        rune_id_want,
        amount_want,
        expiry 
    } = instruction {
        // Security check: Ensure the maker owns enough Runes
        verify_rune_ownership(maker, &amp;rune_id_give, amount_give)?;
        
        // Step 3: Create and store the offer
        let offer = SwapOffer {
            offer_id: get_next_offer_id(offer_account)?,
            maker: *maker.key,
            rune_id_give,
            amount_give,
            rune_id_want,
            amount_want,
            expiry,
            status: OfferStatus::Active,
        };
        
        store_offer(offer_account, &amp;offer)?;
    }

    Ok(())
}</code></pre>
<h3 id="understanding-the-create-offer-process"><a class="header" href="#understanding-the-create-offer-process">Understanding the Create Offer Process</a></h3>
<ol>
<li>First, we extract the accounts passed to our program</li>
<li>We verify that the maker actually owns the Runes they want to trade</li>
<li>We create a new <code>SwapOffer</code> with an Active status</li>
<li>Finally, we store this offer in the program‚Äôs state</li>
</ol>
<h2 id="lesson-5-testing-our-program"><a class="header" href="#lesson-5-testing-our-program">Lesson 5: Testing Our Program</a></h2>
<p>Testing is crucial in blockchain development because once deployed, your program can‚Äôt be easily changed. Let‚Äôs write comprehensive tests for our swap program.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::test_utils::{create_test_account, create_test_pubkey};

    /// Helper function to create a test offer
    fn create_test_offer() -&gt; SwapOffer {
        SwapOffer {
            offer_id: 1,
            maker: create_test_pubkey(),
            rune_id_give: "RUNE1".to_string(),
            amount_give: 100,
            rune_id_want: "RUNE2".to_string(),
            amount_want: 200,
            expiry: 1000,
            status: OfferStatus::Active,
        }
    }

    #[test]
    fn test_create_offer() {
        // Arrange: Set up our test accounts
        let maker = create_test_account();
        let offer_account = create_test_account();
        
        // Act: Create an offer
        let result = process_create_offer(
            &amp;[maker.clone(), offer_account.clone()],
            SwapInstruction::CreateOffer {
                rune_id_give: "RUNE1".to_string(),
                amount_give: 100,
                rune_id_want: "RUNE2".to_string(),
                amount_want: 200,
                expiry: 1000,
            },
        );
        
        // Assert: Check the result
        assert!(result.is_ok());
        // Add more assertions here to verify the offer was stored correctly
    }
}</code></pre>
<h3 id="understanding-our-test-structure"><a class="header" href="#understanding-our-test-structure">Understanding Our Test Structure</a></h3>
<p>We follow the ‚ÄúArrange-Act-Assert‚Äù pattern:</p>
<ol>
<li>Arrange: Set up the test environment and data</li>
<li>Act: Execute the functionality we‚Äôre testing</li>
<li>Assert: Verify the results match our expectations</li>
</ol>
<h2 id="lesson-6-implementing-offer-acceptance"><a class="header" href="#lesson-6-implementing-offer-acceptance">Lesson 6: Implementing Offer Acceptance</a></h2>
<p>Now let‚Äôs implement the logic for accepting an offer. This is where atomic swaps become crucial:</p>
<pre><code class="language-rust ignore">fn process_accept_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all required accounts
    let account_iter = &amp;mut accounts.iter();
    let taker = next_account_info(account_iter)?;
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::AcceptOffer { offer_id } = instruction {
        // Step 2: Load and validate the offer
        let mut offer = load_offer(offer_account)?;
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Step 3: Verify the taker has the required Runes
        verify_rune_ownership(taker, &amp;offer.rune_id_want, offer.amount_want)?;
        
        // Step 4: Perform the atomic swap
        // Transfer Runes from maker to taker
        transfer_runes(
            maker,
            taker,
            &amp;offer.rune_id_give,
            offer.amount_give,
        )?;
        
        // Transfer Runes from taker to maker
        transfer_runes(
            taker,
            maker,
            &amp;offer.rune_id_want,
            offer.amount_want,
        )?;
        
        // Step 5: Update offer status
        offer.status = OfferStatus::Completed;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h3 id="understanding-atomic-swaps"><a class="header" href="#understanding-atomic-swaps">Understanding Atomic Swaps</a></h3>
<p>An atomic swap ensures that either:</p>
<ul>
<li>Both transfers complete successfully, or</li>
<li>Neither transfer happens at all</li>
</ul>
<p>This is crucial for preventing partial swaps where one party could lose their tokens.</p>
<h2 id="lesson-7-implementing-offer-cancellation"><a class="header" href="#lesson-7-implementing-offer-cancellation">Lesson 7: Implementing Offer Cancellation</a></h2>
<p>Finally, let‚Äôs implement the ability to cancel offers:</p>
<pre><code class="language-rust ignore">fn process_cancel_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::CancelOffer { offer_id } = instruction {
        // Load the offer
        let mut offer = load_offer(offer_account)?;
        
        // Security checks
        require!(
            offer.maker == *maker.key,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Update offer status
        offer.status = OfferStatus::Cancelled;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h2 id="deploying-your-runes-swap-program"><a class="header" href="#deploying-your-runes-swap-program">Deploying Your Runes Swap Program</a></h2>
<p>After you‚Äôve written and tested your program, it‚Äôs time to deploy it to the Arch Network:</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program to the Arch Network
arch-cli deploy target/deploy/runes_swap.so
</code></pre>
<p>Make sure you have a validator node running before deployment:</p>
<pre><code class="language-bash"># Start a local validator
arch-cli validator-start
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Congratulations! You‚Äôve built a complete Runes swap program. This program demonstrates several important blockchain concepts:</p>
<ol>
<li>Atomic transactions</li>
<li>State management</li>
<li>Security checks</li>
<li>Program testing</li>
</ol>
<p>Remember to always:</p>
<ul>
<li>Test thoroughly before deployment</li>
<li>Consider edge cases</li>
<li>Implement proper error handling</li>
<li>Add detailed documentation</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>To further improve your program, consider adding:</p>
<ol>
<li>A UI for interacting with the swap program</li>
<li>More sophisticated offer matching</li>
<li>Order book functionality</li>
<li>Price oracle integration</li>
<li>Additional security features</li>
</ol>
<p>Questions? Feel free to ask in the comments below!</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="runes-transfer-implementation"><a class="header" href="#runes-transfer-implementation">Runes Transfer Implementation</a></h3>
<p>Let‚Äôs look at the implementation of the <code>transfer_runes</code> function used in our swap program:</p>
<pre><code class="language-rust ignore">/// Transfers Runes tokens from one account to another
/// 
/// # Arguments
/// * `from` - The account sending the Runes
/// * `to` - The account receiving the Runes
/// * `rune_id` - The identifier of the Rune to transfer
/// * `amount` - The amount of Runes to transfer
/// 
/// # Returns
/// * `Result&lt;(), ProgramError&gt;` - Success or error code
fn transfer_runes(
    from: &amp;AccountInfo,
    to: &amp;AccountInfo,
    rune_id: &amp;str,
    amount: u64,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get Bitcoin script pubkey for both accounts
    let from_script = get_account_script_pubkey(from.key)?;
    let to_script = get_account_script_pubkey(to.key)?;
    
    // Step 2: Create a Bitcoin transaction for the Rune transfer
    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };
    
    // Step 3: Get UTXOs associated with the sender
    let utxos = get_account_utxos(from)?;
    
    // Step 4: Find UTXOs with the specified Rune
    let rune_utxos = utxos.iter()
        .filter(|utxo| has_rune(utxo, rune_id))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    
    // Step 5: Verify sender has enough of the rune
    let total_runes = rune_utxos.iter()
        .map(|utxo| get_rune_amount(utxo, rune_id))
        .sum::&lt;u64&gt;();
    
    require!(
        total_runes &gt;= amount,
        ProgramError::InsufficientRuneBalance
    );
    
    // Step 6: Select UTXOs for the transfer
    let selected_utxos = select_utxos_for_transfer(
        &amp;rune_utxos, 
        rune_id,
        amount
    )?;
    
    // Step 7: Add inputs from selected UTXOs
    for utxo in &amp;selected_utxos {
        tx.input.push(TxIn {
            previous_output: OutPoint::new(utxo.txid.into(), utxo.vout),
            script_sig: Script::new(),
            sequence: Sequence::MAX,
            witness: Witness::new(),
        });
    }
    
    // Step 8: Calculate total input amount
    let total_input_amount = selected_utxos.iter()
        .map(|utxo| utxo.amount)
        .sum::&lt;u64&gt;();
    
    // Step 9: Create output with rune transfer
    let runes_data = create_runes_data(rune_id, amount);
    tx.output.push(TxOut {
        value: DUST_LIMIT, // Minimum amount for a valid output
        script_pubkey: to_script.clone(),
    });
    
    // Step 10: Add change output if needed
    if total_input_amount &gt; DUST_LIMIT {
        // Return change to sender
        let change_amount = total_input_amount - DUST_LIMIT;
        let change_runes = total_runes - amount;
        
        // Create change output with remaining runes
        if change_amount &gt; 0 {
            let change_data = create_runes_data(rune_id, change_runes);
            tx.output.push(TxOut {
                value: change_amount,
                script_pubkey: from_script.clone(),
            });
        }
    }
    
    // Step 11: Create transaction signing request
    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;selected_utxos.iter()
            .enumerate()
            .map(|(i, utxo)| InputToSign {
                index: i as u32,
                signer: *from.key,
            })
            .collect::&lt;Vec&lt;_&gt;&gt;(),
    };
    
    // Step 12: Submit transaction for signing by the Arch runtime
    set_transaction_to_sign(&amp;[from.clone(), to.clone()], tx_to_sign)?;
    
    Ok(())
}

/// Gets UTXOs associated with an account
fn get_account_utxos(account: &amp;AccountInfo) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;, ProgramError&gt; {
    // In a real implementation, this would query the Arch state
    // to get UTXOs associated with the account
    // This is a simplified placeholder implementation
    
    // For tutorial purposes, we simulate fetching UTXOs
    Ok(vec![])
}

/// Checks if a UTXO contains a specific Rune
fn has_rune(utxo: &amp;UtxoMeta, rune_id: &amp;str) -&gt; bool {
    // In a real implementation, this would parse the Bitcoin
    // transaction data to check for Rune presence
    // This is a simplified placeholder for the tutorial
    
    true // For tutorial purposes
}

/// Gets the amount of a specific Rune in a UTXO
fn get_rune_amount(utxo: &amp;UtxoMeta, rune_id: &amp;str) -&gt; u64 {
    // In a real implementation, this would parse the Bitcoin
    // transaction data to get the Rune amount
    // This is a simplified placeholder for the tutorial
    
    1000 // For tutorial purposes
}

/// Creates Rune-specific data for transaction outputs
fn create_runes_data(rune_id: &amp;str, amount: u64) -&gt; Vec&lt;u8&gt; {
    // In a real implementation, this would create the proper
    // script or OP_RETURN data to encode Rune information
    // This is a simplified placeholder for the tutorial
    
    vec![] // For tutorial purposes
}

/// Selects appropriate UTXOs for a Rune transfer
fn select_utxos_for_transfer(
    utxos: &amp;[&amp;UtxoMeta],
    rune_id: &amp;str,
    amount: u64,
) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;, ProgramError&gt; {
    // In a real implementation, this would implement a UTXO
    // selection algorithm optimized for Rune transfers
    // This is a simplified placeholder for the tutorial
    
    // Simply clone the first UTXO for the tutorial
    if let Some(utxo) = utxos.first() {
        Ok(vec![(*utxo).clone()])
    } else {
        Err(ProgramError::InsufficientFunds)
    }
}</code></pre>
<p>The <code>transfer_runes</code> function implements the core logic for transferring Runes tokens between accounts. It:</p>
<ol>
<li>Gets the Bitcoin script pubkeys for the sender and receiver</li>
<li>Creates a new Bitcoin transaction</li>
<li>Finds UTXOs containing the desired Rune</li>
<li>Selects appropriate UTXOs for the transfer</li>
<li>Creates outputs with proper Rune encoding</li>
<li>Handles change output for remaining Runes</li>
<li>Sets up the transaction for signing by the Arch runtime</li>
</ol>
<h3 id="rune-ownership-verification"><a class="header" href="#rune-ownership-verification">Rune Ownership Verification</a></h3>
<p>Let‚Äôs also look at the implementation of the <code>verify_rune_ownership</code> function:</p>
<pre><code class="language-rust ignore">/// Verifies that an account owns sufficient Runes
/// 
/// # Arguments
/// * `account` - The account to check
/// * `rune_id` - The identifier of the Rune to verify
/// * `required_amount` - The amount of Runes required
/// 
/// # Returns
/// * `Result&lt;(), ProgramError&gt;` - Success or error code
fn verify_rune_ownership(
    account: &amp;AccountInfo,
    rune_id: &amp;str,
    required_amount: u64,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get UTXOs associated with the account
    let utxos = get_account_utxos(account)?;
    
    // Step 2: Filter UTXOs that contain the specified Rune
    let rune_utxos = utxos.iter()
        .filter(|utxo| has_rune(utxo, rune_id))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    
    // Step 3: Calculate total Runes owned
    let total_owned = rune_utxos.iter()
        .map(|utxo| get_rune_amount(utxo, rune_id))
        .sum::&lt;u64&gt;();
    
    // Step 4: Verify the account has enough Runes
    if total_owned &lt; required_amount {
        msg!(
            "Insufficient Rune balance. Required: {}, Available: {}",
            required_amount,
            total_owned
        );
        return Err(ProgramError::InsufficientRuneBalance);
    }
    
    Ok(())
}</code></pre>
<p>This function validates that an account owns a sufficient amount of a specific Rune by:</p>
<ol>
<li>Getting the account‚Äôs UTXOs</li>
<li>Filtering those containing the specified Rune</li>
<li>Calculating the total Rune amount owned</li>
<li>Verifying the account has enough to meet the required amount</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-bitcoin-lending-protocol"><a class="header" href="#how-to-build-a-bitcoin-lending-protocol">How to Build a Bitcoin Lending Protocol</a></h1>
<p>This guide walks through building a lending protocol for Bitcoin-based assets (BTC, Runes, Ordinals) on Arch Network. We‚Äôll create a decentralized lending platform similar to Aave, but specifically designed for Bitcoin-based assets.</p>
<h2 id="prerequisites-7"><a class="header" href="#prerequisites-7">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch CLI installed</li>
</ul>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<h3 id="basic-user-flow"><a class="header" href="#basic-user-flow">Basic User Flow</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Depositing
        A[User wants to lend] --&gt;|1. Deposits BTC| B[Lending Pool]
        B --&gt;|2. Receives interest| A
    end

    subgraph Borrowing
        C[User needs loan] --&gt;|3. Provides collateral| B
        B --&gt;|4. Lends BTC| C
        C --&gt;|5. Repays loan + interest| B
    end

    style A fill:#b3e0ff
    style B fill:#98FB98
    style C fill:#b3e0ff
</pre>
<h3 id="safety-system"><a class="header" href="#safety-system">Safety System</a></h3>
<pre class="mermaid">flowchart LR
    subgraph &quot;Price Monitoring&quot;
        direction TB
        A[Price Oracle] --&gt;|1. Updates prices| B[Health Checker]
    end

    subgraph &quot;Health Check&quot;
        direction TB
        B --&gt;|2. Monitors positions| C[User Position]
        C --&gt;|3. If position unsafe| D[Liquidator]
    end

    style A fill:#FFB6C1
    style B fill:#FFB6C1
    style C fill:#b3e0ff
    style D fill:#FFB6C1
</pre>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<p>Let‚Äôs say Alice wants to borrow BTC and Bob wants to earn interest:</p>
<ol>
<li>
<p><strong>Bob (Lender)</strong></p>
<ul>
<li>Deposits 1 BTC into pool</li>
<li>Earns 3% APY interest</li>
</ul>
</li>
<li>
<p><strong>Alice (Borrower)</strong></p>
<ul>
<li>Provides 1.5 BTC as collateral</li>
<li>Borrows 1 BTC</li>
<li>Pays 5% APY interest</li>
</ul>
</li>
<li>
<p><strong>Safety System</strong></p>
<ul>
<li>Monitors BTC price</li>
<li>Checks if Alice‚Äôs collateral stays valuable enough</li>
<li>If BTC price drops too much, liquidates some collateral to protect Bob‚Äôs deposit</li>
</ul>
</li>
</ol>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>Our lending protocol consists of several key components:</p>
<h3 id="1-pool-accounts"><a class="header" href="#1-pool-accounts">1. Pool Accounts</a></h3>
<p>Pool accounts are the core of our lending protocol. They serve as liquidity pools where users can:</p>
<ul>
<li>Deposit Bitcoin-based assets (BTC, Runes, Ordinals)</li>
<li>Earn interest on deposits</li>
<li>Borrow against their collateral</li>
<li>Manage protocol parameters</li>
</ul>
<p>Each pool account maintains:</p>
<ul>
<li>Total deposits and borrows</li>
<li>Interest rates and utilization metrics</li>
<li>Collateral factors and liquidation thresholds</li>
<li>Asset-specific parameters</li>
</ul>
<p>The pool account manages both state and UTXOs:</p>
<ul>
<li><strong>State Management</strong>: Tracks deposits, withdrawals, and user positions</li>
<li><strong>UTXO Management</strong>:
<ul>
<li>Maintains a collection of UTXOs for the pool‚Äôs Bitcoin holdings</li>
<li>Manages UTXO creation for withdrawals</li>
<li>Handles UTXO consolidation for efficient liquidity management</li>
</ul>
</li>
</ul>
<h3 id="2-price-oracle"><a class="header" href="#2-price-oracle">2. Price Oracle</a></h3>
<p>Track asset prices for liquidation calculations</p>
<h3 id="3-user-positions"><a class="header" href="#3-user-positions">3. User Positions</a></h3>
<p>User positions track all user interactions with the lending pools:</p>
<ul>
<li>Active deposits and their earned interest</li>
<li>Outstanding borrows and accrued interest</li>
<li>Collateral positions and health factors</li>
<li>Liquidation thresholds and warnings</li>
</ul>
<p>Each user can have multiple positions across different pools, and the protocol tracks:</p>
<ul>
<li>Position health through real-time monitoring</li>
<li>Collateralization ratios</li>
<li>Interest accrual</li>
<li>Liquidation risks</li>
</ul>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct LendingPool {
    pub pool_pubkey: Pubkey,
    pub asset_type: AssetType, // BTC, Runes, Ordinals
    pub total_deposits: u64,
    pub total_borrows: u64,
    pub interest_rate: u64,
    pub utilization_rate: u64,
    pub liquidation_threshold: u64,
    pub collateral_factor: u64,
    pub utxos: Vec&lt;UtxoMeta&gt;,
    pub validator_signatures: Vec&lt;Signature&gt;,
    pub min_signatures_required: u32,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserPosition {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub deposited_amount: u64,
    pub borrowed_amount: u64,
    pub collateral_amount: u64,
    pub last_update: i64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct InterestRateModel {
    pub base_rate: u64,
    pub multiplier: u64,
    pub jump_multiplier: u64,
    pub optimal_utilization: u64,
}

// Additional helper structures for managing positions
#[derive(BorshSerialize, BorshDeserialize)]
pub struct PositionHealth {
    pub health_factor: u64,
    pub liquidation_price: u64,
    pub safe_borrow_limit: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PoolMetrics {
    pub total_value_locked: u64,
    pub available_liquidity: u64,
    pub utilization_rate: u64,
    pub supply_apy: u64,
    pub borrow_apy: u64,
}</code></pre>
<h2 id="custom-scoring-and-risk-management"><a class="header" href="#custom-scoring-and-risk-management">Custom Scoring and Risk Management</a></h2>
<h3 id="ltv-loan-to-value-scoring-system"><a class="header" href="#ltv-loan-to-value-scoring-system">LTV (Loan-to-Value) Scoring System</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Core_Factors[Core Factors]
        P1[Transaction History]
        P2[Asset Quality]
        P3[Market Volatility]
        P4[Position Size]
    end
    
    subgraph User_Metrics[User Metrics]
        P5[Account History]
        P6[Repayment Record]
        P7[Portfolio Health]
    end
    
    subgraph Market_Context[Market Context]
        P8[Market Conditions]
        P9[Price Impact]
        P10[Network Status]
    end
    
    Core_Factors --&gt; SC[Scoring Engine]
    User_Metrics --&gt; SC
    Market_Context --&gt; SC
    SC --&gt; WF[Weight Calculation]
    WF --&gt; NM[Risk Normalization]
    NM --&gt; LTV[Final LTV Ratio]
    
    style Core_Factors fill:#e1f3d8
    style User_Metrics fill:#fff7e6
    style Market_Context fill:#e6f3ff
    style SC fill:#f9f9f9
    style WF fill:#f9f9f9
    style NM fill:#f9f9f9
    style LTV fill:#d4edda
</pre>
<h3 id="health-score-monitoring"><a class="header" href="#health-score-monitoring">Health Score Monitoring</a></h3>
<pre class="mermaid">sequenceDiagram
    participant User
    participant HealthMonitor
    participant PriceOracle
    participant LiquidationEngine
    participant Market

    loop Every Block
        PriceOracle-&gt;&gt;HealthMonitor: Update Asset Prices
        HealthMonitor-&gt;&gt;HealthMonitor: Calculate Health Score
        
        alt Health Score &lt; Threshold
            HealthMonitor-&gt;&gt;LiquidationEngine: Trigger Liquidation
            LiquidationEngine-&gt;&gt;User: Lock Account
            LiquidationEngine-&gt;&gt;Market: List Assets
            Market--&gt;&gt;LiquidationEngine: Asset Sale Complete
            LiquidationEngine-&gt;&gt;User: Update Position
        else Health Score &gt;= Threshold
            HealthMonitor-&gt;&gt;User: Position Safe
        end
    end
</pre>
<h3 id="liquidation-process"><a class="header" href="#liquidation-process">Liquidation Process</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Monitoring
    Monitoring --&gt; Warning: Health Score Declining
    Warning --&gt; AtRisk: Below Warning Threshold
    AtRisk --&gt; Liquidation: Below Critical Threshold
    Liquidation --&gt; Step1: Lock Account
    Step1 --&gt; Step2: List Assets
    Step2 --&gt; Recovery: Asset Sale
    Recovery --&gt; [*]: Position Cleared
    
    Warning --&gt; Monitoring: Health Restored
    AtRisk --&gt; Warning: Health Improved
</pre>
<h3 id="custom-scoring-implementation"><a class="header" href="#custom-scoring-implementation">Custom Scoring Implementation</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserScore {
    pub historical_data_score: u64,
    pub asset_quality_score: u64,
    pub market_volatility_score: u64,
    pub position_size_score: u64,
    pub account_age_score: u64,
    pub liquidation_history_score: u64,
    pub repayment_history_score: u64,
    pub cross_margin_score: u64,
    pub portfolio_diversity_score: u64,
    pub market_condition_score: u64,
    pub collateral_quality_score: u64,
    pub platform_activity_score: u64,
    pub time_weighted_score: u64,
    pub price_impact_score: u64,
    pub network_status_score: u64,
}

pub fn calculate_ltv_ratio(score: &amp;UserScore) -&gt; Result&lt;u64&gt; {
    // Weighted calculation of LTV based on all scoring parameters
    let weighted_score = calculate_weighted_score(score)?;
    let normalized_score = normalize_score(weighted_score)?;
    
    // Convert normalized score to LTV ratio
    let ltv_ratio = convert_score_to_ltv(normalized_score)?;
    
    // Apply market condition adjustments
    let adjusted_ltv = apply_market_adjustments(ltv_ratio)?;
    
    Ok(adjusted_ltv)
}

pub fn monitor_health_score(
    ctx: Context&lt;HealthCheck&gt;,
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;()&gt; {
    let health_score = calculate_health_score(position, score)?;
    
    if health_score &lt; CRITICAL_THRESHOLD {
        trigger_full_liquidation(ctx, position)?;
        lock_account(ctx.accounts.user_account)?;
    } else if health_score &lt; WARNING_THRESHOLD {
        emit_warning(ctx.accounts.user_account)?;
    }
    
    Ok(())
}

pub fn trigger_full_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    position: &amp;UserPosition,
) -&gt; Result&lt;()&gt; {
    // Step 1: Lock the account
    lock_account(ctx.accounts.user_account)?;
    
    // Step 2: Calculate current position value
    let position_value = calculate_position_value(position)?;
    
    // Step 3: List assets on marketplace
    list_assets_for_liquidation(
        ctx.accounts.marketplace,
        position.assets,
        position_value,
    )?;
    
    // Step 4: Monitor recovery process
    start_recovery_monitoring(ctx.accounts.recovery_manager)?;
    
    Ok(())
}

## Health Score Calculation
The health score is calculated using a combination of factors:

```rust,ignore
pub fn calculate_health_score(
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;u64&gt; {
    // 1. Calculate base health ratio
    let base_health = calculate_base_health_ratio(
        position.collateral_value,
        position.borrowed_value,
    )?;
    
    // 2. Apply user score modifiers
    let score_adjusted_health = apply_score_modifiers(
        base_health,
        score,
    )?;
    
    // 3. Apply market condition adjustments
    let market_adjusted_health = apply_market_conditions(
        score_adjusted_health,
        &amp;position.asset_type,
    )?;
    
    // 4. Apply time-weighted factors
    let final_health_score = apply_time_weights(
        market_adjusted_health,
        position.last_update,
    )?;
    
    Ok(final_health_score)
}</code></pre>
<h3 id="liquidation-implementation"><a class="header" href="#liquidation-implementation">Liquidation Implementation</a></h3>
<p>The two-step liquidation process is implemented as follows:</p>
<pre><code class="language-rust ignore">pub struct LiquidationConfig {
    pub warning_threshold: u64,
    pub critical_threshold: u64,
    pub recovery_timeout: i64,
    pub minimum_recovery_value: u64,
}

pub fn handle_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    config: &amp;LiquidationConfig,
) -&gt; Result&lt;()&gt; {
    // Step 1: Asset Recovery
    let recovery_listing = create_recovery_listing(
        ctx.accounts.marketplace,
        ctx.accounts.user_position,
        config.minimum_recovery_value,
    )?;
    
    // Step 2: Monitor Recovery
    start_recovery_monitoring(
        recovery_listing,
        config.recovery_timeout,
    )?;
    
    // Lock account until recovery complete
    lock_user_account(ctx.accounts.user_account)?;
    
    Ok(())
}</code></pre>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="1-initialize-lending-pool"><a class="header" href="#1-initialize-lending-pool">1. Initialize Lending Pool</a></h3>
<p>First, we‚Äôll create a function to initialize a new lending pool:</p>
<pre><code class="language-rust ignore">pub fn initialize_lending_pool(
    ctx: Context&lt;InitializeLendingPool&gt;,
    asset_type: AssetType,
    initial_interest_rate: u64,
    liquidation_threshold: u64,
    collateral_factor: u64,
) -&gt; Result&lt;()&gt; {
    let lending_pool = &amp;mut ctx.accounts.lending_pool;
    
    lending_pool.pool_pubkey = ctx.accounts.pool.key();
    lending_pool.asset_type = asset_type;
    lending_pool.total_deposits = 0;
    lending_pool.total_borrows = 0;
    lending_pool.interest_rate = initial_interest_rate;
    lending_pool.utilization_rate = 0;
    lending_pool.liquidation_threshold = liquidation_threshold;
    lending_pool.collateral_factor = collateral_factor;
    
    Ok(())
}

// Initialize pool metrics
pub fn initialize_pool_metrics(
    ctx: Context&lt;InitializePoolMetrics&gt;,
) -&gt; Result&lt;()&gt; {
    let pool_metrics = &amp;mut ctx.accounts.pool_metrics;
    
    pool_metrics.total_value_locked = 0;
    pool_metrics.available_liquidity = 0;
    pool_metrics.utilization_rate = 0;
    pool_metrics.supply_apy = 0;
    pool_metrics.borrow_apy = 0;
    
    Ok(())
}</code></pre>
<h3 id="2-manage-user-positions"><a class="header" href="#2-manage-user-positions">2. Manage User Positions</a></h3>
<p>Functions to handle user position management:</p>
<pre><code class="language-rust ignore">pub fn create_user_position(
    ctx: Context&lt;CreateUserPosition&gt;,
    pool_pubkey: Pubkey,
) -&gt; Result&lt;()&gt; {
    let user_position = &amp;mut ctx.accounts.user_position;
    
    user_position.user_pubkey = ctx.accounts.user.key();
    user_position.pool_pubkey = pool_pubkey;
    user_position.deposited_amount = 0;
    user_position.borrowed_amount = 0;
    user_position.collateral_amount = 0;
    user_position.last_update = Clock::get()?.unix_timestamp;
    
    Ok(())
}

pub fn update_position_health(
    ctx: Context&lt;UpdatePositionHealth&gt;,
) -&gt; Result&lt;()&gt; {
    let position = &amp;ctx.accounts.user_position;
    let pool = &amp;ctx.accounts.lending_pool;
    let health = &amp;mut ctx.accounts.position_health;
    
    // Calculate health factor based on current prices and positions
    let collateral_value = calculate_collateral_value(
        position.collateral_amount,
        pool.asset_type,
    )?;
    
    let borrow_value = calculate_borrow_value(
        position.borrowed_amount,
        pool.asset_type,
    )?;
    
    health.health_factor = calculate_health_factor(
        collateral_value,
        borrow_value,
        pool.collateral_factor,
    )?;
    
    health.liquidation_price = calculate_liquidation_price(
        position.borrowed_amount,
        position.collateral_amount,
        pool.liquidation_threshold,
    )?;
    
    health.safe_borrow_limit = calculate_safe_borrow_limit(
        collateral_value,
        pool.collateral_factor,
    )?;
    
    Ok(())
}</code></pre>
<h3 id="3-pool-and-position-utilities"><a class="header" href="#3-pool-and-position-utilities">3. Pool and Position Utilities</a></h3>
<p>Helper functions for managing pools and positions:</p>
<pre><code class="language-rust ignore">// Calculate the utilization rate of a pool
pub fn calculate_utilization_rate(pool: &amp;LendingPool) -&gt; Result&lt;u64&gt; {
    if pool.total_deposits == 0 {
        return Ok(0);
    }
    
    Ok((pool.total_borrows * 10000) / pool.total_deposits)
}

// Calculate the health factor of a position
pub fn calculate_health_factor(
    collateral_value: u64,
    borrow_value: u64,
    collateral_factor: u64,
) -&gt; Result&lt;u64&gt; {
    if borrow_value == 0 {
        return Ok(u64::MAX);
    }
    
    Ok((collateral_value * collateral_factor) / (borrow_value * 10000))
}

// Update pool metrics
pub fn update_pool_metrics(
    pool: &amp;LendingPool,
    metrics: &amp;mut PoolMetrics,
) -&gt; Result&lt;()&gt; {
    metrics.total_value_locked = pool.total_deposits;
    metrics.available_liquidity = pool.total_deposits.saturating_sub(pool.total_borrows);
    metrics.utilization_rate = calculate_utilization_rate(pool)?;
    
    // Update APY rates based on utilization
    let (supply_apy, borrow_apy) = calculate_apy_rates(
        metrics.utilization_rate,
        pool.interest_rate,
    )?;
    
    metrics.supply_apy = supply_apy;
    metrics.borrow_apy = borrow_apy;
    
    Ok(())
}</code></pre>
<h3 id="4-deposit-assets"><a class="header" href="#4-deposit-assets">4. Deposit Assets</a></h3>
<p>Create a deposit function to allow users to provide liquidity:</p>
<pre><code class="language-rust ignore">pub fn deposit(
    ctx: Context&lt;Deposit&gt;,
    amount: u64,
    btc_txid: [u8; 32],
    vout: u32,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;
    
    // Verify the UTXO belongs to the user
    require!(
        validate_utxo_ownership(
            &amp;UtxoMeta {
                txid: btc_txid,
                vout,
                amount,
            },
            &amp;ctx.accounts.user.key()
        )?,
        ErrorCode::InvalidUTXO
    );

    // Create deposit account to hold the UTXO
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            btc_txid,
            vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.user.clone(), ctx.accounts.pool.clone()]
    )?;

    // Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update utilization metrics
    update_utilization_rate(pool)?;
    
    Ok(())
}</code></pre>
<h3 id="5-borrow-assets"><a class="header" href="#5-borrow-assets">5. Borrow Assets</a></h3>
<p>Implement borrowing functionality:</p>
<pre><code class="language-rust ignore">pub fn borrow(
    ctx: Context&lt;Borrow&gt;,
    amount: u64,
    collateral_utxo: UtxoMeta,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let borrower_position = &amp;mut ctx.accounts.user_position;

    // Verify collateral UTXO ownership
    require!(
        validate_utxo_ownership(
            &amp;collateral_utxo,
            &amp;ctx.accounts.borrower.key()
        )?,
        ErrorCode::InvalidCollateral
    );

    // Check collateral requirements
    require!(
        is_collateral_sufficient(borrower_position, pool, amount)?,
        ErrorCode::InsufficientCollateral
    );

    // Create collateral account
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            collateral_utxo.txid,
            collateral_utxo.vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.borrower.clone(), ctx.accounts.pool.clone()]
    )?;

    // Create borrow UTXO for user
    let mut btc_tx = Transaction::new();
    add_state_transition(&amp;mut btc_tx, ctx.accounts.pool);

    // Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;[InputToSign {
                index: 0,
                signer: pool.pool_pubkey
            }]
        }
    );

    // Update states
    pool.total_borrows = pool.total_borrows
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    borrower_position.borrowed_amount = borrower_position.borrowed_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;

    update_utilization_rate(pool)?;
    update_interest_rate(pool)?;

    Ok(())
}</code></pre>
<h3 id="6-liquidation-logic"><a class="header" href="#6-liquidation-logic">6. Liquidation Logic</a></h3>
<p>Implement liquidation for underwater positions:</p>
<pre><code class="language-rust ignore">pub fn liquidate(
    ctx: Context&lt;Liquidate&gt;,
    repay_amount: u64,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let liquidated_position = &amp;mut ctx.accounts.liquidated_position;
    
    // Check if position is liquidatable
    require!(
        is_position_liquidatable(liquidated_position, pool)?,
        ErrorCode::PositionNotLiquidatable
    );
    
    // Calculate liquidation bonus
    let bonus = calculate_liquidation_bonus(repay_amount, pool.liquidation_threshold)?;
    
    // Process liquidation
    process_liquidation(
        pool,
        liquidated_position,
        repay_amount,
        bonus,
    )?;
    
    Ok(())
}</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>Create comprehensive tests for your lending protocol:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_initialize_lending_pool() {
        // Test pool initialization
    }

    #[test]
    fn test_deposit() {
        // Test deposit functionality
    }

    #[test]
    fn test_borrow() {
        // Test borrowing
    }

    #[test]
    fn test_liquidation() {
        // Test liquidation scenarios
    }
}</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<ol>
<li><strong>Collateral Safety</strong>: Implement strict collateral requirements and regular position health checks</li>
<li><strong>Price Oracle Security</strong>: Use reliable price feeds and implement safeguards against price manipulation</li>
<li><strong>Interest Rate Model</strong>: Ensure the model can handle extreme market conditions</li>
<li><strong>Access Control</strong>: Implement proper permission checks for all sensitive operations</li>
<li><strong>Liquidation Thresholds</strong>: Set appropriate thresholds to maintain protocol solvency</li>
</ol>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ol>
<li>
<p>Implement additional features:</p>
<ul>
<li>Flash loans</li>
<li>Multiple collateral types</li>
<li>Governance mechanisms</li>
</ul>
</li>
<li>
<p>Deploy and test on testnet:</p>
<ul>
<li>Monitor pool performance</li>
<li>Test liquidation scenarios</li>
<li>Validate interest rate model</li>
</ul>
</li>
<li>
<p>Security audit:</p>
<ul>
<li>Contract review</li>
<li>Economic model analysis</li>
<li>Risk assessment</li>
</ul>
</li>
</ol>
<h2 id="process-descriptions"><a class="header" href="#process-descriptions">Process Descriptions</a></h2>
<h3 id="1-pool-initialization-process"><a class="header" href="#1-pool-initialization-process">1. Pool Initialization Process</a></h3>
<p>The pool initialization process involves several steps:</p>
<pre class="mermaid">%%{init: {
  'theme': 'base',
  'themeVariables': { 'fontSize': '16px'},
  'flowchart': {
    'curve': 'basis',
    'nodeSpacing': 50,
    'rankSpacing': 50,
    'animation': {
      'sequence': true,
      'duration': 1000,
      'ease': 'linear',
      'diagramUpdate': 200
    }
  }
}}%%
graph LR
    A[Admin] --&gt;|Create Pool| B[Initialize Pool Account]
    B --&gt;|Set Parameters| C[Configure Pool]
    C --&gt;|Initialize Metrics| D[Create Pool Metrics]
    D --&gt;|Enable Oracle| E[Connect Price Feed]
    E --&gt;|Activate| F[Pool Active]

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef active fill:#4a9eff,color:white,stroke:#3182ce,opacity:0;
    classDef complete fill:#98FB98,stroke:#333;

</pre>
<ol>
<li>Admin creates a new pool account</li>
<li>Pool parameters are set (interest rates, thresholds)</li>
<li>Pool metrics are initialized</li>
<li>Price oracle connection is established</li>
<li>Pool is activated for user operations</li>
</ol>
<h3 id="2-deposit-and-borrow-flow"><a class="header" href="#2-deposit-and-borrow-flow">2. Deposit and Borrow Flow</a></h3>
<p>The lending and borrowing process follows this sequence:</p>
<pre class="mermaid">graph TD
    A[User] --&gt;|Deposit Assets| B[Lending Pool]
    B --&gt;|Create Position| C[User Position]
    C --&gt;|Calculate Capacity| D[Borrow Limit]
    D --&gt;|Enable Borrowing| E[Borrow Assets]
    E --&gt;|Update Metrics| F[Pool Metrics]
    F --&gt;|Adjust Rates| G[Interest Rates]
</pre>
<p>Key steps:</p>
<ol>
<li>User deposits assets into the pool</li>
<li>System creates or updates user position</li>
<li>Calculates borrowing capacity based on collateral</li>
<li>Enables borrowing up to the limit</li>
<li>Updates pool metrics and interest rates</li>
</ol>
<h3 id="3-health-monitoring-system"><a class="header" href="#3-health-monitoring-system">3. Health Monitoring System</a></h3>
<p>Continuous health monitoring process:</p>
<pre class="mermaid">graph TD
    A[Price Oracle] --&gt;|Update Prices| B[Position Valuation]
    B --&gt;|Calculate Ratios| C[Health Check]
    C --&gt;|Evaluate| D{Health Factor}
    D --&gt;|&gt;1| E[Healthy]
    D --&gt;|&lt;1| F[At Risk]
    F --&gt;|&lt;Threshold| G[Liquidatable]
    G --&gt;|Notify| H[Liquidators]
</pre>
<p>The system:</p>
<ol>
<li>Continuously monitors asset prices</li>
<li>Updates position valuations</li>
<li>Calculates health factors</li>
<li>Triggers liquidations when necessary</li>
</ol>
<h3 id="withdrawal-process"><a class="header" href="#withdrawal-process">Withdrawal Process</a></h3>
<p>The withdrawal process in our lending protocol involves two key components:</p>
<ol>
<li>State management through program accounts</li>
<li>Actual BTC transfer through UTXOs</li>
</ol>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct WithdrawRequest {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub amount: u64,
    pub recipient_btc_address: String,
}

pub fn process_withdrawal(
    ctx: Context&lt;ProcessWithdraw&gt;,
    request: WithdrawRequest,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;

    // 1. Validate user position
    require!(
        user_position.deposited_amount &gt;= request.amount,
        ErrorCode::InsufficientBalance
    );

    // 2. Check pool liquidity
    require!(
        pool.available_liquidity() &gt;= request.amount,
        ErrorCode::InsufficientLiquidity
    );

    // 3. Find available UTXOs from pool
    let selected_utxos = select_utxos_for_withdrawal(
        &amp;pool.utxos,
        request.amount
    )?;

    // 4. Create Bitcoin withdrawal transaction
    let mut btc_tx = Transaction::new();
    
    // Add inputs from selected UTXOs
    for utxo in selected_utxos {
        btc_tx.input.push(TxIn {
            previous_output: OutPoint::new(utxo.txid, utxo.vout),
            script_sig: Script::new(),
            sequence: Sequence::MAX,
            witness: Witness::new(),
        });
    }

    // Add withdrawal output to user's address
    let recipient_script = Address::from_str(&amp;request.recipient_btc_address)?
        .script_pubkey();
    btc_tx.output.push(TxOut {
        value: request.amount,
        script_pubkey: recipient_script,
    });

    // Add change output back to pool if needed
    let total_input = selected_utxos.iter()
        .map(|utxo| utxo.amount)
        .sum::&lt;u64&gt;();
    if total_input &gt; request.amount {
        btc_tx.output.push(TxOut {
            value: total_input - request.amount,
            script_pubkey: get_account_script_pubkey(&amp;pool.pool_pubkey),
        });
    }

    // 5. Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;selected_utxos.iter()
                .enumerate()
                .map(|(i, _)| InputToSign {
                    index: i as u32,
                    signer: pool.pool_pubkey,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        }
    );

    // 6. Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 7. Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 8. Remove spent UTXOs from pool
    pool.utxos.retain(|utxo| !selected_utxos.contains(utxo));

    Ok(())
}

fn select_utxos_for_withdrawal(
    pool_utxos: &amp;[UtxoMeta],
    amount: u64,
) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;&gt; {
    let mut selected = Vec::new();
    let mut total_selected = 0;

    for utxo in pool_utxos {
        if total_selected &gt;= amount {
            break;
        }
        
        // Verify UTXO is still valid and unspent
        validate_utxo(utxo)?;
        
        selected.push(utxo.clone());
        total_selected += utxo.amount;
    }

    require!(
        total_selected &gt;= amount,
        ErrorCode::InsufficientUtxos
    );

    Ok(selected)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-the-arch-program-library-apl"><a class="header" href="#introduction-to-the-arch-program-library-apl">Introduction to the Arch Program Library (APL)</a></h1>
<p>The Arch Program Library (APL) is a collection of on-chain programs targeting the Arch Network blockchain. These programs serve as fundamental building blocks for developing decentralized applications (dApps) on Arch Network. The APL programs are thoroughly tested and provide developers with reliable and secure components for their applications.</p>
<h2 id="available-programs"><a class="header" href="#available-programs">Available Programs</a></h2>
<p>The APL currently includes the following core programs:</p>
<h3 id="token-program"><a class="header" href="#token-program">Token Program</a></h3>
<p>The foundation for creating and managing fungible tokens on Arch Network. It provides a robust implementation for:</p>
<ul>
<li>Token creation and management</li>
<li>Account management</li>
<li>Transfer operations</li>
<li>Delegation capabilities</li>
<li>Multisignature support</li>
</ul>
<h3 id="associated-token-account-program"><a class="header" href="#associated-token-account-program">Associated Token Account Program</a></h3>
<p>A program that standardizes the creation and management of token accounts:</p>
<ul>
<li>Deterministic account address derivation</li>
<li>Simplified account management</li>
<li>Reduced transaction complexity</li>
</ul>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>The APL is designed with the following principles:</p>
<ol>
<li>
<p><strong>Security First</strong></p>
<ul>
<li>Comprehensive security audits</li>
<li>Battle-tested implementations</li>
<li>Conservative upgrade approach</li>
</ul>
</li>
<li>
<p><strong>Composability</strong></p>
<ul>
<li>Programs designed to work together</li>
<li>Standardized interfaces</li>
<li>Clear dependencies</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Optimized for Arch Network‚Äôs architecture</li>
<li>Efficient resource utilization</li>
<li>Scalable implementations</li>
</ul>
</li>
<li>
<p><strong>Developer Experience</strong></p>
<ul>
<li>Clear documentation</li>
<li>Example implementations</li>
<li>Testing utilities</li>
</ul>
</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To start building with APL:</p>
<ol>
<li>Familiarize yourself with the <a href="apl/../concepts/architecture.html">Arch Network architecture</a></li>
<li>Review the documentation for your program of interest</li>
<li>Check out the example implementations</li>
<li>Use the testing utilities to validate your integration</li>
</ol>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>The APL is an open-source project and welcomes contributions from the community. To contribute:</p>
<ol>
<li>Review the contribution guidelines</li>
<li>Join the developer community</li>
<li>Submit proposals for new features</li>
<li>Help improve documentation</li>
<li>Report and fix bugs</li>
</ol>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>For support with APL:</p>
<ul>
<li>Join the developer community</li>
<li>Check the FAQ and troubleshooting guides</li>
<li>Submit issues on GitHub</li>
<li>Participate in developer forums</li>
</ul>
<h2 id="future-development"><a class="header" href="#future-development">Future Development</a></h2>
<p>The APL is continuously evolving with new programs and improvements being added. Some areas of ongoing development include:</p>
<ul>
<li>Advanced token standards</li>
<li>DeFi primitives (including AMM and Swap functionality)</li>
<li>Cross-chain bridges</li>
<li>Privacy-preserving features</li>
</ul>
<p>Stay connected with the community to learn about new developments and opportunities to contribute to the ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-program-1"><a class="header" href="#token-program-1">Token Program</a></h1>
<p>The APL Token Program is the foundation for creating and managing fungible tokens on the Arch Network. This documentation provides a comprehensive guide for developers implementing token functionality in their applications.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The Token Program enables:</p>
<ul>
<li>Creation and management of fungible tokens (mints)</li>
<li>Token account management</li>
<li>Token transfers and delegations</li>
<li>Multisignature authorities</li>
<li>Account freezing and thawing</li>
</ul>
<h2 id="program-id"><a class="header" href="#program-id">Program ID</a></h2>
<pre><code class="language-text">apl-token00000000000000000000000
</code></pre>
<h2 id="account-types-1"><a class="header" href="#account-types-1">Account Types</a></h2>
<h3 id="mint-account"><a class="header" href="#mint-account">Mint Account</a></h3>
<p>The central record for a token type, containing:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to mint new tokens</td></tr>
<tr><td><code>supply</code></td><td><code>u64</code></td><td>Total number of tokens in circulation</td></tr>
<tr><td><code>decimals</code></td><td><code>u8</code></td><td>Number of decimal places</td></tr>
<tr><td><code>is_initialized</code></td><td><code>bool</code></td><td>Has this mint been initialized</td></tr>
<tr><td><code>freeze_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to freeze token accounts</td></tr>
</tbody></table>
</div>
<h3 id="token-account"><a class="header" href="#token-account">Token Account</a></h3>
<p>Holds token balances for a specific mint:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint</code></td><td><code>Pubkey</code></td><td>The token mint this account holds</td></tr>
<tr><td><code>owner</code></td><td><code>Pubkey</code></td><td>Owner of this account</td></tr>
<tr><td><code>amount</code></td><td><code>u64</code></td><td>Number of tokens held</td></tr>
<tr><td><code>delegate</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional delegate authority</td></tr>
<tr><td><code>state</code></td><td><code>AccountState</code></td><td>Account state (Uninitialized/Initialized/Frozen)</td></tr>
<tr><td><code>delegated_amount</code></td><td><code>u64</code></td><td>Amount delegated</td></tr>
<tr><td><code>close_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to close the account</td></tr>
</tbody></table>
</div>
<h3 id="multisig-account"><a class="header" href="#multisig-account">Multisig Account</a></h3>
<p>Enables shared authority over token operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>m</code></td><td><code>u8</code></td><td>Number of required signers</td></tr>
<tr><td><code>n</code></td><td><code>u8</code></td><td>Number of valid signers</td></tr>
<tr><td><code>is_initialized</code></td><td><code>bool</code></td><td>Has this multisig been initialized</td></tr>
<tr><td><code>signers</code></td><td><code>[Pubkey; MAX_SIGNERS]</code></td><td>Array of valid signer addresses</td></tr>
</tbody></table>
</div>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<h3 id="token-creation-and-initialization"><a class="header" href="#token-creation-and-initialization">Token Creation and Initialization</a></h3>
<h4 id="initializemint"><a class="header" href="#initializemint">InitializeMint</a></h4>
<p>Creates a new token type.</p>
<pre><code class="language-rust ignore">pub struct InitializeMint {
    pub decimals: u8,
    pub mint_authority: Pubkey,
    pub freeze_authority: COption&lt;Pubkey&gt;,
}</code></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The mint to initialize</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let mint = Keypair::new();
let mint_authority = Keypair::new();
let decimals = 9;

let instruction = apl_token::instruction::initialize_mint(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    &amp;mint_authority.pubkey(),
    None, // No freeze authority
    decimals,
)?;</code></pre>
<h4 id="initializeaccount"><a class="header" href="#initializeaccount">InitializeAccount</a></h4>
<p>Creates a new account to hold tokens.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The account to initialize</li>
<li><code>[]</code> The mint this account is for</li>
<li><code>[]</code> The owner of the new account</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let account = Keypair::new();
let owner = Keypair::new();

let instruction = apl_token::instruction::initialize_account(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
)?;</code></pre>
<h4 id="initializemultisig"><a class="header" href="#initializemultisig">InitializeMultisig</a></h4>
<p>Creates a new multisignature authority.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InitializeMultisig {
    pub m: u8, // Number of required signers
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The multisig to initialize</li>
<li><code>[]</code> The signer accounts (1 to 11)</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let multisig = Keypair::new();
let signers = vec![&amp;signer1.pubkey(), &amp;signer2.pubkey(), &amp;signer3.pubkey()];
let min_signers = 2;

let instruction = apl_token::instruction::initialize_multisig(
    &amp;apl_token::id(),
    &amp;multisig.pubkey(),
    &amp;signers,
    min_signers,
)?;</code></pre>
<h3 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h3>
<h4 id="mintto"><a class="header" href="#mintto">MintTo</a></h4>
<p>Creates new tokens in an account.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MintTo {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The mint</li>
<li><code>[writable]</code> The account to mint to</li>
<li><code>[signer]</code> The mint authority</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 1_000_000_000; // 1 token with 9 decimals

let instruction = apl_token::instruction::mint_to(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    &amp;destination.pubkey(),
    &amp;mint_authority.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h4 id="transfer"><a class="header" href="#transfer">Transfer</a></h4>
<p>Moves tokens between accounts.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Transfer {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[writable]</code> Destination account</li>
<li><code>[signer]</code> Owner/delegate authority</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 50_000_000; // 0.05 tokens with 9 decimals

let instruction = apl_token::instruction::transfer(
    &amp;apl_token::id(),
    &amp;source.pubkey(),
    &amp;destination.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h4 id="burn"><a class="header" href="#burn">Burn</a></h4>
<p>Removes tokens from circulation.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Burn {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The account to burn from</li>
<li><code>[writable]</code> The token mint</li>
<li><code>[signer]</code> The owner/delegate</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 1_000_000_000; // 1 token with 9 decimals

let instruction = apl_token::instruction::burn(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h3 id="delegation"><a class="header" href="#delegation">Delegation</a></h3>
<h4 id="approve"><a class="header" href="#approve">Approve</a></h4>
<p>Delegates authority over tokens.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Approve {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[]</code> Delegate</li>
<li><code>[signer]</code> Source account owner</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 5_000_000_000; // 5 tokens with 9 decimals

let instruction = apl_token::instruction::approve(
    &amp;apl_token::id(),
    &amp;source.pubkey(),
    &amp;delegate.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h4 id="revoke"><a class="header" href="#revoke">Revoke</a></h4>
<p>Removes delegated authority.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[signer]</code> Source account owner</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let instruction = apl_token::instruction::revoke(
    &amp;apl_token::id(),
    &amp;source.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
)?;</code></pre>
<h3 id="account-management"><a class="header" href="#account-management">Account Management</a></h3>
<h4 id="setauthority"><a class="header" href="#setauthority">SetAuthority</a></h4>
<p>Changes an authority on a mint or account.</p>
<pre><code class="language-rust ignore">pub struct SetAuthority {
    pub authority_type: AuthorityType,
    pub new_authority: COption&lt;Pubkey&gt;,
}</code></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Mint/account to change</li>
<li><code>[signer]</code> Current authority</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let instruction = apl_token::instruction::set_authority(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    Some(&amp;new_authority.pubkey()),
    apl_token::instruction::AuthorityType::MintTokens,
    &amp;current_authority.pubkey(),
    &amp;[],
)?;</code></pre>
<h4 id="closeaccount"><a class="header" href="#closeaccount">CloseAccount</a></h4>
<p>Closes a token account with zero balance.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Account to close</li>
<li><code>[writable]</code> Destination for rent funds</li>
<li><code>[signer]</code> Account owner</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let instruction = apl_token::instruction::close_account(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;destination.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
)?;</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The program defines specific error types for common failure cases:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenError {
    NotRentExempt,           // Account balance too low
    InsufficientFunds,       // Not enough tokens
    InvalidMint,             // Invalid mint account
    MintMismatch,           // Mint doesn't match
    OwnerMismatch,          // Wrong account owner
    FixedSupply,            // Mint authority disabled
    AlreadyInUse,           // Account already initialized
    InvalidNumberOfProvidedSigners,
    InvalidNumberOfRequiredSigners,
    UninitializedState,     // Account not initialized
    NativeNotSupported,     // Instruction not for native tokens
    NonNativeHasBalance,    // Non-native account with balance
    InvalidInstruction,     // Invalid instruction data
    InvalidState,           // Account in invalid state
    Overflow,               // Operation overflowed
    AuthorityTypeNotSupported,
    MintCannotFreeze,       // Mint has no freeze authority
    AccountFrozen,          // Account is frozen
    // ... other errors
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="security-2"><a class="header" href="#security-2">Security</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account states before operations</li>
<li>Validate mint associations</li>
</ul>
</li>
<li>
<p><strong>Authority Management</strong></p>
<ul>
<li>Use multisig for sensitive operations</li>
<li>Carefully manage mint/freeze authorities</li>
<li>Have clear authority transfer procedures</li>
</ul>
</li>
<li>
<p><strong>Operation Safety</strong></p>
<ul>
<li>Use checked math operations</li>
<li>Handle frozen accounts appropriately</li>
<li>Implement proper error handling</li>
</ul>
</li>
</ol>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<ol>
<li>
<p><strong>Transaction Optimization</strong></p>
<ul>
<li>Combine related operations in one transaction</li>
<li>Minimize account lookups</li>
<li>Pre-allocate accounts when possible</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close unused accounts</li>
<li>Maintain rent-exempt balances</li>
<li>Use Associated Token Accounts when appropriate</li>
</ul>
</li>
</ol>
<h2 id="common-scenarios"><a class="header" href="#common-scenarios">Common Scenarios</a></h2>
<h3 id="creating-a-new-token"><a class="header" href="#creating-a-new-token">Creating a New Token</a></h3>
<pre><code class="language-rust ignore">// 1. Create mint account
let mint = Keypair::new();
let mint_rent = arch_program::account::MIN_ACCOUNT_LAMPORTS;

let create_mint_account = arch_program::system_instruction::create_account(
    &amp;payer.pubkey(),
    &amp;mint.pubkey(),
    mint_rent,
    apl_token::state::Mint::LEN as u64,
    &amp;apl_token::id(),
);

// 2. Initialize mint
let init_mint = apl_token::instruction::initialize_mint(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    &amp;mint_authority.pubkey(),
    Some(&amp;freeze_authority.pubkey()),
    9, // decimals
)?;

// 3. Create token account
let account = Keypair::new();
let account_rent = arch_program::account::MIN_ACCOUNT_LAMPORTS;

let create_account = arch_program::system_instruction::create_account(
    &amp;payer.pubkey(),
    &amp;account.pubkey(),
    account_rent,
    apl_token::state::Account::LEN as u64,
    &amp;apl_token::id(),
);

// 4. Initialize token account
let init_account = apl_token::instruction::initialize_account(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
)?;

// 5. Send instructions using Arch SDK
let transaction = arch_sdk::build_and_sign_transaction(
    arch_program::sanitized::ArchMessage::new(
        &amp;[
            create_mint_account,
            init_mint,
            create_account,
            init_account,
        ],
        Some(payer_pubkey),
        client.get_best_block_hash().unwrap(),
    ),
    vec![payer_keypair, mint, account],
    BITCOIN_NETWORK,
);</code></pre>
<h3 id="implementing-a-token-transfer"><a class="header" href="#implementing-a-token-transfer">Implementing a Token Transfer</a></h3>
<pre><code class="language-rust ignore">// 1. Get token accounts (these would be created beforehand)
// let source = source_token_account_pubkey;
// let destination = destination_token_account_pubkey;

// 2. Create transfer instruction
let transfer = apl_token::instruction::transfer(
    &amp;apl_token::id(),
    &amp;source,
    &amp;destination,
    &amp;source_owner,
    &amp;[],
    amount,
)?;

// 3. Send transaction using Arch SDK
let transaction = arch_sdk::build_and_sign_transaction(
    arch_program::sanitized::ArchMessage::new(
        &amp;[transfer],
        Some(source_owner_pubkey),
        client.get_best_block_hash().unwrap(),
    ),
    vec![source_owner_keypair],
    BITCOIN_NETWORK,
);</code></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<p>The Token Program includes comprehensive tests. When implementing token functionality, you should test:</p>
<ol>
<li>
<p><strong>Basic Operations</strong></p>
<ul>
<li>Mint initialization</li>
<li>Account creation</li>
<li>Token transfers</li>
<li>Balance checks</li>
</ul>
</li>
<li>
<p><strong>Authority Controls</strong></p>
<ul>
<li>Authority validation</li>
<li>Multisig operations</li>
<li>Authority transfers</li>
</ul>
</li>
<li>
<p><strong>Error Cases</strong></p>
<ul>
<li>Insufficient funds</li>
<li>Invalid authorities</li>
<li>Account state violations</li>
</ul>
</li>
</ol>
<p>Example test:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn test_transfer() {
        let mint = Keypair::new();
        let source = Keypair::new();
        let destination = Keypair::new();
        let owner = Keypair::new();

        // Initialize mint and accounts
        // ... setup code ...

        // Test transfer
        let amount = 100;
        let result = apl_token::instruction::transfer(
            &amp;apl_token::id(),
            &amp;source.pubkey(),
            &amp;destination.pubkey(),
            &amp;owner.pubkey(),
            &amp;[],
            amount,
        );

        assert!(result.is_ok());
        // Verify balances
        // ... verification code ...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-token-account-program-1"><a class="header" href="#associated-token-account-program-1">Associated Token Account Program</a></h1>
<p>The Associated Token Account (ATA) Program is a utility program in the Arch Program Library (APL) that standardizes the creation and management of token accounts. It provides a deterministic way to find and create token accounts for any wallet address and token mint combination.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The Associated Token Account Program enables:</p>
<ul>
<li>Deterministic derivation of token account addresses</li>
<li>Automatic token account creation</li>
<li>Standardized account management</li>
<li>Simplified token operations</li>
</ul>
<h2 id="program-id-1"><a class="header" href="#program-id-1">Program ID</a></h2>
<pre><code class="language-text">associated-token-account00000000
</code></pre>
<p>You can get the program ID in code:</p>
<pre><code class="language-rust ignore">let program_id = apl_associated_token_account::id();</code></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="associated-token-accounts"><a class="header" href="#associated-token-accounts">Associated Token Accounts</a></h3>
<p>An Associated Token Account is a Program Derived Address (PDA) that is deterministically derived from:</p>
<ul>
<li>The wallet owner‚Äôs public key</li>
<li>The token mint address</li>
</ul>
<p>This ensures that:</p>
<ol>
<li>Each wallet can have exactly one associated token account per token mint</li>
<li>The account address can be derived by anyone who knows the wallet and mint addresses</li>
<li>The account ownership and permissions are standardized</li>
</ol>
<h3 id="account-structure"><a class="header" href="#account-structure">Account Structure</a></h3>
<p>The Associated Token Account follows the standard Token Account structure but with additional guarantees about its address derivation and ownership.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Address Derivation</strong>: Given a wallet and token mint, the ATA address is derived deterministically</li>
<li><strong>Account Creation</strong>: If the account doesn‚Äôt exist, it can be created by calling the ATA program</li>
<li><strong>Token Operations</strong>: Once created, the ATA works like any other token account for transfers, approvals, etc.</li>
</ol>
<p>The key advantage is that applications can always find a user‚Äôs token account for any mint without needing to store addresses.</p>
<h3 id="key-functions"><a class="header" href="#key-functions">Key Functions</a></h3>
<p>The main function for working with Associated Token Accounts:</p>
<pre><code class="language-rust ignore">// Derive address and bump seed
let (address, bump_seed) = apl_associated_token_account::get_associated_token_address_and_bump_seed(
    &amp;wallet_pubkey,
    &amp;token_mint_pubkey,
    &amp;apl_associated_token_account::id(),
);</code></pre>
<h2 id="instructions-1"><a class="header" href="#instructions-1">Instructions</a></h2>
<h3 id="create-associated-token-account"><a class="header" href="#create-associated-token-account">Create Associated Token Account</a></h3>
<p>Creates a new associated token account for a wallet and token mint combination.</p>
<p>Required accounts:</p>
<ul>
<li><code>[signer]</code> Funding account (pays for account creation)</li>
<li><code>[writable]</code> New associated token account</li>
<li><code>[]</code> Wallet address (account owner)</li>
<li><code>[]</code> Token mint</li>
<li><code>[]</code> System program</li>
<li><code>[]</code> Token program</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">// Derive the associated token account address
let (associated_token_address, _bump_seed) = 
    apl_associated_token_account::get_associated_token_address_and_bump_seed(
        &amp;wallet_address,
        &amp;token_mint,
        &amp;apl_associated_token_account::id(),
    );

// Create instruction to create the associated token account
let instruction = arch_program::instruction::Instruction {
    program_id: apl_associated_token_account::id(),
    accounts: vec![
        arch_program::account::AccountMeta::new(payer_pubkey, true),
        arch_program::account::AccountMeta::new(associated_token_address, false),
        arch_program::account::AccountMeta::new(wallet_address, false),
        arch_program::account::AccountMeta::new_readonly(token_mint, false),
        arch_program::account::AccountMeta::new_readonly(arch_program::system_program::id(), false),
        arch_program::account::AccountMeta::new_readonly(apl_token::id(), false),
    ],
    data: utxo_data, // UTXO data for account creation
};</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="account-management-1"><a class="header" href="#account-management-1">Account Management</a></h3>
<ol>
<li>
<p><strong>Creation</strong></p>
<ul>
<li>Always check if an associated token account exists before creating one</li>
<li>Use the standard creation instruction to ensure proper initialization</li>
<li>Handle account creation costs appropriately</li>
</ul>
</li>
<li>
<p><strong>Usage</strong></p>
<ul>
<li>Use associated token accounts as the default choice for user wallets</li>
<li>Derive addresses deterministically rather than storing them</li>
<li>Verify account ownership and mint before operations</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h3>
<ol>
<li>
<p><strong>Address Derivation</strong></p>
<ul>
<li>Always use the official derivation function</li>
<li>Verify derived addresses match expected patterns</li>
<li>Handle creation failure cases gracefully</li>
</ul>
</li>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Verify account ownership</li>
<li>Check token mint association</li>
<li>Validate account state before operations</li>
</ul>
</li>
</ol>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="creating-an-associated-token-account"><a class="header" href="#creating-an-associated-token-account">Creating an Associated Token Account</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{build_and_sign_transaction, ArchRpcClient};
use arch_program::sanitized::ArchMessage;

// Derive the associated token account address
let (associated_token_address, _bump_seed) = 
    apl_associated_token_account::get_associated_token_address_and_bump_seed(
        &amp;wallet_address,
        &amp;token_mint,
        &amp;apl_associated_token_account::id(),
    );

// Check if account already exists
let client = ArchRpcClient::new("http://localhost:9001");
let account_info = client.get_account_info(associated_token_address);

if account_info.is_err() {
    // Account doesn't exist, create it
    let instruction = arch_program::instruction::Instruction {
        program_id: apl_associated_token_account::id(),
        accounts: vec![
            arch_program::account::AccountMeta::new(payer_pubkey, true),
            arch_program::account::AccountMeta::new(associated_token_address, false),
            arch_program::account::AccountMeta::new(wallet_address, false),
            arch_program::account::AccountMeta::new_readonly(token_mint, false),
            arch_program::account::AccountMeta::new_readonly(arch_program::system_program::id(), false),
            arch_program::account::AccountMeta::new_readonly(apl_token::id(), false),
        ],
        data: utxo_data, // UTXO data for account creation
    };

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[instruction],
            Some(payer_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![payer_keypair],
        BITCOIN_NETWORK,
    );
}</code></pre>
<h3 id="using-associated-token-accounts-in-transfers"><a class="header" href="#using-associated-token-accounts-in-transfers">Using Associated Token Accounts in Transfers</a></h3>
<pre><code class="language-rust ignore">// Get associated token accounts for source and destination
let (source_ata, _) = apl_associated_token_account::get_associated_token_address_and_bump_seed(
    &amp;source_wallet,
    &amp;token_mint,
    &amp;apl_associated_token_account::id(),
);

let (destination_ata, _) = apl_associated_token_account::get_associated_token_address_and_bump_seed(
    &amp;destination_wallet,
    &amp;token_mint,
    &amp;apl_associated_token_account::id(),
);

// Create transfer instruction using ATAs
let transfer_instruction = apl_token::instruction::transfer(
    &amp;apl_token::id(),
    &amp;source_ata,
    &amp;destination_ata,
    &amp;source_wallet,
    &amp;[],
    amount,
)?;</code></pre>
<h2 id="common-scenarios-1"><a class="header" href="#common-scenarios-1">Common Scenarios</a></h2>
<h3 id="token-distribution"><a class="header" href="#token-distribution">Token Distribution</a></h3>
<p>When airdropping or distributing tokens:</p>
<ol>
<li>Derive the recipient‚Äôs associated token account address</li>
<li>Create the account if it doesn‚Äôt exist</li>
<li>Transfer tokens to the associated account</li>
</ol>
<h3 id="wallet-integration"><a class="header" href="#wallet-integration">Wallet Integration</a></h3>
<p>When integrating with user wallets:</p>
<ol>
<li>Use associated token accounts by default</li>
<li>Create accounts on-demand when users acquire new tokens</li>
<li>Display token balances from associated accounts</li>
</ol>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Common error cases to handle:</p>
<ul>
<li>Account already exists</li>
<li>Insufficient funds for account creation</li>
<li>Invalid mint association</li>
<li>Invalid owner</li>
<li>Account creation failure</li>
</ul>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<ul>
<li><a href="apl/./token-program.html">Token Program</a> - The main token program that works with ATAs</li>
<li><a href="apl/../program/program.html">Programs</a> - Understanding Arch programs</li>
<li><a href="apl/../program/accounts.html">Accounts</a> - Account model in Arch</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h1>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<pre class="mermaid">graph TB
    subgraph &quot;Arch Network&quot;
        VM[Arch VM&lt;br/&gt;eBPF-based]
        BTC[Bitcoin Integration]
        
        subgraph &quot;Validator Network&quot;
            L[Leader Node]
            V1[Validator Node 1]
            V2[Validator Node 2]
            V3[Validator Node ...]
            B[Bootnode]
        end
        
        VM --&gt; BTC
        L --&gt; V1
        L --&gt; V2
        L --&gt; V3
        B --&gt; V1
        B --&gt; V2
        B --&gt; V3
    end
</pre>
<h3 id="arch-vm"><a class="header" href="#arch-vm">Arch VM</a></h3>
<p>The Arch Virtual Machine (VM) is built on eBPF technology, providing a secure and efficient environment for executing programs.</p>
<p>Key features:</p>
<ul>
<li>üîÑ Manages program execution</li>
<li>‚ö° Handles state transitions</li>
<li>üéØ Ensures deterministic computation</li>
<li>üîó Provides syscalls for Bitcoin UTXO operations</li>
</ul>
<h3 id="bitcoin-integration-1"><a class="header" href="#bitcoin-integration-1">Bitcoin Integration</a></h3>
<p>Arch Network interacts directly with Bitcoin through:</p>
<ul>
<li>üíº Native UTXO management</li>
<li>‚úÖ Transaction validation</li>
<li>üîê Multi-signature coordination</li>
<li>üìù State commitment to Bitcoin</li>
</ul>
<h3 id="validator-network"><a class="header" href="#validator-network">Validator Network</a></h3>
<p>The validator network consists of multiple node types that work together:</p>
<h4 id="node-types"><a class="header" href="#node-types">Node Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Node Type</th><th>Primary Responsibilities</th></tr></thead><tbody>
<tr><td><strong>Leader Node</strong></td><td>‚Ä¢ Coordinates transaction signing<br/>‚Ä¢ Submits signed transactions to Bitcoin<br/>‚Ä¢ Manages validator communication</td></tr>
<tr><td><strong>Validator Nodes</strong></td><td>‚Ä¢ Execute programs in the Arch VM<br/>‚Ä¢ Validate transactions<br/>‚Ä¢ Participate in multi-signature operations<br/>‚Ä¢ Maintain network state</td></tr>
<tr><td><strong>Bootnode</strong></td><td>‚Ä¢ Handles initial network discovery<br/>‚Ä¢ Similar to Bitcoin DNS seeds<br/>‚Ä¢ Helps new nodes join the network</td></tr>
</tbody></table>
</div>
<h2 id="transaction-flow"><a class="header" href="#transaction-flow">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;L: 4. Sign Results
    L-&gt;&gt;B: 5. Submit to Bitcoin
</pre>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Arch Network implements a robust multi-layered security model that directly leverages Bitcoin‚Äôs security guarantees:</p>
<h3 id="1-utxo-security"><a class="header" href="#1-utxo-security">1. UTXO Security</a></h3>
<ul>
<li>
<p>üîí <strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for secure ownership proofs</li>
<li>Double-spend prevention through UTXO consumption tracking</li>
</ul>
</li>
<li>
<p>üîó <strong>State Management</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Atomic state transitions with rollback capability</li>
<li>Cross-validator state consistency checks</li>
</ul>
</li>
</ul>
<h3 id="2-transaction-security"><a class="header" href="#2-transaction-security">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">pub struct SecurityParams {
    pub min_confirmations: u32,    // Required Bitcoin confirmations
    pub signature_threshold: u32,   // Multi-sig threshold
    pub timelock_blocks: u32,      // Timelock requirement
    pub max_witness_size: usize    // Maximum witness data size
}</code></pre>
<ul>
<li>üìù <strong>Multi-signature Validation</strong>
<ul>
<li>ROAST protocol for distributed signing</li>
<li>Threshold signature scheme (t-of-n)</li>
<li>Malicious signer detection and removal</li>
<li>Binding factor verification for signature shares</li>
</ul>
</li>
</ul>
<h3 id="3-network-security"><a class="header" href="#3-network-security">3. Network Security</a></h3>
<ul>
<li>
<p>üåê <strong>Validator Selection</strong></p>
<pre><code class="language-rust ignore">pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32
}</code></pre>
<ul>
<li>Stake-weighted validator participation</li>
<li>Dynamic threshold adjustment</li>
<li>Automatic malicious node detection</li>
</ul>
</li>
<li>
<p>üõ°Ô∏è <strong>State Protection</strong></p>
<ul>
<li>Multi-stage transaction verification</li>
<li>Bitcoin-based finality guarantees</li>
<li>State root commitment to Bitcoin</li>
<li>Mandatory signature verification for all state changes</li>
</ul>
</li>
</ul>
<h3 id="4-best-practices"><a class="header" href="#4-best-practices">4. Best Practices</a></h3>
<ul>
<li>
<p>‚úÖ <strong>UTXO Management</strong></p>
<ul>
<li>Minimum 6 confirmations for finality</li>
<li>Comprehensive UTXO validation</li>
<li>Double-spend monitoring</li>
<li>Reorg handling for UTXO invalidation</li>
</ul>
</li>
<li>
<p>üîç <strong>Transaction Processing</strong></p>
<ul>
<li>Full signature verification</li>
<li>Input/output validation</li>
<li>Proper error handling</li>
<li>Network partition handling</li>
</ul>
</li>
</ul>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-architecture"><a class="header" href="#network-architecture">Network Architecture</a></h1>
<p>Arch Network operates as a distributed system with different types of nodes working together to provide secure and efficient program execution on Bitcoin. This document details the network‚Äôs architecture and how different components interact.</p>
<h2 id="network-overview"><a class="header" href="#network-overview">Network Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph Core[&quot;Core Components&quot;]
        direction TB
        BN[Bitcoin Network]
        Boot[Bootnode]
    end

    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[MultiSig\nAggregation]
    end
    
    subgraph Validators[&quot;Validator Network&quot;]
        direction TB
        V1[Validator 1]
        V2[Validator 2]
        V3[Validator 3]
        VN[Validator N]
    end

    BN --&gt; LN[Leader Node]
    Boot --&gt; LN
    
    LN --&gt; TC
    LN --&gt; MS
    
    LN --&gt; V1
    LN --&gt; V2
    LN --&gt; V3
    LN --&gt; VN

    %% Styling
    classDef core fill:#e1f5fe,stroke:#01579b
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validators fill:#f3e5f5,stroke:#4a148c
    
    class BN,Boot core
    class TC,MS leader
    class V1,V2,V3,VN validators
</pre>
<h2 id="node-types-1"><a class="header" href="#node-types-1">Node Types</a></h2>
<h3 id="1-bootnode"><a class="header" href="#1-bootnode">1. Bootnode</a></h3>
<p>The bootnode serves as the network‚Äôs entry point, similar to DNS seeds in Bitcoin:</p>
<ul>
<li>Handles initial network discovery</li>
<li>Maintains whitelist of valid validators</li>
<li>Coordinates peer connections</li>
<li>Manages network topology</li>
</ul>
<pre class="mermaid">flowchart LR
    subgraph Bootnode[&quot;Bootnode Services&quot;]
        direction TB
        PR[Peer Registry]
        WL[Validator Whitelist]
    end

    NN[New Node]
    VN[Validator Network]

    %% Connections
    NN &lt;--&gt; PR
    PR &lt;--&gt; VN
    WL -.-&gt; PR

    %% Styling
    classDef bootnode fill:#e1f5fe,stroke:#01579b
    classDef external fill:#f5f5f5,stroke:#333
    classDef connection stroke-width:2px
    
    class PR,WL bootnode
    class NN,VN external
</pre>
<p>Configuration:</p>
<pre><code class="language-bash">cargo run -p bootnode -- \
    --network-mode localnet \
    --p2p-bind-port 19001 \
    --leader-peer-id "&lt;LEADER_ID&gt;" \
    --validator-whitelist "&lt;VALIDATOR_IDS&gt;"
</code></pre>
<h3 id="2-leader-node"><a class="header" href="#2-leader-node">2. Leader Node</a></h3>
<p>The leader node coordinates transaction processing and Bitcoin integration:</p>
<pre class="mermaid">flowchart TB
    %% Main Components
    BN[Bitcoin Network]
    LN[Leader Node]
    VN[Validator Network]
    PE[Program Execution]
    
    %% Leader Node Services
    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[Multi-sig\nAggregation]
    end
    
    %% Connections
    BN &lt;--&gt; LN
    LN --&gt; Leader
    TC --&gt; VN
    MS --&gt; VN
    VN --&gt; PE
    
    %% Styling
    classDef bitcoin fill:#f7931a,stroke:#c16c07,color:white
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validator fill:#f3e5f5,stroke:#4a148c
    classDef execution fill:#e8f5e9,stroke:#1b5e20
    
    class BN bitcoin
    class LN,TC,MS leader
    class VN validator
    class PE execution
</pre>
<p>Key responsibilities:</p>
<ul>
<li>Transaction coordination</li>
<li>Multi-signature aggregation</li>
<li>Bitcoin transaction submission</li>
<li>Network state management</li>
</ul>
<h3 id="3-validator-nodes"><a class="header" href="#3-validator-nodes">3. Validator Nodes</a></h3>
<p>Validator nodes form the core of the network‚Äôs computation and validation:</p>
<pre class="mermaid">flowchart TB
    subgraph ValidatorNode[&quot;Validator Node&quot;]
        direction TB
        
        subgraph Execution[&quot;Execution Layer&quot;]
            direction LR
            VM[&quot;Arch VM\nExecution&quot;]
            SV[&quot;State\nValidation&quot;]
        end
        
        NP[&quot;Network Protocol&quot;]
        P2P[&quot;P2P Network&quot;]
        
        %% Connections within validator
        VM --&gt; NP
        SV --&gt; NP
        NP --&gt; P2P
    end
    
    %% Styling
    classDef validator fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef execution fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
    classDef network fill:#e3f2fd,stroke:#0d47a1,stroke-width:2px
    
    class ValidatorNode validator
    class VM,SV execution
    class NP,P2P network
</pre>
<p>Types:</p>
<ol>
<li>
<p><strong>Full Validator</strong></p>
<ul>
<li>Participates in consensus</li>
<li>Executes programs</li>
<li>Maintains full state</li>
</ul>
</li>
<li>
<p><strong>Lightweight Validator</strong></p>
<ul>
<li>Local development use</li>
<li>Single-node operation</li>
<li>Simulated environment</li>
</ul>
</li>
</ol>
<h2 id="network-communication"><a class="header" href="#network-communication">Network Communication</a></h2>
<h3 id="p2p-protocol"><a class="header" href="#p2p-protocol">P2P Protocol</a></h3>
<p>The network uses libp2p for peer-to-peer communication:</p>
<pre><code class="language-rust ignore">pub const ENABLED_PROTOCOLS: [&amp;str; 2] = [
    ArchNetworkProtocol::STREAM_PROTOCOL,
    ArchNetworkProtocol::VALIDATOR_PROTOCOL,
];

// Protocol versions
pub const PROTOCOL_VERSION: &amp;str = "/arch/1.0.0";
pub const VALIDATOR_VERSION: &amp;str = "/arch/validator/1.0.0";</code></pre>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<ol>
<li>
<p><strong>Network Messages</strong></p>
<pre><code class="language-rust ignore">pub enum NetworkMessage {
    Discovery(DiscoveryMessage),
    State(StateMessage),
    Transaction(TransactionMessage),
}</code></pre>
</li>
<li>
<p><strong>ROAST Protocol Messages</strong></p>
<pre><code class="language-rust ignore">pub enum RoastMessage {
    KeyGeneration(KeyGenMessage),
    Signing(SigningMessage),
    Aggregation(AggregationMessage),
}</code></pre>
</li>
</ol>
<h2 id="network-modes"><a class="header" href="#network-modes">Network Modes</a></h2>
<h3 id="1-devnet"><a class="header" href="#1-devnet">1. Devnet</a></h3>
<ul>
<li>Local development environment</li>
<li>Single validator setup</li>
<li>Simulated Bitcoin interactions</li>
<li>Fast block confirmation</li>
</ul>
<h3 id="2-testnet"><a class="header" href="#2-testnet">2. Testnet</a></h3>
<ul>
<li>Test environment with multiple validators</li>
<li>Bitcoin testnet integration</li>
<li>Real network conditions</li>
<li>Test transaction processing</li>
</ul>
<h3 id="3-mainnet"><a class="header" href="#3-mainnet">3. Mainnet</a></h3>
<ul>
<li>Production network</li>
<li>Full security model</li>
<li>Bitcoin mainnet integration</li>
<li>Live transaction processing</li>
</ul>
<h2 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h2>
<h3 id="1-validator-selection"><a class="header" href="#1-validator-selection">1. Validator Selection</a></h3>
<pre><code class="language-rust ignore">pub struct ValidatorInfo {
    pub peer_id: PeerId,
    pub pubkey: Pubkey,
    pub stake: u64,
}

pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32,
}</code></pre>
<h3 id="2-transaction-security-1"><a class="header" href="#2-transaction-security-1">2. Transaction Security</a></h3>
<ul>
<li>Multi-signature validation using ROAST protocol</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Double-spend prevention</li>
</ul>
<h3 id="3-state-protection"><a class="header" href="#3-state-protection">3. State Protection</a></h3>
<pre><code class="language-rust ignore">pub struct StateUpdate {
    pub block_height: u64,
    pub state_root: Hash,
    pub bitcoin_height: u64,
    pub signatures: Vec&lt;Signature&gt;,
}</code></pre>
<h2 id="monitoring-and-telemetry"><a class="header" href="#monitoring-and-telemetry">Monitoring and Telemetry</a></h2>
<h3 id="1-node-metrics"><a class="header" href="#1-node-metrics">1. Node Metrics</a></h3>
<pre><code class="language-rust ignore">pub struct NodeMetrics {
    pub peer_id: PeerId,
    pub network_mode: ArchNetworkMode,
    pub bitcoin_block_height: u64,
    pub arch_block_height: u64,
    pub peers_connected: u32,
    pub transactions_processed: u64,
    pub program_count: u32,
}</code></pre>
<h3 id="2-network-health"><a class="header" href="#2-network-health">2. Network Health</a></h3>
<pre><code class="language-rust ignore">pub struct NetworkHealth {
    pub validator_count: u32,
    pub active_validators: u32,
    pub network_tps: f64,
    pub average_block_time: Duration,
    pub fork_count: u32,
}</code></pre>
<h3 id="3-monitoring-endpoints"><a class="header" href="#3-monitoring-endpoints">3. Monitoring Endpoints</a></h3>
<ul>
<li><code>/metrics</code> - Prometheus metrics</li>
<li><code>/health</code> - Node health check</li>
<li><code>/peers</code> - Connected peers</li>
<li><code>/status</code> - Network status</li>
</ul>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-node-operation"><a class="header" href="#1-node-operation">1. Node Operation</a></h3>
<ul>
<li>Secure key management</li>
<li>Regular state verification</li>
<li>Proper shutdown procedures</li>
<li>Log management</li>
</ul>
<h3 id="2-network-participation"><a class="header" href="#2-network-participation">2. Network Participation</a></h3>
<ul>
<li>Maintain node availability</li>
<li>Monitor Bitcoin integration</li>
<li>Handle network upgrades</li>
<li>Backup critical data</li>
</ul>
<h3 id="3-development-setup"><a class="header" href="#3-development-setup">3. Development Setup</a></h3>
<ul>
<li>Use lightweight validator for testing</li>
<li>Monitor resource usage</li>
<li>Handle network modes properly</li>
<li>Implement proper error handling</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-integration-2"><a class="header" href="#bitcoin-integration-2">Bitcoin Integration</a></h1>
<p>Arch Network provides direct integration with Bitcoin, enabling programs to interact with Bitcoin‚Äôs UTXO model while maintaining Bitcoin‚Äôs security guarantees. This document details how Arch Network integrates with Bitcoin.</p>
<h2 id="architecture-overview-2"><a class="header" href="#architecture-overview-2">Architecture Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph BN[Bitcoin Network]
        BNode[Bitcoin Node]
    end

    subgraph TC[Titan Client]
        TCNode[Titan Client]
    end

    subgraph AN[Arch Network]
        LN[Leader Node\nBitcoin Integration]
        subgraph VN[Validator Network]
            P1[Program 1]
            PN[Program N]
        end
    end

    BNode &lt;--&gt; TCNode
    TCNode &lt;--&gt; LN
    LN &lt;--&gt; VN
    P1 --- PN
</pre>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<h3 id="1-utxo-management"><a class="header" href="#1-utxo-management">1. UTXO Management</a></h3>
<p>Arch Network manages Bitcoin UTXOs through a specialized system:</p>
<pre class="mermaid">flowchart LR
    subgraph UTXO[Bitcoin UTXO]
        TxID[TransactionID]
        OutIdx[OutputIndex]
    end

    subgraph Account[Arch Account]
        Meta[UTXOMeta]
        State[ProgramState]
    end

    TxID --&gt; Meta
    OutIdx --&gt; Meta
    Meta --- State
</pre>
<pre><code class="language-rust ignore">// UTXO Metadata Structure
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Transaction ID
    pub vout: u32,       // Output index
    pub amount: u64,     // Amount in satoshis
    pub script_pubkey: Vec&lt;u8&gt;, // Output script
    pub confirmation_height: Option&lt;u32&gt;, // Block height of confirmation
}

// UTXO Account State
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: Vec&lt;u8&gt;,
    pub is_frozen: bool,
}</code></pre>
<p>Key operations:</p>
<pre><code class="language-rust ignore">// UTXO Operations
pub trait UtxoOperations {
    fn create_utxo(meta: UtxoMeta, owner: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn spend_utxo(utxo: &amp;UtxoMeta, signature: &amp;Signature) -&gt; Result&lt;()&gt;;
    fn freeze_utxo(utxo: &amp;UtxoMeta, authority: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn delegate_utxo(utxo: &amp;UtxoMeta, delegate: &amp;Pubkey) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="2-bitcoin-rpc-integration"><a class="header" href="#2-bitcoin-rpc-integration">2. Bitcoin RPC Integration</a></h3>
<pre class="mermaid">flowchart LR
    AP[Arch\nProgram]
    RPC[Bitcoin RPC\nInterface]
    BN[Bitcoin\nNode]
    Config[Configuration]
    Network[Bitcoin\nNetwork]

    AP --&gt; RPC
    RPC --&gt; BN
    AP --&gt; Config
    Config --&gt; RPC
    BN --&gt; Network

    style AP fill:#f9f9f9,stroke:#333,stroke-width:2px
    style RPC fill:#f9f9f9,stroke:#333,stroke-width:2px
    style BN fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Config fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Network fill:#f9f9f9,stroke:#333,stroke-width:2px
</pre>
<p>Programs can interact with Bitcoin through RPC calls:</p>
<pre><code class="language-rust ignore">// Bitcoin RPC Configuration
pub struct BitcoinRpcConfig {
    pub endpoint: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub wallet: Option&lt;String&gt;,
    pub network: BitcoinNetwork,
    pub timeout: Duration,
}

// RPC Interface
pub trait BitcoinRpc {
    fn get_block_count(&amp;self) -&gt; Result&lt;u64&gt;;
    fn get_block_hash(&amp;self, height: u64) -&gt; Result&lt;BlockHash&gt;;
    fn get_transaction(&amp;self, txid: &amp;Txid) -&gt; Result&lt;Transaction&gt;;
    fn send_raw_transaction(&amp;self, tx: &amp;[u8]) -&gt; Result&lt;Txid&gt;;
    fn verify_utxo(&amp;self, utxo: &amp;UtxoMeta) -&gt; Result&lt;bool&gt;;
}</code></pre>
<h2 id="transaction-flow-1"><a class="header" href="#transaction-flow-1">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Program
    participant Leader
    participant Validator
    participant Bitcoin

    Program-&gt;&gt;Leader: Create UTXO
    Leader-&gt;&gt;Validator: Validate
    Validator-&gt;&gt;Leader: Sign
    Leader-&gt;&gt;Bitcoin: Submit TX
    Bitcoin--&gt;&gt;Program: Confirmation
</pre>
<h3 id="1-transaction-creation"><a class="header" href="#1-transaction-creation">1. Transaction Creation</a></h3>
<pre><code class="language-rust ignore">// Create new UTXO transaction
pub struct UtxoCreation {
    pub amount: u64,
    pub owner: Pubkey,
    pub metadata: Option&lt;Vec&lt;u8&gt;&gt;,
}

impl UtxoCreation {
    pub fn new(amount: u64, owner: Pubkey) -&gt; Self {
        Self {
            amount,
            owner,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: Vec&lt;u8&gt;) -&gt; Self {
        self.metadata = Some(metadata);
        self
    }
}</code></pre>
<h3 id="2-transaction-validation"><a class="header" href="#2-transaction-validation">2. Transaction Validation</a></h3>
<pre><code class="language-rust ignore">// Validation rules
pub trait TransactionValidation {
    fn validate_inputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_outputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_signatures(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_script(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="3-state-management"><a class="header" href="#3-state-management">3. State Management</a></h3>
<pre><code class="language-rust ignore">// State transition
pub struct StateTransition {
    pub previous_state: Hash,
    pub next_state: Hash,
    pub utxos_created: Vec&lt;UtxoMeta&gt;,
    pub utxos_spent: Vec&lt;UtxoMeta&gt;,
    pub bitcoin_height: u64,
}</code></pre>
<h2 id="security-model-2"><a class="header" href="#security-model-2">Security Model</a></h2>
<h3 id="1-utxo-security-1"><a class="header" href="#1-utxo-security-1">1. UTXO Security</a></h3>
<ul>
<li>Ownership verification through public key cryptography</li>
<li>Double-spend prevention through UTXO consumption</li>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature requirements</li>
</ul>
<h3 id="2-transaction-security-2"><a class="header" href="#2-transaction-security-2">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">// Transaction security parameters
pub struct SecurityParams {
    pub min_confirmations: u32,
    pub signature_threshold: u32,
    pub timelock_blocks: u32,
    pub max_witness_size: usize,
}</code></pre>
<h3 id="3-network-security-1"><a class="header" href="#3-network-security-1">3. Network Security</a></h3>
<ul>
<li>Multi-signature validation</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Cross-validator consistency</li>
</ul>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="1-bitcoin-errors"><a class="header" href="#1-bitcoin-errors">1. Bitcoin Errors</a></h3>
<pre><code class="language-rust ignore">pub enum BitcoinError {
    ConnectionFailed(String),
    InvalidTransaction(String),
    InsufficientFunds(u64),
    InvalidUtxo(UtxoMeta),
    RpcError(String),
}</code></pre>
<h3 id="2-utxo-errors"><a class="header" href="#2-utxo-errors">2. UTXO Errors</a></h3>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound(UtxoMeta),
    AlreadySpent(UtxoMeta),
    InvalidOwner(Pubkey),
    InvalidSignature(Signature),
    InvalidState(Hash),
}</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="1-utxo-management-1"><a class="header" href="#1-utxo-management-1">1. UTXO Management</a></h3>
<ul>
<li>Always verify UTXO ownership</li>
<li>Wait for sufficient confirmations</li>
<li>Handle reorganizations gracefully</li>
<li>Implement proper error handling</li>
</ul>
<h3 id="2-transaction-processing"><a class="header" href="#2-transaction-processing">2. Transaction Processing</a></h3>
<ul>
<li>Validate all inputs and outputs</li>
<li>Check signature thresholds</li>
<li>Maintain proper state transitions</li>
<li>Monitor Bitcoin network status</li>
</ul>
<h3 id="3-security-considerations"><a class="header" href="#3-security-considerations">3. Security Considerations</a></h3>
<ul>
<li>Protect private keys</li>
<li>Validate all signatures</li>
<li>Monitor for double-spend attempts</li>
<li>Handle network partitions</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="roast-and-frost-consensus"><a class="header" href="#roast-and-frost-consensus">ROAST and FROST Consensus</a></h1>
<p>This section explores Arch‚Äôs consensus mechanism, which combines ROAST (Robust Asynchronous Schnorr Threshold Signatures) and FROST (Flexible Round-Optimized Schnorr Threshold Signatures) to create a secure, efficient, and highly scalable approach to distributed consensus that‚Äôs perfectly suited for Bitcoin-based smart contracts.</p>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p>The consensus mechanism implementation has made significant progress, particularly in the core cryptographic components:</p>
<ol>
<li>
<p><strong>Implemented Components</strong></p>
<ul>
<li>Complete Distributed Key Generation (DKG) protocol using FROST-secp256k1</li>
<li>Two-round DKG process with package handling</li>
<li>Network message protocol for DKG coordination</li>
<li>State management and status tracking</li>
<li>Integration with network layer</li>
<li>Error handling and recovery mechanisms</li>
</ul>
</li>
<li>
<p><strong>In Progress</strong></p>
<ul>
<li>Additional ROAST protocol components</li>
<li>Advanced state management features</li>
<li>Performance optimizations</li>
<li>Extended monitoring and telemetry</li>
</ul>
</li>
</ol>
<p>The subsequent sections describe both the implemented features and the complete protocol design.</p>
<h2 id="core-implementation-details"><a class="header" href="#core-implementation-details">Core Implementation Details</a></h2>
<h3 id="distributed-key-generation-dkg"><a class="header" href="#distributed-key-generation-dkg">Distributed Key Generation (DKG)</a></h3>
<pre><code class="language-rust ignore">// Core DKG message types for network coordination
pub enum DKGMessage {
    StartDKG { message: String },
    Round1Package { package: round1::Package },
    Round2Package { package: round2::Package },
    DKGStatus(DKGStatusMessage),
}

// DKG state management
pub enum DKGStatus {
    Pending(String),
    Ongoing(String),
    Failed(String, String),
    Finished(String),
    NetworkCompleted(String),
}</code></pre>
<p>The DKG implementation provides:</p>
<ul>
<li>Two-round key generation protocol</li>
<li>Secure package exchange between validators</li>
<li>State tracking and synchronization</li>
<li>Failure recovery and error handling</li>
</ul>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>Arch‚Äôs consensus mechanism combines ROAST and FROST to provide a robust, Bitcoin-native consensus solution. Validators participate in a threshold signature scheme where blocks are produced by designated leaders and finalized through collective signing. The system maintains both safety and liveness through careful economic incentives and cryptographic guarantees, while ensuring complete compatibility with Bitcoin‚Äôs Schnorr signature scheme.</p>
<h2 id="block-production-process"><a class="header" href="#block-production-process">Block Production Process</a></h2>
<h3 id="1-leader-selection"><a class="header" href="#1-leader-selection">1. Leader Selection</a></h3>
<pre class="mermaid">graph TD
    A[Epoch Start] --&gt; B[Calculate Leader Schedule]
    B --&gt; C[Distribute Schedule to Validators]
    C --&gt; D[Leaders Prepare for Slots]
    D --&gt; E[Next Leader Takes Turn]
    E --&gt; F[Block Production]
    F --&gt; G[Block Distribution]
    G --&gt; E
</pre>
<p>The block production process begins with leader selection:</p>
<ul>
<li>Each epoch (fixed time period) has a predetermined leader schedule</li>
<li>Leaders are selected based on their stake weight</li>
<li>The schedule is deterministic and known to all validators</li>
<li>Multiple backup leaders are selected for fault tolerance</li>
</ul>
<h3 id="2-transaction-collection-and-verification"><a class="header" href="#2-transaction-collection-and-verification">2. Transaction Collection and Verification</a></h3>
<pre class="mermaid">graph LR
    A[Transaction Pool] --&gt; B[Leader]
    C[Mempool] --&gt; B
    B --&gt; D[Transaction Verification]
    D --&gt; E[Block Formation]
    E --&gt; F[Block Proposal]
</pre>
<p>When a validator becomes the leader:</p>
<ol>
<li>Collects pending transactions from the mempool</li>
<li>Verifies transaction signatures and validity</li>
<li>Orders transactions based on priority and fees</li>
<li>Prepares them for inclusion in the next block</li>
</ol>
<h3 id="3-block-formation"><a class="header" href="#3-block-formation">3. Block Formation</a></h3>
<pre class="mermaid">sequenceDiagram
    participant L as Leader
    participant B as Block
    participant V as Validators
    L-&gt;&gt;B: Create Block Header
    L-&gt;&gt;B: Add Transactions
    L-&gt;&gt;B: Add State Updates
    L-&gt;&gt;B: Sign Block
    L-&gt;&gt;V: Broadcast Block
</pre>
<p>The block structure includes:</p>
<ul>
<li>Previous block reference</li>
<li>Timestamp</li>
<li>Transaction merkle root</li>
<li>UTXO state updates</li>
<li>Leader‚Äôs signature</li>
</ul>
<h2 id="consensus-process"><a class="header" href="#consensus-process">Consensus Process</a></h2>
<h3 id="1-block-validation"><a class="header" href="#1-block-validation">1. Block Validation</a></h3>
<pre class="mermaid">graph TD
    A[Receive Block] --&gt; B[Verify Leader]
    B --&gt; C[Verify Signatures]
    C --&gt; D[Execute Transactions]
    D --&gt; E[Verify UTXO States]
    E --&gt; F[Vote Decision]
</pre>
<p>When validators receive a new block:</p>
<ol>
<li>Verify the block producer is the designated leader</li>
<li>Validate all transaction signatures</li>
<li>Execute transactions and verify UTXO states</li>
<li>Check for any consensus rule violations</li>
</ol>
<h3 id="2-utxo-based-state-management"><a class="header" href="#2-utxo-based-state-management">2. UTXO-Based State Management</a></h3>
<pre class="mermaid">graph TD
    A[Transaction] --&gt; B[UTXO Validation]
    B --&gt; C[State Update]
    C --&gt; D[Bitcoin Transaction]
    D --&gt; E[Validator Signatures]

    B --&gt; F[Ownership Verification]
    B --&gt; G[Double-spend Check]
    B --&gt; H[Confirmation Check]

    C --&gt; I[Account Updates]
    C --&gt; J[Program State]
    C --&gt; K[UTXO Set Changes]
</pre>
<p>Arch‚Äôs unique approach to state management leverages Bitcoin‚Äôs UTXO model while extending it for smart contract functionality:</p>
<h4 id="utxo-state-tracking"><a class="header" href="#utxo-state-tracking">UTXO State Tracking</a></h4>
<pre><code class="language-rust ignore">pub struct UtxoState {
    pub meta: UtxoMeta,          // UTXO identification
    pub status: UtxoStatus,      // Current UTXO status
    pub owner: Pubkey,           // UTXO owner
    pub created_at: i64,         // Creation timestamp
    pub spent_at: Option&lt;i64&gt;,   // Spend timestamp if spent
}

pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h4 id="state-transition-process"><a class="header" href="#state-transition-process">State Transition Process</a></h4>
<ol>
<li>
<p><strong>UTXO Validation</strong></p>
<ul>
<li>Verify UTXO existence on Bitcoin</li>
<li>Check confirmation requirements (typically 6+)</li>
<li>Validate ownership and spending conditions</li>
<li>Prevent double-spending attempts</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Atomic account data modifications</li>
<li>Program state transitions</li>
<li>UTXO set updates</li>
<li>Cross-validator state consistency</li>
</ul>
</li>
<li>
<p><strong>Bitcoin Integration</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature aggregation</li>
<li>Transaction finality through Bitcoin confirmations</li>
<li>Reorg handling and state rollbacks</li>
</ul>
</li>
</ol>
<h4 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h4>
<ul>
<li>
<p><strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for ownership proofs</li>
<li>Threshold signature requirements</li>
</ul>
</li>
<li>
<p><strong>Double-spend Prevention</strong></p>
<ul>
<li>UTXO consumption tracking</li>
<li>Cross-validator consistency checks</li>
<li>Bitcoin-based finality guarantees</li>
</ul>
</li>
<li>
<p><strong>State Protection</strong></p>
<ul>
<li>Atomic state transitions</li>
<li>Rollback capability for reorgs</li>
<li>State root commitments</li>
<li>Multi-stage verification</li>
</ul>
</li>
</ul>
<h4 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h4>
<ul>
<li>UTXO caching for frequent access</li>
<li>Batch processing of state updates</li>
<li>Parallel transaction validation</li>
<li>Efficient UTXO lookup mechanisms</li>
</ul>
<p>This UTXO-based approach provides several advantages:</p>
<ol>
<li>Direct compatibility with Bitcoin‚Äôs security model</li>
<li>Natural support for atomic operations</li>
<li>Clear ownership and state transition rules</li>
<li>Built-in protection against double-spending</li>
<li>Simplified state verification and rollback</li>
</ol>
<h3 id="3-frost-signing-process"><a class="header" href="#3-frost-signing-process">3. FROST Signing Process</a></h3>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant C as Consensus
    V1-&gt;&gt;C: Share 1
    V2-&gt;&gt;C: Share 2
    V3-&gt;&gt;C: Share 3
    C-&gt;&gt;C: Aggregate Shares
    C-&gt;&gt;All: Final Signature
</pre>
<p>The FROST signing process involves:</p>
<ol>
<li>Each validator generates their partial signature</li>
<li>Signatures are shared among the threshold group</li>
<li>Partial signatures are aggregated into a final signature</li>
<li>The aggregated signature is verified against the group public key</li>
</ol>
<h3 id="4-roast-enhancement-layer"><a class="header" href="#4-roast-enhancement-layer">4. ROAST Enhancement Layer</a></h3>
<pre class="mermaid">graph TD
    A[Block Proposal] --&gt; B[FROST Signing]
    B --&gt; C[ROAST Protocol]
    C --&gt; D[Asynchronous Consensus]
    D --&gt; E[Block Finalization]
    E --&gt; F[Chain Extension]
</pre>
<p>ROAST transforms FROST into a production-ready consensus mechanism by adding several crucial enhancements:</p>
<h4 id="asynchronous-operation-guarantees"><a class="header" href="#asynchronous-operation-guarantees">Asynchronous Operation Guarantees</a></h4>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant N as Network

    Note over V1,N: Validator 1 experiences delay
    V2-&gt;&gt;N: Sign Share (t=1)
    V3-&gt;&gt;N: Sign Share (t=1)
    V1-&gt;&gt;N: Sign Share (t=3)
    Note over N: Protocol continues despite delay
    N-&gt;&gt;V1: Aggregate &amp; Finalize
    N-&gt;&gt;V2: Aggregate &amp; Finalize
    N-&gt;&gt;V3: Aggregate &amp; Finalize
</pre>
<p>Unlike traditional consensus mechanisms that require strict synchronization:</p>
<ul>
<li>Validators can participate in signing rounds without tight timing constraints</li>
<li>The protocol progresses even when some validators are temporarily delayed</li>
<li>Network partitions and varying message delivery times are handled gracefully</li>
<li>No assumptions about network synchrony are required for safety</li>
</ul>
<h4 id="byzantine-fault-tolerance"><a class="header" href="#byzantine-fault-tolerance">Byzantine Fault Tolerance</a></h4>
<pre class="mermaid">graph TD
    A[Validator Set] --&gt; B[Honest Majority]
    A --&gt; C[Byzantine Nodes]
    B --&gt; D[Valid Signatures]
    C --&gt; E[Detection System]
    E --&gt; F[Isolation]
    F --&gt; G[Protocol Progress]
</pre>
<p>ROAST maintains safety and liveness even in the presence of malicious actors:</p>
<ul>
<li>Tolerates up to f Byzantine validators where f &lt; n/3</li>
<li>Malicious behavior is detected and isolated</li>
<li>Signature shares from Byzantine validators can be identified and excluded</li>
<li>The protocol remains secure even if Byzantine validators:
<ul>
<li>Submit invalid signature shares</li>
<li>Attempt to sign conflicting blocks</li>
<li>Try to delay or prevent consensus</li>
<li>Collude with other malicious validators</li>
</ul>
</li>
</ul>
<h4 id="leader-rotation-mechanism"><a class="header" href="#leader-rotation-mechanism">Leader Rotation Mechanism</a></h4>
<pre class="mermaid">sequenceDiagram
    participant VS as Validator Set
    participant L1 as Leader 1
    participant L2 as Leader 2
    participant L3 as Leader 3

    Note over VS: Round r
    VS-&gt;&gt;L1: Select Leader
    Note over L1: Leader Timeout/Failure
    VS-&gt;&gt;L2: Backup Leader Takes Over
    Note over L2: Successful Block
    Note over VS: Round r+1
    VS-&gt;&gt;L3: New Leader Selection
</pre>
<p>ROAST implements a robust leader rotation system that:</p>
<ul>
<li>Deterministically selects leaders based on stake weight and randomness</li>
<li>Automatically rotates leaders to prevent centralization</li>
<li>Provides backup leaders in case of primary leader failure</li>
<li>Ensures fair distribution of block production opportunities</li>
<li>Maintains progress even when leaders fail or misbehave</li>
</ul>
<h4 id="liveness-guarantees"><a class="header" href="#liveness-guarantees">Liveness Guarantees</a></h4>
<pre class="mermaid">graph TD
    A[Network State] --&gt; B{Leader Active?}
    B --&gt;|Yes| C[Normal Operation]
    B --&gt;|No| D[Backup Leader]
    C --&gt; E[Progress]
    D --&gt; E
    E --&gt; F{Sufficient Signatures?}
    F --&gt;|Yes| G[Block Finalization]
    F --&gt;|No| H[Continue Collection]
    H --&gt; F
</pre>
<p>ROAST ensures the network continues to make progress through several mechanisms:</p>
<ol>
<li>
<p><strong>View Synchronization</strong></p>
<ul>
<li>Validators maintain a consistent view of network state</li>
<li>Recovery procedures for missed blocks or state updates</li>
<li>Automatic resynchronization after network partitions</li>
</ul>
</li>
<li>
<p><strong>Failure Recovery</strong></p>
<ul>
<li>Automatic detection of failed validators</li>
<li>Seamless transition to backup leaders</li>
<li>Recovery from temporary network failures</li>
<li>Rejoining procedures for validators that fall behind</li>
</ul>
</li>
<li>
<p><strong>Progress Conditions</strong></p>
<ul>
<li>Guaranteed block finalization when sufficient honest validators participate</li>
<li>No single validator can prevent progress</li>
<li>Continued operation during validator churn</li>
<li>Resilient to temporary network issues</li>
</ul>
</li>
<li>
<p><strong>Deadlock Prevention</strong></p>
<ul>
<li>No waiting for specific validators</li>
<li>Timeout mechanisms for unresponsive participants</li>
<li>Alternative paths for consensus when optimal path fails</li>
<li>Dynamic adjustment of protocol parameters</li>
</ul>
</li>
</ol>
<p>These enhancements make ROAST particularly well-suited for production environments where:</p>
<ul>
<li>Network conditions are unpredictable</li>
<li>Validators may join or leave the network</li>
<li>Malicious actors may attempt to disrupt consensus</li>
<li>High availability and reliability are required</li>
</ul>
<h2 id="fork-resolution"><a class="header" href="#fork-resolution">Fork Resolution</a></h2>
<pre class="mermaid">graph TD
    A[Fork Detection] --&gt; B[Weight Calculation]
    B --&gt; C[Heaviest Chain]
    C --&gt; D[Switch Decision]
    D --&gt; E[Chain Reorganization]
</pre>
<p>When forks occur:</p>
<ol>
<li>Validators identify competing chains</li>
<li>Calculate the weight of each fork based on stake</li>
<li>Apply the heaviest-chain rule</li>
<li>Coordinate chain reorganization if needed</li>
</ol>
<h2 id="understanding-frost"><a class="header" href="#understanding-frost">Understanding FROST</a></h2>
<p>FROST is a threshold signature scheme that enables a group of participants to collectively generate Schnorr signatures. This foundational protocol is crucial for Arch‚Äôs consensus mechanism because it provides a way to achieve distributed agreement while maintaining compatibility with Bitcoin‚Äôs native signature scheme.</p>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<ul>
<li><strong>Distributed Key Generation</strong>: Validators collectively participate in a process that generates a shared public key while keeping individual private key shares separate and secure.</li>
<li><strong>Threshold Signatures</strong>: The system requires a specific number of validators (t-of-n) to cooperate in order to produce valid signatures, balancing security with fault tolerance.</li>
<li><strong>Share Management</strong>: Each validator maintains their own private key share, contributing to the system‚Äôs security through distribution of trust.</li>
<li><strong>Signature Aggregation</strong>: Multiple partial signatures are combined into a single Schnorr signature that‚Äôs indistinguishable from a standard single-signer signature.</li>
</ul>
<h3 id="benefits-of-frost"><a class="header" href="#benefits-of-frost">Benefits of FROST</a></h3>
<ol>
<li>
<p><strong>Enhanced Security</strong></p>
<ul>
<li>No single validator can compromise the system</li>
<li>Distributed trust model eliminates single points of failure</li>
<li>Cryptographic guarantees of signature validity</li>
</ul>
</li>
<li>
<p><strong>Bitcoin Compatibility</strong></p>
<ul>
<li>Native integration with Bitcoin‚Äôs Schnorr signature scheme</li>
<li>No additional on-chain overhead</li>
<li>Seamless interaction with Bitcoin‚Äôs transaction validation</li>
</ul>
</li>
<li>
<p><strong>Efficiency</strong></p>
<ul>
<li>Constant-size signatures regardless of validator count</li>
<li>Optimized communication patterns</li>
<li>Reduced blockchain space usage</li>
</ul>
</li>
</ol>
<h2 id="roast-enhancing-frost-for-production"><a class="header" href="#roast-enhancing-frost-for-production">ROAST: Enhancing FROST for Production</a></h2>
<p>While FROST provides the cryptographic foundation, ROAST adds crucial properties needed for real-world deployment in adversarial environments. ROAST transforms FROST from a theoretical protocol into a production-ready consensus mechanism.</p>
<h3 id="key-enhancements"><a class="header" href="#key-enhancements">Key Enhancements</a></h3>
<ol>
<li>
<p><strong>Asynchronous Operation</strong></p>
<ul>
<li>Validators can participate without strict timing requirements</li>
<li>Resilient to network delays and partitions</li>
<li>Maintains liveness in real-world conditions</li>
</ul>
</li>
<li>
<p><strong>Robustness Against Attacks</strong></p>
<ul>
<li>Continues operating even with malicious participants</li>
<li>Detects and handles various forms of validator misbehavior</li>
<li>Provides provable security guarantees</li>
</ul>
</li>
<li>
<p><strong>Leader Selection</strong></p>
<ul>
<li>Efficient and fair leader rotation mechanism</li>
<li>Prevents centralization of power</li>
<li>Maintains system progress even if leaders fail</li>
</ul>
</li>
<li>
<p><strong>Liveness Guarantees</strong></p>
<ul>
<li>Ensures forward progress under adverse conditions</li>
<li>Handles validator churn gracefully</li>
<li>Recovers automatically from temporary failures</li>
</ul>
</li>
</ol>
<h2 id="archs-novel-implementation"><a class="header" href="#archs-novel-implementation">Arch‚Äôs Novel Implementation</a></h2>
<p>Arch‚Äôs implementation of ROAST/FROST represents a significant innovation in the blockchain space, particularly for Bitcoin-based smart contract platforms.</p>
<h3 id="unique-features"><a class="header" href="#unique-features">Unique Features</a></h3>
<ol>
<li>
<p><strong>Bitcoin-Native Design</strong></p>
<ul>
<li>Optimized for Bitcoin‚Äôs specific constraints and capabilities</li>
<li>Leverages Bitcoin‚Äôs security model</li>
<li>Minimizes on-chain footprint</li>
</ul>
</li>
<li>
<p><strong>Smart Contract Integration</strong></p>
<ul>
<li>Seamless combination with programmable logic</li>
<li>Maintains Bitcoin‚Äôs security guarantees</li>
<li>Enables complex decentralized applications</li>
</ul>
</li>
<li>
<p><strong>Scalable State Management</strong></p>
<ul>
<li>Efficient handling of state transitions</li>
<li>Parallel transaction processing where possible</li>
<li>Optimized validator resource usage</li>
</ul>
</li>
<li>
<p><strong>Economic Security</strong></p>
<ul>
<li>Carefully designed incentive structure</li>
<li>Slashing conditions for misbehavior</li>
<li>Aligned validator and network interests</li>
</ul>
</li>
</ol>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li><strong>Throughput</strong>: High transaction processing capacity without sacrificing decentralization</li>
<li><strong>Latency</strong>: Optimized confirmation times while maintaining security</li>
<li><strong>Resource Usage</strong>: Efficient use of network and computational resources</li>
<li><strong>Scalability</strong>: Linear scaling with validator count for most operations</li>
</ul>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<h3 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h3>
<ul>
<li><strong>Byzantine Validators</strong>: System remains secure with up to f Byzantine validators (where f &lt; n/3)</li>
<li><strong>Network Adversaries</strong>: Resilient against various network-level attacks</li>
<li><strong>Cryptographic Security</strong>: Based on well-studied cryptographic assumptions</li>
</ul>
<h3 id="security-properties-1"><a class="header" href="#security-properties-1">Security Properties</a></h3>
<ol>
<li>
<p><strong>Safety</strong></p>
<ul>
<li>No conflicting transactions can be confirmed</li>
<li>Cryptographic guarantees of transaction finality</li>
<li>Protection against double-spending</li>
</ul>
</li>
<li>
<p><strong>Liveness</strong></p>
<ul>
<li>System continues to make progress</li>
<li>Recovers from temporary failures</li>
<li>Handles validator set changes</li>
</ul>
</li>
<li>
<p><strong>Fault Tolerance</strong></p>
<ul>
<li>Continues operating with partial validator failures</li>
<li>Graceful degradation under attack</li>
<li>Automatic recovery mechanisms</li>
</ul>
</li>
</ol>
<h2 id="future-directions"><a class="header" href="#future-directions">Future Directions</a></h2>
<p>The ROAST/FROST consensus mechanism in Arch provides a solid foundation for future enhancements:</p>
<ol>
<li>
<p><strong>Scalability Improvements</strong></p>
<ul>
<li>Research into further optimization of signature aggregation</li>
<li>Investigation of layer-2 scaling solutions</li>
<li>Exploration of parallel processing techniques</li>
</ul>
</li>
<li>
<p><strong>Security Enhancements</strong></p>
<ul>
<li>Ongoing cryptographic research</li>
<li>Additional protection against emerging threats</li>
<li>Enhanced monitoring and detection systems</li>
</ul>
</li>
<li>
<p><strong>Feature Extensions</strong></p>
<ul>
<li>Support for more complex smart contract patterns</li>
<li>Enhanced cross-chain interoperability</li>
<li>Advanced state management techniques</li>
</ul>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<h3 id="academic-papers-and-research"><a class="header" href="#academic-papers-and-research">Academic Papers and Research</a></h3>
<h4 id="frost-flexible-round-optimized-schnorr-threshold-signatures"><a class="header" href="#frost-flexible-round-optimized-schnorr-threshold-signatures">FROST (Flexible Round-Optimized Schnorr Threshold Signatures)</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2020/852.pdf">FROST: Flexible Round-Optimized Schnorr Threshold Signatures</a> - The original FROST paper by Chelsea Komlo and Ian Goldberg</li>
<li><a href="https://eprint.iacr.org/2021/1110.pdf">Two-Round Threshold Schnorr Signatures with FROST</a> - An optimized two-round variant of FROST</li>
<li><a href="https://github.com/ZcashFoundation/frost">Implementing FROST</a> - Reference implementation by the Zcash Foundation</li>
</ul>
<h4 id="roast-robust-asynchronous-schnorr-threshold-signatures"><a class="header" href="#roast-robust-asynchronous-schnorr-threshold-signatures">ROAST (Robust Asynchronous Schnorr Threshold Signatures)</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2022/550.pdf">ROAST: Robust Asynchronous Schnorr Threshold Signatures</a> - The foundational ROAST paper</li>
<li><a href="https://medium.com/blockstream/implementing-threshold-signatures-for-bitcoin-8d3b63831325">Practical Threshold Signatures for Bitcoin</a> - Implementation insights for Bitcoin-based threshold signatures</li>
</ul>
<h4 id="threshold-cryptography-and-consensus"><a class="header" href="#threshold-cryptography-and-consensus">Threshold Cryptography and Consensus</a></h4>
<ul>
<li><a href="https://arxiv.org/pdf/1904.04098.pdf">A Survey of Distributed Consensus Protocols for Blockchain Networks</a> - Comprehensive overview of consensus mechanisms</li>
<li><a href="https://eprint.iacr.org/2019/1157.pdf">Threshold Signatures: The Future of Consensus?</a> - Analysis of threshold signatures in consensus protocols</li>
<li><a href="https://eprint.iacr.org/2018/068.pdf">Schnorr Multi-Signatures and Applications</a> - Foundational work on Schnorr multi-signatures</li>
</ul>
<h3 id="technical-resources"><a class="header" href="#technical-resources">Technical Resources</a></h3>
<h4 id="implementation-guides"><a class="header" href="#implementation-guides">Implementation Guides</a></h4>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP 340: Schnorr Signatures for secp256k1</a> - Bitcoin Improvement Proposal for Schnorr signatures</li>
<li><a href="https://tlu.tarilabs.com/cryptography/threshold-signatures">Implementing Threshold Signatures</a> - Technical guide on threshold signature implementation</li>
<li><a href="https://github.com/ZcashFoundation/redjubjub">Multi-Party Computation for Distributed Key Generation</a> - Reference implementation of distributed key generation</li>
</ul>
<h4 id="security-analysis"><a class="header" href="#security-analysis">Security Analysis</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2019/114.pdf">Security Analysis of Threshold Signature Schemes</a> - Comprehensive security analysis</li>
<li><a href="https://eprint.iacr.org/2021/1559.pdf">Formal Verification of FROST</a> - Formal security proofs for FROST</li>
<li><a href="https://arxiv.org/pdf/1908.01738.pdf">Byzantine Fault Tolerance in Distributed Systems</a> - Analysis of BFT in consensus protocols</li>
</ul>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><a href="https://frost.zfnd.org">FROST Working Group</a> - Community working group on FROST implementation</li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/">Bitcoin Dev Mailing List</a> - Discussions on threshold signatures in Bitcoin</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The combination of ROAST and FROST in Arch represents a significant advancement in Bitcoin-based smart contract platforms. This consensus mechanism enables sophisticated applications while maintaining the security and decentralization principles that make Bitcoin valuable. Through careful design and implementation, Arch has created a system that is not just theoretically sound but practically deployable and scalable for real-world applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program"><a class="header" href="#program">Program</a></h1>
<p>A program is a special kind of <a href="program/./accounts.html">account</a> that contains executable <a href="https://ebpf.io">eBPF</a> bytecode, denoted by the <code>Account.is_executable: true</code> field. This allows an account to receive arbitrary <a href="program/./instructions-and-messages.html#instructions">instruction</a> data via a <a href="program/./transaction.html">transaction</a> to be processed by the runtime.</p>
<p>Every program is stateless, meaning that it can only read/write data to other accounts and that it <strong>cannot</strong> write to its own account; this, in-part, is how parallelized execution is made possible (see <a href="program/program.html#4-state">State</a> for more info).</p>
<blockquote>
<p>üí° Additionally, programs can send instructions to other programs which, in turn, receive instructions and thus extend program composability further. This is known as cross-program invocation (CPI) and will be detailed in future sections.</p>
</blockquote>
<h3 id="components"><a class="header" href="#components">Components:</a></h3>
<h4 id="1-entrypoint"><a class="header" href="#1-entrypoint">1. <a href="program/./entrypoint.html">Entrypoint</a></a></h4>
<p>Every Arch program includes a single entrypoint used to invoke the program. A <a href="program/./entrypoint.html#handler-function">handler function</a>, often named <code>process_instruction</code>, is then used to handle the data passed into the entrypoint.</p>
<p><em>These parameters are required for every <a href="program/./instructions-and-messages.html#instructions">instruction</a> to be processed.</em>_</p>
<pre><code class="language-rust ignore">use arch_program::entrypoint;
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    // Program logic here
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<h4 id="2-instruction"><a class="header" href="#2-instruction">2. <a href="program/./instructions-and-messages.html#instructions">Instruction</a></a></h4>
<p>The <code>instruction_data</code> is deserialized after being passed into the entrypoint. From there, if there are multiple instructions, a <code>match</code> statement can be utilized to point the logic flow to the appropriate handler function previously defined within the program which can continue processing the instruction.</p>
<h4 id="3-process-instruction"><a class="header" href="#3-process-instruction">3. Process Instruction</a></h4>
<p>If a program has multiple instructions, a corresponding <a href="program/./entrypoint.html#handler-function">handler function</a> should be defined to include the specific logic unique to the instruction.</p>
<h4 id="4-state"><a class="header" href="#4-state">4. State</a></h4>
<p>Since programs are stateless, a ‚Äúdata‚Äù <a href="program/./accounts.html">account</a> is needed to hold state for a user. This is a non-executable account that holds program data.</p>
<p>If a program receives instruction that results in a user‚Äôs state being altered, the program would manage this user‚Äôs state via a mapping within the program‚Äôs logic. This mapping would link the user‚Äôs <a href="program/./pubkey.html">pubkey</a> with a data <a href="program/./accounts.html">account</a> where the state would live for that specific program.</p>
<p>The program will likely include a struct to define the structure of its state and make it easier to work with. The deserialization of account data occurs during program invocation. After an update is made, state data gets re-serialized into a byte array and stored within the <code>data</code> field of the <a href="program/./accounts.html">account</a>.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-unspent-transaction-output"><a class="header" href="#utxo-unspent-transaction-output">UTXO (Unspent Transaction Output)</a></h1>
<p>UTXOs (Unspent Transaction Outputs) are fundamental to Bitcoin‚Äôs transaction model and serve as the foundation for state management in Arch Network. Unlike account-based systems that track balances, UTXOs represent discrete ‚Äúcoins‚Äù that must be consumed entirely in transactions.</p>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="what-is-a-utxo"><a class="header" href="#what-is-a-utxo">What is a UTXO?</a></h3>
<ul>
<li>A UTXO represents an unspent output from a previous transaction</li>
<li>Each UTXO is uniquely identified by a transaction ID (txid) and output index (vout)</li>
<li>UTXOs are immutable - they can only be created or spent, never modified</li>
<li>Once spent, a UTXO cannot be reused (prevents double-spending)</li>
</ul>
<h3 id="role-in-arch-network"><a class="header" href="#role-in-arch-network">Role in Arch Network</a></h3>
<ul>
<li>UTXOs anchor program state to Bitcoin‚Äôs security model</li>
<li>They provide deterministic state transitions</li>
<li>Enable atomic operations across the network</li>
<li>Allow for provable ownership and state validation</li>
</ul>
<h2 id="utxo-structure"><a class="header" href="#utxo-structure">UTXO Structure</a></h2>
<p>The <code>UtxoMeta</code> struct encapsulates the core UTXO identification data:</p>
<pre><code class="language-rust ignore">use arch_program::utxo::UtxoMeta;
use bitcoin::Txid;

#[derive(Debug, Clone, PartialEq)]
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Bitcoin transaction ID (32 bytes)
    pub vout: u32,       // Output index in the transaction
}

impl UtxoMeta {
    /// Creates a new UTXO metadata instance
    pub fn new(txid: [u8; 32], vout: u32) -&gt; Self {
        Self { txid, vout }
    }

    /// Deserializes UTXO metadata from a byte slice
    /// Format: [txid(32 bytes)][vout(4 bytes)]
    pub fn from_slice(data: &amp;[u8]) -&gt; Self {
        let mut txid = [0u8; 32];
        txid.copy_from_slice(&amp;data[0..32]);
        let vout = u32::from_le_bytes([
            data[32], data[33], data[34], data[35]
        ]);
        Self { txid, vout }
    }
}</code></pre>
<h2 id="utxo-lifecycle"><a class="header" href="#utxo-lifecycle">UTXO Lifecycle</a></h2>
<h3 id="1-creation-process"><a class="header" href="#1-creation-process">1. Creation Process</a></h3>
<h4 id="creating-a-utxo-with-bitcoin-rpc"><a class="header" href="#creating-a-utxo-with-bitcoin-rpc">Creating a UTXO with Bitcoin RPC</a></h4>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client as RpcClient, RpcApi};
use bitcoin::{Amount, Address};
use arch_program::pubkey::Pubkey;

// Initialize Bitcoin RPC client
let rpc = RpcClient::new(
    "http://localhost:18443",  // Bitcoin node RPC endpoint
    Auth::UserPass(
        "user".to_string(),
        "pass".to_string()
    )
).expect("Failed to create RPC client");

// Generate a new account address
let account_address = Pubkey::new_unique();
let btc_address = Address::from_pubkey(&amp;account_address);

// Create UTXO by sending Bitcoin
// Parameters explained:
// - address: Destination Bitcoin address
// - amount: Amount in satoshis (3000 sats = 0.00003 BTC)
// - comment: Optional transaction comment
// - replaceable: Whether the tx can be replaced (RBF)
let txid = rpc.send_to_address(
    &amp;btc_address,
    Amount::from_sat(3000),
    Some("Create Arch UTXO"),  // Comment
    None,                      // Comment_to
    Some(true),               // Replaceable
    None,                     // Fee rate
    None,                     // Fee estimate mode
    None                      // Avoid reuse
)?;

// Wait for confirmation (recommended)
rpc.wait_for_confirmation(&amp;txid, 1)?;</code></pre>
<h4 id="creating-an-arch-account-with-utxo"><a class="header" href="#creating-an-arch-account-with-utxo">Creating an Arch Account with UTXO</a></h4>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction::SystemInstruction,
    pubkey::Pubkey,
    transaction::Transaction,
};

// Create new program account backed by UTXO
let account_pubkey = Pubkey::new_unique();
let instruction = SystemInstruction::new_create_account_instruction(
    txid.try_into().unwrap(),
    0,  // vout index
    account_pubkey,
    // Additional parameters like:
    // - space: Amount of space to allocate
    // - owner: Program that owns the account
);

// Build and sign transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[instruction],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer],
    recent_blockhash
);</code></pre>
<h3 id="2-state-management"><a class="header" href="#2-state-management">2. State Management</a></h3>
<pre><code class="language-rust ignore">// Example UTXO state tracking
#[derive(Debug)]
pub struct UtxoState {
    pub meta: UtxoMeta,
    pub status: UtxoStatus,
    pub owner: Pubkey,
    pub created_at: i64,
    pub spent_at: Option&lt;i64&gt;,
}

#[derive(Debug)]
pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<p>Common UTXO-related errors to handle:</p>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound,                    // UTXO doesn't exist
    AlreadySpent,               // UTXO was already consumed
    InsufficientConfirmations,  // Not enough confirmations
    InvalidOwner,               // Unauthorized attempt to spend
    Reorged,                    // UTXO invalidated by reorg
    InvalidVout,                // Output index doesn't exist
    SerializationError,         // Data serialization failed
}</code></pre>
<h2 id="related-topics-1"><a class="header" href="#related-topics-1">Related Topics</a></h2>
<ul>
<li><a href="program/account.html">Account Model</a> - How UTXOs relate to Arch accounts</li>
<li><a href="program/program.html">Program State</a> - Using UTXOs for program state</li>
<li><a href="program/../system-program/system-program.html">System Program</a> - Core UTXO operations</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-guide"><a class="header" href="#account-guide">Account Guide</a></h1>
<blockquote>
<p><strong>Navigation</strong>: <a href="program/../SUMMARY.html#reference">Reference</a> ‚Üí <a href="program/./program.html">Program</a> ‚Üí Account Guide</p>
<p>For the core account structure and data types, see <a href="program/./account.html">Account Structure</a>.</p>
</blockquote>
<p>Accounts are the fundamental building blocks for state management and program interaction in Arch Network. They serve as containers for both program code and state data, bridging the gap between Bitcoin‚Äôs UTXO model and modern programmable state machines.</p>
<blockquote>
<p><strong>Note</strong>: For detailed documentation on core system functions used to interact with accounts (like <code>invoke</code>, <code>new_create_account_instruction</code>, <code>add_state_transition</code>, and <code>set_transaction_to_sign</code>), see <a href="program/./system-functions.html">System Functions</a>.</p>
</blockquote>
<pre class="mermaid">flowchart TD
    A[Account] --&gt; B[Program Account]
    A --&gt; C[Data Account]
    A --&gt; D[Native Account]
    B --&gt; E[Executable Code]
    C --&gt; F[Program State]
    C --&gt; G[UTXOs]
    D --&gt; H[System Operations]

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#f5f5f5,stroke:#666
    style C fill:#f5f5f5,stroke:#666
    style D fill:#f5f5f5,stroke:#666
</pre>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<h3 id="account-fundamentals"><a class="header" href="#account-fundamentals">Account Fundamentals</a></h3>
<p>Every account in Arch Network is uniquely identified by a public key (pubkey) and contains four essential components:</p>
<pre><code class="language-rust ignore">pub struct Account {
    /// The program that owns this account
    pub owner: Pubkey,
    /// Number of lamports assigned to this account
    pub lamports: u64,
    /// Data held in this account
    pub data: Vec&lt;u8&gt;,
    /// Whether this account can process instructions
    pub executable: bool,
}</code></pre>
<h4 id="component-details"><a class="header" href="#component-details">Component Details:</a></h4>
<ol>
<li>
<p><strong>Owner (Pubkey)</strong></p>
<ul>
<li>Controls account modifications</li>
<li>Determines which program can modify data</li>
<li>Can be transferred to new programs</li>
<li>Required for all accounts</li>
</ul>
</li>
<li>
<p><strong>Lamports (u64)</strong></p>
<ul>
<li>Native token balance</li>
<li>Used for:
<ul>
<li>Transaction fees</li>
<li>Rent payments</li>
<li>State storage costs</li>
<li>Program execution fees</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Data (Vec<u8>)</strong></p>
<ul>
<li>Flexible byte array for state storage</li>
<li>Common uses:
<ul>
<li>Program code (if executable)</li>
<li>Program state</li>
<li>UTXO metadata</li>
<li>Configuration data</li>
</ul>
</li>
<li>Size determined at creation</li>
</ul>
</li>
<li>
<p><strong>Executable Flag (bool)</strong></p>
<ul>
<li>Determines if account contains program code</li>
<li>Immutable after deployment</li>
<li>Controls instruction processing capability</li>
</ul>
</li>
</ol>
<pre class="mermaid">flowchart LR
    A[Account Creation] --&gt; B[Initial State]
    B --&gt; C[Runtime Operations]
    C --&gt; D[State Updates]
    D --&gt; E[Account Closure]
    
    subgraph Lifecycle
        A -. Initialize .-&gt; B
        B -. Process Instructions .-&gt; C
        C -. Modify State .-&gt; D
        D -. Cleanup .-&gt; E
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#9ff,stroke:#333,stroke-width:2px
    style Lifecycle fill:#f5f5f5,stroke:#666,stroke-width:1px
</pre>
<h2 id="account-types--use-cases"><a class="header" href="#account-types--use-cases">Account Types &amp; Use Cases</a></h2>
<h3 id="1-program-accounts"><a class="header" href="#1-program-accounts">1. Program Accounts</a></h3>
<p>Program accounts contain executable code and form the backbone of Arch Network‚Äôs programmable functionality.</p>
<pre><code class="language-rust ignore">// Example program account creation
let program_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(program_data.len()),
    space: program_data.len() as u64,
    owner: bpf_loader::id(),  // BPF Loader owns program accounts
    executable: true,
    data: program_data,
};</code></pre>
<p>Key characteristics:</p>
<ul>
<li>Immutable after deployment</li>
<li>Owned by BPF loader</li>
<li>Contains verified program code</li>
<li>Processes instructions</li>
</ul>
<h3 id="2-data-accounts"><a class="header" href="#2-data-accounts">2. Data Accounts</a></h3>
<p>Data accounts store program state and user data. They‚Äôre highly flexible and can be structured to meet various needs.</p>
<pre><code class="language-rust ignore">// Example data structure for a game account
#[derive(BorshSerialize, BorshDeserialize)]
pub struct GameAccount {
    pub player: Pubkey,
    pub score: u64,
    pub level: u8,
    pub achievements: Vec&lt;Achievement&gt;,
    pub last_played: i64,
}

// Creating a data account
let game_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;GameAccount&gt;()),
    space: size_of::&lt;GameAccount&gt;() as u64,
    owner: game_program::id(),
    executable: false,
    data: Vec::new(),  // Will be initialized by program
};</code></pre>
<p>Common use cases:</p>
<ul>
<li>Player profiles</li>
<li>Game state</li>
<li>DeFi positions</li>
<li>NFT metadata</li>
<li>Configuration settings</li>
</ul>
<h3 id="3-utxo-accounts"><a class="header" href="#3-utxo-accounts">3. UTXO Accounts</a></h3>
<p>Special data accounts that bridge Bitcoin UTXOs with Arch Network state.</p>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: UtxoState,
    pub created_at: i64,
    pub last_updated: i64,
    pub constraints: Vec&lt;UtxoConstraint&gt;,
}

// Example UTXO account creation
let utxo_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;UtxoAccount&gt;()),
    space: size_of::&lt;UtxoAccount&gt;() as u64,
    owner: utxo_program::id(),
    executable: false,
    data: Vec::new(),
};</code></pre>
<h2 id="account-interactions"><a class="header" href="#account-interactions">Account Interactions</a></h2>
<p>Account interactions in Arch Network are facilitated through a set of core system functions. These functions handle everything from account creation to state transitions and are documented in detail in <a href="program/./system-functions.html">System Functions</a>. Below are common patterns for account interactions:</p>
<h3 id="1-creation-patterns"><a class="header" href="#1-creation-patterns">1. Creation Patterns</a></h3>
<pre><code class="language-rust ignore">// 1. Basic account creation
pub fn create_basic_account(
    payer: &amp;Keypair,
    space: u64,
    owner: &amp;Pubkey,
) -&gt; Result&lt;Keypair, Error&gt; {
    let account = Keypair::new();
    let rent = banks_client.get_rent().await?;
    let lamports = rent.minimum_balance(space as usize);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;account.pubkey(),
        lamports,
        space,
        owner,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[ix],
        Some(&amp;payer.pubkey()),
        &amp;[payer, &amp;account],
        recent_blockhash,
    );
    
    banks_client.process_transaction(tx).await?;
    Ok(account)
}

// 2. PDA (Program Derived Address) creation
pub fn create_pda_account(
    program_id: &amp;Pubkey,
    seeds: &amp;[&amp;[u8]],
    space: u64,
) -&gt; Result&lt;Pubkey, Error&gt; {
    let (pda, bump) = Pubkey::find_program_address(seeds, program_id);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;pda,
        lamports,
        space,
        program_id,
    );
    
    // Include the bump seed for deterministic address
    let seeds_with_bump = &amp;[&amp;seeds[..], &amp;[&amp;[bump]]].concat();
    let signer_seeds = &amp;[&amp;seeds_with_bump[..]];
    
    invoke_signed(&amp;ix, &amp;[payer, pda], signer_seeds)?;
    Ok(pda)
}</code></pre>
<h3 id="2-state-management-1"><a class="header" href="#2-state-management-1">2. State Management</a></h3>
<pre><code class="language-rust ignore">// Example of managing account state
pub trait AccountState: Sized {
    fn try_from_slice(data: &amp;[u8]) -&gt; Result&lt;Self, Error&gt;;
    fn try_serialize(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
    
    fn load(account: &amp;AccountInfo) -&gt; Result&lt;Self, Error&gt; {
        Self::try_from_slice(&amp;account.data.borrow())
    }
    
    fn save(&amp;self, account: &amp;AccountInfo) -&gt; Result&lt;(), Error&gt; {
        let data = self.try_serialize()?;
        let mut account_data = account.data.borrow_mut();
        account_data[..data.len()].copy_from_slice(&amp;data);
        Ok(())
    }
}

// Implementation example
impl AccountState for GameAccount {
    fn update_score(&amp;mut self, new_score: u64) -&gt; Result&lt;(), Error&gt; {
        self.score = new_score;
        self.last_played = Clock::get()?.unix_timestamp;
        Ok(())
    }
}</code></pre>
<h3 id="3-cross-program-invocation-cpi"><a class="header" href="#3-cross-program-invocation-cpi">3. Cross-Program Invocation (CPI)</a></h3>
<pre><code class="language-rust ignore">// Example of one program calling another
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    // Deserialize accounts
    let account_info_iter = &amp;mut accounts.iter();
    let source_info = next_account_info(account_info_iter)?;
    let dest_info = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;
    
    // Create CPI context
    let cpi_accounts = Transfer {
        from: source_info.clone(),
        to: dest_info.clone(),
    };
    let cpi_program = system_program.clone();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    
    // Perform cross-program invocation
    transfer(cpi_ctx, amount)?;
    
    Ok(())
}</code></pre>
<h2 id="security-considerations-4"><a class="header" href="#security-considerations-4">Security Considerations</a></h2>
<h3 id="1-access-control"><a class="header" href="#1-access-control">1. Access Control</a></h3>
<pre><code class="language-rust ignore">fn verify_account_access(
    account: &amp;AccountInfo,
    expected_owner: &amp;Pubkey,
    writable: bool,
) -&gt; ProgramResult {
    // Check account ownership
    if account.owner != expected_owner {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Verify write permission if needed
    if writable &amp;&amp; !account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Additional checks...
    Ok(())
}</code></pre>
<h3 id="2-data-validation"><a class="header" href="#2-data-validation">2. Data Validation</a></h3>
<pre><code class="language-rust ignore">fn validate_account_data&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    validate_fn: impl Fn(&amp;T) -&gt; bool,
) -&gt; ProgramResult {
    // Load and validate account data
    let data = T::load(account)?;
    if !validate_fn(&amp;data) {
        return Err(ProgramError::InvalidAccountData);
    }
    Ok(())
}</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-account-management"><a class="header" href="#1-account-management">1. Account Management</a></h3>
<ul>
<li>Always validate account ownership before modifications</li>
<li>Use PDAs for deterministic addresses</li>
<li>Implement proper error handling</li>
<li>Close unused accounts to reclaim rent</li>
</ul>
<h3 id="2-data-safety"><a class="header" href="#2-data-safety">2. Data Safety</a></h3>
<ul>
<li>Validate all input data</li>
<li>Use proper serialization</li>
<li>Handle account size limits</li>
<li>Implement atomic operations</li>
</ul>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<ul>
<li>Minimize account creations</li>
<li>Batch operations when possible</li>
<li>Use appropriate data structures</li>
<li>Cache frequently accessed data</li>
</ul>
<h3 id="4-upgrades"><a class="header" href="#4-upgrades">4. Upgrades</a></h3>
<ul>
<li>Plan for version management</li>
<li>Implement migration strategies</li>
<li>Use flexible data structures</li>
<li>Document state changes</li>
</ul>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="1-account-initialization"><a class="header" href="#1-account-initialization">1. Account Initialization</a></h3>
<pre><code class="language-rust ignore">pub fn initialize_account&lt;T: AccountState&gt;(
    program_id: &amp;Pubkey,
    account: &amp;AccountInfo,
    initial_state: T,
) -&gt; ProgramResult {
    // Verify account is uninitialized
    if !account.data_is_empty() {
        return Err(ProgramError::AccountAlreadyInitialized);
    }
    
    // Set account owner
    account.set_owner(program_id)?;
    
    // Initialize state
    initial_state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="2-account-updates"><a class="header" href="#2-account-updates">2. Account Updates</a></h3>
<pre><code class="language-rust ignore">pub fn update_account&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    update_fn: impl FnOnce(&amp;mut T) -&gt; ProgramResult,
) -&gt; ProgramResult {
    // Load current state
    let mut state = T::load(account)?;
    
    // Apply update
    update_fn(&amp;mut state)?;
    
    // Save updated state
    state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="3-account-closure"><a class="header" href="#3-account-closure">3. Account Closure</a></h3>
<pre><code class="language-rust ignore">pub fn close_account(
    account: &amp;AccountInfo,
    destination: &amp;AccountInfo,
) -&gt; ProgramResult {
    // Transfer lamports
    let dest_starting_lamports = destination.lamports();
    **destination.lamports.borrow_mut() = dest_starting_lamports
        .checked_add(account.lamports())
        .ok_or(ProgramError::Overflow)?;
    **account.lamports.borrow_mut() = 0;
    
    // Clear data
    account.data.borrow_mut().fill(0);
    
    Ok(())
}</code></pre>
<h2 id="related-topics-2"><a class="header" href="#related-topics-2">Related Topics</a></h2>
<ul>
<li><a href="program/./utxo.html">UTXOs</a> - How UTXOs integrate with accounts</li>
<li><a href="program/./program.html">Programs</a> - Programs that own and modify accounts</li>
<li><a href="program/./instructions-and-messages.html">Instructions</a> - How to interact with accounts</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructions-and-messages"><a class="header" href="#instructions-and-messages">Instructions and Messages</a></h1>
<p>Instructions and messages are fundamental components of Arch‚Äôs transaction processing system that enable communication between clients and <a href="program/./program.html">programs</a>. They form the basis for all state changes and interactions within the Arch network.</p>
<h3 id="instructions-2"><a class="header" href="#instructions-2">Instructions</a></h3>
<p>An instruction is the basic unit of program execution in Arch. It contains all the information needed for a <a href="program/./program.html">program</a> to execute a specific operation. Instructions are processed atomically, meaning they either complete entirely or have no effect.</p>
<h4 id="structure"><a class="header" href="#structure">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Instruction {
    /// Program ID that executes this instruction
    pub program_id: Pubkey,
    /// Accounts required for this instruction
    pub accounts: Vec&lt;AccountMeta&gt;,
    /// Instruction data
    pub data: Vec&lt;u8&gt;,
}</code></pre>
<h4 id="components-1"><a class="header" href="#components-1">Components:</a></h4>
<ol>
<li><strong>Program ID</strong>: The <a href="program/./pubkey.html">pubkey</a> of the <a href="program/./program.html">program</a> that will process the instruction</li>
<li><strong>Accounts</strong>: List of accounts required for the instruction, with their metadata</li>
<li><strong>Instruction Data</strong>: Custom data specific to the instruction, typically serialized using Borsh or another format</li>
</ol>
<h4 id="account-metadata"><a class="header" href="#account-metadata">Account Metadata</a></h4>
<pre><code class="language-rust ignore">pub struct AccountMeta {
    pub pubkey: Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
}</code></pre>
<ul>
<li><code>pubkey</code>: The account‚Äôs public key</li>
<li><code>is_signer</code>: Whether the account must sign the transaction</li>
<li><code>is_writable</code>: Whether the account‚Äôs data can be modified</li>
</ul>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>A message is a collection of instructions that form a <a href="program/./transaction.html">transaction</a>. Messages ensure atomic execution of multiple instructions, meaning either all instructions succeed or none take effect.</p>
<h4 id="structure-1"><a class="header" href="#structure-1">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Message {
    /// List of account keys referenced by the instructions
    pub account_keys: Vec&lt;Pubkey&gt;,
    /// Recent blockhash
    pub recent_blockhash: Hash,
    /// List of instructions to execute
    pub instructions: Vec&lt;CompiledInstruction&gt;,
}</code></pre>
<h4 id="components-2"><a class="header" href="#components-2">Components:</a></h4>
<ol>
<li><strong>Account Keys</strong>: All unique accounts referenced across instructions</li>
<li><strong>Recent Blockhash</strong>: Used for transaction uniqueness and timeout</li>
<li><strong>Instructions</strong>: List of instructions to execute in sequence</li>
</ol>
<h3 id="instruction-processing-flow"><a class="header" href="#instruction-processing-flow">Instruction Processing Flow:</a></h3>
<ol>
<li>
<p>Client creates an instruction with:</p>
<ul>
<li><a href="program/./program.html">Program</a> ID to execute the instruction</li>
<li>Required accounts with appropriate permissions</li>
<li>Instruction-specific data (serialized parameters)</li>
</ul>
</li>
<li>
<p>Instruction(s) are bundled into a message:</p>
<ul>
<li>Multiple instructions can be atomic</li>
<li>Account permissions are consolidated</li>
<li>Blockhash is included for uniqueness</li>
</ul>
</li>
<li>
<p>Message is signed to create a <a href="program/./transaction.html">transaction</a>:</p>
<ul>
<li>All required signers must sign</li>
<li>Transaction size limits apply</li>
<li>Fees are calculated</li>
</ul>
</li>
<li>
<p>Transaction is sent to the network:</p>
<ul>
<li>Validated by validators</li>
<li>Processed in parallel when possible</li>
<li>Results are confirmed</li>
</ul>
</li>
<li>
<p>Program processes the instruction:</p>
<ul>
<li>Deserializes instruction data</li>
<li>Validates accounts and permissions</li>
<li>Executes operation</li>
<li>Updates account state</li>
</ul>
</li>
</ol>
<h3 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices:</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account permissions</li>
<li>Validate account relationships</li>
</ul>
</li>
<li>
<p><strong>Data Serialization</strong></p>
<ul>
<li>Use consistent serialization format (preferably Borsh)</li>
<li>Include version information</li>
<li>Handle errors gracefully</li>
<li>Validate data lengths</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Return specific error types</li>
<li>Provide clear error messages</li>
<li>Handle all edge cases</li>
<li>Implement proper cleanup</li>
</ul>
</li>
</ol>
<h3 id="cross-program-invocation-cpi-1"><a class="header" href="#cross-program-invocation-cpi-1">Cross-Program Invocation (CPI)</a></h3>
<p>Instructions can invoke other <a href="program/./program.html">programs</a> through CPI, enabling composability:</p>
<ol>
<li>
<p>Create new instruction for target program:</p>
<ul>
<li>Specify program ID</li>
<li>Include required accounts</li>
<li>Prepare instruction data</li>
</ul>
</li>
<li>
<p>Pass required accounts:</p>
<ul>
<li>Include all necessary accounts</li>
<li>Set proper permissions</li>
<li>Handle PDA derivation</li>
</ul>
</li>
<li>
<p>Invoke using <code>invoke</code> or <code>invoke_signed</code>:</p>
<ul>
<li>For regular accounts: <code>invoke</code></li>
<li>For PDAs: <code>invoke_signed</code></li>
<li>Handle return values</li>
</ul>
</li>
<li>
<p>Handle results:</p>
<ul>
<li>Check return status</li>
<li>Process any returned data</li>
<li>Handle errors appropriately</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-5"><a class="header" href="#security-considerations-5">Security Considerations:</a></h3>
<ol>
<li>
<p><strong>Account Verification</strong></p>
<ul>
<li>Verify all account permissions</li>
<li>Check ownership and signatures</li>
<li>Validate account relationships</li>
<li>Prevent privilege escalation</li>
</ul>
</li>
<li>
<p><strong>Data Validation</strong></p>
<ul>
<li>Sanitize all input data</li>
<li>Check buffer lengths</li>
<li>Validate numerical ranges</li>
<li>Prevent integer overflow</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Maintain atomic operations</li>
<li>Handle partial failures</li>
<li>Prevent race conditions</li>
<li>Ensure consistent state</li>
</ul>
</li>
</ol>
<h3 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns:</a></h3>
<ol>
<li>
<p><strong>Initialization</strong></p>
<ul>
<li>Create necessary accounts</li>
<li>Set initial state</li>
<li>Assign proper ownership</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Validate permissions</li>
<li>Update account data</li>
<li>Maintain invariants</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close accounts when done</li>
<li>Manage PDAs properly</li>
</ul>
</li>
</ol>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscalls"><a class="header" href="#syscalls">Syscalls</a></h1>
<p>A syscall is a function that can be used to obtain information from the underlying virtual machine.</p>
<pre><code class="language-rust ignore">// Used for cross-program invocation (CPI)

// Invokes a cross-program call
define_syscall!(fn sol_invoke_signed_rust(instruction_addr: *const u8, account_infos_addr: *const u8, account_infos_len: u64) -&gt; u64);

// Sets the data to be returned for the cross-program invocation
define_syscall!(fn sol_set_return_data(data: *const u8, length: u64));

// Returns the cross-program invocation data
define_syscall!(fn sol_get_return_data(data: *mut u8, length: u64, program_id: *mut Pubkey) -&gt; u64);

// Arch

// Validates and sets up transaction for being signed
define_syscall!(fn arch_set_transaction_to_sign(transaction_to_sign: *const TransactionToSign));

// Retrieves raw Bitcoin transaction from RPC and copies into memory buffer
define_syscall!(fn arch_get_bitcoin_tx(data: *mut u8, length: u64, txid: &amp;[u8; 32]) -&gt; u64);

// Retrieves the multi-sig public key and copies into memory buffer
define_syscall!(fn arch_get_network_xonly_pubkey(data: *mut u8) -&gt; u64);

// Validates ownership of a Bitcoin UTXO against a public key
define_syscall!(fn arch_validate_utxo_ownership(utxo: *const UtxoMeta, owner: *const Pubkey) -&gt; u64);

// Generates a Bitcoin script public key and copies into memory buffer
define_syscall!(fn arch_get_account_script_pubkey(script: *mut u8, pubkey: *const Pubkey) -&gt; u64);

// Retrieves the latest Bitcoin block height
define_syscall!(fn arch_get_bitcoin_block_height() -&gt; u64);

// logs

// Prints the hexidecimal representation of a string slice to stdout
define_syscall!(fn sol_log_(message: *const u8, len: u64));

// Prints 64-bit values represented as hexadecimal to stdout
define_syscall!(fn sol_log_64_(arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64));

// Prints the hexidecimal representation of a public key to stdout
define_syscall!(fn sol_log_pubkey(pubkey_addr: *const u8));

// Prints the base64 representation of a data array to stdout
define_syscall!(fn sol_log_data(data: *const u8, data_len: u64));</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/syscalls/definitions.rs">syscalls/definition.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Let‚Äôs introduce the nodes that comprise the Arch Network stack in greater detail.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Bootnode</a></p>
<div style="display: flex; align-items: flex-start; gap: 20px;">
<div>
The bootnode works similarly to DNS seeds in Bitcoin whereby the server handles the first connection to nodes joining the Arch Network.
</div>
<img src="concepts/../images/bootnode.png" alt="Bootnode" style="width: 200px; flex-shrink: 0;" />
</div>
<p><a href="https://github.com/Arch-Network/arch-node">Leader</a></p>
<p>All signing is coordinated by the leader. Ultimately, the leader submits signed Bitcoin transactions to the Bitcoin network following program execution.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Validator</a></p>
<p>This node represents a generic node operated by another party. It performs the validator role and has a share in the network‚Äôs distributed signing key. The leader node passes transactions to validator nodes to validate and sign. After enough signatures have been collected (a threshold has been met), the leader can then submit a fully signed Bitcoin transaction to the Bitcoin network.</p>
<p>The validator node also runs the <a href="https://ebpf.io/">eBPF</a> virtual machine and executes the transactions asynchronously alongside the other validator nodes in the network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a></p>
<p>This validator is a lightweight server that only serves as an RPC for developers to get up and running quickly with the least amount of overhead. It simulates a single-node blockchain environment that is meant for efficient, rapid development.</p>
<blockquote>
<p>Note: the <a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a> node uses the same image as the <a href="https://github.com/Arch-Network/arch-node">Validator</a> node though operates singularly for maximum efficiency. You can start a lightweight validator using the <code>arch-cli validator start</code> command.</p>
</blockquote>
<p>More can be read about the Arch Network architecture in our <a href="https://docs.arch.network">docs</a>.</p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-reference"><a class="header" href="#sdk-reference">SDK Reference</a></h1>
<p>The Arch Network SDK provides type definitions and utilities for building applications on the Arch Network. This section covers the core data structures and types you‚Äôll work with when developing programs or interacting with the network.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="runtime-transaction"><a class="header" href="#runtime-transaction"><a href="sdk/runtime-transaction.html">Runtime Transaction</a></a></h3>
<p>The fundamental transaction type that gets processed by the Arch Network runtime. Contains version information, signatures, and a message with instructions.</p>
<h3 id="processed-transaction"><a class="header" href="#processed-transaction"><a href="sdk/processed-transaction.html">Processed Transaction</a></a></h3>
<p>A wrapper around Runtime Transaction that includes execution status and associated Bitcoin transaction IDs. This is what you‚Äôll receive from RPC methods like <code>get_processed_transaction</code>.</p>
<h3 id="signature"><a class="header" href="#signature"><a href="sdk/signature.html">Signature</a></a></h3>
<p>Digital signature implementation used to authenticate transactions and instructions.</p>
<h2 id="sdk-libraries"><a class="header" href="#sdk-libraries">SDK Libraries</a></h2>
<p>For development, use the official SDK libraries:</p>
<ul>
<li><strong>TypeScript/JavaScript</strong>: <code>@saturnbtcio/arch-sdk</code></li>
<li><strong>Rust</strong>: <code>arch_sdk</code> crate</li>
</ul>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The complete SDK source code is available on <a href="https://github.com/Arch-Network/arch-sdk/tree/main/sdk/">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-transaction-1"><a class="header" href="#runtime-transaction-1">Runtime Transaction</a></h1>
<p>A runtime transaction includes a version number, a slice of <a href="sdk/./signature.html">signatures</a> included on the transaction and a <a href="sdk/../program/message.html">message</a> field, which details a list of <a href="sdk/../program/instructions-and-messages.html#instructions">instructions</a> to be processed atomically.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
pub struct RuntimeTransaction {
    pub version: u32,
    pub signatures: Vec&lt;Signature&gt;,
    pub message: Message,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/runtime_transaction.rs">runtime_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="processed-transaction-1"><a class="header" href="#processed-transaction-1">Processed Transaction</a></h1>
<p>A processed transaction is a custom data type that contains a <a href="sdk/./runtime-transaction.html">runtime transaction</a>, a status, denoting the result of executing this runtime transaction, as well as a collection of Bitcoin transaction IDs.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Deserialize, Serialize, BorshDeserialize, BorshSerialize)]
pub enum Status {
    Processing,
    Processed,
}

#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct ProcessedTransaction {
    pub runtime_transaction: RuntimeTransaction,
    pub status: Status,
    pub bitcoin_txids: Vec&lt;String&gt;,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/processed_transaction.rs">processed_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature-1"><a class="header" href="#signature-1">Signature</a></h1>
<p>A signature is a custom data type that holds a slice of 64 bytes.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct Signature(pub Vec&lt;u8&gt;);</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/signature.rs">signature.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-api-reference"><a class="header" href="#rpc-api-reference">RPC API Reference</a></h1>
<p>The Arch Network provides a comprehensive JSON-RPC API for interacting with validator nodes. This API allows you to:</p>
<ul>
<li>Query account information and balances</li>
<li>Submit transactions to the network</li>
<li>Retrieve block and transaction data</li>
<li>Monitor network state and readiness</li>
<li>Manage validator operations</li>
</ul>
<h2 id="api-endpoints"><a class="header" href="#api-endpoints">API Endpoints</a></h2>
<h3 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h3>
<ul>
<li><strong>Default Port</strong>: <code>9002</code> for validator nodes, <code>9001</code> for local validators</li>
<li><strong>Endpoint URL</strong>: <code>http://localhost:9002</code> (or your node‚Äôs IP address)</li>
<li><strong>Protocol</strong>: HTTP POST with JSON-RPC 2.0</li>
</ul>
<h3 id="request-format"><a class="header" href="#request-format">Request Format</a></h3>
<p>All RPC requests must be sent as HTTP <code>POST</code> requests with:</p>
<ul>
<li><strong>Content-Type</strong>: <code>application/json</code></li>
<li><strong>JSON-RPC Version</strong>: <code>"2.0"</code></li>
</ul>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "method_name",
  "params": [/* parameters */]
}
</code></pre>
<h3 id="response-format"><a class="header" href="#response-format">Response Format</a></h3>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {/* response data */}
}
</code></pre>
<h2 id="available-methods"><a class="header" href="#available-methods">Available Methods</a></h2>
<h3 id="account-operations-1"><a class="header" href="#account-operations-1">Account Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#read_account_info"><code>read_account_info</code></a> - Get account information</li>
<li><a href="rpc/rpc.html#get_account_address"><code>get_account_address</code></a> - Get Bitcoin address for account</li>
<li><a href="rpc/rpc.html#get_program_accounts"><code>get_program_accounts</code></a> - Query accounts by program ID</li>
<li><a href="rpc/rpc.html#get_multiple_accounts"><code>get_multiple_accounts</code></a> - Get multiple accounts at once</li>
<li><a href="rpc/rpc.html#request_airdrop"><code>request_airdrop</code></a> - Request airdrop of lamports (dev networks only)</li>
<li><a href="rpc/rpc.html#create_account_with_faucet"><code>create_account_with_faucet</code></a> - Create and fund account with faucet (dev networks only)</li>
</ul>
<h3 id="transaction-operations-1"><a class="header" href="#transaction-operations-1">Transaction Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#send_transaction"><code>send_transaction</code></a> - Submit a single transaction</li>
<li><a href="rpc/rpc.html#send_transactions"><code>send_transactions</code></a> - Submit multiple transactions</li>
<li><a href="rpc/rpc.html#get_processed_transaction"><code>get_processed_transaction</code></a> - Get transaction status and details</li>
<li><a href="rpc/rpc.html#recent_transactions"><code>recent_transactions</code></a> - Get recent transactions with filtering</li>
<li><a href="rpc/rpc.html#get_transactions_by_block"><code>get_transactions_by_block</code></a> - Get transactions from specific block</li>
<li><a href="rpc/rpc.html#get_transactions_by_ids"><code>get_transactions_by_ids</code></a> - Get multiple transactions by their IDs</li>
</ul>
<h3 id="block-operations"><a class="header" href="#block-operations">Block Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#get_block"><code>get_block</code></a> - Get block by hash</li>
<li><a href="rpc/rpc.html#get_block_by_height"><code>get_block_by_height</code></a> - Get block by height</li>
<li><a href="rpc/rpc.html#get_block_count"><code>get_block_count</code></a> - Get current block count</li>
<li><a href="rpc/rpc.html#get_block_hash"><code>get_block_hash</code></a> - Get block hash by height</li>
<li><a href="rpc/rpc.html#get_best_block_hash"><code>get_best_block_hash</code></a> - Get latest block hash</li>
</ul>
<h3 id="network-operations"><a class="header" href="#network-operations">Network Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#is_node_ready"><code>is_node_ready</code></a> - Check node readiness</li>
<li><a href="rpc/rpc.html#get_peers"><code>get_peers</code></a> - Get connected network peers</li>
<li><a href="rpc/rpc.html#get_current_state"><code>get_current_state</code></a> - Get current validator node state</li>
<li><a href="rpc/rpc.html#start_dkg"><code>start_dkg</code></a> - Initiate Distributed Key Generation (leader only)</li>
<li><a href="rpc/rpc.html#reset_network"><code>reset_network</code></a> - Reset network state (leader only)</li>
</ul>
<h3 id="local-validator-specific-methods"><a class="header" href="#local-validator-specific-methods">Local Validator Specific Methods</a></h3>
<ul>
<li><a href="rpc/rpc.html#get_arch_txid_from_btc_txid"><code>get_arch_txid_from_btc_txid</code></a> - Map Bitcoin txid to Arch txid</li>
<li><a href="rpc/rpc.html#get_transaction_report"><code>get_transaction_report</code></a> - Get detailed transaction processing report</li>
<li><a href="rpc/rpc.html#get_latest_tx_using_account"><code>get_latest_tx_using_account</code></a> - Find most recent transaction for account</li>
<li><a href="rpc/rpc.html#get_all_accounts"><code>get_all_accounts</code></a> - Get all account public keys</li>
</ul>
<hr />
<h2 id="account-operations-2"><a class="header" href="#account-operations-2">Account Operations</a></h2>
<h3 id="read_account_info"><a class="header" href="#read_account_info">read_account_info</a></h3>
<p>Retrieves information for a specified account.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> Account information object with <code>data</code>, <code>owner</code>, <code>utxo</code>, <code>is_executable</code>, and <code>tag</code> fields.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"read_account_info",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_account_address"><a class="header" href="#get_account_address">get_account_address</a></h3>
<p>Retrieves the Bitcoin address for a given account public key.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>account_pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> Bitcoin address string (format depends on network mode)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_account_address",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32] 
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_program_accounts"><a class="header" href="#get_program_accounts">get_program_accounts</a></h3>
<p>Fetches all accounts owned by a specified program ID.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>program_id</code> - Program public key as a 32-byte array</li>
<li><code>filters</code> (optional) - Array of filter objects:
<ul>
<li><code>{ "DataSize": &lt;size&gt; }</code> - Filter by account data size</li>
<li><code>{ "DataContent": { "offset": &lt;offset&gt;, "bytes": &lt;byte_array&gt; } }</code> - Filter by data content</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of account objects with <code>pubkey</code> and <code>account</code> information.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
  "jsonrpc":"2.0",
  "id":1,
  "method": "get_program_accounts",
  "params": [
    [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
    [
      {
        "DataSize": 165
      },
      {
        "DataContent": {
          "offset": 0,
          "bytes": [1, 2, 3, 4]
        }
      }
    ]
  ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_multiple_accounts"><a class="header" href="#get_multiple_accounts">get_multiple_accounts</a></h3>
<p>Retrieves information for multiple accounts in a single request.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkeys</code> - Array of account public keys (32-byte arrays)</li>
</ol>
<p><strong>Returns:</strong> Array of account information objects.</p>
<h3 id="request_airdrop"><a class="header" href="#request_airdrop">request_airdrop</a></h3>
<p>Requests airdrop of lamports to a specified account.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> Transaction ID string of the airdrop transaction</p>
<p><strong>Note:</strong> Only available on non-mainnet networks (testnet, devnet, regtest).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"request_airdrop",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="create_account_with_faucet"><a class="header" href="#create_account_with_faucet">create_account_with_faucet</a></h3>
<p>Creates a new account and funds it using the faucet.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> RuntimeTransaction object for the account creation</p>
<p><strong>Note:</strong> Only available on non-mainnet networks (testnet, devnet, regtest).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"create_account_with_faucet",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' http://localhost:9002/
</code></pre>
<h2 id="transaction-operations-2"><a class="header" href="#transaction-operations-2">Transaction Operations</a></h2>
<h3 id="send_transaction"><a class="header" href="#send_transaction">send_transaction</a></h3>
<p>Submits a single transaction to the network.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>transaction</code> - RuntimeTransaction object containing:
<ul>
<li><code>version</code> - Transaction version (currently 0)</li>
<li><code>signatures</code> - Array of transaction signatures</li>
<li><code>message</code> - Transaction message with signers and instructions</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Transaction ID (txid) string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"send_transaction",
    "params":[{
        "version": 0,
        "signatures": [
            {"0": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]}
        ],
        "message": {
            "signers": [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]],
            "instructions": [
                {
                    "program_id": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
                    "accounts": [
                        {
                            "pubkey": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
                            "is_signer": true,
                            "is_writable": true
                        }
                    ],
                    "data": [1,2,3,4]
                }
            ]
        }
    }]
}' http://localhost:9002/
</code></pre>
<h3 id="send_transactions"><a class="header" href="#send_transactions">send_transactions</a></h3>
<p>Submits multiple transactions to the network.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>transactions</code> - Array of serialized transactions (byte arrays)</li>
</ol>
<p><strong>Returns:</strong> Array of transaction ID strings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"send_transactions",
    "params": [
        [
            [1,2,3,4,5,6,7,8,9,10],
            [11,12,13,14,15,16,17,18,19,20]
        ]
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_processed_transaction"><a class="header" href="#get_processed_transaction">get_processed_transaction</a></h3>
<p>Retrieves a processed transaction and its status.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>transaction_id</code> - Transaction ID string</li>
</ol>
<p><strong>Returns:</strong> Object containing <code>runtime_transaction</code>, <code>status</code>, and <code>bitcoin_txids</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_processed_transaction",
    "params":[
        "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="recent_transactions"><a class="header" href="#recent_transactions">recent_transactions</a></h3>
<p>Retrieves recent transactions with optional filtering.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>params</code> - Object with optional fields:
<ul>
<li><code>limit</code> (optional) - Maximum number of transactions to return</li>
<li><code>offset</code> (optional) - Number of transactions to skip</li>
<li><code>account</code> (optional) - Filter by account involvement (32-byte array)</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of ProcessedTransaction objects</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"recent_transactions",
    "params":[{
        "limit": 10,
        "offset": 0,
        "account": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    }]
}' http://localhost:9002/
</code></pre>
<h3 id="get_transactions_by_block"><a class="header" href="#get_transactions_by_block">get_transactions_by_block</a></h3>
<p>Retrieves transactions from a specific block.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>params</code> - Object with required and optional fields:
<ul>
<li><code>block_hash</code> - Block hash string</li>
<li><code>limit</code> (optional) - Maximum number of transactions to return</li>
<li><code>offset</code> (optional) - Number of transactions to skip</li>
<li><code>account</code> (optional) - Filter by account involvement (32-byte array)</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of ProcessedTransaction objects</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_transactions_by_block",
    "params":[{
        "block_hash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
        "limit": 50,
        "offset": 0
    }]
}' http://localhost:9002/
</code></pre>
<h3 id="get_transactions_by_ids"><a class="header" href="#get_transactions_by_ids">get_transactions_by_ids</a></h3>
<p>Retrieves multiple transactions by their IDs.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>params</code> - Object with required field:
<ul>
<li><code>txids</code> - Array of transaction ID strings</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of ProcessedTransaction objects (null for missing transactions)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_transactions_by_ids",
    "params":[{
        "txids": [
            "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
            "fedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
        ]
    }]
}' http://localhost:9002/
</code></pre>
<h2 id="block-operations-1"><a class="header" href="#block-operations-1">Block Operations</a></h2>
<h3 id="get_block"><a class="header" href="#get_block">get_block</a></h3>
<p>Retrieves a block by its hash.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>block_hash</code> - Block hash string</li>
<li><code>filter</code> (optional) - Block transaction filter</li>
</ol>
<p><strong>Returns:</strong> Block object with transaction data</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block",
    "params":[
        "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f" 
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_block_by_height"><a class="header" href="#get_block_by_height">get_block_by_height</a></h3>
<p>Retrieves a block by its height.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>block_height</code> - Block height number</li>
<li><code>filter</code> (optional) - Block transaction filter</li>
</ol>
<p><strong>Returns:</strong> Block object with transaction data</p>
<h3 id="get_block_count"><a class="header" href="#get_block_count">get_block_count</a></h3>
<p>Retrieves the current block count.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Current block count as a number</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block_count",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_block_hash"><a class="header" href="#get_block_hash">get_block_hash</a></h3>
<p>Retrieves the block hash for a given height.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>block_height</code> - Block height number</li>
</ol>
<p><strong>Returns:</strong> Block hash string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block_hash",
    "params":[680000]
}' http://localhost:9002/
</code></pre>
<h3 id="get_best_block_hash"><a class="header" href="#get_best_block_hash">get_best_block_hash</a></h3>
<p>Retrieves the hash of the latest block.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Latest block hash string</p>
<h2 id="network-operations-1"><a class="header" href="#network-operations-1">Network Operations</a></h2>
<h3 id="is_node_ready"><a class="header" href="#is_node_ready">is_node_ready</a></h3>
<p>Checks if the node is ready to process requests.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Boolean indicating readiness</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_peers"><a class="header" href="#get_peers">get_peers</a></h3>
<p>Retrieves information about connected network peers.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Array of peer statistics objects</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_peers",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_current_state"><a class="header" href="#get_current_state">get_current_state</a></h3>
<p>Retrieves the current state of the validator node.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> CurrentState object containing validator state information</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_current_state",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="start_dkg"><a class="header" href="#start_dkg">start_dkg</a></h3>
<p>Initiates the Distributed Key Generation (DKG) process.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Success message if the DKG process is initiated</p>
<p><strong>Note:</strong> Not available for local validators.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"start_dkg",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="reset_network"><a class="header" href="#reset_network">reset_network</a></h3>
<p>Resets the network state.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Success message if the network reset is successful</p>
<p><strong>Note:</strong> Only callable by the Leader node. Not available for local validators.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"reset_network",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h2 id="local-validator-specific-methods-1"><a class="header" href="#local-validator-specific-methods-1">Local Validator Specific Methods</a></h2>
<p>The following methods are available only when using the local validator (for development):</p>
<h3 id="get_arch_txid_from_btc_txid"><a class="header" href="#get_arch_txid_from_btc_txid">get_arch_txid_from_btc_txid</a></h3>
<p>Maps a Bitcoin transaction ID to its corresponding Arch transaction ID.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>btc_txid</code> - Bitcoin transaction ID string</li>
</ol>
<p><strong>Returns:</strong> Optional Arch transaction ID string (null if not found)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_arch_txid_from_btc_txid",
    "params":["1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"]
}' http://localhost:9002/
</code></pre>
<h3 id="get_transaction_report"><a class="header" href="#get_transaction_report">get_transaction_report</a></h3>
<p>Retrieves detailed transaction processing report for debugging.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>txid</code> - Transaction ID string</li>
</ol>
<p><strong>Returns:</strong> Transaction report string with processing details</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_transaction_report",
    "params":["1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"]
}' http://localhost:9002/
</code></pre>
<h3 id="get_latest_tx_using_account"><a class="header" href="#get_latest_tx_using_account">get_latest_tx_using_account</a></h3>
<p>Finds the most recent transaction involving a specific account.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>account_pubkey</code> - Account public key as hex string</li>
</ol>
<p><strong>Returns:</strong> Optional transaction ID string (null if not found)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_latest_tx_using_account",
    "params":["0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"]
}' http://localhost:9002/
</code></pre>
<h3 id="get_all_accounts"><a class="header" href="#get_all_accounts">get_all_accounts</a></h3>
<p>Retrieves all account public keys in the database.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Array of account public key hex strings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_all_accounts",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h2 id="sdk-integration"><a class="header" href="#sdk-integration">SDK Integration</a></h2>
<p>For easier integration, use the official SDK:</p>
<ul>
<li><strong>TypeScript/JavaScript</strong>: <code>@saturnbtcio/arch-sdk</code></li>
<li><strong>Rust</strong>: <code>arch_sdk</code> crate</li>
</ul>
<h2 id="cli-alternative"><a class="header" href="#cli-alternative">CLI Alternative</a></h2>
<p>Most RPC operations can also be performed using the <a href="rpc/../getting-started/quick-start.html#cli-alternative">Arch Network CLI</a>:</p>
<pre><code class="language-bash"># Deploy a program
arch-cli deploy &lt;ELF_PATH&gt;

# Check transaction status  
arch-cli confirm &lt;TX_ID&gt;

# Get account information
arch-cli account &lt;ACCOUNT_ADDRESS&gt;

# Get block information
arch-cli get-block &lt;BLOCK_HASH&gt;

# Get current block height
arch-cli get-block-height

# Get program messages from transaction
arch-cli log-program-messages &lt;TX_ID&gt;

# Change account owner
arch-cli change-owner &lt;ACCOUNT_ADDRESS&gt; &lt;NEW_OWNER&gt;
</code></pre>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<p>All RPC methods return JSON-RPC 2.0 compliant error responses:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32600,
    "message": "Invalid Request",
    "data": "Additional error details"
  }
}
</code></pre>
<p>Common error codes:</p>
<ul>
<li><code>-32600</code>: Invalid Request</li>
<li><code>-32601</code>: Method not found</li>
<li><code>-32602</code>: Invalid params</li>
<li><code>-32603</code>: Internal error</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-program"><a class="header" href="#system-program">System Program</a></h1>
<p>The Arch System Program is the core program that manages fundamental account operations on the Arch Network. This program provides essential functionality for account creation, ownership management, UTXO anchoring, and lamport transfers.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The System Program handles:</p>
<ul>
<li><strong>Account Creation</strong>: Creating new accounts with specified ownership and data allocation</li>
<li><strong>UTXO Integration</strong>: Anchoring accounts to Bitcoin UTXOs for native Bitcoin integration</li>
<li><strong>Ownership Management</strong>: Transferring account ownership between programs</li>
<li><strong>Lamport Transfers</strong>: Moving lamports (the base unit of value) between accounts</li>
<li><strong>Space Allocation</strong>: Allocating data storage space for accounts</li>
</ul>
<h2 id="available-instructions"><a class="header" href="#available-instructions">Available Instructions</a></h2>
<h3 id="createaccount"><a class="header" href="#createaccount">CreateAccount</a></h3>
<p>Creates a new account with the specified parameters.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>lamports: u64</code> - Number of lamports to transfer to the new account</li>
<li><code>space: u64</code> - Number of bytes of memory to allocate</li>
<li><code>owner: Pubkey</code> - Address of the program that will own the new account</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Funding account (payer)</li>
<li><code>[WRITE, SIGNER]</code> New account to create</li>
</ol>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_program::{
    system_instruction,
    pubkey::Pubkey,
};

let instruction = system_instruction::create_account(
    &amp;from_pubkey,
    &amp;to_pubkey,
    1_000_000,  // lamports
    165,        // space in bytes
    &amp;owner_pubkey,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="createaccountwithanchor"><a class="header" href="#createaccountwithanchor">CreateAccountWithAnchor</a></h3>
<p>Creates a new account and anchors it to a specific Bitcoin UTXO.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>lamports: u64</code> - Number of lamports to transfer</li>
<li><code>space: u64</code> - Number of bytes to allocate</li>
<li><code>owner: Pubkey</code> - Program that will own the account</li>
<li><code>txid: [u8; 32]</code> - Bitcoin transaction ID</li>
<li><code>vout: u32</code> - Output index in the Bitcoin transaction</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Funding account</li>
<li><code>[WRITE, SIGNER]</code> New account to create</li>
</ol>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = system_instruction::create_account_with_anchor(
    &amp;from_pubkey,
    &amp;to_pubkey,
    1_000_000,  // lamports
    165,        // space
    &amp;owner_pubkey,
    txid,       // Bitcoin transaction ID
    vout,       // Bitcoin output index
);
<span class="boring">}</span></code></pre></pre>
<h3 id="assign"><a class="header" href="#assign">Assign</a></h3>
<p>Changes the owner of an existing account.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>owner: Pubkey</code> - New owner program</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Account to reassign</li>
</ol>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = system_instruction::assign(
    &amp;account_pubkey,
    &amp;new_owner_pubkey,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="anchor"><a class="header" href="#anchor">Anchor</a></h3>
<p>Anchors an existing account to a Bitcoin UTXO.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>txid: [u8; 32]</code> - Bitcoin transaction ID</li>
<li><code>vout: u32</code> - Output index</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Account to anchor</li>
</ol>
<h3 id="transfer-1"><a class="header" href="#transfer-1">Transfer</a></h3>
<p>Transfers lamports from one account to another.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>lamports: u64</code> - Amount to transfer</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Source account</li>
<li><code>[WRITE]</code> Destination account</li>
</ol>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = system_instruction::transfer(
    &amp;from_pubkey,
    &amp;to_pubkey,
    500_000,  // lamports to transfer
);
<span class="boring">}</span></code></pre></pre>
<h3 id="allocate"><a class="header" href="#allocate">Allocate</a></h3>
<p>Allocates space in an account without funding it.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>space: u64</code> - Number of bytes to allocate</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Account to allocate space for</li>
</ol>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instruction = system_instruction::allocate(
    &amp;account_pubkey,
    1024,  // bytes to allocate
);
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<p>The System Program can return the following errors:</p>
<ul>
<li><code>AccountAlreadyInUse</code> - Account with the same address already exists</li>
<li><code>ResultWithNegativeLamports</code> - Account doesn‚Äôt have enough lamports for operation</li>
<li><code>InvalidProgramId</code> - Cannot assign account to this program ID</li>
<li><code>InvalidAccountDataLength</code> - Cannot allocate account data of this length</li>
<li><code>MaxSeedLengthExceeded</code> - Requested seed length is too long</li>
<li><code>AddressWithSeedMismatch</code> - Address doesn‚Äôt match derived seed</li>
</ul>
<h2 id="important-constants"><a class="header" href="#important-constants">Important Constants</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Minimum lamports required for any account
pub const MIN_ACCOUNT_LAMPORTS: u64 = 1024;

// Maximum permitted data length for accounts
pub const MAX_PERMITTED_DATA_LENGTH: usize = 10 * 1024 * 1024; // 10MB
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="account-creation"><a class="header" href="#account-creation">Account Creation</a></h3>
<ol>
<li><strong>Always fund with sufficient lamports</strong>: Accounts need at least <code>MIN_ACCOUNT_LAMPORTS</code> to be created</li>
<li><strong>Use appropriate space allocation</strong>: Allocate only the space you need to minimize costs</li>
<li><strong>Set correct ownership</strong>: Ensure the owner program can properly manage the account</li>
</ol>
<h3 id="utxo-integration"><a class="header" href="#utxo-integration">UTXO Integration</a></h3>
<ol>
<li><strong>Verify UTXO existence</strong>: Ensure the referenced Bitcoin UTXO exists and is confirmed</li>
<li><strong>Use proper confirmation counts</strong>: Wait for sufficient Bitcoin confirmations before using anchored accounts</li>
<li><strong>Handle reorgs gracefully</strong>: Account for potential Bitcoin reorganizations</li>
</ol>
<h3 id="security-considerations-6"><a class="header" href="#security-considerations-6">Security Considerations</a></h3>
<ol>
<li><strong>Validate signers</strong>: Always verify that required accounts are properly signed</li>
<li><strong>Check ownership</strong>: Verify account ownership before operations</li>
<li><strong>Handle edge cases</strong>: Account for insufficient funds, invalid parameters, etc.</li>
</ol>
<h2 id="integration-with-bitcoin"><a class="header" href="#integration-with-bitcoin">Integration with Bitcoin</a></h2>
<p>The System Program‚Äôs UTXO anchoring functionality enables direct integration with Bitcoin:</p>
<ul>
<li><strong>Account-UTXO Mapping</strong>: Accounts can be directly linked to Bitcoin UTXOs</li>
<li><strong>Ownership Verification</strong>: Bitcoin signatures can prove account ownership</li>
<li><strong>State Synchronization</strong>: Account states can be synchronized with Bitcoin state</li>
</ul>
<p>This integration provides:</p>
<ul>
<li>Native Bitcoin security guarantees</li>
<li>Direct UTXO management capabilities</li>
<li>Seamless Bitcoin transaction integration</li>
<li>Provable ownership and state anchoring</li>
</ul>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="system-program/../program/accounts.html">Account Model</a> - Understanding Arch‚Äôs account structure</li>
<li><a href="system-program/../program/instructions-and-messages.html">Instructions and Messages</a> - How instructions work</li>
<li><a href="system-program/../concepts/bitcoin-integration.html">Bitcoin Integration</a> - Bitcoin-native features</li>
<li><a href="system-program/../program/utxo.html">UTXO Management</a> - Working with Bitcoin UTXOs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="createaccount-1"><a class="header" href="#createaccount-1"><code>CreateAccount</code></a></h1>
<p><strong>Index:</strong> <code>0</code></p>
<p>Create a new account.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![0]</code>, the correct index for making a call to <code>SystemProgram::CreateAccount</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![0];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="makeexecutable"><a class="header" href="#makeexecutable"><code>MakeExecutable</code></a></h1>
<p><strong>Index:</strong> <code>2</code></p>
<p>Sets the account as executable, marking it as a program.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![2]</code>, the correct index for making a call to <code>SystemProgram::MakeExecutable</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![2];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<p>We can proceed to confirm that the program is executable with <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L368">read_account_info</a> which returns an <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L358">AccountInfoResult</a> that gets parsed to obtain the <code>is_executable</code> value.</p>
<pre><code class="language-rust ignore">assert!(
    read_account_info("node_url", program_pubkey)
        .unwrap()
        .is_executable
);</code></pre>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h1>
<p>This guide helps you diagnose and resolve common issues you might encounter while developing on the Arch Network.</p>
<h2 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h2>
<h3 id="build-errors"><a class="header" href="#build-errors">Build Errors</a></h3>
<h4 id="1-cargo-build-failures"><a class="header" href="#1-cargo-build-failures">1. Cargo Build Failures</a></h4>
<pre><code class="language-bash">error: failed to run custom build command for `arch-sdk v0.1.0`
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Ensure you have the latest Rust toolchain installed</li>
<li>Check that you‚Äôre using a compatible version of the Arch SDK</li>
<li>Try cleaning your build directory:
<pre><code class="language-bash">cargo clean
cargo build
</code></pre>
</li>
</ul>
<h4 id="2-program-compilation-errors"><a class="header" href="#2-program-compilation-errors">2. Program Compilation Errors</a></h4>
<pre><code class="language-bash">error: linking with `cc` failed: exit status: 1
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify you have the required system dependencies</li>
<li>Update your Arch SDK to the latest version</li>
<li>Check your program‚Äôs target architecture:
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
</li>
</ul>
<h3 id="deployment-issues"><a class="header" href="#deployment-issues">Deployment Issues</a></h3>
<h4 id="1-program-deployment-failures"><a class="header" href="#1-program-deployment-failures">1. Program Deployment Failures</a></h4>
<pre><code class="language-bash">Error: Program deployment failed: Transaction simulation failed
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check your account has sufficient balance</li>
<li>Verify the program binary size is within limits</li>
<li>Ensure you‚Äôre connected to the correct network:
<pre><code class="language-bash">arch-cli config get
</code></pre>
</li>
</ul>
<h4 id="2-transaction-errors"><a class="header" href="#2-transaction-errors">2. Transaction Errors</a></h4>
<pre><code class="language-bash">Error: Transaction failed: Custom program error: 0x1
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check program logs for detailed error information</li>
<li>Verify instruction data format</li>
<li>Ensure all required accounts are provided</li>
</ul>
<h3 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h3>
<h4 id="1-account-creation-failures"><a class="header" href="#1-account-creation-failures">1. Account Creation Failures</a></h4>
<pre><code class="language-bash">Error: Failed to create account: insufficient funds
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify account balance</li>
<li>Check rent-exempt minimum:
<pre><code class="language-bash">arch-cli rent minimum-balance &lt;size&gt;
</code></pre>
</li>
<li>Ensure correct account size calculation</li>
</ul>
<h4 id="2-instruction-processing-errors"><a class="header" href="#2-instruction-processing-errors">2. Instruction Processing Errors</a></h4>
<pre><code class="language-bash">Error: Program failed to complete: Program failed to process instruction
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Enable program logging:
<pre><code class="language-rust ignore">msg!("Debug output: {:?}", data);</code></pre>
</li>
<li>Check account ownership</li>
<li>Verify instruction data format</li>
</ul>
<h2 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h2>
<h3 id="1-connection-problems"><a class="header" href="#1-connection-problems">1. Connection Problems</a></h3>
<pre><code class="language-bash">Error: Unable to connect to RPC endpoint
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check network status</li>
<li>Verify endpoint configuration:
<pre><code class="language-bash">arch-cli config get
</code></pre>
</li>
<li>Try alternate RPC endpoints</li>
</ul>
<h3 id="2-validator-issues"><a class="header" href="#2-validator-issues">2. Validator Issues</a></h3>
<pre><code class="language-bash">Error: Validator node is not responding
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check validator logs</li>
<li>Verify Bitcoin Core and Titan are running</li>
<li>Ensure sufficient system resources</li>
</ul>
<h2 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h2>
<h3 id="1-sdk-version-mismatch"><a class="header" href="#1-sdk-version-mismatch">1. SDK Version Mismatch</a></h3>
<pre><code class="language-bash">error: package `arch-sdk v0.1.0` cannot be built
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Update Arch SDK:
<pre><code class="language-bash">cargo update -p arch-sdk
</code></pre>
</li>
<li>Check compatibility matrix</li>
<li>Clean and rebuild project</li>
</ul>
<h3 id="2-tool-chain-issues"><a class="header" href="#2-tool-chain-issues">2. Tool Chain Issues</a></h3>
<pre><code class="language-bash">error: linker `cc` not found
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Install required system dependencies</li>
<li>Update Rust toolchain:
<pre><code class="language-bash">rustup update
</code></pre>
</li>
<li>Verify PATH configuration</li>
</ul>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="1-slow-transaction-processing"><a class="header" href="#1-slow-transaction-processing">1. Slow Transaction Processing</a></h3>
<p><strong>Solution:</strong></p>
<ul>
<li>Check compute budget usage</li>
<li>Optimize account lookups</li>
<li>Consider batching transactions</li>
</ul>
<h3 id="2-high-resource-usage"><a class="header" href="#2-high-resource-usage">2. High Resource Usage</a></h3>
<p><strong>Solution:</strong></p>
<ul>
<li>Monitor program size</li>
<li>Optimize data structures</li>
<li>Review account storage strategy</li>
</ul>
<h2 id="debugging-tools"><a class="header" href="#debugging-tools">Debugging Tools</a></h2>
<h3 id="1-program-logs"><a class="header" href="#1-program-logs">1. Program Logs</a></h3>
<p>Enable detailed logging:</p>
<pre><code class="language-bash">RUST_LOG=debug arch-cli program-logs &lt;PROGRAM_ID&gt;
</code></pre>
<h3 id="2-transaction-inspection"><a class="header" href="#2-transaction-inspection">2. Transaction Inspection</a></h3>
<p>Analyze transaction details:</p>
<pre><code class="language-bash">arch-cli transaction-info &lt;TX_SIGNATURE&gt;
</code></pre>
<h3 id="3-account-inspection"><a class="header" href="#3-account-inspection">3. Account Inspection</a></h3>
<p>View account data:</p>
<pre><code class="language-bash">arch-cli account &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ol>
<li>
<p><strong>Development Workflow</strong></p>
<ul>
<li>Use local validator for testing</li>
<li>Maintain separate development/production configs</li>
<li>Regular testing with minimal test accounts</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Implement comprehensive error types</li>
<li>Add detailed error messages</li>
<li>Log relevant debug information</li>
</ul>
</li>
<li>
<p><strong>Maintenance</strong></p>
<ul>
<li>Regular dependency updates</li>
<li>Security audits</li>
<li>Performance monitoring</li>
</ul>
</li>
</ol>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<p>If you‚Äôre still experiencing issues:</p>
<ol>
<li>Check the <a href="https://github.com/arch-network/arch-node/issues">GitHub Issues</a></li>
<li>Join the <a href="https://discord.gg/arch-network">Discord Community</a></li>
<li>Review the <a href="https://docs.arch.network">API Documentation</a></li>
</ol>
<p>Remember to provide relevant information when seeking help:</p>
<ul>
<li>Error messages</li>
<li>Program logs</li>
<li>Environment details</li>
<li>Steps to reproduce</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h3 id="bitcoin-mempool-and-blockchain-explorer"><a class="header" href="#bitcoin-mempool-and-blockchain-explorer">Bitcoin mempool and blockchain explorer</a></h3>
<ul>
<li><a href="https://mempool.dev.aws.archnetwork.xyz">mempool.space - Arch Regtest</a>
<ul>
<li>Bitcoin mempool and block explorer. This <a href="https://mempool.space">mempool.space</a> instance monitors the regtest Bitcoin blockchain being used to run and validate all examples in this repo.</li>
</ul>
</li>
<li><a href="https://docs.solanalabs.com/cli/install">Solana CLI</a></li>
<li><a href="https://solana.com/developers/guides/getstarted/setup-local-development">Solana Local Development Guide</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
