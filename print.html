<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Arch Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for the Arch Network - A Bitcoin-native computation environment">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="getting-started/quick-start.html">üöÄ Quick Start Guide</a></li><li class="chapter-item "><a href="getting-started/bitcoin-and-titan-setup.html">üèóÔ∏è Validator Setup</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="getting-started/requirements.html">System Requirements</a></li><li class="chapter-item "><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html">Setup Options</a></li><li class="chapter-item "><a href="getting-started/validator-staking.html">Running Your Node</a></li></ol></li><li class="chapter-item "><li class="part-title">Program Development</li><li class="chapter-item "><a href="guides/understanding-arch-programs.html">Understanding Arch Programs</a></li><li class="chapter-item "><a href="getting-started/setting-up-a-project.html">Setting Up a Project</a></li><li class="chapter-item "><a href="guides/writing-your-first-program.html">Writing Your First Program</a></li><li class="chapter-item "><a href="guides/testing-guide.html">Testing Your Program</a></li><li class="chapter-item "><a href="guides/guides.html">Program Examples</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li><li class="chapter-item "><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li><li class="chapter-item "><a href="guides/how-to-build-runes-swap.html">Runes Swap</a></li><li class="chapter-item "><a href="guides/how-to-build-lending-protocol.html">Lending Protocol</a></li></ol></li><li class="chapter-item "><li class="part-title">Arch Program Library (APL)</li><li class="chapter-item "><a href="apl/introduction.html">Introduction</a></li><li class="chapter-item "><a href="apl/token-program.html">Token Program</a></li><li class="chapter-item "><a href="apl/associated-token-account.html">Associated Token Account Program</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="concepts/architecture.html">Architecture Overview</a></li><li class="chapter-item "><a href="concepts/network-architecture.html">Network Architecture</a></li><li class="chapter-item "><a href="concepts/bitcoin-integration.html">Bitcoin Integration</a></li><li class="chapter-item "><a href="concepts/consensus.html">ROAST and FROST Consensus</a></li><li class="chapter-item "><a href="concepts/validator-state-machine.html">Validator State Machine</a></li><li class="chapter-item "><a href="program/program.html">Programs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="program/utxo.html">UTXOs</a></li><li class="chapter-item "><a href="program/accounts.html">Accounts</a></li><li class="chapter-item "><a href="program/instructions-and-messages.html">Instructions</a></li><li class="chapter-item "><a href="program/syscall.html">System Calls</a></li></ol></li><li class="chapter-item "><a href="concepts/nodes.html">Node Operation</a></li><li class="chapter-item affix "><li class="part-title">SDK Reference</li><li class="chapter-item "><a href="sdk/sdk.html">SDK Overview</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/typescript/getting-started.html">TypeScript SDK (Saturn)</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/typescript/api-reference.html">TypeScript API Reference</a></li><li class="chapter-item "><a href="sdk/typescript/examples.html">TypeScript Examples</a></li><li class="chapter-item "><a href="sdk/typescript/web3-integration.html">Web3 Integration</a></li></ol></li><li class="chapter-item "><a href="sdk/rust/getting-started.html">Rust SDK</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/rust/api-reference.html">Rust API Reference</a></li><li class="chapter-item "><a href="sdk/rust/examples.html">Rust Examples</a></li><li class="chapter-item "><a href="sdk/rust/program-development.html">Program Development</a></li></ol></li><li class="chapter-item "><a href="sdk/core-types.html">Core Types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/pubkey.html">Pubkey</a></li><li class="chapter-item "><a href="sdk/account.html">Account</a></li><li class="chapter-item "><a href="sdk/instructions-and-messages.html">Instructions and Messages</a></li><li class="chapter-item "><a href="sdk/runtime-transaction.html">Runtime Transaction</a></li><li class="chapter-item "><a href="sdk/processed-transaction.html">Processed Transaction</a></li><li class="chapter-item "><a href="sdk/signature.html">Signature</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Tools & CLI</li><li class="chapter-item "><a href="guides/arch-cli-reference.html">Arch CLI Reference</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="rpc/rpc.html">API Reference</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rpc/rpc-method-availability.html">RPC Method Availability</a></li></ol></li><li class="chapter-item "><a href="system-program/system-program.html">System Program</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="system-program/create-account.html">Account Creation</a></li><li class="chapter-item "><a href="system-program/make-executable.html">Program Deployment</a></li></ol></li><li class="chapter-item "><li class="part-title">Resources</li><li class="chapter-item "><a href="reference/troubleshooting.html">Troubleshooting</a></li><li class="chapter-item "><a href="getting-started/faq.html">FAQ</a></li><li class="chapter-item "><a href="getting-started/resources.html">External Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Arch Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arch-network/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-arch-network"><a class="header" href="#welcome-to-arch-network">Welcome to Arch Network</a></h1>
<div class="info">
This documentation is actively maintained. If you find any issues or have suggestions for improvements, please visit our <a href="https://github.com/arch-network/docs">GitHub repository</a>.
</div>
<div style="float: right; margin: 0 0 20px 20px; max-width: 40%;">
    <img src="images/coders.png" alt="Developer coding" style="width: 100%; height: auto;">
</div>
<h2 id="what-is-arch-network"><a class="header" href="#what-is-arch-network">What is Arch Network?</a></h2>
<p>Arch Network is a computation environment that enhances Bitcoin‚Äôs capabilities by enabling complex operations on Bitcoin UTXOs through its specialized virtual machine. Unlike Layer 2 solutions, Arch Network provides a native computation layer that works directly with Bitcoin‚Äôs security model.</p>
<h2 id="choose-your-path-"><a class="header" href="#choose-your-path-">Choose Your Path üëã</a></h2>
<div class="path-selector">
    <div class="path-option">
        <h3 id="-deploy-first"><a class="header" href="#-deploy-first">üöÄ Deploy First</a></h3>
        <p>Get your first smart contract running on Arch Network as quickly as possible</p>
        <ul>
            <li>Download CLI and deploy a program in 15 minutes</li>
            <li>Use our pre-configured development environment</li>
            <li>Perfect for developers wanting to try Arch Network</li>
        </ul>
        <a href="getting-started/quick-start.html" class="button">Start Building ‚Üí</a>
    </div>
</div>
<h3 id="-run-a-validator"><a class="header" href="#-run-a-validator">üèóÔ∏è Run a Validator</a></h3>
<p>Set up and run your own validator node on the Arch Network</p>
<ul>
<li>Set up Bitcoin Core and Titan</li>
<li>Configure and run a validator node</li>
<li>Perfect for those wanting to participate in network security</li>
</ul>
<p><a href="getting-started/bitcoin-and-titan-setup.html">Start Running ‚Üí</a></p>
<div class="network-selector">
    <h3 id="network-options"><a class="header" href="#network-options">Network Options</a></h3>
    <div class="network-grid">
        <div class="network-option">
            <h4 id="-regtest"><a class="header" href="#-regtest">üîß Regtest</a></h4>
            <p>Local development environment with instant block confirmation. Perfect for development and testing.</p>
        </div>
        <div class="network-option">
            <h4 id="-testnet"><a class="header" href="#-testnet">üß™ Testnet</a></h4>
            <p>Test network with real Bitcoin testnet integration. For testing in a live environment.</p>
        </div>
    </div>
</div>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<div class="feature-grid">
<div class="feature">
    <h4 id="bitcoin-native"><a class="header" href="#bitcoin-native">Bitcoin-Native</a></h4>
    <p>Direct <a href="concepts/bitcoin-integration.html">integration with Bitcoin</a> through UTXO management</p>
</div>
<div class="feature">
    <h4 id="computation-environment"><a class="header" href="#computation-environment">Computation Environment</a></h4>
    <p>Execute complex programs within the <a href="concepts/architecture.html">Arch VM</a></p>
</div>
<div class="feature">
    <h4 id="program-development"><a class="header" href="#program-development">Program Development</a></h4>
    <p>Write <a href="program/program.html">programs in Rust</a> to interact with <a href="program/utxo.html">Bitcoin UTXOs</a></p>
</div>
<div class="feature">
    <h4 id="security"><a class="header" href="#security">Security</a></h4>
    <p>Leverages Bitcoin's proven security guarantees through <a href="concepts/network-architecture.html#security-model">multi-signature validation</a></p>
</div>
<div class="feature">
    <h4 id="developer-tools"><a class="header" href="#developer-tools">Developer Tools</a></h4>
    <p>Complete development environment with <a href="getting-started/environment-setup.html">CLI tools</a> and explorer</p>
</div>
</div>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<div class="prerequisites-box">
Before you begin, ensure you have:
<ul>
<li>Node.js v19+ (<a href="getting-started/requirements.html">installation guide</a>)</li>
<li>Rust (latest stable)</li>
<li>Docker for local development</li>
<li>Basic understanding of <a href="program/utxo.html">Bitcoin UTXOs</a></li>
</ul>
</div>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<h3 id="how-arch-works"><a class="header" href="#how-arch-works">How Arch Works</a></h3>
<div class="architecture-overview">
Arch Network consists of three main components:
<ol>
<li><strong>Network Layer</strong></li>
</ol>
<ul>
<li><a href="concepts/network-architecture.html">Network Architecture</a>
<ul>
<li><a href="concepts/network-architecture.html#1-bootnode">Bootnode</a>: Network discovery and peer management</li>
<li><a href="concepts/network-architecture.html#2-leader-node">Leader Node</a>: Transaction coordination</li>
<li><a href="concepts/network-architecture.html#3-validator-nodes">Validator Nodes</a>: Program execution</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Bitcoin Integration</strong></li>
</ol>
<ul>
<li><a href="concepts/bitcoin-integration.html#1-utxo-management">UTXO Management</a>
<ul>
<li>Transaction tracking</li>
<li>State anchoring</li>
<li>Ownership validation</li>
</ul>
</li>
<li><a href="concepts/bitcoin-integration.html#2-bitcoin-rpc-integration">RPC Integration</a>
<ul>
<li>Bitcoin node communication</li>
<li>Transaction submission</li>
<li>Network synchronization</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Computation Layer</strong></li>
</ol>
<ul>
<li><a href="program/program.html">Programs</a>
<ul>
<li><a href="program/instructions-and-messages.html">Instructions</a></li>
<li><a href="program/accounts.html">Accounts</a></li>
<li><a href="program/syscall.html">System Calls</a></li>
</ul>
</li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a>
<ul>
<li>Message validation</li>
<li>State updates</li>
<li>UTXO management</li>
</ul>
</li>
</ul>
</div>
<h3 id="-reference-documentation"><a class="header" href="#-reference-documentation">üõ† Reference Documentation</a></h3>
<div class="reference-grid">
Technical documentation:
<ul>
<li><a href="rpc/rpc.html">API Reference</a>
<ul>
<li><a href="rpc/rpc.html">RPC API Reference</a></li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a></li>
</ul>
</li>
<li><a href="guides/writing-your-first-program.html">Program Examples</a>
<ul>
<li><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li>
</ul>
</li>
<li><a href="system-program/system-program.html">System Program</a>
<ul>
<li><a href="system-program/create-account.html">Account Creation</a></li>
<li><a href="system-program/make-executable.html">Program Deployment</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="need-help"><a class="header" href="#need-help">Need Help?</a></h2>
<div class="help-box">
<ul>
<li><a href="https://discord.gg/archnetwork">Join our Discord</a></li>
<li><a href="concepts/architecture.html">Read the Architecture Overview</a></li>
<li><a href="guides/writing-your-first-program.html">View Example Programs</a></li>
<li><a href="concepts/network-architecture.html#monitoring-and-telemetry">Check Network Status</a></li>
<li><a href="rpc/rpc.html">API Reference</a></li>
</ul>
</div>
<div class="tip">
üí° <strong>Pro Tip:</strong> Use the search function (press 's' or '/' on your keyboard) to quickly find what you're looking for in the documentation.
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-quick-start-guide"><a class="header" href="#-quick-start-guide">üöÄ Quick Start Guide</a></h1>
<p>Welcome to Arch Network! Let‚Äôs get your first program running in under 15 minutes.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting, ensure you have the following tools installed:</p>
<ul>
<li><strong>Git</strong> (v2.0 or later)</li>
<li><strong>Rust</strong> (v1.84.1 or later) - <a href="https://rustup.rs/">Install Rust</a></li>
<li><strong>Solana CLI</strong> (v2.2.14 or later) - <a href="https://docs.solana.com/cli/install-solana-cli-tools">Install Solana</a></li>
<li><strong>Arch Network CLI</strong> - Download from <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network Releases</a></li>
<li><strong>Docker</strong> - Required for local development - <a href="https://docs.docker.com/engine/install/">Install Docker</a></li>
</ul>
<blockquote>
<p>‚ö†Ô∏è <strong>Important</strong>: Arch Network now requires Solana CLI 2.x. Please ensure you have version 2.2.14 or later installed.</p>
</blockquote>
<p>Verify your installation:</p>
<pre><code class="language-bash">git --version
rustc --version
solana --version  # Should show 2.2.14 or later
arch-cli --version
docker --version
</code></pre>
<blockquote>
<p>üí° Note: If you encounter any issues during installation, join our <a href="https://discord.gg/archnetwork">Discord</a> for support.</p>
</blockquote>
<h2 id="-quick-start-project"><a class="header" href="#-quick-start-project">üöÄ Quick Start Project</a></h2>
<h3 id="1-clone-example-project"><a class="header" href="#1-clone-example-project">1. Clone Example Project</a></h3>
<pre><code class="language-bash"># Get the starter example
git clone https://github.com/Arch-Network/arch-examples
cd arch-examples/examples/helloworld
</code></pre>
<h3 id="2-start-local-development-environment"><a class="header" href="#2-start-local-development-environment">2. Start Local Development Environment</a></h3>
<p>Choose one of the following network modes:</p>
<h4 id="option-a-local-development-recommended"><a class="header" href="#option-a-local-development-recommended">Option A: Local Development (Recommended)</a></h4>
<p><strong>Prerequisites:</strong></p>
<ul>
<li><strong>Docker</strong>: Required on all platforms</li>
<li><strong>Docker Management</strong> (optional but recommended):
<ul>
<li><strong>macOS</strong>: <a href="https://orbstack.dev/">OrbStack</a> (recommended) or <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></li>
<li><strong>Linux</strong>: <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> (optional GUI)</li>
</ul>
</li>
</ul>
<pre><code class="language-bash"># Use the orchestrate command for full local devnet
arch-cli orchestrate start
</code></pre>
<p>This starts a complete local development environment with:</p>
<ul>
<li>Bitcoin Core (regtest mode)</li>
<li>Titan indexer</li>
<li>Local validator</li>
</ul>
<p><strong>Advanced Options:</strong></p>
<pre><code class="language-bash"># Use local source code for development
arch-cli orchestrate start --local "$(pwd)"

# Skip bitcoind and use remote Bitcoin RPC
arch-cli orchestrate start --no-bitcoind

# Force rebuild images
arch-cli orchestrate start --force-rebuild
</code></pre>
<h4 id="option-b-testnet-remote-bitcoin--local-arch"><a class="header" href="#option-b-testnet-remote-bitcoin--local-arch">Option B: Testnet (Remote Bitcoin + Local Arch)</a></h4>
<p>For testnet development with remote Bitcoin node:</p>
<pre><code class="language-bash"># 1. Create a configuration profile
arch-cli config create-profile testnet \
    --bitcoin-node-endpoint http://bitcoin-rpc.test.arch.network:80 \
    --bitcoin-node-username bitcoin \
    --bitcoin-node-password 0F_Ed53o4kR7nxh3xNaSQx-2M3TY16L55mz5y9fjdrk \
    --bitcoin-network testnet \
    --arch-node-url http://localhost:9002

# 2. Start local Arch environment (no local bitcoind)
arch-cli --profile testnet orchestrate start --local "$(pwd)" --no-bitcoind
</code></pre>
<h4 id="option-c-devnet-full-local-stack"><a class="header" href="#option-c-devnet-full-local-stack">Option C: Devnet (Full Local Stack)</a></h4>
<p>For devnet, you‚Äôll need to run your own Bitcoin regtest node and Titan indexer:</p>
<pre><code class="language-bash"># 1. Start Bitcoin Core in regtest mode
bitcoind -regtest -port=18444 -rpcport=18443 \
    -rpcuser=bitcoin -rpcpassword=bitcoinpass \
    -fallbackfee=0.001

# 2. First-time setup (only needed once)
# Create a wallet called "testwallet"
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass createwallet testwallet

# Generate an address and mine the first 100 blocks to it
ADDRESS=$(bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass getnewaddress)
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass generatetoaddress 100 $ADDRESS

# 3. Clone and build Titan indexer (if not already done)
git clone https://github.com/saturnbtc/Titan.git
cd Titan
cargo build --release
cd ..

# 4. Start Titan indexer
./Titan/target/release/titan \
    --network regtest \
    --bitcoin-rpc-url http://bitcoin:bitcoinpass@127.0.0.1:18443 \
    --http-addr 127.0.0.1:8080 \
    --tcp-addr 127.0.0.1:3030

# 5. Start local validator
arch-cli orchestrate validator-start
</code></pre>
<h3 id="3-verify-your-environment"><a class="header" href="#3-verify-your-environment">3. Verify Your Environment</a></h3>
<p>Check that all services are running:</p>
<pre><code class="language-bash"># Check orchestrated services status
arch-cli orchestrate validator-status

# Check network connectivity
arch-cli get-block-height

# Check Bitcoin integration
arch-cli orchestrate mine-blocks --num-blocks 1
</code></pre>
<h3 id="4-build-and-deploy-your-program"><a class="header" href="#4-build-and-deploy-your-program">4. Build and Deploy Your Program</a></h3>
<pre><code class="language-bash"># Build the example program
cargo build-bpf

# Deploy to your local network
arch-cli deploy target/deploy/
</code></pre>
<h3 id="5-test-your-program"><a class="header" href="#5-test-your-program">5. Test Your Program</a></h3>
<pre><code class="language-bash"># Check the deployed program
arch-cli show &lt;PROGRAM_ID&gt;

# Run the program (if it has a client)
cargo run
</code></pre>
<h2 id="-next-steps"><a class="header" href="#-next-steps">üéØ Next Steps</a></h2>
<ul>
<li><strong>Learn More</strong>: Check out our <a href="getting-started/guides/writing-your-first-program.html">Program Development Guide</a></li>
<li><strong>Token Development</strong>: Explore <a href="getting-started/guides/how-to-create-a-fungible-token.html">APL Token Creation</a></li>
<li><strong>Examples</strong>: Browse more examples in the <a href="https://github.com/Arch-Network/arch-examples">examples directory</a></li>
<li><strong>Community</strong>: Join our <a href="https://discord.gg/archnetwork">Discord</a> for support and updates</li>
</ul>
<h2 id="-troubleshooting"><a class="header" href="#-troubleshooting">üîß Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Docker not running:</strong></p>
<pre><code class="language-bash"># Check Docker status
docker ps

# Start Docker if needed
# macOS: Open Docker Desktop or OrbStack
# Linux: sudo systemctl start docker
</code></pre>
<p><strong>Port conflicts:</strong></p>
<pre><code class="language-bash"># Check if ports are in use
netstat -an | grep 9002
netstat -an | grep 18443

# Stop conflicting services or use different ports
</code></pre>
<p><strong>Build failures:</strong></p>
<pre><code class="language-bash"># Clean and rebuild
cargo clean
cargo build-bpf

# Check Rust version
rustc --version  # Should be 1.84.1+
</code></pre>
<p><strong>Validator won‚Äôt start:</strong></p>
<pre><code class="language-bash"># Reset environment
arch-cli orchestrate reset

# Check logs
arch-cli orchestrate validator-status
</code></pre>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<ul>
<li><strong>Discord</strong>: <a href="https://discord.gg/archnetwork">https://discord.gg/archnetwork</a></li>
<li><strong>GitHub Issues</strong>: <a href="https://github.com/Arch-Network/arch-node/issues">https://github.com/Arch-Network/arch-node/issues</a></li>
<li><strong>Documentation</strong>: <a href="https://docs.arch.network">https://docs.arch.network</a></li>
</ul>
<hr />
<p><strong>Congratulations!</strong> You‚Äôve successfully set up your Arch Network development environment. You‚Äôre now ready to build and deploy programs on the most Bitcoin-native smart contract platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-validator-setup"><a class="header" href="#-validator-setup">üèóÔ∏è Validator Setup</a></h1>
<p>Welcome to the validator setup guide! This guide will walk you through setting up a full Arch Network validator node. You can choose between an automated setup or manual configuration depending on your needs.</p>
<h2 id="-what-youll-build"><a class="header" href="#-what-youll-build">üéØ What You‚Äôll Build</a></h2>
<pre class="mermaid">graph TD
    A[Bitcoin Core] --&gt;|Blockchain Data| B[Titan Indexer]
    B --&gt;|Efficient Queries| C[Validator Node]
    C --&gt;|Participate in| D[Arch Network]
    D --&gt;|Secure| E[Bitcoin Network]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef bitcoin fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    classDef titan fill:#4a90e2,stroke:#357abd,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef arch fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    class A,E bitcoin
    class B titan
    class C validator
    class D arch
</pre>
<h2 id="-component-architecture"><a class="header" href="#-component-architecture">üéØ Component Architecture</a></h2>
<pre class="mermaid">graph TD
    A[Your dApp] --&gt;|Interacts with| B[Local Validator]
    B --&gt;|Queries| C[Titan]
    C --&gt;|Reads| D[Bitcoin Core]
    D --&gt;|Manages| E[Local Blockchain]
    classDef default fill:#f8f9fa,stroke:#dee2e6,stroke-width:2px,rx:10px,ry:10px
    classDef dapp fill:#ff6b81,stroke:#ff4757,stroke-width:2px,rx:10px,ry:10px
    classDef validator fill:#2ed573,stroke:#26ae60,stroke-width:2px,rx:10px,ry:10px
    classDef titan fill:#4a90e2,stroke:#357abd,stroke-width:2px,rx:10px,ry:10px
    classDef bitcoin fill:#ffd700,stroke:#f4c430,stroke-width:2px,rx:10px,ry:10px
    classDef blockchain fill:#a4b0be,stroke:#747d8c,stroke-width:2px,rx:10px,ry:10px
    class A dapp
    class B validator
    class C titan
    class D bitcoin
    class E blockchain
    linkStyle default stroke:#a4b0be,stroke-width:2px
</pre>
<h2 id="-understanding-your-role"><a class="header" href="#-understanding-your-role">üí° Understanding Your Role</a></h2>
<p>As a validator, you will:</p>
<ul>
<li>Execute smart contracts and validate transactions</li>
<li>Participate in network consensus</li>
<li>Help secure the Bitcoin integration</li>
<li>Earn rewards for your contribution</li>
</ul>
<h2 id="-system-requirements"><a class="header" href="#-system-requirements">üìã System Requirements</a></h2>
<ul>
<li><strong>CPU</strong>: 4+ cores recommended</li>
<li><strong>RAM</strong>: 16GB+ recommended</li>
<li><strong>Storage</strong>: 100GB+ SSD for regtest, 500GB+ for testnet/mainnet</li>
<li><strong>Network</strong>: Stable internet connection (10+ Mbps)</li>
<li><strong>OS</strong>: Linux (Ubuntu 20.04+) or macOS (12.0+)</li>
</ul>
<h2 id="-setup-options"><a class="header" href="#-setup-options">üöÄ Setup Options</a></h2>
<p>Choose your preferred setup method:</p>
<h3 id="option-a-automated-setup-recommended"><a class="header" href="#option-a-automated-setup-recommended">Option A: Automated Setup (Recommended)</a></h3>
<p>The easiest way to get started using the CLI orchestrate command.</p>
<p><strong>Prerequisites:</strong></p>
<ul>
<li><strong>Docker</strong>: Required on all platforms - <a href="https://docs.docker.com/engine/install/">Install Docker</a></li>
<li><strong>Docker Management</strong> (optional but recommended):
<ul>
<li><strong>macOS</strong>: <a href="https://orbstack.dev/">OrbStack</a> (recommended) or <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></li>
<li><strong>Linux</strong>: <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a> (optional GUI)</li>
</ul>
</li>
<li><strong>Arch Network CLI</strong> - Download from <a href="https://github.com/Arch-Network/arch-node/releases/latest">releases</a></li>
</ul>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash"># 1. Download and install the Arch CLI
# (Download the appropriate binary for your platform from the releases page)

# 2. Start the complete validator stack
arch-cli orchestrate start
</code></pre>
<p>This automatically starts:</p>
<ul>
<li>Bitcoin Core (regtest mode)</li>
<li>Titan indexer</li>
<li>Local validator</li>
<li>All necessary networking and configuration</li>
</ul>
<p><strong>Service URLs:</strong></p>
<ul>
<li>Bitcoin Core RPC: <code>http://127.0.0.1:18443</code></li>
<li>Titan API: <code>http://127.0.0.1:3030</code></li>
<li>Validator RPC: <code>http://127.0.0.1:9002</code></li>
</ul>
<p><strong>Management Commands:</strong></p>
<pre><code class="language-bash"># Stop all services
arch-cli orchestrate stop

# Check validator status specifically
arch-cli orchestrate validator-status

# Reset all data (removes all data)
arch-cli orchestrate reset
</code></pre>
<h3 id="option-b-manual-setup-advanced"><a class="header" href="#option-b-manual-setup-advanced">Option B: Manual Setup (Advanced)</a></h3>
<p>For developers who want full control over their environment.</p>
<h4 id="step-1-bitcoin-core-setup"><a class="header" href="#step-1-bitcoin-core-setup">Step 1: Bitcoin Core Setup</a></h4>
<p><strong>Install and Start Bitcoin Core:</strong></p>
<pre><code class="language-bash"># Install Bitcoin Core (if not already installed)
# macOS: brew install bitcoin
# Linux: Download from https://bitcoin.org/en/download

# Start Bitcoin Core in regtest mode
bitcoind -regtest -port=18444 -rpcport=18443 \
    -rpcuser=bitcoin -rpcpassword=bitcoinpass \
    -fallbackfee=0.001

# First-time setup (only needed once)
# Create a wallet called "testwallet"
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass createwallet testwallet

# Generate an address and mine the first 100 blocks to it
ADDRESS=$(bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass getnewaddress)
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass generatetoaddress 100 $ADDRESS
</code></pre>
<h4 id="step-2-titan-indexer-setup"><a class="header" href="#step-2-titan-indexer-setup">Step 2: Titan Indexer Setup</a></h4>
<p><strong>Clone and Build Titan:</strong></p>
<pre><code class="language-bash"># Clone Titan repository
git clone https://github.com/saturnbtc/Titan.git
cd Titan

# Build Titan
cargo build --release
</code></pre>
<p><strong>Start Titan:</strong></p>
<pre><code class="language-bash"># Start Titan indexer
cargo run --bin titan -- \
    --bitcoin-rpc-url http://127.0.0.1:18443 \
    --bitcoin-rpc-username bitcoin \
    --bitcoin-rpc-password bitcoinpass \
    --chain regtest \
    --index-addresses \
    --index-bitcoin-transactions \
    --enable-tcp-subscriptions \
    --main-loop-interval 0 \
    --http-listen 127.0.0.1:3030
</code></pre>
<h4 id="step-3-validator-setup"><a class="header" href="#step-3-validator-setup">Step 3: Validator Setup</a></h4>
<p><strong>Start Validator:</strong></p>
<pre><code class="language-bash"># Using the CLI (recommended)
arch-cli validator-start

# OR using the binary directly
./local_validator \
    --rpc-bind-ip 127.0.0.1 \
    --rpc-bind-port 9002 \
    --titan-endpoint http://127.0.0.1:3030
</code></pre>
<h2 id="-process-management"><a class="header" href="#-process-management">üîÑ Process Management</a></h2>
<h3 id="for-automated-setup"><a class="header" href="#for-automated-setup">For Automated Setup</a></h3>
<p>The orchestrate command handles all process management automatically using Docker containers.</p>
<h3 id="for-manual-setup"><a class="header" href="#for-manual-setup">For Manual Setup</a></h3>
<p>You may want to use a process manager to keep services running:</p>
<p><strong>Using tmux (recommended):</strong></p>
<pre><code class="language-bash"># Create a new tmux session
tmux new -s arch-validator

# Split into three panes
# Ctrl+b then " to split horizontally
# Ctrl+b then % to split vertically
# Use arrow keys to navigate between panes

# Start each service in a separate pane:
# Pane 1: bitcoind
# Pane 2: Titan
# Pane 3: Validator
</code></pre>
<p><strong>Using systemd (Linux):</strong></p>
<pre><code class="language-bash"># Create service files for each component
sudo tee /etc/systemd/system/bitcoind.service &gt; /dev/null &lt;&lt;EOF
[Unit]
Description=Bitcoin Core Daemon
After=network.target

[Service]
ExecStart=/usr/local/bin/bitcoind -regtest -port=18444 -rpcport=18443 -rpcuser=bitcoin -rpcpassword=bitcoinpass -fallbackfee=0.001
User=bitcoin
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# Enable and start services
sudo systemctl enable bitcoind
sudo systemctl start bitcoind
</code></pre>
<h2 id="-verification"><a class="header" href="#-verification">‚úÖ Verification</a></h2>
<h3 id="check-service-status"><a class="header" href="#check-service-status">Check Service Status</a></h3>
<p><strong>Automated Setup:</strong></p>
<pre><code class="language-bash">arch-cli orchestrate validator-status
</code></pre>
<p><strong>Manual Setup:</strong></p>
<pre><code class="language-bash"># Check Bitcoin Core
bitcoin-cli -regtest -rpcuser=bitcoin -rpcpassword=bitcoinpass getblockchaininfo

# Check Titan
curl http://127.0.0.1:3030/status

# Check Validator
curl -X POST -H 'Content-Type: application/json' \
    -d '{"jsonrpc":"2.0","id":1,"method":"is_node_ready"}' \
    http://127.0.0.1:9002
</code></pre>
<h3 id="test-transaction-flow"><a class="header" href="#test-transaction-flow">Test Transaction Flow</a></h3>
<pre><code class="language-bash"># Deploy a simple program using the CLI
arch-cli deploy ./target/deploy/

# Check transaction status
arch-cli tx confirm &lt;TX_ID&gt;

# Get transaction details
arch-cli tx get &lt;TX_ID&gt;
</code></pre>
<h2 id="-troubleshooting-1"><a class="header" href="#-troubleshooting-1">üîç Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<p><strong>Docker/Orchestrate Issues:</strong></p>
<pre><code class="language-bash"># Check Docker is running
docker ps

# Check validator status
arch-cli orchestrate validator-status

# Reset everything
arch-cli orchestrate stop
arch-cli orchestrate reset
arch-cli orchestrate start
</code></pre>
<p><strong>Manual Setup Issues:</strong></p>
<pre><code class="language-bash"># Check if ports are in use
lsof -i :18443  # Bitcoin RPC
lsof -i :3030   # Titan API  
lsof -i :9002   # Validator RPC

# Check service logs
tail -f ~/.bitcoin/regtest/debug.log  # Bitcoin Core logs
</code></pre>
<p><strong>Connectivity Issues:</strong></p>
<ul>
<li>Ensure all services start in order: Bitcoin ‚Üí Titan ‚Üí Validator</li>
<li>Verify Bitcoin Core is fully synced before starting Titan</li>
<li>Check firewall settings aren‚Äôt blocking required ports</li>
<li>Confirm RPC credentials match across all services</li>
</ul>
<h2 id="-network-configurations"><a class="header" href="#-network-configurations">üåê Network Configurations</a></h2>
<h3 id="regtest-development"><a class="header" href="#regtest-development">Regtest (Development)</a></h3>
<ul>
<li><strong>Purpose</strong>: Local development and testing</li>
<li><strong>Bitcoin Network</strong>: Local regtest blockchain</li>
<li><strong>Data</strong>: Minimal, starts fresh each time</li>
<li><strong>Use Case</strong>: Development, testing, learning</li>
</ul>
<h3 id="testnet-testing"><a class="header" href="#testnet-testing">Testnet (Testing)</a></h3>
<pre><code class="language-bash"># For testnet, modify your configuration:
arch-cli orchestrate start --network testnet
# OR manually configure with testnet parameters
</code></pre>
<h3 id="mainnet-production"><a class="header" href="#mainnet-production">Mainnet (Production)</a></h3>
<pre><code class="language-bash"># For mainnet (when available):
arch-cli orchestrate start --network mainnet
# Requires significant storage and bandwidth
</code></pre>
<h2 id="-next-steps-1"><a class="header" href="#-next-steps-1">üìö Next Steps</a></h2>
<p>Once your validator is running:</p>
<ol>
<li><strong>Deploy Your First Program</strong>: Follow the <a href="getting-started/./quick-start.html">Quick Start Guide</a></li>
<li><strong>Explore RPC Methods</strong>: Check the <a href="getting-started/../rpc/rpc.html">RPC API Reference</a></li>
<li><strong>Build Advanced Programs</strong>: See <a href="getting-started/../guides/understanding-arch-programs.html">Program Development</a></li>
<li><strong>Join the Community</strong>: Connect on <a href="https://discord.gg/archnetwork">Discord</a></li>
</ol>
<h2 id="-congratulations"><a class="header" href="#-congratulations">üéâ Congratulations!</a></h2>
<p>You now have a complete Arch Network validator node running! You‚Äôre ready to:</p>
<ul>
<li>Deploy and test smart contracts</li>
<li>Participate in network consensus</li>
<li>Explore Bitcoin-native applications</li>
<li>Build the future of Bitcoin programmability</li>
</ul>
<p>For additional help, join our <a href="https://discord.gg/archnetwork">Discord community</a> or visit our <a href="https://github.com/Arch-Network">GitHub repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h1>
<p>Welcome to the Arch Network development guide. This page contains all the requirements and setup instructions needed to start developing with Arch Network.</p>
<h2 id="system-requirements-1"><a class="header" href="#system-requirements-1">System Requirements</a></h2>
<h3 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Minimum</th><th>Recommended</th></tr></thead><tbody>
<tr><td>CPU</td><td>4+ cores</td><td>8+ cores</td></tr>
<tr><td>RAM</td><td>16GB</td><td>32GB</td></tr>
<tr><td>Storage</td><td>100GB SSD</td><td>500GB+ SSD</td></tr>
<tr><td>Network</td><td>100Mbps</td><td>1Gbps+</td></tr>
</tbody></table>
</div>
<h3 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Minimum Version</th><th>Description</th></tr></thead><tbody>
<tr><td>Operating System</td><td>Ubuntu 20.04+ / macOS 12.0+</td><td>Latest LTS recommended</td></tr>
<tr><td>Git</td><td>Latest</td><td>Version control</td></tr>
<tr><td>Rust</td><td>Latest stable</td><td>Core development language</td></tr>
<tr><td>Solana CLI</td><td>v2.0+</td><td>Program compilation tools</td></tr>
<tr><td>Arch Network CLI</td><td>Latest</td><td>Development toolkit</td></tr>
</tbody></table>
</div>
<h2 id="installation-guide"><a class="header" href="#installation-guide">Installation Guide</a></h2>
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<pre><code class="language-bash"># Install Rust using rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env  # Add Rust to your current shell session

# Verify installation
rustc --version
cargo --version
</code></pre>
<h3 id="2-install-build-tools"><a class="header" href="#2-install-build-tools">2. Install Build Tools</a></h3>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<pre><code class="language-bash">xcode-select --install  # Install Command Line Tools
</code></pre>
<h4 id="linux-debianubuntu"><a class="header" href="#linux-debianubuntu">Linux (Debian/Ubuntu)</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y build-essential gcc-multilib jq
</code></pre>
<h3 id="3-install-solana-cli"><a class="header" href="#3-install-solana-cli">3. Install Solana CLI</a></h3>
<pre><code class="language-bash">sh -c "$(curl -sSfL https://release.solana.com/stable/install)"

# Verify installation (should show 2.x.x or later)
solana --version
</code></pre>
<h3 id="4-install-arch-network-cli"><a class="header" href="#4-install-arch-network-cli">4. Install Arch Network CLI</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos---apple-silicon"><a class="header" href="#macos---apple-silicon">macOS - Apple Silicon</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="macos---intel"><a class="header" href="#macos---intel">macOS - Intel</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---x86_64"><a class="header" href="#linux---x86_64">Linux - x86_64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---arm64"><a class="header" href="#linux---arm64">Linux - ARM64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
</div>
<p>Verify installation:</p>
<pre><code class="language-bash">cli --version
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="solana-installation-issues"><a class="header" href="#solana-installation-issues">Solana Installation Issues</a></h3>
<p>If you installed Rust through Homebrew and encounter <code>cargo-build-sbf</code> issues:</p>
<ol>
<li>Remove existing Rust installation:</li>
</ol>
<pre><code class="language-bash">rustup self uninstall
</code></pre>
<ol start="2">
<li>Perform clean Rust installation:</li>
</ol>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<ol start="3">
<li>Reinstall Solana:</li>
</ol>
<pre><code class="language-bash">sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
</code></pre>
<h2 id="need-help-1"><a class="header" href="#need-help-1">Need Help?</a></h2>
<ul>
<li>Check our <a href="getting-started/troubleshooting.html">Troubleshooting Guide</a></li>
<li>Join our <a href="https://discord.com/channels/1241112027963986001/1270921925991989268">Discord dev-chat</a></li>
<li>Review the <a href="https://github.com/arch-network/arch-node/releases">Arch Network CLI documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-local-validator-with-bitcoin-testnet4"><a class="header" href="#configuring-local-validator-with-bitcoin-testnet4">Configuring Local Validator with Bitcoin Testnet4</a></h1>
<p>This guide covers how to configure your Arch Network local validator to connect to Bitcoin testnet4, which provides access to additional tools and features for development and testing, including ordinals and runes functionality.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Bitcoin testnet4 is the latest Bitcoin test network that provides:</p>
<ul>
<li><strong>Ordinals Support</strong>: Create and test Bitcoin ordinal inscriptions</li>
<li><strong>Runes Protocol</strong>: Test BRC-20 and rune token functionality</li>
<li><strong>Enhanced Tooling</strong>: Access to advanced Bitcoin testing tools</li>
<li><strong>Real Network Conditions</strong>: More realistic testing environment than regtest</li>
</ul>
<p><strong>When to Use This Setup:</strong></p>
<ul>
<li>Testing ordinals/runes integration</li>
<li>Developing Bitcoin-native features</li>
<li>Testing with external Bitcoin services</li>
<li>Preparing for mainnet deployment</li>
</ul>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li><strong>Arch Network CLI</strong> installed - <a href="https://github.com/Arch-Network/arch-node/releases/latest">Download Latest</a></li>
<li><strong>Docker</strong> installed and running - <a href="https://docs.docker.com/get-docker/">Install Docker</a></li>
<li><strong>Bitcoin Core</strong> (optional, for advanced users) - <a href="https://bitcoin.org/en/download">Install Guide</a></li>
</ul>
<h2 id="quick-start-recommended"><a class="header" href="#quick-start-recommended">Quick Start (Recommended)</a></h2>
<p>The easiest way to run a local validator with testnet4 connectivity:</p>
<pre><code class="language-bash"># Start validator connected to hosted testnet4 infrastructure
arch-cli validator-start --network-mode testnet
</code></pre>
<p>This connects to Arch‚Äôs hosted testnet4 infrastructure including:</p>
<ul>
<li>Bitcoin testnet4 node</li>
<li>Titan indexer</li>
<li>Network coordination services</li>
</ul>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="basic-testnet4-configuration"><a class="header" href="#basic-testnet4-configuration">Basic Testnet4 Configuration</a></h3>
<pre><code class="language-bash">arch-cli validator-start \
  --network-mode testnet \
  --data-dir ./.arch_data \
  --rpc-bind-ip 127.0.0.1 \
  --rpc-bind-port 9002 \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h3 id="custom-network-configuration"><a class="header" href="#custom-network-configuration">Custom Network Configuration</a></h3>
<p>If you want to run your own Bitcoin testnet4 node:</p>
<pre><code class="language-bash"># Start your Bitcoin testnet4 node
bitcoind \
  -testnet4 \
  -server \
  -rpcuser=bitcoin \
  -rpcpassword=bitcoinpass \
  -rpcbind=0.0.0.0 \
  -rpcallowip=0.0.0.0/0 \
  -fallbackfee=0.00001 \
  -zmqpubrawblock=tcp://0.0.0.0:28332 \
  -zmqpubrawtx=tcp://0.0.0.0:28333

# Start validator with custom Bitcoin node
arch-cli validator-start \
  --network-mode testnet \
  --bitcoin-rpc-endpoint http://localhost:48332 \
  --bitcoin-rpc-username bitcoin \
  --bitcoin-rpc-password bitcoinpass
</code></pre>
<h2 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration Parameters</a></h2>
<h3 id="core-settings"><a class="header" href="#core-settings">Core Settings</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--network-mode</code></td><td>Network to connect to (<code>regtest</code>, <code>testnet</code>, <code>mainnet</code>)</td><td><code>regtest</code></td></tr>
<tr><td><code>--data-dir</code></td><td>Directory for validator data storage</td><td><code>./.arch_data</code></td></tr>
<tr><td><code>--rpc-bind-ip</code></td><td>IP address for RPC server</td><td><code>127.0.0.1</code></td></tr>
<tr><td><code>--rpc-bind-port</code></td><td>Port for RPC server</td><td><code>9002</code></td></tr>
</tbody></table>
</div>
<h3 id="bitcoin-integration"><a class="header" href="#bitcoin-integration">Bitcoin Integration</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--bitcoin-rpc-endpoint</code></td><td>Bitcoin node RPC URL</td><td>Uses hosted node</td></tr>
<tr><td><code>--bitcoin-rpc-username</code></td><td>Bitcoin RPC username</td><td>-</td></tr>
<tr><td><code>--bitcoin-rpc-password</code></td><td>Bitcoin RPC password</td><td>-</td></tr>
</tbody></table>
</div>
<h3 id="titan-indexer"><a class="header" href="#titan-indexer">Titan Indexer</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>--titan-endpoint</code></td><td>Titan HTTP endpoint</td><td>Hosted endpoint</td></tr>
<tr><td><code>--titan-socket-endpoint</code></td><td>Titan WebSocket endpoint</td><td>Hosted endpoint</td></tr>
</tbody></table>
</div>
<h2 id="advanced-setup-standalone-binary"><a class="header" href="#advanced-setup-standalone-binary">Advanced Setup: Standalone Binary</a></h2>
<p>For advanced users who want more control over the validator process:</p>
<h3 id="download-and-setup"><a class="header" href="#download-and-setup">Download and Setup</a></h3>
<ol>
<li>
<p><strong>Download Required Files</strong>:</p>
<pre><code class="language-bash"># Create working directory
mkdir arch-testnet4-validator
cd arch-testnet4-validator

# Download validator binary and system program
wget https://github.com/Arch-Network/arch-node/releases/latest/download/local_validator
wget https://github.com/Arch-Network/arch-node/releases/latest/download/system_program.so

# Create required directory structure
mkdir ebpf
mv system_program.so ebpf/
chmod +x local_validator
</code></pre>
</li>
<li>
<p><strong>Verify Directory Structure</strong>:</p>
<pre><code class="language-text">arch-testnet4-validator/
‚îú‚îÄ‚îÄ ebpf/
‚îÇ   ‚îî‚îÄ‚îÄ system_program.so
‚îî‚îÄ‚îÄ local_validator
</code></pre>
</li>
</ol>
<h3 id="run-standalone-validator"><a class="header" href="#run-standalone-validator">Run Standalone Validator</a></h3>
<pre><code class="language-bash">RUST_LOG=info ./local_validator \
  --network-mode testnet \
  --rpc-bind-ip 127.0.0.1 \
  --rpc-bind-port 9002 \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h2 id="testing-your-setup"><a class="header" href="#testing-your-setup">Testing Your Setup</a></h2>
<h3 id="health-check"><a class="header" href="#health-check">Health Check</a></h3>
<p>Verify your validator is running correctly:</p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' http://localhost:9002/
</code></pre>
<p><strong>Expected Response:</strong></p>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "result": true,
    "id": 1
}
</code></pre>
<h3 id="deploy-test-program"><a class="header" href="#deploy-test-program">Deploy Test Program</a></h3>
<p>Test program deployment to verify everything works:</p>
<pre><code class="language-bash"># Using CLI (automatic endpoint detection)
arch-cli deploy --network-mode testnet

# Using CLI with explicit endpoint
arch-cli deploy --network-mode testnet --rpc-url http://localhost:9002
</code></pre>
<h3 id="check-validator-status"><a class="header" href="#check-validator-status">Check Validator Status</a></h3>
<pre><code class="language-bash">arch-cli validator-status --rpc-url http://localhost:9002
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h3>
<h4 id="1-connection-refused"><a class="header" href="#1-connection-refused">1. Connection Refused</a></h4>
<pre><code class="language-bash"># Check if validator is running
curl -X POST http://localhost:9002/ \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","id":1,"method":"is_node_ready","params":[]}'
</code></pre>
<h4 id="2-reset-validator-state"><a class="header" href="#2-reset-validator-state">2. Reset Validator State</a></h4>
<pre><code class="language-bash"># Stop validator first (Ctrl+C or docker stop)
rm -rf .arch_data

# Restart validator
arch-cli validator-start --network-mode testnet
</code></pre>
<h4 id="3-view-logs"><a class="header" href="#3-view-logs">3. View Logs</a></h4>
<p><strong>Docker Logs:</strong></p>
<pre><code class="language-bash"># Find container name
docker ps

# View logs
docker logs -f &lt;container_name&gt;
</code></pre>
<p><strong>Standalone Binary Logs:</strong></p>
<pre><code class="language-bash"># Redirect logs to file
RUST_LOG=info ./local_validator \
  --network-mode testnet \
  [other options] &gt; validator.log 2&gt;&amp;1

# Monitor logs in another terminal
tail -f validator.log
</code></pre>
<h4 id="4-network-connectivity-issues"><a class="header" href="#4-network-connectivity-issues">4. Network Connectivity Issues</a></h4>
<pre><code class="language-bash"># Test connection to Titan endpoint
curl -I https://titan-node.test.aws.archnetwork.xyz

# Test WebSocket endpoint (requires wscat)
wscat -c wss://titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="1-development-cycle"><a class="header" href="#1-development-cycle">1. Development Cycle</a></h3>
<pre><code class="language-bash"># Start validator
arch-cli validator-start --network-mode testnet

# Build your program
cd your-program
cargo build-sbf

# Deploy and test
arch-cli deploy --network-mode testnet
arch-cli invoke [program-id] [account] --data [instruction-data]
</code></pre>
<h3 id="2-reset-between-tests"><a class="header" href="#2-reset-between-tests">2. Reset Between Tests</a></h3>
<pre><code class="language-bash"># Quick reset
arch-cli orchestrate reset

# Full reset (if needed)
rm -rf .arch_data
arch-cli validator-start --network-mode testnet
</code></pre>
<h3 id="3-working-with-testnet4-features"><a class="header" href="#3-working-with-testnet4-features">3. Working with Testnet4 Features</a></h3>
<p><strong>Ordinals Testing:</strong></p>
<pre><code class="language-bash"># Your program can interact with ordinal inscriptions
# Use the Bitcoin testnet4 ordinals APIs
</code></pre>
<p><strong>Runes Integration:</strong></p>
<pre><code class="language-bash"># Test rune token operations
# Integrate with runes protocol via Bitcoin transactions
</code></pre>
<h2 id="production-considerations"><a class="header" href="#production-considerations">Production Considerations</a></h2>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ul>
<li><strong>Never expose RPC ports</strong> publicly in production</li>
<li><strong>Use strong credentials</strong> for Bitcoin RPC connections</li>
<li><strong>Monitor validator health</strong> continuously</li>
</ul>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ul>
<li><strong>Allocate sufficient resources</strong> (4+ GB RAM recommended)</li>
<li><strong>Use SSD storage</strong> for data directory</li>
<li><strong>Monitor disk usage</strong> (logs can grow large)</li>
</ul>
<h3 id="networking"><a class="header" href="#networking">Networking</a></h3>
<ul>
<li><strong>Configure firewalls</strong> appropriately</li>
<li><strong>Use SSL/TLS</strong> for external connections</li>
<li><strong>Monitor network latency</strong> to Bitcoin and Titan nodes</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ol>
<li><strong>Deploy Your First Program</strong>: Follow the <a href="guides/./writing-your-first-program.html">Writing Your First Program</a> guide</li>
<li><strong>Test Thoroughly</strong>: Use the <a href="guides/./testing-guide.html">Testing Guide</a> for comprehensive testing</li>
<li><strong>Explore Examples</strong>: Check out <a href="guides/./guides.html">advanced examples</a> for complex scenarios</li>
<li><strong>Join the Community</strong>: Get help on <a href="https://discord.gg/archnetwork">Discord</a> if you run into issues</li>
</ol>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><a href="guides/../rpc/rpc.html">Arch Network CLI Reference</a></li>
<li><a href="https://mempool.space/testnet4">Bitcoin Testnet4 Faucet</a></li>
<li><a href="https://docs.ordinals.com/">Ordinals Documentation</a></li>
<li><a href="https://runes.com/">Runes Protocol Guide</a></li>
</ul>
<p><strong>Need Help?</strong> Join our <a href="https://discord.gg/archnetwork">Discord community</a> or file issues on our <a href="https://github.com/Arch-Network/arch-node/issues">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-your-node"><a class="header" href="#running-your-node">Running Your Node</a></h1>
<blockquote>
<p>‚ö†Ô∏è <strong>Mainnet Status</strong>: Arch Network mainnet has not launched yet. This guide currently covers testnet operations. ARCH token staking and mainnet validator operations will be available when mainnet launches. More details coming soon.</p>
<p>üîí <strong>Validator Pool Status</strong>: The staking validator pool is currently closed membership. When mainnet launches, the validator pool will initially be limited to approved participants and will be opened to the public at some point in the future.</p>
</blockquote>
<p>This guide will walk you through the process of operating an Arch Network validator node on testnet, including future staking mechanisms and network participation. When mainnet launches, validator operators will be an integral part of the network‚Äôs security and computation infrastructure.</p>
<div class="toc">
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<div class="toc-list">
<a href="getting-started/validator-staking.html#prerequisites" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">01</span>
        <span class="toc-text">Prerequisites</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#validator-responsibilities" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">02</span>
        <span class="toc-text">Validator Responsibilities</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#setup-and-configuration" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">03</span>
        <span class="toc-text">Setup & Configuration</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
<a href="getting-started/validator-staking.html#monitoring-and-maintenance" class="toc-item">
    <div class="toc-left">
        <span class="toc-number">04</span>
        <span class="toc-text">Monitoring & Maintenance</span>
    </div>
    <div class="toc-right">‚Üí</div>
</a>
</div>
</div>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<div class="requirement-grid">
<div class="requirement-card">
<h3 id="-system-requirements-1"><a class="header" href="#-system-requirements-1">üñ•Ô∏è System Requirements</a></h3>
<table>
<tr><th>Component</th><th>Minimum</th><th>Recommended</th></tr>
<tr><td>CPU</td><td>4+ cores</td><td>8+ cores</td></tr>
<tr><td>RAM</td><td>16GB</td><td>32GB</td></tr>
<tr><td>Storage</td><td>100GB SSD</td><td>500GB+ SSD</td></tr>
<tr><td>Network</td><td>100Mbps</td><td>1Gbps+</td></tr>
<tr><td>OS</td><td>Ubuntu 20.04+ / macOS 12.0+</td><td>Latest LTS</td></tr>
</table>
</div>
<div class="requirement-card">
<h3 id="-arch-tokens-future-mainnet"><a class="header" href="#-arch-tokens-future-mainnet">üîë ARCH Tokens (Future Mainnet)</a></h3>
<p><strong>‚ö†Ô∏è Not yet available:</strong> ARCH token staking will be available for approved validators when mainnet launches. The staking validator pool is currently closed membership.</p>
<ul>
<li>Minimum stake amounts (TBD)</li>
<li>Lockup periods (TBD)</li>
<li>Commission rates (TBD)</li>
<li>Application process for validator pool membership (TBD)</li>
</ul>
<p><strong>Current Testnet:</strong> No ARCH tokens required - use the faucet for test tokens.</p>
<p>More details about mainnet staking and validator pool access will be announced closer to mainnet launch.</p>
</div>
</div>
<h2 id="validator-responsibilities"><a class="header" href="#validator-responsibilities">Validator Responsibilities</a></h2>
<div class="responsibility-grid">
<div class="responsibility-card">
<h3 id="-transaction-processing"><a class="header" href="#-transaction-processing">üîÑ Transaction Processing</a></h3>
<ul>
<li>Execute programs in Arch VM</li>
<li>Validate transaction signatures</li>
<li>Process Bitcoin-related transactions</li>
<li>Maintain transaction history</li>
</ul>
</div>
<div class="responsibility-card">
<h3 id="-consensus-participation"><a class="header" href="#-consensus-participation">ü§ù Consensus Participation</a></h3>
<ul>
<li>Participate in ROAST protocol</li>
<li>Contribute to threshold signing</li>
<li>Coordinate transaction finality</li>
<li>Verify state transitions</li>
</ul>
</div>
<div class="responsibility-card">
<h3 id="-state-management"><a class="header" href="#-state-management">üìä State Management</a></h3>
<ul>
<li>Track UTXO states</li>
<li>Validate Bitcoin operations</li>
<li>Maintain state consistency</li>
<li>Verify network state</li>
</ul>
</div>
</div>
<h2 id="setup--configuration"><a class="header" href="#setup--configuration">Setup &amp; Configuration</a></h2>
<h3 id="1-install-arch-network-cli"><a class="header" href="#1-install-arch-network-cli">1. Install Arch Network CLI</a></h3>
<div class="platform-select">
<div class="platform-option">
<h4 id="macos---apple-silicon-1"><a class="header" href="#macos---apple-silicon-1">macOS - Apple Silicon</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="macos---intel-1"><a class="header" href="#macos---intel-1">macOS - Intel</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-apple-darwin
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---x86_64-1"><a class="header" href="#linux---x86_64-1">Linux - x86_64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-x86_64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
<div class="platform-option">
<h4 id="linux---arm64-1"><a class="header" href="#linux---arm64-1">Linux - ARM64</a></h4>
<pre><code class="language-bash">curl -L -o cli https://github.com/Arch-Network/arch-node/releases/latest/download/cli-aarch64-unknown-linux-gnu
chmod +x cli
sudo mv cli /usr/local/bin/
</code></pre>
</div>
</div>
<p>Verify installation:</p>
<pre><code class="language-bash">cli --version
</code></pre>
<h3 id="2-configure-bitcoin-node-access"><a class="header" href="#2-configure-bitcoin-node-access">2. Configure Bitcoin Node Access</a></h3>
<div class="network-select">
<div class="network-option">
<h4 id="-remote-node-recommended"><a class="header" href="#-remote-node-recommended">üì° Remote Node (Recommended)</a></h4>
<p><strong>Regtest/Development:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint bitcoin-node.dev.aws.archnetwork.xyz \
--bitcoin-rpc-port 18443 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testwallet
</code></pre>
<p><strong>Testnet:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint bitcoin-rpc.test.arch.network \
--bitcoin-rpc-port 80 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testwallet
</code></pre>
</div>
<div class="network-option">
<h4 id="-local-node"><a class="header" href="#-local-node">üñ•Ô∏è Local Node</a></h4>
<p>For advanced users who want full control. See our <a href="getting-started/bitcoin-and-titan-setup.html">Bitcoin Node Setup Guide</a>.</p>
<p><strong>Local Regtest Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 18443 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet regtest
</code></pre>
<p><strong>Local Testnet Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 18332 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet testnet
</code></pre>
<p><strong>Local Mainnet Configuration:</strong></p>
<pre><code class="language-bash">--bitcoin-rpc-endpoint 127.0.0.1 \
--bitcoin-rpc-port 8332 \
--bitcoin-rpc-username your_username \
--bitcoin-rpc-password your_password \
--bitcoin-rpc-wallet mainnet
</code></pre>
</div>
</div>
<h3 id="3-start-your-validator"><a class="header" href="#3-start-your-validator">3. Start Your Validator</a></h3>
<blockquote>
<p>‚ö†Ô∏è <strong>Current Status</strong>: Mainnet is not yet available. Use testnet for current operations.</p>
</blockquote>
<p><strong>For Testnet (Currently Available):</strong></p>
<pre><code class="language-bash">cli validator-start \
  --network-mode testnet \
  --titan-endpoint titan-node.test.aws.archnetwork.xyz \
  --titan-socket-endpoint titan-node.test.aws.archnetwork.xyz:49332
</code></pre>
<p><strong>For Mainnet (Future):</strong></p>
<pre><code class="language-bash"># Mainnet configuration will be available when mainnet launches
cli validator-start \
  --network-mode mainnet \
  --titan-endpoint &lt;mainnet-endpoint-tbd&gt; \
  --titan-socket-endpoint &lt;mainnet-socket-tbd&gt;
</code></pre>
<h2 id="monitoring--maintenance"><a class="header" href="#monitoring--maintenance">Monitoring &amp; Maintenance</a></h2>
<div class="monitoring-grid">
<div class="monitoring-card">
<h3 id="-health-checks"><a class="header" href="#-health-checks">üìä Health Checks</a></h3>
<pre><code class="language-bash"># Node status
arch-cli validator status

# Performance metrics
arch-cli validator metrics
</code></pre>
</div>
<div class="monitoring-card">
<h3 id="-sync-management"><a class="header" href="#-sync-management">üîÑ Sync Management</a></h3>
<pre><code class="language-bash"># Check sync status
arch-cli validator sync-status

# Force resync if needed
arch-cli validator resync
</code></pre>
</div>
</div>
<h2 id="understanding-staking-in-arch-network-future"><a class="header" href="#understanding-staking-in-arch-network-future">Understanding Staking in Arch Network (Future)</a></h2>
<blockquote>
<p>‚ö†Ô∏è <strong>Note</strong>: The staking mechanisms described below are planned for mainnet launch and are not currently available. Current testnet operations do not require ARCH token staking.</p>
</blockquote>
<div class="staking-explanation">
<h3 id="-what-will-staking-be"><a class="header" href="#-what-will-staking-be">üîê What will Staking be?</a></h3>
<p>Staking in Arch Network will be fundamentally different from traditional Proof of Stake systems. Instead of using staking for consensus, Arch Network will use staked validators to participate in the ROAST protocol for secure Bitcoin transaction signing.</p>
<pre class="mermaid">flowchart TB
    subgraph Staking[&quot;Staking Process&quot;]
        direction TB
        V[Validator Node] --&gt;|1. Stakes ARCH| N[Network]
        N --&gt;|2. Assigns Share| DKG[Distributed Key]
        DKG --&gt;|3. Participates in| ROAST[ROAST Protocol]
    end

    subgraph Validation[&quot;Transaction Validation&quot;]
        direction TB
        TX[Transaction] --&gt;|1. Submitted| L[Leader]
        L --&gt;|2. Distributes| VS[Validator Set]
        VS --&gt;|3. Execute &amp; Sign| R[Results]
        R --&gt;|4. Aggregate| BTC[Bitcoin Network]
    end

    style Staking fill:#f3e5f5,stroke:#4a148c
    style Validation fill:#e8f5e9,stroke:#1b5e20
</pre>
<h3 id="-solana-vs-arch-network-validator-comparison"><a class="header" href="#-solana-vs-arch-network-validator-comparison">ü§î Solana vs. Arch Network: Validator Comparison</a></h3>
<div class="comparison-table">
<table>
<tr><th>Feature</th><th>Solana</th><th>Arch Network</th></tr>
<tr>
  <td><b>Consensus Role</b></td>
  <td>Validators vote on blocks and produce blocks when selected as leader</td>
  <td>Validators execute transactions and sign Bitcoin transactions using threshold signatures</td>
</tr>
<tr>
  <td><b>Economic Model</b></td>
  <td>Block rewards + transaction fees</td>
  <td>Transaction fees + commission from Bitcoin operations</td>
</tr>
<tr>
  <td><b>Selection Mechanism</b></td>
  <td>Stake-weighted leader selection</td>
  <td>Stake-weighted participation in threshold signing committee</td>
</tr>
<tr>
  <td><b>Performance Metrics</b></td>
  <td>Vote signing speed, block production, uptime</td>
  <td>Transaction execution correctness, signing participation, uptime</td>
</tr>
<tr>
  <td><b>Slashing Conditions</b></td>
  <td>Double signing, unavailability</td>
  <td>Malicious signing, transaction manipulation attempts</td>
</tr>
<tr>
  <td><b>Hardware Requirements</b></td>
  <td>High-end CPU, 128GB+ RAM, 2TB+ NVMe</td>
  <td>4+ CPU cores, 16GB+ RAM, 100GB+ SSD</td>
</tr>
</table>
</div>
<h3 id="-from-solana-to-arch-operational-transition-guide"><a class="header" href="#-from-solana-to-arch-operational-transition-guide">üöÄ From Solana to Arch: Operational Transition Guide</a></h3>
<p>If you‚Äôre an experienced Solana validator operator, here‚Äôs what you need to know about running an Arch Network validator:</p>
<div class="transition-grid">
<div class="transition-card">
<h4 id="-technical-setup"><a class="header" href="#-technical-setup">‚öôÔ∏è Technical Setup</a></h4>
<ul>
<li><b>Lower Hardware Requirements:</b> Arch Network requires less powerful hardware than Solana</li>
<li><b>Bitcoin RPC Access:</b> Validators need Bitcoin node access (remote or local)</li>
<li><b>Key Management:</b> Different key structure focusing on distributed key generation</li>
<li><b>Monitoring:</b> Focus on signing participation rather than block production</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-economic-considerations"><a class="header" href="#-economic-considerations">üí∞ Economic Considerations</a></h4>
<ul>
<li><b>Staking Return Model:</b> Fee-based with transaction execution rewards</li>
<li><b>Reward Distribution:</b> Based on stake proportion and signing participation</li>
<li><b>Commission Structure:</b> Set during validator configuration</li>
<li><b>Lockup Periods:</b> Network-defined based on security requirements</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-operational-differences"><a class="header" href="#-operational-differences">üîÑ Operational Differences</a></h4>
<ul>
<li><b>Signing vs. Voting:</b> Focus on correct transaction execution and signing</li>
<li><b>Performance Metrics:</b> Measured by signing participation and availability</li>
<li><b>Updates:</b> Less frequent than Solana's rapid release cycle</li>
<li><b>Network Bandwidth:</b> Lower requirements due to different architecture</li>
</ul>
</div>
<div class="transition-card">
<h4 id="-onboarding-process-future-mainnet"><a class="header" href="#-onboarding-process-future-mainnet">üõ£Ô∏è Onboarding Process (Future Mainnet)</a></h4>
<ul>
<li><b>Application:</b> Apply for validator pool membership (initially closed membership)</li>
<li><b>Approval:</b> Await approval for validator participation</li>
<li><b>Registration:</b> Complete validator registration through the network portal (TBD)</li>
<li><b>Stake Deposit:</b> Transfer ARCH tokens to the validator staking contract (TBD)</li>
<li><b>Configuration:</b> Set up your validator with proper Bitcoin node access</li>
<li><b>Key Generation:</b> Participate in distributed key generation ceremony</li>
<li><b>Activation:</b> Begin participation after stake activation period</li>
</ul>
<p><strong>Note:</strong> The validator pool will initially be limited to approved participants and will open to the public in the future.</p>
<h4 id="-current-testnet-onboarding"><a class="header" href="#-current-testnet-onboarding">üß™ Current Testnet Onboarding</a></h4>
<ul>
<li><b>No Registration Required:</b> Simply start a testnet validator</li>
<li><b>No Stake Required:</b> Testnet operation is free</li>
<li><b>Configuration:</b> Set up your validator with testnet endpoints</li>
<li><b>Testing:</b> Deploy programs and test functionality</li>
<li><b>Immediate Participation:</b> Begin testing immediately</li>
</ul>
</div>
</div>
<h3 id="-staking-economics-future-mainnet"><a class="header" href="#-staking-economics-future-mainnet">üìä Staking Economics (Future Mainnet)</a></h3>
<div class="economics-grid">
<div class="economics-card">
<h4 id="validator-requirements-planned"><a class="header" href="#validator-requirements-planned">Validator Requirements (Planned)</a></h4>
<ul>
<li><b>Minimum Stake:</b> TBD - Details will be announced before mainnet launch</li>
<li><b>Lockup Period:</b> Network-defined based on security requirements (TBD)</li>
<li><b>Uptime Requirement:</b> High availability expected for signing participation</li>
<li><b>Performance Bonding:</b> Stake will act as bond for correct behavior</li>
</ul>
</div>
<div class="economics-card">
<h4 id="reward-structure-planned"><a class="header" href="#reward-structure-planned">Reward Structure (Planned)</a></h4>
<ul>
<li><b>Base Rewards:</b> From transaction fees distributed proportionally to stake</li>
<li><b>Signing Rewards:</b> Additional rewards for participating in threshold signing</li>
<li><b>Commission:</b> Set percentage of rewards retained by validator</li>
<li><b>Distribution Frequency:</b> Continuous as transactions are processed</li>
</ul>
</div>
</div>
<div class="economics-card">
<h4 id="current-testnet-operations"><a class="header" href="#current-testnet-operations">Current Testnet Operations</a></h4>
<ul>
<li><b>Open Access:</b> Anyone can run a testnet validator</li>
<li><b>No Staking Required:</b> Testnet validators operate without ARCH token requirements</li>
<li><b>Test Tokens:</b> Use the faucet to get test tokens for transactions</li>
<li><b>No Rewards:</b> Testnet operation is for testing and development only</li>
<li><b>Free Operation:</b> No costs beyond infrastructure for testnet participation</li>
</ul>
</div>
<div class="economics-card">
<h4 id="validator-types-comparison"><a class="header" href="#validator-types-comparison">Validator Types Comparison</a></h4>
<table>
<tr><th>Validator Type</th><th>Access</th><th>Staking</th><th>Rewards</th></tr>
<tr>
  <td><b>Testnet Validators</b></td>
  <td>Open to all</td>
  <td>No staking required</td>
  <td>No rewards (testing only)</td>
</tr>
<tr>
  <td><b>Mainnet Staking Validators</b></td>
  <td>Closed membership initially</td>
  <td>ARCH tokens required (TBD)</td>
  <td>Transaction fees + signing rewards</td>
</tr>
</table>
</div>
<h3 id="-roast-protocol-integration"><a class="header" href="#-roast-protocol-integration">üîÑ ROAST Protocol Integration</a></h3>
<p>The ROAST (Robust Asynchronous Schnorr Threshold) protocol enables validators to collectively sign Bitcoin transactions:</p>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;L: 4. Sign Results
    L-&gt;&gt;B: 5. Submit to Bitcoin
</pre>
<h3 id="-security-model"><a class="header" href="#-security-model">üõ°Ô∏è Security Model</a></h3>
<pre class="mermaid">flowchart LR
    subgraph Security[&quot;Security Layers&quot;]
        direction TB
        UTXO[UTXO Validation] --&gt;|Verifies| Own[Ownership]
        Own --&gt;|Ensures| State[State Consistency]
        State --&gt;|Commits to| BTC[Bitcoin]
    end

    subgraph Threshold[&quot;Threshold Signing&quot;]
        direction TB
        Val[Validators] --&gt;|t-of-n| Sign[Signature]
        Sign --&gt;|ROAST| Agg[Aggregation]
        Agg --&gt;|Submit| Final[Final Transaction]
    end

    style Security fill:#e1f5fe,stroke:#01579b
    style Threshold fill:#fff3e0,stroke:#e65100
</pre>
<div class="staking-card">
<h4 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h4>
<ul>
<li>Distributed key generation for secure signing</li>
<li>Threshold signature scheme (t-of-n) for fault tolerance</li>
<li>Bitcoin-based finality guarantees</li>
<li>Automatic malicious node detection</li>
</ul>
</div>
</div>
<style>
.requirement-grid, .responsibility-grid, .monitoring-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.requirement-card, .responsibility-card, .monitoring-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.requirement-card h3, .responsibility-card h3, .monitoring-card h3 {
    margin-top: 0;
    color: #2c3e50;
}

.platform-select, .network-select {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
    margin: 1.5rem 0;
}

.platform-option, .network-option {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
    width: 100%;
    border-collapse: collapse;
}

th, td {
    padding: 0.5rem;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    background: #f1f3f5;
}

.staking-explanation {
    background: #ffffff;
    border-radius: 8px;
    padding: 2rem;
    margin: 2rem 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.staking-explanation h3 {
    color: #2c3e50;
    margin-top: 2rem;
}

.staking-explanation h3:first-child {
    margin-top: 0;
}

.staking-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    margin-top: 2rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.staking-card h4 {
    margin-top: 0;
    color: #2c3e50;
}

.comparison-table {
    overflow-x: auto;
    margin: 1.5rem 0;
}

.comparison-table table {
    width: 100%;
    border-collapse: collapse;
}

.comparison-table th {
    background: #f1f3f5;
    padding: 0.75rem;
    text-align: left;
}

.comparison-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #ddd;
}

.transition-grid, .economics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 1.5rem 0;
}

.transition-card, .economics-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.transition-card h4, .economics-card h4 {
    margin-top: 0;
    color: #2c3e50;
}
</style> <div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-arch-programs"><a class="header" href="#understanding-arch-programs">Understanding Arch Programs</a></h1>
<p>This comprehensive guide walks you through building Arch Network programs by examining a complete, working example. We‚Äôll build a ‚ÄúHello World‚Äù program that demonstrates all the essential concepts you need to start developing on Arch Network.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You‚Äôll Learn</a></h2>
<p>By the end of this guide, you‚Äôll understand:</p>
<ul>
<li>Program structure and architecture</li>
<li>Account management and state handling</li>
<li>Bitcoin transaction integration</li>
<li>Error handling best practices</li>
<li>Testing and deployment patterns</li>
</ul>
<h2 id="complete-example-hello-world-program"><a class="header" href="#complete-example-hello-world-program">Complete Example: Hello World Program</a></h2>
<p>Let‚Äôs build a complete program that stores personalized greetings and demonstrates key Arch Network concepts.</p>
<h3 id="1-project-setup"><a class="header" href="#1-project-setup">1. Project Setup</a></h3>
<p>First, create your program with the correct dependencies:</p>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "hello_world_program"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = { path = "../../program" }
borsh = { version = "1.5.1", features = ["derive"] }

[lib]
crate-type = ["cdylib", "lib"]

[workspace]
</code></pre>
<h3 id="2-program-dependencies-and-imports"><a class="header" href="#2-program-dependencies-and-imports">2. Program Dependencies and Imports</a></h3>
<p><strong>src/lib.rs</strong></p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    bitcoin::{self, absolute::LockTime, transaction::Version, Transaction},
    entrypoint,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    msg,
    program::{next_account_info, set_transaction_to_sign},
    program_error::ProgramError,
    pubkey::Pubkey,
    transaction_to_sign::TransactionToSign,
};
use borsh::{BorshDeserialize, BorshSerialize};</code></pre>
<p><strong>Key Dependencies Explained:</strong></p>
<ul>
<li><code>AccountInfo</code>: Access to account data and metadata</li>
<li><code>bitcoin</code>: Bitcoin transaction types and functionality</li>
<li><code>entrypoint</code>: Macro for registering program entry point</li>
<li><code>helper::add_state_transition</code>: Manages Bitcoin state transitions</li>
<li><code>msg</code>: Logging for debugging and monitoring</li>
<li><code>borsh</code>: Efficient serialization for program data</li>
</ul>
<h3 id="3-program-data-structures"><a class="header" href="#3-program-data-structures">3. Program Data Structures</a></h3>
<pre><code class="language-rust ignore">/// Parameters sent to our Hello World program
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct HelloWorldParams {
    /// The name to include in the greeting
    pub name: String,
    /// Bitcoin transaction for paying fees
    pub tx_hex: Vec&lt;u8&gt;,
}

/// State stored in the account
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct GreetingAccount {
    /// The greeting message
    pub message: String,
    /// Who was greeted
    pub name: String,
    /// When this greeting was created (block height)
    pub created_at: u64,
    /// How many times this account has been updated
    pub update_count: u32,
}

impl GreetingAccount {
    pub const MAX_SIZE: usize = 4 + 50 + 4 + 50 + 8 + 4; // Borsh overhead + data
    
    pub fn new(name: String, message: String, block_height: u64) -&gt; Self {
        Self {
            message,
            name,
            created_at: block_height,
            update_count: 1,
        }
    }
}</code></pre>
<h3 id="4-custom-error-handling"><a class="header" href="#4-custom-error-handling">4. Custom Error Handling</a></h3>
<pre><code class="language-rust ignore">/// Custom errors for our Hello World program
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HelloWorldError {
    /// The provided name is too long (max 50 chars)
    NameTooLong,
    /// The provided name is empty
    NameEmpty,
    /// The provided name contains invalid characters
    InvalidCharacters,
    /// Account data is corrupted
    InvalidAccountData,
    /// Insufficient fees provided
    InsufficientFees,
}

impl From&lt;HelloWorldError&gt; for ProgramError {
    fn from(e: HelloWorldError) -&gt; Self {
        ProgramError::Custom(match e {
            HelloWorldError::NameTooLong =&gt; 1001,
            HelloWorldError::NameEmpty =&gt; 1002,
            HelloWorldError::InvalidCharacters =&gt; 1003,
            HelloWorldError::InvalidAccountData =&gt; 1004,
            HelloWorldError::InsufficientFees =&gt; 1005,
        })
    }
}

/// Validates the provided name
fn validate_name(name: &amp;str) -&gt; Result&lt;(), HelloWorldError&gt; {
    if name.is_empty() {
        return Err(HelloWorldError::NameEmpty);
    }
    
    if name.len() &gt; 50 {
        return Err(HelloWorldError::NameTooLong);
    }
    
    if !name.chars().all(|c| c.is_alphanumeric() || c.is_whitespace() || c == '-' || c == '_') {
        return Err(HelloWorldError::InvalidCharacters);
    }
    
    Ok(())
}</code></pre>
<h3 id="5-program-entry-point-and-logic"><a class="header" href="#5-program-entry-point-and-logic">5. Program Entry Point and Logic</a></h3>
<pre><code class="language-rust ignore">// Register our program's entry point
entrypoint!(process_instruction);

/// Main program entry point
pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    msg!("Hello World program invoked");

    // Parse instruction data
    let params: HelloWorldParams = borsh::from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    
    // Validate input
    validate_name(&amp;params.name)?;
    
    msg!("Processing greeting for: {}", params.name);

    // Validate accounts
    if accounts.len() != 1 {
        msg!("Expected 1 account, got {}", accounts.len());
        return Err(ProgramError::NotEnoughAccountKeys);
    }

    let account_iter = &amp;mut accounts.iter();
    let greeting_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !greeting_account.is_writable {
        msg!("Account must be writable");
        return Err(ProgramError::InvalidAccountData);
    }

    if !greeting_account.is_signer {
        msg!("Account must be a signer");
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Process the greeting
    process_greeting(greeting_account, &amp;params)?;
    
    // Handle Bitcoin transaction
    handle_bitcoin_transaction(greeting_account, &amp;params.tx_hex)?;

    msg!("Hello World program completed successfully");
    Ok(())
}

/// Processes the greeting and updates account state
fn process_greeting(
    account: &amp;AccountInfo,
    params: &amp;HelloWorldParams,
) -&gt; Result&lt;(), ProgramError&gt; {
    let current_data_len = account.data.borrow().len();
    
    // Check if account is initialized
    let mut greeting_data = if current_data_len == 0 {
        msg!("Initializing new greeting account");
        GreetingAccount::new(
            params.name.clone(),
            format!("Hello, {}! Welcome to Arch Network!", params.name),
            0, // We'll get actual block height in a real implementation
        )
    } else {
        // Update existing account
        let existing_data = GreetingAccount::try_from_slice(&amp;account.data.borrow())
            .map_err(|_| HelloWorldError::InvalidAccountData)?;
        
        msg!("Updating greeting for existing account");
        GreetingAccount {
            message: format!("Hello again, {}! Visit count: {}", 
                           params.name, existing_data.update_count + 1),
            name: params.name.clone(),
            created_at: existing_data.created_at,
            update_count: existing_data.update_count + 1,
        }
    };

    // Serialize the new data
    let serialized_data = borsh::to_vec(&amp;greeting_data)
        .map_err(|_| ProgramError::InvalidAccountData)?;

    // Ensure account has enough space
    if serialized_data.len() &gt; current_data_len {
        msg!("Reallocating account space from {} to {} bytes", 
             current_data_len, serialized_data.len());
        account.realloc(serialized_data.len(), true)?;
    }

    // Write the data
    account.data.borrow_mut().copy_from_slice(&amp;serialized_data);
    
    msg!("Greeting stored: {}", greeting_data.message);
    Ok(())
}

/// Handles Bitcoin transaction for state transition
fn handle_bitcoin_transaction(
    account: &amp;AccountInfo,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    if tx_hex.is_empty() {
        return Err(HelloWorldError::InsufficientFees.into());
    }

    // Deserialize the fee transaction
    let fees_tx: Transaction = bitcoin::consensus::deserialize(tx_hex)
        .map_err(|_| HelloWorldError::InsufficientFees)?;

    msg!("Processing Bitcoin transaction with {} inputs", fees_tx.input.len());

    // Create state transition transaction
    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };

    // Add state transition for our account
    add_state_transition(&amp;mut tx, account);
    
    // Add fee input
    if !fees_tx.input.is_empty() {
        tx.input.push(fees_tx.input[0].clone());
    }

    // Prepare transaction for signing
    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;[InputToSign {
            index: 0,
            signer: account.key.clone(),
        }],
    };

    msg!("Submitting transaction for signing");
    set_transaction_to_sign(&amp;[account.clone()], tx_to_sign)?;

    Ok(())
}</code></pre>
<h2 id="program-architecture-breakdown"><a class="header" href="#program-architecture-breakdown">Program Architecture Breakdown</a></h2>
<h3 id="1-entrypoint-pattern"><a class="header" href="#1-entrypoint-pattern">1. <strong>Entrypoint Pattern</strong></a></h3>
<pre><code class="language-rust ignore">entrypoint!(process_instruction);</code></pre>
<p>Every Arch program needs exactly one entry point. The <code>entrypoint!</code> macro registers your <code>process_instruction</code> function as the program‚Äôs main entry point.</p>
<h3 id="2-function-signature"><a class="header" href="#2-function-signature">2. <strong>Function Signature</strong></a></h3>
<pre><code class="language-rust ignore">pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt;</code></pre>
<p><strong>Parameters explained:</strong></p>
<ul>
<li><code>program_id</code>: Your program‚Äôs public key (often unused in simple programs)</li>
<li><code>accounts</code>: Array of accounts this instruction will read/write</li>
<li><code>instruction_data</code>: Serialized parameters for your specific instruction</li>
</ul>
<h3 id="3-account-validation"><a class="header" href="#3-account-validation">3. <strong>Account Validation</strong></a></h3>
<p>Always validate accounts before use:</p>
<pre><code class="language-rust ignore">// Check account count
if accounts.len() != expected_count {
    return Err(ProgramError::NotEnoughAccountKeys);
}

// Check permissions
if !account.is_writable {
    return Err(ProgramError::InvalidAccountData);
}

if !account.is_signer {
    return Err(ProgramError::MissingRequiredSignature);
}</code></pre>
<h3 id="4-state-management"><a class="header" href="#4-state-management">4. <strong>State Management</strong></a></h3>
<pre><code class="language-rust ignore">// Read existing state
let data = MyState::try_from_slice(&amp;account.data.borrow())?;

// Modify state
let new_data = MyState { /* updated fields */ };

// Serialize and store
let serialized = borsh::to_vec(&amp;new_data)?;
account.data.borrow_mut().copy_from_slice(&amp;serialized);</code></pre>
<h3 id="5-bitcoin-integration"><a class="header" href="#5-bitcoin-integration">5. <strong>Bitcoin Integration</strong></a></h3>
<p>Every state change must be committed to Bitcoin:</p>
<pre><code class="language-rust ignore">// Create Bitcoin transaction
let mut tx = Transaction { /* ... */ };

// Add state transition
add_state_transition(&amp;mut tx, account);

// Submit for signing
set_transaction_to_sign(accounts, TransactionToSign { /* ... */ })?;</code></pre>
<h2 id="testing-your-program"><a class="header" href="#testing-your-program">Testing Your Program</a></h2>
<p>Create comprehensive tests for your program:</p>
<p><strong>tests/integration_test.rs</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::helper::sign_and_send_instruction;
use arch_test_sdk::{
    get_balance_bitcoin, initialize_client, Account, Balance
};

#[test]
fn test_hello_world_basic() {
    let (client, _boot_info) = initialize_client();
    
    let program_pubkey = deploy_program();
    let user_account = Account::new();
    
    // Test initial greeting
    let params = HelloWorldParams {
        name: "Alice".to_string(),
        tx_hex: create_fee_transaction(),
    };
    
    let result = send_hello_instruction(&amp;client, &amp;program_pubkey, &amp;user_account, params);
    assert!(result.is_ok());
    
    // Verify state was stored correctly
    let account_data = client.read_account_info(user_account.pubkey()).unwrap();
    let greeting = GreetingAccount::try_from_slice(&amp;account_data.data).unwrap();
    
    assert_eq!(greeting.name, "Alice");
    assert!(greeting.message.contains("Hello, Alice"));
    assert_eq!(greeting.update_count, 1);
}

#[test]
fn test_error_handling() {
    // Test name too long
    let params = HelloWorldParams {
        name: "A".repeat(100), // Too long
        tx_hex: create_fee_transaction(),
    };
    
    let result = send_hello_instruction(&amp;client, &amp;program_pubkey, &amp;user_account, params);
    assert!(result.is_err());
    
    // Test empty name
    let params = HelloWorldParams {
        name: "".to_string(),
        tx_hex: create_fee_transaction(),
    };
    
    let result = send_hello_instruction(&amp;client, &amp;program_pubkey, &amp;user_account, params);
    assert!(result.is_err());
}</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-error-handling"><a class="header" href="#1-error-handling">1. <strong>Error Handling</strong></a></h3>
<ul>
<li>Define custom error types for better debugging</li>
<li>Use descriptive error messages with <code>msg!</code></li>
<li>Validate all inputs before processing</li>
<li>Handle both program logic and Bitcoin transaction errors</li>
</ul>
<h3 id="2-account-management"><a class="header" href="#2-account-management">2. <strong>Account Management</strong></a></h3>
<ul>
<li>Always check account permissions (<code>is_signer</code>, <code>is_writable</code>)</li>
<li>Validate account ownership when needed</li>
<li>Use <code>realloc</code> when data size changes</li>
<li>Consider account rent and minimum balances</li>
</ul>
<h3 id="3-state-design"><a class="header" href="#3-state-design">3. <strong>State Design</strong></a></h3>
<ul>
<li>Keep state structures simple and well-defined</li>
<li>Use Borsh for efficient serialization</li>
<li>Consider data size limits</li>
<li>Plan for state evolution</li>
</ul>
<h3 id="4-bitcoin-integration"><a class="header" href="#4-bitcoin-integration">4. <strong>Bitcoin Integration</strong></a></h3>
<ul>
<li>Always include fee transactions</li>
<li>Validate transaction structure</li>
<li>Use proper input/output management</li>
<li>Handle signing requirements correctly</li>
</ul>
<h3 id="5-security"><a class="header" href="#5-security">5. <strong>Security</strong></a></h3>
<ul>
<li>Validate all input parameters</li>
<li>Check account ownership and permissions</li>
<li>Prevent reentrancy attacks</li>
<li>Use safe arithmetic operations</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="program-derived-addresses-pdas"><a class="header" href="#program-derived-addresses-pdas">Program-Derived Addresses (PDAs)</a></h3>
<pre><code class="language-rust ignore">let (pda, bump) = Pubkey::find_program_address(
    &amp;[b"greeting", user.key.as_ref()],
    program_id
);</code></pre>
<h3 id="cross-program-invocation-cpi"><a class="header" href="#cross-program-invocation-cpi">Cross-Program Invocation (CPI)</a></h3>
<pre><code class="language-rust ignore">let instruction = system_instruction::create_account(/* ... */);
invoke(&amp;instruction, &amp;[account1, account2, system_program])?;</code></pre>
<h3 id="multiple-instructions"><a class="header" href="#multiple-instructions">Multiple Instructions</a></h3>
<pre><code class="language-rust ignore">match MyInstruction::try_from_slice(instruction_data)? {
    MyInstruction::Initialize { .. } =&gt; process_initialize(accounts)?,
    MyInstruction::Update { .. } =&gt; process_update(accounts)?,
    MyInstruction::Close =&gt; process_close(accounts)?,
}</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you understand the fundamentals:</p>
<ol>
<li><strong>Explore Advanced Examples</strong>: Check out the <a href="guides/../apl/token-program.html">token program</a> and <a href="guides/./how-to-write-oracle-program.html">oracle implementation</a></li>
<li><strong>Learn Testing</strong>: Set up comprehensive test suites for your programs</li>
<li><strong>Understand PDAs</strong>: Master program-derived addresses for complex state management</li>
<li><strong>Study CPI</strong>: Learn cross-program invocation for composable programs</li>
<li><strong>Deploy and Monitor</strong>: Learn deployment and monitoring best practices</li>
</ol>
<h2 id="additional-resources-1"><a class="header" href="#additional-resources-1">Additional Resources</a></h2>
<ul>
<li><a href="https://github.com/Arch-Network/arch-examples">Program Examples Repository</a></li>
<li><a href="guides/../apl/token-program.html">APL Token Implementation</a></li>
<li><a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration Guide</a></li>
<li><a href="guides/../rpc/rpc.html">RPC API Reference</a></li>
</ul>
<p>The complete code for this example is available in the <a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/helloworld">Hello World example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-an-arch-network-project"><a class="header" href="#setting-up-an-arch-network-project">Setting up an Arch Network Project</a></h1>
<p>This guide walks you through creating your first Arch Network project. You‚Äôll learn how to set up, build, and deploy a ‚ÄúHello World‚Äù program to the Arch Network using the Arch Network CLI tool.</p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>Before starting, ensure you have the following dependencies installed:</p>
<ul>
<li>Arch Network CLI (Latest)</li>
<li>Solana CLI (Latest stable version)</li>
<li>Cargo (v1.81.0 or later)</li>
<li>Rust (Latest stable version)</li>
<li>Bitcoin Core and Titan: Required for local validation</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<h3 id="1-clone-the-example-repository"><a class="header" href="#1-clone-the-example-repository">1. Clone the Example Repository</a></h3>
<p>Start by cloning the Arch Network examples repository:</p>
<pre><code class="language-bash"># Clone the examples repository
git clone https://github.com/Arch-Network/arch-examples.git

# Navigate to the Hello World example
cd arch-examples/examples/helloworld
</code></pre>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<p>After cloning, you‚Äôll see the following project structure:</p>
<p>The helloworld folder should look like this:</p>
<pre><code class="language-ignore">
helloworld/
‚îú‚îÄ‚îÄ Cargo.toml              # Workspace configuration
‚îú‚îÄ‚îÄ program/                # Program directory containing on-chain code
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.lock
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml         # Program dependencies
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs         # Program logic
‚îî‚îÄ‚îÄ src/                   # Client-side code
    ‚îî‚îÄ‚îÄ lib.rs             # Client interface
</code></pre>
<h3 id="2-build-the-program"><a class="header" href="#2-build-the-program">2. Build the program</a></h3>
<p>Build the program using the Solana BPF compiler:</p>
<pre><code class="language-bash"># Navigate to the program directory
cd program

# Build the program using Solana's BPF compiler
cargo build-sbf
</code></pre>
<p>This command compiles your Rust code into a format that can be deployed to the Arch Network.</p>
<h3 id="3-start-the-local-validator"><a class="header" href="#3-start-the-local-validator">3. Start the local validator</a></h3>
<p>Start a local validator for testing:</p>
<pre><code class="language-bash"># Start the Arch Network validator
arch-cli validator-start
</code></pre>
<blockquote>
<p>Important: Ensure Bitcoin Core and Titan are properly configured and running before starting the validator. See the setup guide for details.</p>
</blockquote>
<h3 id="4-deploy-the-program"><a class="header" href="#4-deploy-the-program">4. Deploy the program</a></h3>
<p>Deploy your compiled program to the local Arch Network:</p>
<pre><code class="language-bash"># Deploy the program
arch-cli deploy ./target/deploy/
</code></pre>
<h3 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h3>
<p>Common issues and solutions:</p>
<ul>
<li>
<p>If cargo build-sbf fails:</p>
<ul>
<li>Ensure you have the latest version of Rust and Cargo</li>
<li>Check that all dependencies are properly installed</li>
</ul>
</li>
<li>
<p>If validator fails to start:</p>
<ul>
<li>Verify Bitcoin Core and Titan are running</li>
<li>Check the logs for specific error messages</li>
</ul>
</li>
</ul>
<h2 id="additional-cli-commands"><a class="header" href="#additional-cli-commands">Additional CLI Commands</a></h2>
<p>For more advanced operations, the Arch Network CLI provides additional commands:</p>
<pre><code class="language-bash"># Show program information
arch-cli show &lt;PROGRAM_ADDRESS&gt;

# Confirm transaction status
arch-cli confirm &lt;TX_ID&gt;

# Get block information
arch-cli get-block &lt;BLOCK_HASH&gt;

# Get block height
arch-cli get-block-height
</code></pre>
<p>For a complete list of available commands, refer to the <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network CLI documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-first-arch-program"><a class="header" href="#writing-your-first-arch-program">Writing Your First Arch Program</a></h1>
<p>This comprehensive guide walks you through creating your first Arch program from scratch. We‚Äôll build a feature-rich counter program that demonstrates the complete development workflow and all essential concepts you need for building production-ready Arch Network applications.</p>
<h2 id="what-youll-build"><a class="header" href="#what-youll-build">What You‚Äôll Build</a></h2>
<p>By the end of this guide, you‚Äôll have created a complete counter program that:</p>
<ul>
<li>Manages state in program accounts</li>
<li>Handles multiple instruction types</li>
<li>Integrates with Bitcoin transactions</li>
<li>Includes comprehensive error handling</li>
<li>Provides extensive testing coverage</li>
<li>Follows security best practices</li>
</ul>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li><strong>Rust 1.70+</strong> and Cargo installed (<a href="https://rustup.rs/">Install Rust</a>)</li>
<li><strong>Solana CLI 2.0+</strong> - <a href="https://docs.solana.com/cli/install-solana-cli-tools">Install Guide</a></li>
<li><strong>Arch Network CLI</strong> - <a href="https://github.com/Arch-Network/arch-node/releases/latest">Download Latest</a></li>
<li><strong>Running validator</strong> (see <a href="guides/../getting-started/bitcoin-and-titan-setup.html">Validator Setup Guide</a>)</li>
<li><strong>Basic Rust knowledge</strong> and understanding of <a href="guides/../concepts/architecture.html">Arch concepts</a></li>
</ul>
<h2 id="step-1-project-setup"><a class="header" href="#step-1-project-setup">Step 1: Project Setup</a></h2>
<h3 id="11-create-project-structure"><a class="header" href="#11-create-project-structure">1.1 Create Project Structure</a></h3>
<pre><code class="language-bash"># Create project directory
mkdir my-counter-program
cd my-counter-program

# Create program directory
mkdir program
cd program

# Initialize Rust library
cargo init --lib
</code></pre>
<h3 id="12-configure-dependencies"><a class="header" href="#12-configure-dependencies">1.2 Configure Dependencies</a></h3>
<p>Create a proper <code>Cargo.toml</code>:</p>
<p><strong>program/Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "my_counter_program"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = "0.5.4"
borsh = { version = "1.5.1", features = ["derive"] }

[lib]
crate-type = ["cdylib", "lib"]

[workspace]
</code></pre>
<h3 id="13-project-structure"><a class="header" href="#13-project-structure">1.3 Project Structure</a></h3>
<p>Your project should look like this:</p>
<pre><code class="language-text">my-counter-program/
‚îú‚îÄ‚îÄ program/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ client/          # We'll add this later
‚îî‚îÄ‚îÄ tests/           # We'll add this later
</code></pre>
<h2 id="step-2-define-program-data-structures"><a class="header" href="#step-2-define-program-data-structures">Step 2: Define Program Data Structures</a></h2>
<p>Create comprehensive data structures for your program:</p>
<p><strong>program/src/lib.rs</strong></p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    bitcoin::{self, absolute::LockTime, transaction::Version, Transaction},
    entrypoint,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    msg,
    program::{next_account_info, set_transaction_to_sign},
    program_error::ProgramError,
    pubkey::Pubkey,
    transaction_to_sign::TransactionToSign,
};
use borsh::{BorshDeserialize, BorshSerialize};

/// Counter program state stored in accounts
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct CounterAccount {
    /// Current counter value
    pub count: i64,
    /// Who created this counter
    pub authority: Pubkey,
    /// When this counter was created (block height)
    pub created_at: u64,
    /// When this counter was last updated
    pub updated_at: u64,
    /// Total number of operations performed
    pub operation_count: u64,
    /// Whether the counter is frozen
    pub is_frozen: bool,
}

impl CounterAccount {
    pub const SIZE: usize = 8 + 32 + 8 + 8 + 8 + 1; // i64 + Pubkey + u64 + u64 + u64 + bool
    
    pub fn new(authority: Pubkey, block_height: u64) -&gt; Self {
        Self {
            count: 0,
            authority,
            created_at: block_height,
            updated_at: block_height,
            operation_count: 0,
            is_frozen: false,
        }
    }
}

/// Instructions that can be performed on the counter
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub enum CounterInstruction {
    /// Initialize a new counter
    /// Accounts:
    /// 0. [writable, signer] Counter account to initialize
    Initialize,
    
    /// Increment the counter by a specified amount
    /// Accounts:
    /// 0. [writable] Counter account to increment
    /// 1. [signer] Authority or allowed user
    Increment { amount: u32 },
    
    /// Decrement the counter by a specified amount
    /// Accounts:
    /// 0. [writable] Counter account to decrement
    /// 1. [signer] Authority or allowed user
    Decrement { amount: u32 },
    
    /// Reset the counter to zero
    /// Accounts:
    /// 0. [writable] Counter account to reset
    /// 1. [signer] Authority only
    Reset,
    
    /// Freeze the counter to prevent modifications
    /// Accounts:
    /// 0. [writable] Counter account to freeze
    /// 1. [signer] Authority only
    Freeze,
    
    /// Unfreeze the counter to allow modifications
    /// Accounts:
    /// 0. [writable] Counter account to unfreeze
    /// 1. [signer] Authority only
    Unfreeze,
}

/// Parameters for counter operations that require Bitcoin transactions
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct CounterParams {
    /// The instruction to execute
    pub instruction: CounterInstruction,
    /// Bitcoin transaction for fees
    pub tx_hex: Vec&lt;u8&gt;,
}

/// Custom errors for the counter program
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CounterError {
    /// Counter is frozen and cannot be modified
    CounterFrozen,
    /// Only the authority can perform this operation
    UnauthorizedAccess,
    /// Counter overflow occurred
    Overflow,
    /// Counter underflow occurred
    Underflow,
    /// Invalid instruction data
    InvalidInstruction,
    /// Counter account not initialized
    UninitializedAccount,
    /// Invalid account provided
    InvalidAccount,
    /// Insufficient fees provided
    InsufficientFees,
}

impl From&lt;CounterError&gt; for ProgramError {
    fn from(e: CounterError) -&gt; Self {
        ProgramError::Custom(match e {
            CounterError::CounterFrozen =&gt; 1001,
            CounterError::UnauthorizedAccess =&gt; 1002,
            CounterError::Overflow =&gt; 1003,
            CounterError::Underflow =&gt; 1004,
            CounterError::InvalidInstruction =&gt; 1005,
            CounterError::UninitializedAccount =&gt; 1006,
            CounterError::InvalidAccount =&gt; 1007,
            CounterError::InsufficientFees =&gt; 1008,
        })
    }
}</code></pre>
<h2 id="step-3-implement-program-logic"><a class="header" href="#step-3-implement-program-logic">Step 3: Implement Program Logic</a></h2>
<p>Add the complete program implementation:</p>
<pre><code class="language-rust ignore">// Register program entrypoint
entrypoint!(process_instruction);

/// Main program entrypoint
pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    msg!("Counter program invoked");

    // Parse instruction data
    let params: CounterParams = borsh::from_slice(instruction_data)
        .map_err(|_| CounterError::InvalidInstruction)?;

    msg!("Processing instruction: {:?}", params.instruction);

    // Dispatch to appropriate handler
    match params.instruction {
        CounterInstruction::Initialize =&gt; {
            process_initialize(accounts, &amp;params.tx_hex)
        }
        CounterInstruction::Increment { amount } =&gt; {
            process_increment(accounts, amount, &amp;params.tx_hex)
        }
        CounterInstruction::Decrement { amount } =&gt; {
            process_decrement(accounts, amount, &amp;params.tx_hex)
        }
        CounterInstruction::Reset =&gt; {
            process_reset(accounts, &amp;params.tx_hex)
        }
        CounterInstruction::Freeze =&gt; {
            process_freeze(accounts, &amp;params.tx_hex)
        }
        CounterInstruction::Unfreeze =&gt; {
            process_unfreeze(accounts, &amp;params.tx_hex)
        }
    }
}

/// Initialize a new counter account
fn process_initialize(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !counter_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Check if account is already initialized
    if counter_account.data.borrow().len() &gt;= CounterAccount::SIZE {
        let existing_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow());
        if existing_data.is_ok() {
            msg!("Counter account already initialized");
            return Err(CounterError::InvalidAccount.into());
        }
    }

    // Initialize counter account
    let counter_data = CounterAccount::new(*counter_account.key, 0); // TODO: Get actual block height
    
    // Ensure account has enough space
    if counter_account.data.borrow().len() &lt; CounterAccount::SIZE {
        counter_account.realloc(CounterAccount::SIZE, true)?;
    }

    // Serialize and store data
    let serialized_data = borsh::to_vec(&amp;counter_data)
        .map_err(|_| ProgramError::InvalidAccountData)?;
    
    counter_account.data.borrow_mut()[..serialized_data.len()]
        .copy_from_slice(&amp;serialized_data);

    msg!("Counter initialized with authority: {}", counter_account.key);

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Increment the counter
fn process_increment(
    accounts: &amp;[AccountInfo],
    amount: u32,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter).unwrap_or(counter_account);

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check if counter is frozen
    if counter_data.is_frozen {
        return Err(CounterError::CounterFrozen.into());
    }

    // Perform increment with overflow protection
    let new_count = counter_data.count
        .checked_add(amount as i64)
        .ok_or(CounterError::Overflow)?;

    // Update counter data
    counter_data.count = new_count;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter incremented by {} to {}", amount, new_count);

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Decrement the counter
fn process_decrement(
    accounts: &amp;[AccountInfo],
    amount: u32,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter).unwrap_or(counter_account);

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check if counter is frozen
    if counter_data.is_frozen {
        return Err(CounterError::CounterFrozen.into());
    }

    // Perform decrement with underflow protection
    let new_count = counter_data.count
        .checked_sub(amount as i64)
        .ok_or(CounterError::Underflow)?;

    // Update counter data
    counter_data.count = new_count;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter decremented by {} to {}", amount, new_count);

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Reset the counter to zero
fn process_reset(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check authority
    if counter_data.authority != *authority_account.key {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Check if counter is frozen
    if counter_data.is_frozen {
        return Err(CounterError::CounterFrozen.into());
    }

    // Reset counter
    counter_data.count = 0;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter reset to 0");

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Freeze the counter
fn process_freeze(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check authority
    if counter_data.authority != *authority_account.key {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Freeze counter
    counter_data.is_frozen = true;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter frozen");

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Unfreeze the counter
fn process_unfreeze(
    accounts: &amp;[AccountInfo],
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(account_iter)?;
    let authority_account = next_account_info(account_iter)?;

    // Verify account permissions
    if !counter_account.is_writable {
        return Err(CounterError::InvalidAccount.into());
    }

    if !authority_account.is_signer {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Load and validate counter data
    let mut counter_data = CounterAccount::try_from_slice(&amp;counter_account.data.borrow())
        .map_err(|_| CounterError::UninitializedAccount)?;

    // Check authority
    if counter_data.authority != *authority_account.key {
        return Err(CounterError::UnauthorizedAccess.into());
    }

    // Unfreeze counter
    counter_data.is_frozen = false;
    counter_data.updated_at = 0; // TODO: Get actual block height
    counter_data.operation_count += 1;

    // Save updated data
    save_counter_data(counter_account, &amp;counter_data)?;

    msg!("Counter unfrozen");

    // Handle Bitcoin transaction
    handle_bitcoin_transaction(counter_account, tx_hex)?;

    Ok(())
}

/// Helper function to save counter data
fn save_counter_data(
    counter_account: &amp;AccountInfo,
    counter_data: &amp;CounterAccount,
) -&gt; Result&lt;(), ProgramError&gt; {
    let serialized_data = borsh::to_vec(counter_data)
        .map_err(|_| ProgramError::InvalidAccountData)?;
    
    counter_account.data.borrow_mut()[..serialized_data.len()]
        .copy_from_slice(&amp;serialized_data);
    
    Ok(())
}

/// Handle Bitcoin transaction for state changes
fn handle_bitcoin_transaction(
    account: &amp;AccountInfo,
    tx_hex: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    if tx_hex.is_empty() {
        return Err(CounterError::InsufficientFees.into());
    }

    // Deserialize the fee transaction
    let fees_tx: Transaction = bitcoin::consensus::deserialize(tx_hex)
        .map_err(|_| CounterError::InsufficientFees)?;

    msg!("Processing Bitcoin transaction with {} inputs", fees_tx.input.len());

    // Create state transition transaction
    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };

    // Add state transition for our account
    add_state_transition(&amp;mut tx, account);
    
    // Add fee input
    if !fees_tx.input.is_empty() {
        tx.input.push(fees_tx.input[0].clone());
    }

    // Prepare transaction for signing
    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;[InputToSign {
            index: 0,
            signer: account.key.clone(),
        }],
    };

    msg!("Submitting transaction for signing");
    set_transaction_to_sign(&amp;[account.clone()], tx_to_sign)?;

    Ok(())
}</code></pre>
<h2 id="step-4-build-your-program"><a class="header" href="#step-4-build-your-program">Step 4: Build Your Program</a></h2>
<p>Build your program using the Solana toolchain:</p>
<pre><code class="language-bash">cd program

# Build the program
cargo build-sbf

# Verify the build output
ls target/deploy/
</code></pre>
<p>You should see <code>my_counter_program.so</code> in the <code>target/deploy/</code> directory.</p>
<h2 id="step-5-deploy-your-program"><a class="header" href="#step-5-deploy-your-program">Step 5: Deploy Your Program</a></h2>
<p>Deploy your program to the Arch Network:</p>
<pre><code class="language-bash"># Deploy to testnet (recommended for testing)
arch-cli deploy ./target/deploy/ --network-mode testnet

# Or deploy to local network for development
arch-cli deploy ./target/deploy/ --network-mode regtest
</code></pre>
<p><strong>Save the Program ID</strong> from the output - you‚Äôll need it for testing!</p>
<h2 id="step-6-create-a-client-for-testing"><a class="header" href="#step-6-create-a-client-for-testing">Step 6: Create a Client for Testing</a></h2>
<p>Create a client to interact with your program:</p>
<p><strong>client/Cargo.toml</strong></p>
<pre><code class="language-toml ignore">[package]
name = "counter_client"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_sdk = "0.5.4"
my_counter_program = { path = "../program" }
borsh = "1.5.1"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<p><strong>client/src/main.rs</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::{
    instruction::Instruction,
    message::ArchMessage,
    pubkey::Pubkey,
    signer::{create_account, Keypair},
    transaction::Transaction,
};
use my_counter_program::{CounterInstruction, CounterParams, CounterAccount};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Your program ID (replace with actual deployed program ID)
    let program_id = Pubkey::from_str("YOUR_PROGRAM_ID_HERE")?;
    
    // Create a new account for the counter
    let counter_keypair = Keypair::new();
    
    // Create fee transaction (simplified)
    let fee_tx = create_fee_transaction();
    
    // Test initialize instruction
    test_initialize(&amp;program_id, &amp;counter_keypair, &amp;fee_tx)?;
    
    // Test increment instruction
    test_increment(&amp;program_id, &amp;counter_keypair, &amp;fee_tx, 5)?;
    
    // Test decrement instruction
    test_decrement(&amp;program_id, &amp;counter_keypair, &amp;fee_tx, 2)?;
    
    // Test reset instruction
    test_reset(&amp;program_id, &amp;counter_keypair, &amp;fee_tx)?;
    
    println!("All tests completed successfully!");
    Ok(())
}

fn test_initialize(
    program_id: &amp;Pubkey,
    counter_keypair: &amp;Keypair,
    fee_tx: &amp;[u8],
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let params = CounterParams {
        instruction: CounterInstruction::Initialize,
        tx_hex: fee_tx.to_vec(),
    };
    
    let instruction = Instruction {
        program_id: *program_id,
        accounts: vec![
            AccountMeta::new(counter_keypair.pubkey(), true),
        ],
        data: borsh::to_vec(&amp;params)?,
    };
    
    // Send transaction (implementation depends on your client setup)
    send_transaction(&amp;instruction, &amp;[counter_keypair])?;
    
    println!("Counter initialized successfully");
    Ok(())
}

// Add similar functions for other operations...</code></pre>
<h2 id="step-7-comprehensive-testing"><a class="header" href="#step-7-comprehensive-testing">Step 7: Comprehensive Testing</a></h2>
<p>Create extensive tests for your program:</p>
<p><strong>tests/integration_tests.rs</strong></p>
<pre><code class="language-rust ignore">use my_counter_program::*;
use arch_test_sdk::*;

#[tokio::test]
async fn test_counter_full_workflow() {
    let (client, _boot_info) = initialize_client();
    
    // Deploy program
    let program_id = deploy_counter_program(&amp;client).await;
    
    // Create test account
    let user_keypair = Keypair::new();
    fund_account(&amp;client, &amp;user_keypair.pubkey(), 1000).await;
    
    // Test initialization
    let counter_account = test_initialize(&amp;client, &amp;program_id, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 0, false).await;
    
    // Test increment
    test_increment(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair, 10).await;
    verify_counter_state(&amp;client, &amp;counter_account, 10, false).await;
    
    // Test decrement
    test_decrement(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair, 3).await;
    verify_counter_state(&amp;client, &amp;counter_account, 7, false).await;
    
    // Test freeze
    test_freeze(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 7, true).await;
    
    // Test operations while frozen (should fail)
    let result = test_increment(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair, 1).await;
    assert!(result.is_err(), "Increment should fail when counter is frozen");
    
    // Test unfreeze
    test_unfreeze(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 7, false).await;
    
    // Test reset
    test_reset(&amp;client, &amp;program_id, &amp;counter_account, &amp;user_keypair).await;
    verify_counter_state(&amp;client, &amp;counter_account, 0, false).await;
}

#[tokio::test]
async fn test_error_conditions() {
    // Test overflow protection
    // Test underflow protection
    // Test unauthorized access
    // Test invalid instructions
    // TODO: Implement comprehensive error testing
}</code></pre>
<h2 id="step-8-best-practices-implementation"><a class="header" href="#step-8-best-practices-implementation">Step 8: Best Practices Implementation</a></h2>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li><strong>Input Validation</strong>: Always validate all inputs</li>
<li><strong>Overflow Protection</strong>: Use checked arithmetic operations</li>
<li><strong>Access Control</strong>: Verify account ownership and permissions</li>
<li><strong>State Validation</strong>: Ensure account state is valid before operations</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ol>
<li><strong>Efficient Serialization</strong>: Use Borsh for optimal performance</li>
<li><strong>Minimal Account Size</strong>: Keep state structures compact</li>
<li><strong>Transaction Batching</strong>: Group related operations when possible</li>
</ol>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<ol>
<li><strong>Custom Error Types</strong>: Define specific errors for better debugging</li>
<li><strong>Comprehensive Logging</strong>: Use <code>msg!</code> for important state changes</li>
<li><strong>Graceful Failures</strong>: Handle edge cases appropriately</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you‚Äôve built your first program:</p>
<ol>
<li><strong>Enhance the Counter</strong>: Add features like access control lists, multiple counters per account, or counter metadata</li>
<li><strong>Explore Advanced Patterns</strong>: Learn about <a href="guides/../program/accounts.html">Program Derived Addresses</a> and <a href="guides/../program/instructions-and-messages.html">Cross-Program Invocation</a></li>
<li><strong>Build Complex Programs</strong>: Try the <a href="guides/./how-to-create-a-fungible-token.html">Token Program</a> or <a href="guides/./how-to-write-oracle-program.html">Oracle Program</a> guides</li>
<li><strong>Deploy to Mainnet</strong>: When ready, deploy your programs to mainnet (when available)</li>
</ol>
<h2 id="additional-resources-2"><a class="header" href="#additional-resources-2">Additional Resources</a></h2>
<ul>
<li><a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a> - Deep dive into program architecture</li>
<li><a href="guides/./testing-guide.html">Testing Guide</a> - Comprehensive testing strategies</li>
<li><a href="https://github.com/Arch-Network/arch-examples">Program Examples</a> - More example programs</li>
<li><a href="guides/../rpc/rpc.html">API Reference</a> - Complete RPC documentation</li>
</ul>
<p><strong>Congratulations!</strong> You‚Äôve successfully built, deployed, and tested your first Arch Network program. You now have the foundation to build more complex applications on the Arch Network.</p>
<pre><code class="language-bash"># Start the Arch Network validator
arch-cli validator-start
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehensive-testing-guide-for-arch-network-programs"><a class="header" href="#comprehensive-testing-guide-for-arch-network-programs">Comprehensive Testing Guide for Arch Network Programs</a></h1>
<p>This guide provides complete coverage of testing strategies, tools, and best practices for building robust and reliable Arch Network programs. Proper testing is essential for ensuring your programs work correctly and securely before deployment.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Testing Arch programs involves multiple layers:</p>
<ul>
<li><strong>Unit Tests</strong>: Individual function and logic testing</li>
<li><strong>Integration Tests</strong>: Cross-component functionality testing</li>
<li><strong>End-to-End Tests</strong>: Full program workflow testing</li>
<li><strong>Security Tests</strong>: Vulnerability and attack vector testing</li>
<li><strong>Performance Tests</strong>: Load and efficiency testing</li>
</ul>
<h2 id="project-setup-for-testing"><a class="header" href="#project-setup-for-testing">Project Setup for Testing</a></h2>
<h3 id="test-directory-structure"><a class="header" href="#test-directory-structure">Test Directory Structure</a></h3>
<pre><code class="language-text">my-program/
‚îú‚îÄ‚îÄ program/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ integration.rs
‚îÇ   ‚îú‚îÄ‚îÄ security.rs
‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îÇ       ‚îî‚îÄ‚îÄ mod.rs
‚îî‚îÄ‚îÄ Cargo.toml (workspace)
</code></pre>
<h3 id="test-dependencies-configuration"><a class="header" href="#test-dependencies-configuration">Test Dependencies Configuration</a></h3>
<p><strong>Cargo.toml (workspace root)</strong></p>
<pre><code class="language-toml">[workspace]
members = ["program", "tests"]

[workspace.dependencies]
arch_program = "0.5.4"
arch_sdk = "0.5.4"
borsh = { version = "1.5.1", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<p><strong>tests/Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "program-tests"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = { workspace = true }
arch_sdk = { workspace = true }
borsh = { workspace = true }
tokio = { workspace = true }

# Test utilities
proptest = "1.0"
rstest = "0.18"
serial_test = "3.0"

# Your program dependency
my_program = { path = "../program" }

[[bin]]
name = "test-runner"
path = "src/main.rs"
</code></pre>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<h3 id="basic-unit-tests"><a class="header" href="#basic-unit-tests">Basic Unit Tests</a></h3>
<p>Unit tests go directly in your program‚Äôs <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::{
        account::AccountInfo,
        program_error::ProgramError,
        pubkey::Pubkey,
    };

    #[test]
    fn test_counter_account_serialization() {
        let counter = CounterAccount::new(Pubkey::new_unique(), 100);
        
        // Test serialization
        let serialized = borsh::to_vec(&amp;counter).unwrap();
        let deserialized: CounterAccount = borsh::from_slice(&amp;serialized).unwrap();
        
        assert_eq!(counter, deserialized);
    }

    #[test]
    fn test_instruction_parsing() {
        let instruction = CounterInstruction::Increment { amount: 5 };
        let params = CounterParams {
            instruction,
            tx_hex: vec![0x01, 0x02, 0x03],
        };
        
        let serialized = borsh::to_vec(&amp;params).unwrap();
        let parsed: CounterParams = borsh::from_slice(&amp;serialized).unwrap();
        
        match parsed.instruction {
            CounterInstruction::Increment { amount } =&gt; assert_eq!(amount, 5),
            _ =&gt; panic!("Wrong instruction type"),
        }
    }

    #[test]
    fn test_error_codes() {
        let error: ProgramError = CounterError::CounterFrozen.into();
        assert_eq!(error, ProgramError::Custom(1001));
    }

    #[test]
    fn test_overflow_protection() {
        let mut counter = CounterAccount::new(Pubkey::new_unique(), 100);
        counter.count = i64::MAX;
        
        // This should detect overflow
        let result = counter.count.checked_add(1);
        assert!(result.is_none());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-unit-testing"><a class="header" href="#advanced-unit-testing">Advanced Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod advanced_tests {
    use super::*;
    use proptest::prelude::*;

    // Property-based testing
    proptest! {
        #[test]
        fn test_counter_operations_never_panic(
            initial_value in i32::MIN..i32::MAX,
            operation_value in 1u32..1000u32
        ) {
            let mut counter = CounterAccount::new(Pubkey::new_unique(), 100);
            counter.count = initial_value as i64;

            // These operations should never panic
            let _ = counter.count.checked_add(operation_value as i64);
            let _ = counter.count.checked_sub(operation_value as i64);
        }
    }

    // Parameterized tests
    use rstest::rstest;

    #[rstest]
    #[case(CounterInstruction::Increment { amount: 1 })]
    #[case(CounterInstruction::Decrement { amount: 1 })]
    #[case(CounterInstruction::Reset)]
    #[case(CounterInstruction::Freeze)]
    #[case(CounterInstruction::Unfreeze)]
    fn test_instruction_serialization(#[case] instruction: CounterInstruction) {
        let params = CounterParams {
            instruction: instruction.clone(),
            tx_hex: vec![],
        };
        
        let serialized = borsh::to_vec(&amp;params).unwrap();
        let deserialized: CounterParams = borsh::from_slice(&amp;serialized).unwrap();
        
        assert_eq!(params.instruction, deserialized.instruction);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h3>
<p><strong>tests/common/mod.rs</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::{
    client::ArchClient,
    instruction::Instruction,
    pubkey::Pubkey,
    signer::Keypair,
    transaction::Transaction,
};
use std::sync::Once;

static INIT: Once = Once::new();

pub struct TestEnvironment {
    pub client: ArchClient,
    pub payer: Keypair,
    pub program_id: Pubkey,
}

impl TestEnvironment {
    pub async fn new() -&gt; Self {
        INIT.call_once(|| {
            env_logger::init();
        });

        let client = ArchClient::new("http://localhost:9001").unwrap();
        let payer = Keypair::new();
        
        // Fund the payer
        let airdrop_signature = client
            .request_airdrop(&amp;payer.pubkey(), 10_000_000)
            .await
            .unwrap();
        
        client.confirm_transaction(&amp;airdrop_signature).await.unwrap();

        // Deploy program
        let program_id = deploy_test_program(&amp;client, &amp;payer).await;

        TestEnvironment {
            client,
            payer,
            program_id,
        }
    }

    pub async fn create_funded_account(&amp;self) -&gt; Keypair {
        let account = Keypair::new();
        let signature = self.client
            .request_airdrop(&amp;account.pubkey(), 1_000_000)
            .await
            .unwrap();
        
        self.client.confirm_transaction(&amp;signature).await.unwrap();
        account
    }
}

async fn deploy_test_program(client: &amp;ArchClient, payer: &amp;Keypair) -&gt; Pubkey {
    let program_data = include_bytes!("../../program/target/deploy/my_counter_program.so");
    
    let program_id = client
        .deploy_program(payer, program_data)
        .await
        .unwrap();
    
    program_id
}

// Helper functions for test data
pub fn create_counter_initialize_instruction(
    program_id: &amp;Pubkey,
    counter_account: &amp;Pubkey,
    authority: &amp;Pubkey,
) -&gt; Instruction {
    use my_program::{CounterInstruction, CounterParams};
    
    let params = CounterParams {
        instruction: CounterInstruction::Initialize,
        tx_hex: create_test_fee_transaction(),
    };
    
    Instruction {
        program_id: *program_id,
        accounts: vec![
            AccountMeta::new(*counter_account, true),
            AccountMeta::new_readonly(*authority, true),
        ],
        data: borsh::to_vec(&amp;params).unwrap(),
    }
}

pub fn create_test_fee_transaction() -&gt; Vec&lt;u8&gt; {
    // Return a minimal valid Bitcoin transaction for testing
    vec![
        0x02, 0x00, 0x00, 0x00, // version
        0x01, // input count
        // ... simplified test transaction data
    ]
}</code></pre>
<h3 id="complete-integration-tests"><a class="header" href="#complete-integration-tests">Complete Integration Tests</a></h3>
<p><strong>tests/integration.rs</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::prelude::*;
use my_program::*;
use serial_test::serial;

mod common;
use common::*;

#[tokio::test]
#[serial]
async fn test_complete_counter_workflow() {
    let env = TestEnvironment::new().await;
    
    // Create counter account
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Test 1: Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Initialize should succeed");
    
    // Verify initial state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 0);
    assert_eq!(counter_state.authority, user.pubkey());
    assert!(!counter_state.is_frozen);
    
    // Test 2: Increment counter
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        10,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Increment should succeed");
    
    // Verify incremented state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 10);
    assert_eq!(counter_state.operation_count, 1);
    
    // Test 3: Freeze counter
    let freeze_ix = create_counter_freeze_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[freeze_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Freeze should succeed");
    
    // Test 4: Try to increment frozen counter (should fail)
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        5,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Increment should fail when frozen");
    
    // Test 5: Unfreeze and increment
    let unfreeze_ix = create_counter_unfreeze_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        5,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[unfreeze_ix, increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Unfreeze and increment should succeed");
    
    // Final verification
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 15);
    assert!(!counter_state.is_frozen);
}</code></pre>
<h2 id="security-testing"><a class="header" href="#security-testing">Security Testing</a></h2>
<p><strong>tests/security.rs</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::prelude::*;
use my_program::*;
use serial_test::serial;

mod common;
use common::*;

#[tokio::test]
#[serial]
async fn test_unauthorized_access() {
    let env = TestEnvironment::new().await;
    
    // Create counter with user1 as authority
    let counter_keypair = Keypair::new();
    let user1 = env.create_funded_account().await;
    let user2 = env.create_funded_account().await;
    
    // Initialize counter with user1 as authority
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user1.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user1],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Try to reset counter with user2 (should fail)
    let reset_ix = create_counter_reset_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user2.pubkey(), // Wrong authority
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[reset_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user2],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Reset should fail with wrong authority");
}

#[tokio::test]
#[serial]
async fn test_overflow_protection() {
    let env = TestEnvironment::new().await;
    
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Try to increment by maximum value (should fail due to overflow protection)
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        u32::MAX, // This should cause overflow
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Large increment should fail due to overflow protection");
}</code></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p><strong>tests/performance.rs</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::prelude::*;
use my_program::*;
use std::time::Instant;
use tokio::time::{sleep, Duration};

mod common;
use common::*;

#[tokio::test]
async fn test_transaction_throughput() {
    let env = TestEnvironment::new().await;
    
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Benchmark multiple increments
    let start_time = Instant::now();
    let num_operations = 100;
    
    for i in 0..num_operations {
        let increment_ix = create_counter_increment_instruction(
            &amp;env.program_id,
            &amp;counter_keypair.pubkey(),
            &amp;user.pubkey(),
            1,
        );
        
        let tx = Transaction::new_signed_with_payer(
            &amp;[increment_ix],
            Some(&amp;env.payer.pubkey()),
            &amp;[&amp;env.payer, &amp;user],
            env.client.get_latest_blockhash().await.unwrap(),
        );
        
        env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
        
        if i % 10 == 0 {
            println!("Completed {} operations", i + 1);
        }
        
        // Small delay to avoid overwhelming the network
        sleep(Duration::from_millis(10)).await;
    }
    
    let elapsed = start_time.elapsed();
    let ops_per_second = num_operations as f64 / elapsed.as_secs_f64();
    
    println!("Completed {} operations in {:?}", num_operations, elapsed);
    println!("Throughput: {:.2} operations/second", ops_per_second);
    
    // Verify final state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, num_operations);
    assert_eq!(counter_state.operation_count, num_operations as u64);
}</code></pre>
<h2 id="test-execution"><a class="header" href="#test-execution">Test Execution</a></h2>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test

# Run specific test categories
cargo test --test integration
cargo test --test security
cargo test --test performance

# Run with logs
RUST_LOG=debug cargo test

# Run tests in sequence (for tests that modify shared state)
cargo test -- --test-threads=1
</code></pre>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<p><strong>.github/workflows/test.yml</strong></p>
<pre><code class="language-yaml">name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      bitcoind:
        image: ruimarinho/bitcoin-core:22
        options: &gt;-
          --health-cmd "bitcoin-cli -regtest getblockchaininfo"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 18443:18443
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        
    - name: Install Solana CLI
      run: |
        sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
        echo "$HOME/.local/share/solana/install/active_release/bin" &gt;&gt; $GITHUB_PATH
        
    - name: Start local validator
      run: |
        solana-test-validator --detach
        
    - name: Build program
      run: |
        cargo build-sbf
        
    - name: Run tests
      run: |
        cargo test
        
    - name: Run integration tests
      run: |
        cargo test --test integration
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-test-organization"><a class="header" href="#1-test-organization">1. Test Organization</a></h3>
<ul>
<li>Separate unit, integration, and security tests</li>
<li>Use common test utilities to reduce duplication</li>
<li>Group related tests into modules</li>
</ul>
<h3 id="2-test-data-management"><a class="header" href="#2-test-data-management">2. Test Data Management</a></h3>
<ul>
<li>Use deterministic test data when possible</li>
<li>Clean up test accounts and state</li>
<li>Use property-based testing for edge cases</li>
</ul>
<h3 id="3-error-testing"><a class="header" href="#3-error-testing">3. Error Testing</a></h3>
<ul>
<li>Test all error conditions explicitly</li>
<li>Verify correct error codes are returned</li>
<li>Test permission and access control</li>
</ul>
<h3 id="4-performance-considerations"><a class="header" href="#4-performance-considerations">4. Performance Considerations</a></h3>
<ul>
<li>Monitor transaction costs in tests</li>
<li>Test with realistic data sizes</li>
<li>Benchmark critical operations</li>
</ul>
<h3 id="5-security-focus"><a class="header" href="#5-security-focus">5. Security Focus</a></h3>
<ul>
<li>Test privilege escalation attempts</li>
<li>Verify input validation</li>
<li>Test resource exhaustion scenarios</li>
</ul>
<h2 id="debugging-tests"><a class="header" href="#debugging-tests">Debugging Tests</a></h2>
<h3 id="logging-and-diagnostics"><a class="header" href="#logging-and-diagnostics">Logging and Diagnostics</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod debug_tests {
    use super::*;
    use arch_program::msg;
    
    #[test]
    fn test_with_logging() {
        env_logger::init();
        
        // Your test code with msg! calls will now show logs
        msg!("Debug: Testing counter initialization");
        
        // ... test code ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-helpers-for-debugging"><a class="header" href="#test-helpers-for-debugging">Test Helpers for Debugging</a></h3>
<pre><code class="language-rust ignore">pub fn debug_account_state(client: &amp;ArchClient, account: &amp;Pubkey) -&gt; CounterAccount {
    let account_data = client.get_account(account).unwrap().unwrap();
    let state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    
    println!("Account: {}", account);
    println!("Count: {}", state.count);
    println!("Authority: {}", state.authority);
    println!("Frozen: {}", state.is_frozen);
    println!("Operations: {}", state.operation_count);
    
    state
}</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Comprehensive testing is crucial for Arch Network program development. This guide provides:</p>
<ul>
<li><strong>Complete test setup</strong> with proper dependencies and project structure</li>
<li><strong>Multi-layer testing strategy</strong> covering unit, integration, security, and performance</li>
<li><strong>Real working examples</strong> that you can adapt for your programs</li>
<li><strong>Best practices</strong> for maintainable and effective test suites</li>
<li><strong>CI/CD integration</strong> for automated testing</li>
</ul>
<p>Remember to test early, test often, and test thoroughly. Your users depend on your programs being secure and reliable!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arch-network-development-guides"><a class="header" href="#arch-network-development-guides">Arch Network Development Guides</a></h1>
<p>This section provides comprehensive guides for building, testing, and deploying Arch Network programs. Whether you‚Äôre just starting out or building complex applications, these guides will help you develop robust and efficient programs.</p>
<h2 id="getting-started-guides"><a class="header" href="#getting-started-guides">Getting Started Guides</a></h2>
<h3 id="understanding-arch-programs-1"><a class="header" href="#understanding-arch-programs-1"><a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a></a></h3>
<p>Learn the fundamental concepts, architecture, and development patterns for Arch Network programs. This guide covers the complete foundation you need before building your first program.</p>
<p><strong>Covers:</strong> Program structure, Bitcoin integration, state management, error handling, and development best practices.</p>
<h3 id="writing-your-first-program"><a class="header" href="#writing-your-first-program"><a href="guides/./writing-your-first-program.html">Writing Your First Program</a></a></h3>
<p>A comprehensive step-by-step tutorial for creating, deploying, and testing a complete counter program with advanced features.</p>
<p><strong>Covers:</strong> Project setup, program logic, Bitcoin transactions, security patterns, and comprehensive testing.</p>
<h3 id="comprehensive-testing-guide"><a class="header" href="#comprehensive-testing-guide"><a href="guides/./testing-guide.html">Comprehensive Testing Guide</a></a></h3>
<p>Master testing strategies for Arch Network programs with unit tests, integration tests, security tests, and performance testing.</p>
<p><strong>Covers:</strong> Test environment setup, multi-layer testing, security testing, CI/CD integration, and debugging techniques.</p>
<h2 id="configuration--setup"><a class="header" href="#configuration--setup">Configuration &amp; Setup</a></h2>
<h3 id="local-validator-with-bitcoin-testnet4"><a class="header" href="#local-validator-with-bitcoin-testnet4"><a href="guides/./how-to-configure-local-validator-bitcoin-testnet4.html">Local Validator with Bitcoin Testnet4</a></a></h3>
<p>Configure your development environment to work with Bitcoin testnet4 for testing ordinals, runes, and advanced Bitcoin features.</p>
<p><strong>Covers:</strong> Testnet4 setup, validator configuration, ordinals support, runes protocol, and production considerations.</p>
<h3 id="arch-cli-reference-guide"><a class="header" href="#arch-cli-reference-guide"><a href="guides/./arch-cli-reference.html">Arch CLI Reference Guide</a></a></h3>
<p>Complete reference for all Arch CLI commands, options, and features. Essential for developers working with the command-line interface.</p>
<p><strong>Covers:</strong> All CLI commands, configuration profiles, token operations, orchestration, troubleshooting, and best practices.</p>
<h2 id="program-examples--tutorials"><a class="header" href="#program-examples--tutorials">Program Examples &amp; Tutorials</a></h2>
<h3 id="fungible-token-program"><a class="header" href="#fungible-token-program"><a href="guides/./how-to-create-a-fungible-token.html">Fungible Token Program</a></a></h3>
<p>Build a complete fungible token implementation compatible with standard token interfaces.</p>
<p><strong>What you‚Äôll build:</strong> Token minting, transfers, allowances, and metadata management.</p>
<h3 id="oracle-program"><a class="header" href="#oracle-program"><a href="guides/./how-to-write-oracle-program.html">Oracle Program</a></a></h3>
<p>Create a price oracle program that fetches and stores external data on-chain.</p>
<p><strong>What you‚Äôll build:</strong> Price feeds, data validation, timestamp management, and trusted data sources.</p>
<h3 id="runes-swap-program"><a class="header" href="#runes-swap-program"><a href="guides/./how-to-build-runes-swap.html">Runes Swap Program</a></a></h3>
<p>Implement a decentralized exchange for trading Bitcoin runes and ordinals.</p>
<p><strong>What you‚Äôll build:</strong> AMM functionality, liquidity pools, runes integration, and swap mechanisms.</p>
<h3 id="lending-protocol"><a class="header" href="#lending-protocol"><a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a></a></h3>
<p>Build a complete DeFi lending platform with collateralized loans and interest rates.</p>
<p><strong>What you‚Äôll build:</strong> Collateral management, loan origination, interest calculations, and liquidation mechanisms.</p>
<h2 id="recommended-learning-path"><a class="header" href="#recommended-learning-path">Recommended Learning Path</a></h2>
<h3 id="for-beginners"><a class="header" href="#for-beginners">For Beginners</a></h3>
<ol>
<li><strong><a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a></strong> - Learn the fundamentals</li>
<li><strong><a href="guides/./writing-your-first-program.html">Writing Your First Program</a></strong> - Build your first complete program</li>
<li><strong><a href="guides/./testing-guide.html">Testing Guide</a></strong> - Learn to test thoroughly</li>
<li><strong><a href="guides/./how-to-create-a-fungible-token.html">Fungible Token</a></strong> - Build a practical program</li>
</ol>
<h3 id="for-intermediate-developers"><a class="header" href="#for-intermediate-developers">For Intermediate Developers</a></h3>
<ol>
<li><strong><a href="guides/./how-to-write-oracle-program.html">Oracle Program</a></strong> - External data integration</li>
<li><strong><a href="guides/./how-to-configure-local-validator-bitcoin-testnet4.html">Local Validator Setup</a></strong> - Advanced testing environments</li>
<li><strong><a href="guides/./how-to-build-runes-swap.html">Runes Swap</a></strong> - Bitcoin-native features</li>
<li><strong><a href="guides/./arch-cli-reference.html">Arch CLI Reference</a></strong> - Master the command-line interface</li>
</ol>
<h3 id="for-advanced-developers"><a class="header" href="#for-advanced-developers">For Advanced Developers</a></h3>
<ol>
<li><strong><a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a></strong> - Complex DeFi mechanics</li>
<li><strong>All testing guides</strong> - Production-ready development practices</li>
<li><strong><a href="guides/./arch-cli-reference.html">Arch CLI Reference</a></strong> - Advanced CLI operations and automation</li>
</ol>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Guide</th><th>Difficulty</th><th>Time</th><th>Key Concepts</th></tr></thead><tbody>
<tr><td>Understanding Arch Programs</td><td>Beginner</td><td>30 min</td><td>Architecture, concepts</td></tr>
<tr><td>Writing Your First Program</td><td>Beginner</td><td>2-3 hours</td><td>Complete development cycle</td></tr>
<tr><td>Testing Guide</td><td>Intermediate</td><td>1-2 hours</td><td>Testing strategies</td></tr>
<tr><td>Testnet4 Setup</td><td>Intermediate</td><td>30 min</td><td>Advanced configuration</td></tr>
<tr><td>Arch CLI Reference</td><td>All Levels</td><td>1-2 hours</td><td>Command-line interface</td></tr>
<tr><td>Fungible Token</td><td>Intermediate</td><td>3-4 hours</td><td>Token standards</td></tr>
<tr><td>Oracle Program</td><td>Intermediate</td><td>2-3 hours</td><td>External data</td></tr>
<tr><td>Runes Swap</td><td>Advanced</td><td>4-6 hours</td><td>DEX mechanics</td></tr>
<tr><td>Lending Protocol</td><td>Advanced</td><td>6-8 hours</td><td>DeFi protocols</td></tr>
</tbody></table>
</div>
<h2 id="development-tips"><a class="header" href="#development-tips">Development Tips</a></h2>
<h3 id="before-you-start"><a class="header" href="#before-you-start">Before You Start</a></h3>
<ul>
<li><strong>Set up your environment</strong> following the <a href="guides/../getting-started/quick-start.html">Quick Start Guide</a></li>
<li><strong>Understand Bitcoin basics</strong> if you‚Äôre new to Bitcoin development</li>
<li><strong>Review Rust fundamentals</strong> if you‚Äôre not familiar with Rust</li>
<li><strong>Familiarize yourself with the CLI</strong> using the <a href="guides/./arch-cli-reference.html">Arch CLI Reference</a></li>
</ul>
<h3 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h3>
<ul>
<li><strong>Start simple</strong> - Begin with basic programs before building complex systems</li>
<li><strong>Test thoroughly</strong> - Use the comprehensive testing strategies from our guides</li>
<li><strong>Follow security patterns</strong> - Always validate inputs and handle errors gracefully</li>
<li><strong>Document your code</strong> - Future you (and your team) will thank you</li>
<li><strong>Use CLI profiles</strong> - Set up configuration profiles for different environments</li>
</ul>
<h3 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h3>
<ul>
<li><strong>Join our <a href="https://discord.gg/archnetwork">Discord</a></strong> for real-time support</li>
<li><strong>Check the <a href="guides/../rpc/rpc.html">API Reference</a></strong> for detailed documentation</li>
<li><strong>Review <a href="guides/../concepts/architecture.html">Core Concepts</a></strong> for architectural guidance</li>
<li><strong>File issues</strong> on <a href="https://github.com/Arch-Network/arch-node/issues">GitHub</a> for bugs</li>
<li><strong>Use CLI help</strong> - Run <code>arch-cli --help</code> or <code>arch-cli &lt;command&gt; --help</code> for command-specific help</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Found an issue or want to improve these guides? We welcome contributions!</p>
<ul>
<li><strong>Report bugs</strong> or unclear instructions</li>
<li><strong>Suggest improvements</strong> to existing guides</li>
<li><strong>Propose new guides</strong> for topics we haven‚Äôt covered</li>
<li><strong>Share your programs</strong> as examples for the community</li>
</ul>
<h2 id="whats-next"><a class="header" href="#whats-next">What‚Äôs Next?</a></h2>
<p>Choose your path based on your experience level and goals:</p>
<ul>
<li><strong>New to Arch?</strong> Start with <a href="guides/./understanding-arch-programs.html">Understanding Arch Programs</a></li>
<li><strong>Ready to code?</strong> Jump into <a href="guides/./writing-your-first-program.html">Writing Your First Program</a></li>
<li><strong>Need CLI help?</strong> Check the <a href="guides/./arch-cli-reference.html">Arch CLI Reference</a></li>
<li><strong>Building tokens?</strong> Check out the <a href="guides/./how-to-create-a-fungible-token.html">Fungible Token</a> guide</li>
<li><strong>Interested in DeFi?</strong> Try the <a href="guides/./how-to-build-lending-protocol.html">Lending Protocol</a> guide</li>
</ul>
<p>Happy building! üöÄ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-apl-tokens-on-arch-network"><a class="header" href="#creating-apl-tokens-on-arch-network">Creating APL Tokens on Arch Network</a></h1>
<p>This guide shows you how to create and manage fungible tokens on Arch Network using the built-in <strong>APL (Arch Program Library) Token Program</strong>. APL tokens are based on Solana‚Äôs SPL token standard and provide a robust foundation for creating and managing tokens on Arch Network.</p>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You‚Äôll Learn</a></h2>
<p>By the end of this guide, you‚Äôll understand how to:</p>
<ul>
<li><strong>Create token mints</strong> using the Arch CLI</li>
<li><strong>Initialize token accounts</strong> for holding tokens</li>
<li><strong>Mint tokens</strong> to accounts</li>
<li><strong>Transfer tokens</strong> between accounts</li>
<li><strong>Approve delegations</strong> for spending tokens</li>
<li><strong>Burn tokens</strong> and manage token lifecycle</li>
<li><strong>Use advanced features</strong> like multisig, freezing, and batch operations</li>
</ul>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<blockquote>
<p>Note: All arch-cli addresses, public keys, transaction IDs, and block hashes are base58 (32 bytes for IDs/pubkeys).</p>
</blockquote>
<p>The APL Token Program is Arch Network‚Äôs native token standard, providing:</p>
<ul>
<li><strong>SPL Token Compatibility</strong>: Based on Solana‚Äôs proven token standard</li>
<li><strong>Bitcoin Integration</strong>: All operations are recorded on Bitcoin</li>
<li><strong>Comprehensive Features</strong>: Minting, transferring, burning, delegation, freezing</li>
<li><strong>Multisig Support</strong>: Multiple signature authorities for enhanced security</li>
<li><strong>CLI Integration</strong>: Full command-line interface for token management</li>
</ul>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li><strong>Rust 1.84.1+</strong> and Cargo installed (<a href="https://rustup.rs/">Install Rust</a>)</li>
<li><strong>Arch Network CLI</strong> - <a href="https://github.com/Arch-Network/arch-network/releases/latest">Download Latest</a></li>
<li><strong>Docker</strong> - Required for local development</li>
<li><strong>Running development environment</strong> (see <a href="guides/../getting-started/quick-start.html">Quick Start Guide</a>)</li>
</ul>
<h2 id="apl-token-program-id"><a class="header" href="#apl-token-program-id">APL Token Program ID</a></h2>
<p>The APL Token Program has a fixed program ID:</p>
<pre><code class="language-text">AplToken111111111111111111111111
</code></pre>
<h2 id="quick-start-create-your-first-token"><a class="header" href="#quick-start-create-your-first-token">Quick Start: Create Your First Token</a></h2>
<h3 id="step-1-start-local-environment"><a class="header" href="#step-1-start-local-environment">Step 1: Start Local Environment</a></h3>
<pre><code class="language-bash"># Start local development environment
arch-cli orchestrate start

# Verify services are running
arch-cli orchestrate validator-status
arch-cli get-block-height
</code></pre>
<h3 id="step-2-create-configuration-profile"><a class="header" href="#step-2-create-configuration-profile">Step 2: Create Configuration Profile</a></h3>
<pre><code class="language-bash"># Create a profile for local development
arch-cli config create-profile local \
    --bitcoin-node-endpoint http://127.0.0.1:18443 \
    --bitcoin-node-username bitcoin \
    --bitcoin-node-password bitcoinpass \
    --bitcoin-network regtest \
    --arch-node-url http://localhost:9002

# Set as default profile
arch-cli config set-default-profile local
</code></pre>
<h3 id="step-3-generate-demo-keys"><a class="header" href="#step-3-generate-demo-keys">Step 3: Generate Demo Keys</a></h3>
<pre><code class="language-bash"># Create directory for demo keys
mkdir -p ~/DEMO_KEYS

# Generate keys for different roles
openssl rand -out ~/DEMO_KEYS/payer.key 32
openssl rand -out ~/DEMO_KEYS/mint_authority.key 32
openssl rand -out ~/DEMO_KEYS/mint.key 32

# Fund the payer account
arch-cli account airdrop --keypair-path ~/DEMO_KEYS/payer.key
</code></pre>
<h3 id="step-4-create-token-mint"><a class="header" href="#step-4-create-token-mint">Step 4: Create Token Mint</a></h3>
<pre><code class="language-bash"># Create a new token mint with 6 decimals (SPL-style)
# Provide the mint authority and payer; optionally provide a mint keypair
arch-cli token create-mint \
  --decimals 6 \
  --mint-authority ~/DEMO_KEYS/mint_authority.key \
  --mint-keypair-path ~/DEMO_KEYS/mint.key \
  --keypair-path  ~/DEMO_KEYS/payer.key

# Save the mint address (disable colors to parse reliably)
export MINT=$(NO_COLOR=1 arch-cli token show-mint ~/DEMO_KEYS/mint.key | awk -F': ' '/^Address:/{print $2}')
echo "Mint address: $MINT"
</code></pre>
<h3 id="step-5-create-token-account"><a class="header" href="#step-5-create-token-account">Step 5: Create Token Account</a></h3>
<pre><code class="language-bash"># Create an Associated Token Account (ATA) for the mint authority
arch-cli token create-account \
  --mint "$MINT" \
  --owner ~/DEMO_KEYS/mint_authority.key \
  --keypair-path  ~/DEMO_KEYS/payer.key

# Save the ATA address from the command output
export ATA=$(NO_COLOR=1 arch-cli token create-account \
  --mint "$MINT" \
  --owner ~/DEMO_KEYS/mint_authority.key \
  --keypair-path  ~/DEMO_KEYS/payer.key \
  | awk -F': ' '/^Account Address:/{print $2; exit}')
echo "Token account: $ATA"
</code></pre>
<h3 id="step-6-mint-initial-supply"><a class="header" href="#step-6-mint-initial-supply">Step 6: Mint Initial Supply</a></h3>
<pre><code class="language-bash"># Mint 1,000,000 raw units (with 6 decimals = 1.000000 tokens)
# Uses positional args for mint address and amount, and auto-creates ATA if needed
arch-cli token mint "$MINT" 1000000 \
  --authority ~/DEMO_KEYS/mint_authority.key \
  --auto-create-ata
</code></pre>
<h3 id="step-7-verify-your-token"><a class="header" href="#step-7-verify-your-token">Step 7: Verify Your Token</a></h3>
<pre><code class="language-bash"># Check mint information
arch-cli token show-mint "$MINT"

# Check account balance
arch-cli token balance "$ATA"

# Check mint supply
arch-cli token supply "$MINT"
</code></pre>
<h2 id="advanced-token-operations"><a class="header" href="#advanced-token-operations">Advanced Token Operations</a></h2>
<h3 id="transferring-tokens"><a class="header" href="#transferring-tokens">Transferring Tokens</a></h3>
<pre><code class="language-bash"># Create a recipient account
openssl rand -out ~/DEMO_KEYS/recipient.key 32

# Create ATA for recipient (payer funds creation)
arch-cli token create-account \
  --mint "$MINT" \
  --owner ~/DEMO_KEYS/recipient.key \
  --keypair-path  ~/DEMO_KEYS/payer.key

# Get recipient ATA from output
export RECIPIENT_ATA=$(NO_COLOR=1 arch-cli token create-account \
  --mint "$MINT" \
  --owner ~/DEMO_KEYS/recipient.key \
  --keypair-path  ~/DEMO_KEYS/payer.key \
  | awk -F': ' '/^Account Address:/{print $2; exit}')

# Transfer 100,000 raw units (0.100000 with 6 decimals)
# Uses positional args for source, destination, amount; provide the owner keypair
arch-cli token transfer "$ATA" "$RECIPIENT_ATA" 100000 \
  --owner ~/DEMO_KEYS/mint_authority.key
</code></pre>
<h3 id="delegation-and-approval"><a class="header" href="#delegation-and-approval">Delegation and Approval</a></h3>
<pre><code class="language-bash"># Approve a delegate to spend up to 500,000 raw units
# Provide the delegate's base58 public key (32-byte). If you only have a key file,
# run a one-time airdrop with that key to print its public key, then use that value here.
export DELEGATE_PUBKEY=&lt;RECIPIENT_PUBKEY_BASE58&gt;
arch-cli token approve "$ATA" "$DELEGATE_PUBKEY" 500000 \
  --owner ~/DEMO_KEYS/mint_authority.key

# Later, revoke the delegation
arch-cli token revoke "$ATA" \
  --owner ~/DEMO_KEYS/mint_authority.key
</code></pre>
<h3 id="account-control"><a class="header" href="#account-control">Account Control</a></h3>
<pre><code class="language-bash"># Freeze the account (requires freeze authority)
arch-cli token freeze-account "$ATA" \
  --authority ~/DEMO_KEYS/mint_authority.key

# Thaw the account
arch-cli token thaw-account "$ATA" \
  --authority ~/DEMO_KEYS/freeze_authority.key
</code></pre>
<h3 id="multisignature-operations"><a class="header" href="#multisignature-operations">Multisignature Operations</a></h3>
<pre><code class="language-bash"># Create a multisig with 2-of-3 threshold
arch-cli token create-multisig 2 \
  --signers ~/DEMO_KEYS/mint_authority.key,~/DEMO_KEYS/new_mint_authority.key,~/DEMO_KEYS/freeze_authority.key \
  --keypair-path ~/DEMO_KEYS/payer.key

# Show multisig account details
arch-cli token multisig-show &lt;MULTISIG_ADDRESS&gt;

# Sign a transaction with multisig
arch-cli token multisig-sign \
    --keypair-path ~/DEMO_KEYS/key1.key \
    --multisig "$MULTISIG" \
    --transaction &lt;TRANSACTION_DATA&gt;

# Execute the signed transaction
arch-cli token multisig-execute \
    --keypair-path ~/DEMO_KEYS/key2.key \
    --multisig "$MULTISIG" \
    --transaction &lt;SIGNED_TRANSACTION&gt;
</code></pre>
<h3 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h3>
<h4 id="checked-operations-decimal-verification"><a class="header" href="#checked-operations-decimal-verification">Checked Operations (Decimal Verification)</a></h4>
<pre><code class="language-bash"># Transfer with decimal verification
arch-cli token transfer-checked \
    --keypair-path ~/DEMO_KEYS/mint_authority.key \
    --mint "$MINT" \
    --from "$ATA" \
    --to "$RECIPIENT_ATA" \
    --amount 100000 \
    --decimals 6

# Mint with decimal verification
arch-cli token mint-to-checked \
    --keypair-path ~/DEMO_KEYS/mint_authority.key \
    --mint "$MINT" \
    --to "$ATA" \
    --amount 500000 \
    --decimals 6
</code></pre>
<h4 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h4>
<pre><code class="language-bash"># Prepare JSON files and pass their paths to the batch commands
# Example transfers.json: [{"source_account":"&lt;SRC&gt;","destination_account":"&lt;DST&gt;","amount":12345,"owner_keypair_path":"~/DEMO_KEYS/mint_authority.key"}]
arch-cli token batch-transfer ./transfers.json \
  --keypair-path ~/DEMO_KEYS/payer.key

# Example mints.json: [{"mint_address":"&lt;MINT&gt;","account_address":"&lt;DST&gt;","amount":1000000,"authority_keypair_path":"~/DEMO_KEYS/mint_authority.key"}]
arch-cli token batch-mint ./mints.json \
  --keypair-path ~/DEMO_KEYS/payer.key
</code></pre>
<h4 id="authority-management"><a class="header" href="#authority-management">Authority Management</a></h4>
<pre><code class="language-bash"># Set new mint authority
arch-cli token set-authority "$MINT" \
  --authority-type mint \
  --new-authority &lt;NEW_AUTHORITY_PUBKEY_BASE58&gt; \
  --current-authority ~/DEMO_KEYS/mint_authority.key

# Set new freeze authority
arch-cli token set-authority "$MINT" \
  --authority-type freeze \
  --new-authority &lt;NEW_FREEZE_AUTHORITY_BASE58&gt; \
  --current-authority ~/DEMO_KEYS/mint_authority.key
</code></pre>
<h2 id="utility-commands"><a class="header" href="#utility-commands">Utility Commands</a></h2>
<h3 id="information-and-queries"><a class="header" href="#information-and-queries">Information and Queries</a></h3>
<pre><code class="language-bash"># List all mints
arch-cli token mints

# List all accounts for a mint
arch-cli token accounts "$MINT"

# Convert amounts between raw and UI format
arch-cli token amount-to-ui "$MINT" 1000000  # Raw to UI
arch-cli token ui-to-amount "$MINT" 1.5      # UI to raw
</code></pre>
<h3 id="account-lifecycle"><a class="header" href="#account-lifecycle">Account Lifecycle</a></h3>
<pre><code class="language-bash"># Close a token account (reclaims rent)
arch-cli token close-account "$RECIPIENT_ATA" &lt;DESTINATION_PUBKEY&gt; \
  --owner ~/DEMO_KEYS/mint_authority.key
</code></pre>
<h2 id="programmatic-token-creation"><a class="header" href="#programmatic-token-creation">Programmatic Token Creation</a></h2>
<p>For developers who want to create tokens programmatically, here‚Äôs how to use the APL token program directly:</p>
<h3 id="project-setup-1"><a class="header" href="#project-setup-1">Project Setup</a></h3>
<pre><code class="language-bash"># Create project directory
mkdir arch-token-example
cd arch-token-example

# Initialize Rust project
cargo init --bin
</code></pre>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "arch_token_example"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_sdk = { git = "https://github.com/Arch-Network/arch-network", branch = "dev" }
arch_program = { git = "https://github.com/Arch-Network/arch-network", branch = "dev" }
apl-token = { git = "https://github.com/Arch-Network/arch-network", branch = "dev", features = ["no-entrypoint"] }
apl-associated-token-account = { git = "https://github.com/Arch-Network/arch-network", branch = "dev", features = ["no-entrypoint"] }
borsh = { version = "1.5.1", features = ["derive"] }
</code></pre>
<h3 id="create-token-programmatically"><a class="header" href="#create-token-programmatically">Create Token Programmatically</a></h3>
<pre><code class="language-rust ignore">use apl_token::{
    instruction,
    state::{Mint, Account},
};
use arch_sdk::{ArchRpcClient, generate_new_keypair};
use arch_program::pubkey::Pubkey;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let client = ArchRpcClient::new("http://localhost:9002");

    // Generate keypairs
    let (mint_keypair, mint_pubkey, _) = generate_new_keypair("regtest");
    let (authority_keypair, authority_pubkey, _) = generate_new_keypair("regtest");

    // Create mint account
    let mint_rent = client.get_minimum_balance_for_rent_exemption(Mint::LEN).await?;
    
    // Initialize mint
    let init_mint_ix = instruction::initialize_mint(
        &amp;apl_token::id(),
        &amp;mint_pubkey,
        &amp;authority_pubkey,
        None, // No freeze authority
        6,    // Decimals
    )?;

    // Create and send transaction
    let signature = client.send_and_confirm_transaction_with_spinner(
        &amp;[&amp;mint_keypair, &amp;authority_keypair],
        &amp;[init_mint_ix],
        &amp;mint_pubkey,
    ).await?;

    println!("Mint created: {}", mint_pubkey);
    println!("Transaction: {}", signature);

    Ok(())
}</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="security-2"><a class="header" href="#security-2">Security</a></h3>
<ol>
<li><strong>Separate Authorities</strong>: Use different keypairs for mint authority, freeze authority, and payer</li>
<li><strong>Multisig for High-Value Operations</strong>: Implement multisig for minting and authority changes</li>
<li><strong>Freeze Authority</strong>: Only set freeze authority if you need the ability to freeze accounts</li>
<li><strong>Key Management</strong>: Store private keys securely and never share them</li>
</ol>
<h3 id="token-design"><a class="header" href="#token-design">Token Design</a></h3>
<ol>
<li><strong>Decimal Precision</strong>: Choose appropriate decimals (6-9 is common)</li>
<li><strong>Supply Planning</strong>: Plan your initial supply and minting schedule</li>
<li><strong>Metadata</strong>: Consider adding off-chain metadata for name, symbol, and logo</li>
<li><strong>Access Control</strong>: Design your authority structure carefully</li>
</ol>
<h3 id="development-workflow-1"><a class="header" href="#development-workflow-1">Development Workflow</a></h3>
<ol>
<li><strong>Local Testing</strong>: Always test on local environment first</li>
<li><strong>Profile Management</strong>: Use different profiles for different environments</li>
<li><strong>Transaction Monitoring</strong>: Monitor transactions and verify state changes</li>
<li><strong>Error Handling</strong>: Implement proper error handling in your applications</li>
</ol>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="common-issues-3"><a class="header" href="#common-issues-3">Common Issues</a></h3>
<p><strong>Insufficient Balance:</strong></p>
<pre><code class="language-bash"># Check account balance
arch-cli token balance &lt;ACCOUNT_ADDRESS&gt;

# Fund account if needed
arch-cli account airdrop --keypair-path &lt;KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Invalid Authority:</strong></p>
<pre><code class="language-bash"># Check mint authorities
arch-cli token show-mint &lt;MINT_ADDRESS&gt;

# Check account owner
arch-cli token show-account &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<p><strong>Transaction Failures:</strong></p>
<pre><code class="language-bash"># Check transaction status
arch-cli tx confirm &lt;SIGNATURE&gt;

# View program logs
arch-cli tx log-program-messages &lt;SIGNATURE&gt;
</code></pre>
<h3 id="getting-help-2"><a class="header" href="#getting-help-2">Getting Help</a></h3>
<ul>
<li><strong>Discord Community</strong>: <a href="https://discord.gg/archnetwork">https://discord.gg/archnetwork</a></li>
<li><strong>GitHub Issues</strong>: <a href="https://github.com/Arch-Network/arch-node/issues">https://github.com/Arch-Network/arch-node/issues</a></li>
<li><strong>Documentation</strong>: <a href="https://docs.arch.network">https://docs.arch.network</a></li>
</ul>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><strong>Advanced Token Features</strong>: Explore <a href="guides/../apl/token-program.html">APL Token Program</a> for detailed program information</li>
<li><strong>Program Development</strong>: Learn about <a href="guides/writing-your-first-program.html">Writing Your First Program</a></li>
<li><strong>Testing</strong>: Understand <a href="guides/testing-guide.html">Testing Strategies</a></li>
<li><strong>Deployment</strong>: Deploy to <a href="guides/../getting-started/bitcoin-and-titan-setup.html">Testnet and Mainnet</a></li>
</ul>
<hr />
<p><strong>Congratulations!</strong> You‚Äôve successfully created and managed APL tokens on Arch Network. You now have the foundation to build sophisticated token-based applications that integrate seamlessly with Bitcoin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-an-oracle-program"><a class="header" href="#how-to-write-an-oracle-program">How to write an oracle program</a></h1>
<p>This guide walks through the innerworkings of an oracle program as well as details how oracle data can be utilized by other programs on Arch Network.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#description">Description</a></li>
<li><a href="guides/how-to-write-oracle-program.html#flow">Flow</a></li>
<li><a href="guides/how-to-write-oracle-program.html#logic">Logic</a></li>
<li><a href="guides/how-to-write-oracle-program.html#implementation">Implementation</a></li>
</ul>
<hr />
<h3 id="description"><a class="header" href="#description">Description</a></h3>
<p>Two important aspects of understanding how this oracle example is implemented within Arch:</p>
<ol>
<li>The oracle is a program that updates an account which holds the data</li>
<li>No cross-program invocation occurs since only the account is updated and read from versus this being another program that gets interacted with from another program</li>
</ol>
<p>The source code can be found within the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<ul>
<li>Project deploys oracle program</li>
<li>Project creates state account that the oracle program will control in order to write state to it</li>
<li>Projects submit data to the oracle state account by submitting instructions to the oracle program</li>
<li>Programs include oracle state account alongside their program instructions in order to use this referenced data stored in the oracle state account within their program</li>
<li>Projects submit instructions to oracle program periodically to update oracle state account with fresh data</li>
</ul>
<h3 id="logic"><a class="header" href="#logic">Logic</a></h3>
<p>If you haven‚Äôt already read <a href="guides/./writing-your-first-program.html">How to write an Arch program</a>, we recommend starting there to get a basic understanding of the program anatomy before going further.</p>
<p>We‚Äôll look closely at the logic block contained within the <code>update_data</code> <a href="guides/how-to-write-oracle-program.html#logic">handler</a>.</p>
<pre><code class="language-rust ignore">pub fn update_data(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let oracle_account = next_account_info(account_iter)?;

    assert!(oracle_account.is_signer);
    assert_eq!(instruction_data.len(), 8);

    ...
}</code></pre>
<p>First, we‚Äôll iterate over the accounts that get passed into the function, which includes the newly created state account that will be responsible for managing the oracle‚Äôs data.</p>
<p>We then assert that the oracle state account has the appropriate authority to be written to and update what it stores within its data field. Additionally, we assert that the data we wish to update the account with is at least a certain number of bytes.</p>
<pre><code class="language-rust ignore">let data_len = oracle_account.data.try_borrow().unwrap().len();
if instruction_data.len() &gt; data_len {
    oracle_account.realloc(instruction_data.len(), true)?;
}</code></pre>
<p>Next, we calculate the length of the new data that we are looking to store in the account and reallocate memory to the account if the new data is larger than the data currently existing within the account. This step is important for ensuring that there is no remaining, stale data stored in the account before adding new data to it.</p>
<pre><code class="language-rust ignore">oracle_account
    .data
    .try_borrow_mut()
    .unwrap()
    .copy_from_slice(instruction_data);

msg!("updated");

Ok(())</code></pre>
<p>Lastly, we store the new data that is passed into the program via the instruction to the state account for management, thus marking the end of the oracle update process.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Let‚Äôs look at an example implementation of this oracle program. This includes:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#create-oracle-project">Create oracle project</a></li>
<li><a href="guides/how-to-write-oracle-program.html#deploy-program">Deploy program</a></li>
<li><a href="guides/how-to-write-oracle-program.html#create-a-state-account">Create a state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#update-the-state-account">Update the state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#read-from-the-state-account">Read from the state account</a></li>
</ul>
<h4 id="create-oracle-project"><a class="header" href="#create-oracle-project">Create oracle project</a></h4>
<p>First, we‚Äôll need to create a new project to hold our oracle logic.</p>
<pre><code class="language-bash"># Create a new directory for your oracle project
mkdir oracle
cd oracle

# Initialize a Rust project
cargo init --lib
</code></pre>
<blockquote>
<p>Note: The new CLI does not currently have a project creation command. We‚Äôll manually set up our project structure.</p>
</blockquote>
<p>You‚Äôll need to create and edit the following files:</p>
<ul>
<li><code>Cargo.toml</code> - Add dependencies for your oracle program</li>
<li><code>src/lib.rs</code> - Implement the oracle program logic</li>
</ul>
<p>Example program files can be found in the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h4 id="deploy-program"><a class="header" href="#deploy-program">Deploy program</a></h4>
<p>After the project is created, the program is written and the <code>Cargo.toml</code> is set with the proper dependencies, we can deploy the program.</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program
arch-cli deploy target/deploy/oracle.so
</code></pre>
<p>During the deployment, a new account is created for the deployed program logic and set to be executable, marking it as a <a href="guides/../program/program.html">Program</a> rather than a data <a href="guides/../program/account.html">Account</a>.</p>
<h4 id="create-state-account"><a class="header" href="#create-state-account">Create state account</a></h4>
<p>From the deployment output, you should obtain the <code>program_id</code>. We can use this <code>program_id</code> to create a state account that is owned and updated by the program.</p>
<p>The oracle state account can then be read from by any program in order to retrieve the associated oracle data.</p>
<pre><code class="language-bash"># The new CLI may not have direct account creation functionality
# You'll need to use an RPC call to create the account

# For example, using curl:
curl -X POST http://localhost:9002 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"sendTransaction",
    "params":[{
      "signature":"your_signature",
      "message":{
        "accountKeys":["your_pubkey", "your_program_id"],
        "instructions":[{
          "programId":"system_program_id",
          "accounts":["your_pubkey", "new_account_pubkey"],
          "data":"encoded_create_account_data"
        }]
      }
    }]
  }'
</code></pre>
<blockquote>
<p>Note: The above is a simplified example. You‚Äôll need to properly construct, sign, and encode your transaction according to the Arch Network protocol.</p>
</blockquote>
<p>In this step, the account is created and ownership is transferred to the program. This allows the program to update the account‚Äôs data field which holds state for the program.</p>
<h4 id="update-the-state-account"><a class="header" href="#update-the-state-account">Update the state account</a></h4>
<p>Now that we have created an account and the oracle program has authority to update it, we now want to update the data that the account holds.</p>
<p>In order to update the data stored in the account, we simply need to make a transaction that includes the data that we wish to update the oracle state account to hold, and submit this within the context of an instruction.</p>
<p>As an example, below we have a sample rust program that we‚Äôll use to fetch the Bitcoin fees from the <a href="https://mempool.space">mempool.space</a> API and store this fee data in our oracle state account that was created during deployment.</p>
<blockquote>
<p>Note: The below is a rust program and is not an Arch program.</p>
<p>The call to update the oracle state account can be written in any programming language as it is simply an RPC call. For sake of continuity, we‚Äôre using rust along with methods from both the <code>program</code> and <code>sdk</code> crates.</p>
</blockquote>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client};

let mut old_feerate = 0;

let body: Value = reqwest::blocking::get("https://mempool.space/api/v1/fees/recommended").unwrap().json().unwrap();
let feerate = body.get("fastestFee").unwrap().as_u64().unwrap();

if old_feerate != feerate {
    let (txid, instruction_hash) = sign_and_send_instruction(
        Instruction {
            program_id: program_pubkey.clone(),
            accounts: vec![AccountMeta {
                pubkey: caller_pubkey.clone(),
                is_signer: true,
                is_writable: true
            }],
            data: feerate.to_le_bytes().to_vec()
        },
        vec![caller_keypair],
    ).expect("signing and sending a transaction should not fail");

    let processed_tx = get_processed_transaction(NODE1_ADDRESS, txid.clone()).expect("get processed transaction should not fail");
    println!("processed_tx {:?}", processed_tx);

    println!("{:?}", read_account_info(NODE1_ADDRESS, caller_pubkey.clone()));

    old_feerate = feerate;
}</code></pre>
<h4 id="read-from-the-state-account"><a class="header" href="#read-from-the-state-account">Read from the state account</a></h4>
<p>Below is an example of a different program (we‚Äôll call this app-program) that would like to access the oracle data.</p>
<p>Essentially, what happens here is that when we pass an instruction into our app-program, we must also include the oracle state account alongside any other account that we need for the app-program. In this way, the oracle state account is now in-scope and its data can be read from.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-first-bitcoin-runes-swap-application"><a class="header" href="#building-your-first-bitcoin-runes-swap-application">Building Your First Bitcoin Runes Swap Application</a></h1>
<p>Welcome to this hands-on tutorial! Today, we‚Äôre going to build a decentralized application that enables users to swap Bitcoin Runes tokens on the Arch Network. By the end of this lesson, you‚Äôll understand how to create a secure, trustless swap mechanism for Runes tokens.</p>
<h2 id="class-prerequisites"><a class="header" href="#class-prerequisites">Class Prerequisites</a></h2>
<p>Before we dive in, please ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch Network CLI installed</li>
</ul>
<h2 id="lesson-1-understanding-the-basics"><a class="header" href="#lesson-1-understanding-the-basics">Lesson 1: Understanding the Basics</a></h2>
<h3 id="what-are-runes"><a class="header" href="#what-are-runes">What are Runes?</a></h3>
<p>Before we write any code, let‚Äôs understand what we‚Äôre working with. Runes is a Bitcoin protocol for fungible tokens, similar to how BRC-20 works. Each Rune token has a unique identifier and can be transferred between Bitcoin addresses.</p>
<h3 id="what-are-we-building"><a class="header" href="#what-are-we-building">What are we building?</a></h3>
<p>We‚Äôre creating a swap program that will:</p>
<ol>
<li>Allow users to create swap offers (‚ÄúI want to trade X amount of Rune A for Y amount of Rune B‚Äù)</li>
<li>Enable other users to accept these offers</li>
<li>Let users cancel their offers if they change their mind</li>
<li>Ensure all swaps are atomic (they either complete fully or not at all)</li>
</ol>
<h2 id="lesson-2-setting-up-our-project"><a class="header" href="#lesson-2-setting-up-our-project">Lesson 2: Setting Up Our Project</a></h2>
<p>Let‚Äôs start by creating our project structure. Open your terminal and run:</p>
<pre><code class="language-bash"># Create a new directory for your project
mkdir runes-swap
cd runes-swap

# Initialize a new Rust project
cargo init --lib

# Your project structure should look like this:
# runes-swap/
# ‚îú‚îÄ‚îÄ Cargo.toml
# ‚îú‚îÄ‚îÄ src/
# ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
</code></pre>
<h2 id="lesson-3-defining-our-data-structures"><a class="header" href="#lesson-3-defining-our-data-structures">Lesson 3: Defining Our Data Structures</a></h2>
<p>Now, let‚Äôs define the building blocks of our swap program. In programming, it‚Äôs crucial to plan our data structures before implementing functionality.</p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    entrypoint,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    utxo::UtxoMeta,
    borsh::{BorshDeserialize, BorshSerialize},
};

/// This structure represents a single swap offer in our system
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct SwapOffer {
    // Unique identifier for the offer
    pub offer_id: u64,
    // The public key of the person creating the offer
    pub maker: Pubkey,
    // The Rune ID they want to give
    pub rune_id_give: String,
    // Amount of Runes they want to give
    pub amount_give: u64,
    // The Rune ID they want to receive
    pub rune_id_want: String,
    // Amount of Runes they want to receive
    pub amount_want: u64,
    // When this offer expires (in block height)
    pub expiry: u64,
    // Current status of the offer
    pub status: OfferStatus,
}</code></pre>
<p>Let‚Äôs break down why we chose each field:</p>
<ul>
<li><code>offer_id</code>: Every offer needs a unique identifier so we can reference it later</li>
<li><code>maker</code>: We store who created the offer to ensure only they can cancel it</li>
<li><code>rune_id_give/want</code>: These identify which Runes are being swapped</li>
<li><code>amount_give/want</code>: The quantities of each Rune in the swap</li>
<li><code>expiry</code>: Offers shouldn‚Äôt live forever, so we add an expiration</li>
</ul>
<h2 id="lesson-4-implementing-the-swap-logic"><a class="header" href="#lesson-4-implementing-the-swap-logic">Lesson 4: Implementing the Swap Logic</a></h2>
<p>Now that we understand our data structures, let‚Äôs implement the core swap functionality. We‚Äôll start with creating an offer:</p>
<pre><code class="language-rust ignore">fn process_create_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all the accounts we need
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    // Step 2: Verify the maker has the Runes they want to swap
    if let SwapInstruction::CreateOffer { 
        rune_id_give, 
        amount_give,
        rune_id_want,
        amount_want,
        expiry 
    } = instruction {
        // Security check: Ensure the maker owns enough Runes
        verify_rune_ownership(maker, &amp;rune_id_give, amount_give)?;
        
        // Step 3: Create and store the offer
        let offer = SwapOffer {
            offer_id: get_next_offer_id(offer_account)?,
            maker: *maker.key,
            rune_id_give,
            amount_give,
            rune_id_want,
            amount_want,
            expiry,
            status: OfferStatus::Active,
        };
        
        store_offer(offer_account, &amp;offer)?;
    }

    Ok(())
}</code></pre>
<h3 id="understanding-the-create-offer-process"><a class="header" href="#understanding-the-create-offer-process">Understanding the Create Offer Process</a></h3>
<ol>
<li>First, we extract the accounts passed to our program</li>
<li>We verify that the maker actually owns the Runes they want to trade</li>
<li>We create a new <code>SwapOffer</code> with an Active status</li>
<li>Finally, we store this offer in the program‚Äôs state</li>
</ol>
<h2 id="lesson-5-testing-our-program"><a class="header" href="#lesson-5-testing-our-program">Lesson 5: Testing Our Program</a></h2>
<p>Testing is crucial in blockchain development because once deployed, your program can‚Äôt be easily changed. Let‚Äôs write comprehensive tests for our swap program.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::test_utils::{create_test_account, create_test_pubkey};

    /// Helper function to create a test offer
    fn create_test_offer() -&gt; SwapOffer {
        SwapOffer {
            offer_id: 1,
            maker: create_test_pubkey(),
            rune_id_give: "RUNE1".to_string(),
            amount_give: 100,
            rune_id_want: "RUNE2".to_string(),
            amount_want: 200,
            expiry: 1000,
            status: OfferStatus::Active,
        }
    }

    #[test]
    fn test_create_offer() {
        // Arrange: Set up our test accounts
        let maker = create_test_account();
        let offer_account = create_test_account();
        
        // Act: Create an offer
        let result = process_create_offer(
            &amp;[maker.clone(), offer_account.clone()],
            SwapInstruction::CreateOffer {
                rune_id_give: "RUNE1".to_string(),
                amount_give: 100,
                rune_id_want: "RUNE2".to_string(),
                amount_want: 200,
                expiry: 1000,
            },
        );
        
        // Assert: Check the result
        assert!(result.is_ok());
        // Add more assertions here to verify the offer was stored correctly
    }
}</code></pre>
<h3 id="understanding-our-test-structure"><a class="header" href="#understanding-our-test-structure">Understanding Our Test Structure</a></h3>
<p>We follow the ‚ÄúArrange-Act-Assert‚Äù pattern:</p>
<ol>
<li>Arrange: Set up the test environment and data</li>
<li>Act: Execute the functionality we‚Äôre testing</li>
<li>Assert: Verify the results match our expectations</li>
</ol>
<h2 id="lesson-6-implementing-offer-acceptance"><a class="header" href="#lesson-6-implementing-offer-acceptance">Lesson 6: Implementing Offer Acceptance</a></h2>
<p>Now let‚Äôs implement the logic for accepting an offer. This is where atomic swaps become crucial:</p>
<pre><code class="language-rust ignore">fn process_accept_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all required accounts
    let account_iter = &amp;mut accounts.iter();
    let taker = next_account_info(account_iter)?;
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::AcceptOffer { offer_id } = instruction {
        // Step 2: Load and validate the offer
        let mut offer = load_offer(offer_account)?;
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Step 3: Verify the taker has the required Runes
        verify_rune_ownership(taker, &amp;offer.rune_id_want, offer.amount_want)?;
        
        // Step 4: Perform the atomic swap
        // Transfer Runes from maker to taker
        transfer_runes(
            maker,
            taker,
            &amp;offer.rune_id_give,
            offer.amount_give,
        )?;
        
        // Transfer Runes from taker to maker
        transfer_runes(
            taker,
            maker,
            &amp;offer.rune_id_want,
            offer.amount_want,
        )?;
        
        // Step 5: Update offer status
        offer.status = OfferStatus::Completed;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h3 id="understanding-atomic-swaps"><a class="header" href="#understanding-atomic-swaps">Understanding Atomic Swaps</a></h3>
<p>An atomic swap ensures that either:</p>
<ul>
<li>Both transfers complete successfully, or</li>
<li>Neither transfer happens at all</li>
</ul>
<p>This is crucial for preventing partial swaps where one party could lose their tokens.</p>
<h2 id="lesson-7-implementing-offer-cancellation"><a class="header" href="#lesson-7-implementing-offer-cancellation">Lesson 7: Implementing Offer Cancellation</a></h2>
<p>Finally, let‚Äôs implement the ability to cancel offers:</p>
<pre><code class="language-rust ignore">fn process_cancel_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::CancelOffer { offer_id } = instruction {
        // Load the offer
        let mut offer = load_offer(offer_account)?;
        
        // Security checks
        require!(
            offer.maker == *maker.key,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Update offer status
        offer.status = OfferStatus::Cancelled;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h2 id="deploying-your-runes-swap-program"><a class="header" href="#deploying-your-runes-swap-program">Deploying Your Runes Swap Program</a></h2>
<p>After you‚Äôve written and tested your program, it‚Äôs time to deploy it to the Arch Network:</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program to the Arch Network
arch-cli deploy target/deploy/runes_swap.so
</code></pre>
<p>Make sure you have a validator node running before deployment:</p>
<pre><code class="language-bash"># Start a local validator
arch-cli validator-start
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Congratulations! You‚Äôve built a complete Runes swap program. This program demonstrates several important blockchain concepts:</p>
<ol>
<li>Atomic transactions</li>
<li>State management</li>
<li>Security checks</li>
<li>Program testing</li>
</ol>
<p>Remember to always:</p>
<ul>
<li>Test thoroughly before deployment</li>
<li>Consider edge cases</li>
<li>Implement proper error handling</li>
<li>Add detailed documentation</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>To further improve your program, consider adding:</p>
<ol>
<li>A UI for interacting with the swap program</li>
<li>More sophisticated offer matching</li>
<li>Order book functionality</li>
<li>Price oracle integration</li>
<li>Additional security features</li>
</ol>
<p>Questions? Feel free to ask in the comments below!</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="runes-transfer-implementation"><a class="header" href="#runes-transfer-implementation">Runes Transfer Implementation</a></h3>
<p>Let‚Äôs look at the implementation of the <code>transfer_runes</code> function used in our swap program:</p>
<pre><code class="language-rust ignore">/// Transfers Runes tokens from one account to another
/// 
/// # Arguments
/// * `from` - The account sending the Runes
/// * `to` - The account receiving the Runes
/// * `rune_id` - The identifier of the Rune to transfer
/// * `amount` - The amount of Runes to transfer
/// 
/// # Returns
/// * `Result&lt;(), ProgramError&gt;` - Success or error code
fn transfer_runes(
    from: &amp;AccountInfo,
    to: &amp;AccountInfo,
    rune_id: &amp;str,
    amount: u64,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get Bitcoin script pubkey for both accounts
    let from_script = get_account_script_pubkey(from.key)?;
    let to_script = get_account_script_pubkey(to.key)?;
    
    // Step 2: Create a Bitcoin transaction for the Rune transfer
    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };
    
    // Step 3: Get UTXOs associated with the sender
    let utxos = get_account_utxos(from)?;
    
    // Step 4: Find UTXOs with the specified Rune
    let rune_utxos = utxos.iter()
        .filter(|utxo| has_rune(utxo, rune_id))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    
    // Step 5: Verify sender has enough of the rune
    let total_runes = rune_utxos.iter()
        .map(|utxo| get_rune_amount(utxo, rune_id))
        .sum::&lt;u64&gt;();
    
    require!(
        total_runes &gt;= amount,
        ProgramError::InsufficientRuneBalance
    );
    
    // Step 6: Select UTXOs for the transfer
    let selected_utxos = select_utxos_for_transfer(
        &amp;rune_utxos, 
        rune_id,
        amount
    )?;
    
    // Step 7: Add inputs from selected UTXOs
    for utxo in &amp;selected_utxos {
        tx.input.push(TxIn {
            previous_output: OutPoint::new(utxo.txid.into(), utxo.vout),
            script_sig: Script::new(),
            sequence: Sequence::MAX,
            witness: Witness::new(),
        });
    }
    
    // Step 8: Calculate total input amount
    let total_input_amount = selected_utxos.iter()
        .map(|utxo| utxo.amount)
        .sum::&lt;u64&gt;();
    
    // Step 9: Create output with rune transfer
    let runes_data = create_runes_data(rune_id, amount);
    tx.output.push(TxOut {
        value: DUST_LIMIT, // Minimum amount for a valid output
        script_pubkey: to_script.clone(),
    });
    
    // Step 10: Add change output if needed
    if total_input_amount &gt; DUST_LIMIT {
        // Return change to sender
        let change_amount = total_input_amount - DUST_LIMIT;
        let change_runes = total_runes - amount;
        
        // Create change output with remaining runes
        if change_amount &gt; 0 {
            let change_data = create_runes_data(rune_id, change_runes);
            tx.output.push(TxOut {
                value: change_amount,
                script_pubkey: from_script.clone(),
            });
        }
    }
    
    // Step 11: Create transaction signing request
    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;selected_utxos.iter()
            .enumerate()
            .map(|(i, utxo)| InputToSign {
                index: i as u32,
                signer: *from.key,
            })
            .collect::&lt;Vec&lt;_&gt;&gt;(),
    };
    
    // Step 12: Submit transaction for signing by the Arch runtime
    set_transaction_to_sign(&amp;[from.clone(), to.clone()], tx_to_sign)?;
    
    Ok(())
}

/// Gets UTXOs associated with an account
fn get_account_utxos(account: &amp;AccountInfo) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;, ProgramError&gt; {
    // In a real implementation, this would query the Arch state
    // to get UTXOs associated with the account
    // This is a simplified placeholder implementation
    
    // For tutorial purposes, we simulate fetching UTXOs
    Ok(vec![])
}

/// Checks if a UTXO contains a specific Rune
fn has_rune(utxo: &amp;UtxoMeta, rune_id: &amp;str) -&gt; bool {
    // In a real implementation, this would parse the Bitcoin
    // transaction data to check for Rune presence
    // This is a simplified placeholder for the tutorial
    
    true // For tutorial purposes
}

/// Gets the amount of a specific Rune in a UTXO
fn get_rune_amount(utxo: &amp;UtxoMeta, rune_id: &amp;str) -&gt; u64 {
    // In a real implementation, this would parse the Bitcoin
    // transaction data to get the Rune amount
    // This is a simplified placeholder for the tutorial
    
    1000 // For tutorial purposes
}

/// Creates Rune-specific data for transaction outputs
fn create_runes_data(rune_id: &amp;str, amount: u64) -&gt; Vec&lt;u8&gt; {
    // In a real implementation, this would create the proper
    // script or OP_RETURN data to encode Rune information
    // This is a simplified placeholder for the tutorial
    
    vec![] // For tutorial purposes
}

/// Selects appropriate UTXOs for a Rune transfer
fn select_utxos_for_transfer(
    utxos: &amp;[&amp;UtxoMeta],
    rune_id: &amp;str,
    amount: u64,
) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;, ProgramError&gt; {
    // In a real implementation, this would implement a UTXO
    // selection algorithm optimized for Rune transfers
    // This is a simplified placeholder for the tutorial
    
    // Simply clone the first UTXO for the tutorial
    if let Some(utxo) = utxos.first() {
        Ok(vec![(*utxo).clone()])
    } else {
        Err(ProgramError::InsufficientFunds)
    }
}</code></pre>
<p>The <code>transfer_runes</code> function implements the core logic for transferring Runes tokens between accounts. It:</p>
<ol>
<li>Gets the Bitcoin script pubkeys for the sender and receiver</li>
<li>Creates a new Bitcoin transaction</li>
<li>Finds UTXOs containing the desired Rune</li>
<li>Selects appropriate UTXOs for the transfer</li>
<li>Creates outputs with proper Rune encoding</li>
<li>Handles change output for remaining Runes</li>
<li>Sets up the transaction for signing by the Arch runtime</li>
</ol>
<h3 id="rune-ownership-verification"><a class="header" href="#rune-ownership-verification">Rune Ownership Verification</a></h3>
<p>Let‚Äôs also look at the implementation of the <code>verify_rune_ownership</code> function:</p>
<pre><code class="language-rust ignore">/// Verifies that an account owns sufficient Runes
/// 
/// # Arguments
/// * `account` - The account to check
/// * `rune_id` - The identifier of the Rune to verify
/// * `required_amount` - The amount of Runes required
/// 
/// # Returns
/// * `Result&lt;(), ProgramError&gt;` - Success or error code
fn verify_rune_ownership(
    account: &amp;AccountInfo,
    rune_id: &amp;str,
    required_amount: u64,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get UTXOs associated with the account
    let utxos = get_account_utxos(account)?;
    
    // Step 2: Filter UTXOs that contain the specified Rune
    let rune_utxos = utxos.iter()
        .filter(|utxo| has_rune(utxo, rune_id))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    
    // Step 3: Calculate total Runes owned
    let total_owned = rune_utxos.iter()
        .map(|utxo| get_rune_amount(utxo, rune_id))
        .sum::&lt;u64&gt;();
    
    // Step 4: Verify the account has enough Runes
    if total_owned &lt; required_amount {
        msg!(
            "Insufficient Rune balance. Required: {}, Available: {}",
            required_amount,
            total_owned
        );
        return Err(ProgramError::InsufficientRuneBalance);
    }
    
    Ok(())
}</code></pre>
<p>This function validates that an account owns a sufficient amount of a specific Rune by:</p>
<ol>
<li>Getting the account‚Äôs UTXOs</li>
<li>Filtering those containing the specified Rune</li>
<li>Calculating the total Rune amount owned</li>
<li>Verifying the account has enough to meet the required amount</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-bitcoin-lending-protocol"><a class="header" href="#how-to-build-a-bitcoin-lending-protocol">How to Build a Bitcoin Lending Protocol</a></h1>
<p>This guide walks through building a lending protocol for Bitcoin-based assets (BTC, Runes, Ordinals) on Arch Network. We‚Äôll create a decentralized lending platform similar to Aave, but specifically designed for Bitcoin-based assets.</p>
<h2 id="prerequisites-7"><a class="header" href="#prerequisites-7">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch CLI installed</li>
</ul>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<h3 id="basic-user-flow"><a class="header" href="#basic-user-flow">Basic User Flow</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Depositing
        A[User wants to lend] --&gt;|1. Deposits BTC| B[Lending Pool]
        B --&gt;|2. Receives interest| A
    end

    subgraph Borrowing
        C[User needs loan] --&gt;|3. Provides collateral| B
        B --&gt;|4. Lends BTC| C
        C --&gt;|5. Repays loan + interest| B
    end

    style A fill:#b3e0ff
    style B fill:#98FB98
    style C fill:#b3e0ff
</pre>
<h3 id="safety-system"><a class="header" href="#safety-system">Safety System</a></h3>
<pre class="mermaid">flowchart LR
    subgraph &quot;Price Monitoring&quot;
        direction TB
        A[Price Oracle] --&gt;|1. Updates prices| B[Health Checker]
    end

    subgraph &quot;Health Check&quot;
        direction TB
        B --&gt;|2. Monitors positions| C[User Position]
        C --&gt;|3. If position unsafe| D[Liquidator]
    end

    style A fill:#FFB6C1
    style B fill:#FFB6C1
    style C fill:#b3e0ff
    style D fill:#FFB6C1
</pre>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<p>Let‚Äôs say Alice wants to borrow BTC and Bob wants to earn interest:</p>
<ol>
<li>
<p><strong>Bob (Lender)</strong></p>
<ul>
<li>Deposits 1 BTC into pool</li>
<li>Earns 3% APY interest</li>
</ul>
</li>
<li>
<p><strong>Alice (Borrower)</strong></p>
<ul>
<li>Provides 1.5 BTC as collateral</li>
<li>Borrows 1 BTC</li>
<li>Pays 5% APY interest</li>
</ul>
</li>
<li>
<p><strong>Safety System</strong></p>
<ul>
<li>Monitors BTC price</li>
<li>Checks if Alice‚Äôs collateral stays valuable enough</li>
<li>If BTC price drops too much, liquidates some collateral to protect Bob‚Äôs deposit</li>
</ul>
</li>
</ol>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>Our lending protocol consists of several key components:</p>
<h3 id="1-pool-accounts"><a class="header" href="#1-pool-accounts">1. Pool Accounts</a></h3>
<p>Pool accounts are the core of our lending protocol. They serve as liquidity pools where users can:</p>
<ul>
<li>Deposit Bitcoin-based assets (BTC, Runes, Ordinals)</li>
<li>Earn interest on deposits</li>
<li>Borrow against their collateral</li>
<li>Manage protocol parameters</li>
</ul>
<p>Each pool account maintains:</p>
<ul>
<li>Total deposits and borrows</li>
<li>Interest rates and utilization metrics</li>
<li>Collateral factors and liquidation thresholds</li>
<li>Asset-specific parameters</li>
</ul>
<p>The pool account manages both state and UTXOs:</p>
<ul>
<li><strong>State Management</strong>: Tracks deposits, withdrawals, and user positions</li>
<li><strong>UTXO Management</strong>:
<ul>
<li>Maintains a collection of UTXOs for the pool‚Äôs Bitcoin holdings</li>
<li>Manages UTXO creation for withdrawals</li>
<li>Handles UTXO consolidation for efficient liquidity management</li>
</ul>
</li>
</ul>
<h3 id="2-price-oracle"><a class="header" href="#2-price-oracle">2. Price Oracle</a></h3>
<p>Track asset prices for liquidation calculations</p>
<h3 id="3-user-positions"><a class="header" href="#3-user-positions">3. User Positions</a></h3>
<p>User positions track all user interactions with the lending pools:</p>
<ul>
<li>Active deposits and their earned interest</li>
<li>Outstanding borrows and accrued interest</li>
<li>Collateral positions and health factors</li>
<li>Liquidation thresholds and warnings</li>
</ul>
<p>Each user can have multiple positions across different pools, and the protocol tracks:</p>
<ul>
<li>Position health through real-time monitoring</li>
<li>Collateralization ratios</li>
<li>Interest accrual</li>
<li>Liquidation risks</li>
</ul>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct LendingPool {
    pub pool_pubkey: Pubkey,
    pub asset_type: AssetType, // BTC, Runes, Ordinals
    pub total_deposits: u64,
    pub total_borrows: u64,
    pub interest_rate: u64,
    pub utilization_rate: u64,
    pub liquidation_threshold: u64,
    pub collateral_factor: u64,
    pub utxos: Vec&lt;UtxoMeta&gt;,
    pub validator_signatures: Vec&lt;Signature&gt;,
    pub min_signatures_required: u32,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserPosition {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub deposited_amount: u64,
    pub borrowed_amount: u64,
    pub collateral_amount: u64,
    pub last_update: i64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct InterestRateModel {
    pub base_rate: u64,
    pub multiplier: u64,
    pub jump_multiplier: u64,
    pub optimal_utilization: u64,
}

// Additional helper structures for managing positions
#[derive(BorshSerialize, BorshDeserialize)]
pub struct PositionHealth {
    pub health_factor: u64,
    pub liquidation_price: u64,
    pub safe_borrow_limit: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PoolMetrics {
    pub total_value_locked: u64,
    pub available_liquidity: u64,
    pub utilization_rate: u64,
    pub supply_apy: u64,
    pub borrow_apy: u64,
}</code></pre>
<h2 id="custom-scoring-and-risk-management"><a class="header" href="#custom-scoring-and-risk-management">Custom Scoring and Risk Management</a></h2>
<h3 id="ltv-loan-to-value-scoring-system"><a class="header" href="#ltv-loan-to-value-scoring-system">LTV (Loan-to-Value) Scoring System</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Core_Factors[Core Factors]
        P1[Transaction History]
        P2[Asset Quality]
        P3[Market Volatility]
        P4[Position Size]
    end
    
    subgraph User_Metrics[User Metrics]
        P5[Account History]
        P6[Repayment Record]
        P7[Portfolio Health]
    end
    
    subgraph Market_Context[Market Context]
        P8[Market Conditions]
        P9[Price Impact]
        P10[Network Status]
    end
    
    Core_Factors --&gt; SC[Scoring Engine]
    User_Metrics --&gt; SC
    Market_Context --&gt; SC
    SC --&gt; WF[Weight Calculation]
    WF --&gt; NM[Risk Normalization]
    NM --&gt; LTV[Final LTV Ratio]
    
    style Core_Factors fill:#e1f3d8
    style User_Metrics fill:#fff7e6
    style Market_Context fill:#e6f3ff
    style SC fill:#f9f9f9
    style WF fill:#f9f9f9
    style NM fill:#f9f9f9
    style LTV fill:#d4edda
</pre>
<h3 id="health-score-monitoring"><a class="header" href="#health-score-monitoring">Health Score Monitoring</a></h3>
<pre class="mermaid">sequenceDiagram
    participant User
    participant HealthMonitor
    participant PriceOracle
    participant LiquidationEngine
    participant Market

    loop Every Block
        PriceOracle-&gt;&gt;HealthMonitor: Update Asset Prices
        HealthMonitor-&gt;&gt;HealthMonitor: Calculate Health Score
        
        alt Health Score &lt; Threshold
            HealthMonitor-&gt;&gt;LiquidationEngine: Trigger Liquidation
            LiquidationEngine-&gt;&gt;User: Lock Account
            LiquidationEngine-&gt;&gt;Market: List Assets
            Market--&gt;&gt;LiquidationEngine: Asset Sale Complete
            LiquidationEngine-&gt;&gt;User: Update Position
        else Health Score &gt;= Threshold
            HealthMonitor-&gt;&gt;User: Position Safe
        end
    end
</pre>
<h3 id="liquidation-process"><a class="header" href="#liquidation-process">Liquidation Process</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Monitoring
    Monitoring --&gt; Warning: Health Score Declining
    Warning --&gt; AtRisk: Below Warning Threshold
    AtRisk --&gt; Liquidation: Below Critical Threshold
    Liquidation --&gt; Step1: Lock Account
    Step1 --&gt; Step2: List Assets
    Step2 --&gt; Recovery: Asset Sale
    Recovery --&gt; [*]: Position Cleared
    
    Warning --&gt; Monitoring: Health Restored
    AtRisk --&gt; Warning: Health Improved
</pre>
<h3 id="custom-scoring-implementation"><a class="header" href="#custom-scoring-implementation">Custom Scoring Implementation</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserScore {
    pub historical_data_score: u64,
    pub asset_quality_score: u64,
    pub market_volatility_score: u64,
    pub position_size_score: u64,
    pub account_age_score: u64,
    pub liquidation_history_score: u64,
    pub repayment_history_score: u64,
    pub cross_margin_score: u64,
    pub portfolio_diversity_score: u64,
    pub market_condition_score: u64,
    pub collateral_quality_score: u64,
    pub platform_activity_score: u64,
    pub time_weighted_score: u64,
    pub price_impact_score: u64,
    pub network_status_score: u64,
}

pub fn calculate_ltv_ratio(score: &amp;UserScore) -&gt; Result&lt;u64&gt; {
    // Weighted calculation of LTV based on all scoring parameters
    let weighted_score = calculate_weighted_score(score)?;
    let normalized_score = normalize_score(weighted_score)?;
    
    // Convert normalized score to LTV ratio
    let ltv_ratio = convert_score_to_ltv(normalized_score)?;
    
    // Apply market condition adjustments
    let adjusted_ltv = apply_market_adjustments(ltv_ratio)?;
    
    Ok(adjusted_ltv)
}

pub fn monitor_health_score(
    ctx: Context&lt;HealthCheck&gt;,
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;()&gt; {
    let health_score = calculate_health_score(position, score)?;
    
    if health_score &lt; CRITICAL_THRESHOLD {
        trigger_full_liquidation(ctx, position)?;
        lock_account(ctx.accounts.user_account)?;
    } else if health_score &lt; WARNING_THRESHOLD {
        emit_warning(ctx.accounts.user_account)?;
    }
    
    Ok(())
}

pub fn trigger_full_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    position: &amp;UserPosition,
) -&gt; Result&lt;()&gt; {
    // Step 1: Lock the account
    lock_account(ctx.accounts.user_account)?;
    
    // Step 2: Calculate current position value
    let position_value = calculate_position_value(position)?;
    
    // Step 3: List assets on marketplace
    list_assets_for_liquidation(
        ctx.accounts.marketplace,
        position.assets,
        position_value,
    )?;
    
    // Step 4: Monitor recovery process
    start_recovery_monitoring(ctx.accounts.recovery_manager)?;
    
    Ok(())
}

## Health Score Calculation
The health score is calculated using a combination of factors:

```rust,ignore
pub fn calculate_health_score(
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;u64&gt; {
    // 1. Calculate base health ratio
    let base_health = calculate_base_health_ratio(
        position.collateral_value,
        position.borrowed_value,
    )?;
    
    // 2. Apply user score modifiers
    let score_adjusted_health = apply_score_modifiers(
        base_health,
        score,
    )?;
    
    // 3. Apply market condition adjustments
    let market_adjusted_health = apply_market_conditions(
        score_adjusted_health,
        &amp;position.asset_type,
    )?;
    
    // 4. Apply time-weighted factors
    let final_health_score = apply_time_weights(
        market_adjusted_health,
        position.last_update,
    )?;
    
    Ok(final_health_score)
}</code></pre>
<h3 id="liquidation-implementation"><a class="header" href="#liquidation-implementation">Liquidation Implementation</a></h3>
<p>The two-step liquidation process is implemented as follows:</p>
<pre><code class="language-rust ignore">pub struct LiquidationConfig {
    pub warning_threshold: u64,
    pub critical_threshold: u64,
    pub recovery_timeout: i64,
    pub minimum_recovery_value: u64,
}

pub fn handle_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    config: &amp;LiquidationConfig,
) -&gt; Result&lt;()&gt; {
    // Step 1: Asset Recovery
    let recovery_listing = create_recovery_listing(
        ctx.accounts.marketplace,
        ctx.accounts.user_position,
        config.minimum_recovery_value,
    )?;
    
    // Step 2: Monitor Recovery
    start_recovery_monitoring(
        recovery_listing,
        config.recovery_timeout,
    )?;
    
    // Lock account until recovery complete
    lock_user_account(ctx.accounts.user_account)?;
    
    Ok(())
}</code></pre>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="1-initialize-lending-pool"><a class="header" href="#1-initialize-lending-pool">1. Initialize Lending Pool</a></h3>
<p>First, we‚Äôll create a function to initialize a new lending pool:</p>
<pre><code class="language-rust ignore">pub fn initialize_lending_pool(
    ctx: Context&lt;InitializeLendingPool&gt;,
    asset_type: AssetType,
    initial_interest_rate: u64,
    liquidation_threshold: u64,
    collateral_factor: u64,
) -&gt; Result&lt;()&gt; {
    let lending_pool = &amp;mut ctx.accounts.lending_pool;
    
    lending_pool.pool_pubkey = ctx.accounts.pool.key();
    lending_pool.asset_type = asset_type;
    lending_pool.total_deposits = 0;
    lending_pool.total_borrows = 0;
    lending_pool.interest_rate = initial_interest_rate;
    lending_pool.utilization_rate = 0;
    lending_pool.liquidation_threshold = liquidation_threshold;
    lending_pool.collateral_factor = collateral_factor;
    
    Ok(())
}

// Initialize pool metrics
pub fn initialize_pool_metrics(
    ctx: Context&lt;InitializePoolMetrics&gt;,
) -&gt; Result&lt;()&gt; {
    let pool_metrics = &amp;mut ctx.accounts.pool_metrics;
    
    pool_metrics.total_value_locked = 0;
    pool_metrics.available_liquidity = 0;
    pool_metrics.utilization_rate = 0;
    pool_metrics.supply_apy = 0;
    pool_metrics.borrow_apy = 0;
    
    Ok(())
}</code></pre>
<h3 id="2-manage-user-positions"><a class="header" href="#2-manage-user-positions">2. Manage User Positions</a></h3>
<p>Functions to handle user position management:</p>
<pre><code class="language-rust ignore">pub fn create_user_position(
    ctx: Context&lt;CreateUserPosition&gt;,
    pool_pubkey: Pubkey,
) -&gt; Result&lt;()&gt; {
    let user_position = &amp;mut ctx.accounts.user_position;
    
    user_position.user_pubkey = ctx.accounts.user.key();
    user_position.pool_pubkey = pool_pubkey;
    user_position.deposited_amount = 0;
    user_position.borrowed_amount = 0;
    user_position.collateral_amount = 0;
    user_position.last_update = Clock::get()?.unix_timestamp;
    
    Ok(())
}

pub fn update_position_health(
    ctx: Context&lt;UpdatePositionHealth&gt;,
) -&gt; Result&lt;()&gt; {
    let position = &amp;ctx.accounts.user_position;
    let pool = &amp;ctx.accounts.lending_pool;
    let health = &amp;mut ctx.accounts.position_health;
    
    // Calculate health factor based on current prices and positions
    let collateral_value = calculate_collateral_value(
        position.collateral_amount,
        pool.asset_type,
    )?;
    
    let borrow_value = calculate_borrow_value(
        position.borrowed_amount,
        pool.asset_type,
    )?;
    
    health.health_factor = calculate_health_factor(
        collateral_value,
        borrow_value,
        pool.collateral_factor,
    )?;
    
    health.liquidation_price = calculate_liquidation_price(
        position.borrowed_amount,
        position.collateral_amount,
        pool.liquidation_threshold,
    )?;
    
    health.safe_borrow_limit = calculate_safe_borrow_limit(
        collateral_value,
        pool.collateral_factor,
    )?;
    
    Ok(())
}</code></pre>
<h3 id="3-pool-and-position-utilities"><a class="header" href="#3-pool-and-position-utilities">3. Pool and Position Utilities</a></h3>
<p>Helper functions for managing pools and positions:</p>
<pre><code class="language-rust ignore">// Calculate the utilization rate of a pool
pub fn calculate_utilization_rate(pool: &amp;LendingPool) -&gt; Result&lt;u64&gt; {
    if pool.total_deposits == 0 {
        return Ok(0);
    }
    
    Ok((pool.total_borrows * 10000) / pool.total_deposits)
}

// Calculate the health factor of a position
pub fn calculate_health_factor(
    collateral_value: u64,
    borrow_value: u64,
    collateral_factor: u64,
) -&gt; Result&lt;u64&gt; {
    if borrow_value == 0 {
        return Ok(u64::MAX);
    }
    
    Ok((collateral_value * collateral_factor) / (borrow_value * 10000))
}

// Update pool metrics
pub fn update_pool_metrics(
    pool: &amp;LendingPool,
    metrics: &amp;mut PoolMetrics,
) -&gt; Result&lt;()&gt; {
    metrics.total_value_locked = pool.total_deposits;
    metrics.available_liquidity = pool.total_deposits.saturating_sub(pool.total_borrows);
    metrics.utilization_rate = calculate_utilization_rate(pool)?;
    
    // Update APY rates based on utilization
    let (supply_apy, borrow_apy) = calculate_apy_rates(
        metrics.utilization_rate,
        pool.interest_rate,
    )?;
    
    metrics.supply_apy = supply_apy;
    metrics.borrow_apy = borrow_apy;
    
    Ok(())
}</code></pre>
<h3 id="4-deposit-assets"><a class="header" href="#4-deposit-assets">4. Deposit Assets</a></h3>
<p>Create a deposit function to allow users to provide liquidity:</p>
<pre><code class="language-rust ignore">pub fn deposit(
    ctx: Context&lt;Deposit&gt;,
    amount: u64,
    btc_txid: [u8; 32],
    vout: u32,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;
    
    // Verify the UTXO belongs to the user
    require!(
        validate_utxo_ownership(
            &amp;UtxoMeta {
                txid: btc_txid,
                vout,
                amount,
            },
            &amp;ctx.accounts.user.key()
        )?,
        ErrorCode::InvalidUTXO
    );

    // Create deposit account to hold the UTXO
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            btc_txid,
            vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.user.clone(), ctx.accounts.pool.clone()]
    )?;

    // Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update utilization metrics
    update_utilization_rate(pool)?;
    
    Ok(())
}</code></pre>
<h3 id="5-borrow-assets"><a class="header" href="#5-borrow-assets">5. Borrow Assets</a></h3>
<p>Implement borrowing functionality:</p>
<pre><code class="language-rust ignore">pub fn borrow(
    ctx: Context&lt;Borrow&gt;,
    amount: u64,
    collateral_utxo: UtxoMeta,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let borrower_position = &amp;mut ctx.accounts.user_position;

    // Verify collateral UTXO ownership
    require!(
        validate_utxo_ownership(
            &amp;collateral_utxo,
            &amp;ctx.accounts.borrower.key()
        )?,
        ErrorCode::InvalidCollateral
    );

    // Check collateral requirements
    require!(
        is_collateral_sufficient(borrower_position, pool, amount)?,
        ErrorCode::InsufficientCollateral
    );

    // Create collateral account
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            collateral_utxo.txid,
            collateral_utxo.vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.borrower.clone(), ctx.accounts.pool.clone()]
    )?;

    // Create borrow UTXO for user
    let mut btc_tx = Transaction::new();
    add_state_transition(&amp;mut btc_tx, ctx.accounts.pool);

    // Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;[InputToSign {
                index: 0,
                signer: pool.pool_pubkey
            }]
        }
    );

    // Update states
    pool.total_borrows = pool.total_borrows
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    borrower_position.borrowed_amount = borrower_position.borrowed_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;

    update_utilization_rate(pool)?;
    update_interest_rate(pool)?;

    Ok(())
}</code></pre>
<h3 id="6-liquidation-logic"><a class="header" href="#6-liquidation-logic">6. Liquidation Logic</a></h3>
<p>Implement liquidation for underwater positions:</p>
<pre><code class="language-rust ignore">pub fn liquidate(
    ctx: Context&lt;Liquidate&gt;,
    repay_amount: u64,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let liquidated_position = &amp;mut ctx.accounts.liquidated_position;
    
    // Check if position is liquidatable
    require!(
        is_position_liquidatable(liquidated_position, pool)?,
        ErrorCode::PositionNotLiquidatable
    );
    
    // Calculate liquidation bonus
    let bonus = calculate_liquidation_bonus(repay_amount, pool.liquidation_threshold)?;
    
    // Process liquidation
    process_liquidation(
        pool,
        liquidated_position,
        repay_amount,
        bonus,
    )?;
    
    Ok(())
}</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Create comprehensive tests for your lending protocol:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_initialize_lending_pool() {
        // Test pool initialization
    }

    #[test]
    fn test_deposit() {
        // Test deposit functionality
    }

    #[test]
    fn test_borrow() {
        // Test borrowing
    }

    #[test]
    fn test_liquidation() {
        // Test liquidation scenarios
    }
}</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<ol>
<li><strong>Collateral Safety</strong>: Implement strict collateral requirements and regular position health checks</li>
<li><strong>Price Oracle Security</strong>: Use reliable price feeds and implement safeguards against price manipulation</li>
<li><strong>Interest Rate Model</strong>: Ensure the model can handle extreme market conditions</li>
<li><strong>Access Control</strong>: Implement proper permission checks for all sensitive operations</li>
<li><strong>Liquidation Thresholds</strong>: Set appropriate thresholds to maintain protocol solvency</li>
</ol>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ol>
<li>
<p>Implement additional features:</p>
<ul>
<li>Flash loans</li>
<li>Multiple collateral types</li>
<li>Governance mechanisms</li>
</ul>
</li>
<li>
<p>Deploy and test on testnet:</p>
<ul>
<li>Monitor pool performance</li>
<li>Test liquidation scenarios</li>
<li>Validate interest rate model</li>
</ul>
</li>
<li>
<p>Security audit:</p>
<ul>
<li>Contract review</li>
<li>Economic model analysis</li>
<li>Risk assessment</li>
</ul>
</li>
</ol>
<h2 id="process-descriptions"><a class="header" href="#process-descriptions">Process Descriptions</a></h2>
<h3 id="1-pool-initialization-process"><a class="header" href="#1-pool-initialization-process">1. Pool Initialization Process</a></h3>
<p>The pool initialization process involves several steps:</p>
<pre class="mermaid">%%{init: {
  'theme': 'base',
  'themeVariables': { 'fontSize': '16px'},
  'flowchart': {
    'curve': 'basis',
    'nodeSpacing': 50,
    'rankSpacing': 50,
    'animation': {
      'sequence': true,
      'duration': 1000,
      'ease': 'linear',
      'diagramUpdate': 200
    }
  }
}}%%
graph LR
    A[Admin] --&gt;|Create Pool| B[Initialize Pool Account]
    B --&gt;|Set Parameters| C[Configure Pool]
    C --&gt;|Initialize Metrics| D[Create Pool Metrics]
    D --&gt;|Enable Oracle| E[Connect Price Feed]
    E --&gt;|Activate| F[Pool Active]

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef active fill:#4a9eff,color:white,stroke:#3182ce,opacity:0;
    classDef complete fill:#98FB98,stroke:#333;

</pre>
<ol>
<li>Admin creates a new pool account</li>
<li>Pool parameters are set (interest rates, thresholds)</li>
<li>Pool metrics are initialized</li>
<li>Price oracle connection is established</li>
<li>Pool is activated for user operations</li>
</ol>
<h3 id="2-deposit-and-borrow-flow"><a class="header" href="#2-deposit-and-borrow-flow">2. Deposit and Borrow Flow</a></h3>
<p>The lending and borrowing process follows this sequence:</p>
<pre class="mermaid">graph TD
    A[User] --&gt;|Deposit Assets| B[Lending Pool]
    B --&gt;|Create Position| C[User Position]
    C --&gt;|Calculate Capacity| D[Borrow Limit]
    D --&gt;|Enable Borrowing| E[Borrow Assets]
    E --&gt;|Update Metrics| F[Pool Metrics]
    F --&gt;|Adjust Rates| G[Interest Rates]
</pre>
<p>Key steps:</p>
<ol>
<li>User deposits assets into the pool</li>
<li>System creates or updates user position</li>
<li>Calculates borrowing capacity based on collateral</li>
<li>Enables borrowing up to the limit</li>
<li>Updates pool metrics and interest rates</li>
</ol>
<h3 id="3-health-monitoring-system"><a class="header" href="#3-health-monitoring-system">3. Health Monitoring System</a></h3>
<p>Continuous health monitoring process:</p>
<pre class="mermaid">graph TD
    A[Price Oracle] --&gt;|Update Prices| B[Position Valuation]
    B --&gt;|Calculate Ratios| C[Health Check]
    C --&gt;|Evaluate| D{Health Factor}
    D --&gt;|&gt;1| E[Healthy]
    D --&gt;|&lt;1| F[At Risk]
    F --&gt;|&lt;Threshold| G[Liquidatable]
    G --&gt;|Notify| H[Liquidators]
</pre>
<p>The system:</p>
<ol>
<li>Continuously monitors asset prices</li>
<li>Updates position valuations</li>
<li>Calculates health factors</li>
<li>Triggers liquidations when necessary</li>
</ol>
<h3 id="withdrawal-process"><a class="header" href="#withdrawal-process">Withdrawal Process</a></h3>
<p>The withdrawal process in our lending protocol involves two key components:</p>
<ol>
<li>State management through program accounts</li>
<li>Actual BTC transfer through UTXOs</li>
</ol>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct WithdrawRequest {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub amount: u64,
    pub recipient_btc_address: String,
}

pub fn process_withdrawal(
    ctx: Context&lt;ProcessWithdraw&gt;,
    request: WithdrawRequest,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;

    // 1. Validate user position
    require!(
        user_position.deposited_amount &gt;= request.amount,
        ErrorCode::InsufficientBalance
    );

    // 2. Check pool liquidity
    require!(
        pool.available_liquidity() &gt;= request.amount,
        ErrorCode::InsufficientLiquidity
    );

    // 3. Find available UTXOs from pool
    let selected_utxos = select_utxos_for_withdrawal(
        &amp;pool.utxos,
        request.amount
    )?;

    // 4. Create Bitcoin withdrawal transaction
    let mut btc_tx = Transaction::new();
    
    // Add inputs from selected UTXOs
    for utxo in selected_utxos {
        btc_tx.input.push(TxIn {
            previous_output: OutPoint::new(utxo.txid, utxo.vout),
            script_sig: Script::new(),
            sequence: Sequence::MAX,
            witness: Witness::new(),
        });
    }

    // Add withdrawal output to user's address
    let recipient_script = Address::from_str(&amp;request.recipient_btc_address)?
        .script_pubkey();
    btc_tx.output.push(TxOut {
        value: request.amount,
        script_pubkey: recipient_script,
    });

    // Add change output back to pool if needed
    let total_input = selected_utxos.iter()
        .map(|utxo| utxo.amount)
        .sum::&lt;u64&gt;();
    if total_input &gt; request.amount {
        btc_tx.output.push(TxOut {
            value: total_input - request.amount,
            script_pubkey: get_account_script_pubkey(&amp;pool.pool_pubkey),
        });
    }

    // 5. Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;selected_utxos.iter()
                .enumerate()
                .map(|(i, _)| InputToSign {
                    index: i as u32,
                    signer: pool.pool_pubkey,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        }
    );

    // 6. Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 7. Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 8. Remove spent UTXOs from pool
    pool.utxos.retain(|utxo| !selected_utxos.contains(utxo));

    Ok(())
}

fn select_utxos_for_withdrawal(
    pool_utxos: &amp;[UtxoMeta],
    amount: u64,
) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;&gt; {
    let mut selected = Vec::new();
    let mut total_selected = 0;

    for utxo in pool_utxos {
        if total_selected &gt;= amount {
            break;
        }
        
        // Verify UTXO is still valid and unspent
        validate_utxo(utxo)?;
        
        selected.push(utxo.clone());
        total_selected += utxo.amount;
    }

    require!(
        total_selected &gt;= amount,
        ErrorCode::InsufficientUtxos
    );

    Ok(selected)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-the-arch-program-library-apl"><a class="header" href="#introduction-to-the-arch-program-library-apl">Introduction to the Arch Program Library (APL)</a></h1>
<p>The Arch Program Library (APL) is a collection of on-chain programs targeting the Arch Network blockchain. These programs serve as fundamental building blocks for developing decentralized applications (dApps) on Arch Network. The APL programs are thoroughly tested and provide developers with reliable and secure components for their applications.</p>
<h2 id="available-programs"><a class="header" href="#available-programs">Available Programs</a></h2>
<p>The APL currently includes the following core programs:</p>
<h3 id="token-program"><a class="header" href="#token-program">Token Program</a></h3>
<p>The foundation for creating and managing fungible tokens on Arch Network. It provides a robust implementation for:</p>
<ul>
<li>Token creation and management</li>
<li>Account management</li>
<li>Transfer operations</li>
<li>Delegation capabilities</li>
<li>Multisignature support</li>
</ul>
<h3 id="associated-token-account-program"><a class="header" href="#associated-token-account-program">Associated Token Account Program</a></h3>
<p>A program that standardizes the creation and management of token accounts:</p>
<ul>
<li>Deterministic account address derivation</li>
<li>Simplified account management</li>
<li>Reduced transaction complexity</li>
</ul>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>The APL is designed with the following principles:</p>
<ol>
<li>
<p><strong>Security First</strong></p>
<ul>
<li>Comprehensive security audits</li>
<li>Battle-tested implementations</li>
<li>Conservative upgrade approach</li>
</ul>
</li>
<li>
<p><strong>Composability</strong></p>
<ul>
<li>Programs designed to work together</li>
<li>Standardized interfaces</li>
<li>Clear dependencies</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Optimized for Arch Network‚Äôs architecture</li>
<li>Efficient resource utilization</li>
<li>Scalable implementations</li>
</ul>
</li>
<li>
<p><strong>Developer Experience</strong></p>
<ul>
<li>Clear documentation</li>
<li>Example implementations</li>
<li>Testing utilities</li>
</ul>
</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To start building with APL:</p>
<ol>
<li>Familiarize yourself with the <a href="apl/../concepts/architecture.html">Arch Network architecture</a></li>
<li>Review the documentation for your program of interest</li>
<li>Check out the example implementations</li>
<li>Use the testing utilities to validate your integration</li>
</ol>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>The APL is an open-source project and welcomes contributions from the community. To contribute:</p>
<ol>
<li>Review the contribution guidelines</li>
<li>Join the developer community</li>
<li>Submit proposals for new features</li>
<li>Help improve documentation</li>
<li>Report and fix bugs</li>
</ol>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>For support with APL:</p>
<ul>
<li>Join the developer community</li>
<li>Check the FAQ and troubleshooting guides</li>
<li>Submit issues on GitHub</li>
<li>Participate in developer forums</li>
</ul>
<h2 id="future-development"><a class="header" href="#future-development">Future Development</a></h2>
<p>The APL is continuously evolving with new programs and improvements being added. Some areas of ongoing development include:</p>
<ul>
<li>Advanced token standards</li>
<li>DeFi primitives (including AMM and Swap functionality)</li>
<li>Cross-chain bridges</li>
<li>Privacy-preserving features</li>
</ul>
<p>Stay connected with the community to learn about new developments and opportunities to contribute to the ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-program-1"><a class="header" href="#token-program-1">Token Program</a></h1>
<p>The APL Token Program is the foundation for creating and managing fungible tokens on the Arch Network. This documentation provides a comprehensive guide for developers implementing token functionality in their applications.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The Token Program enables:</p>
<ul>
<li>Creation and management of fungible tokens (mints)</li>
<li>Token account management</li>
<li>Token transfers and delegations</li>
<li>Multisignature authorities</li>
<li>Account freezing and thawing</li>
</ul>
<h2 id="program-id"><a class="header" href="#program-id">Program ID</a></h2>
<pre><code class="language-text">AplToken111111111111111111111111
</code></pre>
<h2 id="account-types"><a class="header" href="#account-types">Account Types</a></h2>
<h3 id="mint-account"><a class="header" href="#mint-account">Mint Account</a></h3>
<p>The central record for a token type, containing:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to mint new tokens</td></tr>
<tr><td><code>supply</code></td><td><code>u64</code></td><td>Total number of tokens in circulation</td></tr>
<tr><td><code>decimals</code></td><td><code>u8</code></td><td>Number of decimal places</td></tr>
<tr><td><code>is_initialized</code></td><td><code>bool</code></td><td>Has this mint been initialized</td></tr>
<tr><td><code>freeze_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to freeze token accounts</td></tr>
</tbody></table>
</div>
<h3 id="token-account"><a class="header" href="#token-account">Token Account</a></h3>
<p>Holds token balances for a specific mint:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mint</code></td><td><code>Pubkey</code></td><td>The token mint this account holds</td></tr>
<tr><td><code>owner</code></td><td><code>Pubkey</code></td><td>Owner of this account</td></tr>
<tr><td><code>amount</code></td><td><code>u64</code></td><td>Number of tokens held</td></tr>
<tr><td><code>delegate</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional delegate authority</td></tr>
<tr><td><code>state</code></td><td><code>AccountState</code></td><td>Account state (Uninitialized/Initialized/Frozen)</td></tr>
<tr><td><code>delegated_amount</code></td><td><code>u64</code></td><td>Amount delegated</td></tr>
<tr><td><code>close_authority</code></td><td><code>COption&lt;Pubkey&gt;</code></td><td>Optional authority to close the account</td></tr>
</tbody></table>
</div>
<h3 id="multisig-account"><a class="header" href="#multisig-account">Multisig Account</a></h3>
<p>Enables shared authority over token operations:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>m</code></td><td><code>u8</code></td><td>Number of required signers</td></tr>
<tr><td><code>n</code></td><td><code>u8</code></td><td>Number of valid signers</td></tr>
<tr><td><code>is_initialized</code></td><td><code>bool</code></td><td>Has this multisig been initialized</td></tr>
<tr><td><code>signers</code></td><td><code>[Pubkey; MAX_SIGNERS]</code></td><td>Array of valid signer addresses</td></tr>
</tbody></table>
</div>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<h3 id="token-creation-and-initialization"><a class="header" href="#token-creation-and-initialization">Token Creation and Initialization</a></h3>
<h4 id="initializemint"><a class="header" href="#initializemint">InitializeMint</a></h4>
<p>Creates a new token type.</p>
<pre><code class="language-rust ignore">pub struct InitializeMint {
    pub decimals: u8,
    pub mint_authority: Pubkey,
    pub freeze_authority: COption&lt;Pubkey&gt;,
}</code></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The mint to initialize</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let mint = Keypair::new();
let mint_authority = Keypair::new();
let decimals = 9;

let instruction = apl_token::instruction::initialize_mint(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    &amp;mint_authority.pubkey(),
    None, // No freeze authority
    decimals,
)?;</code></pre>
<h4 id="initializeaccount"><a class="header" href="#initializeaccount">InitializeAccount</a></h4>
<p>Creates a new account to hold tokens.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The account to initialize</li>
<li><code>[]</code> The mint this account is for</li>
<li><code>[]</code> The owner of the new account</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let account = Keypair::new();
let owner = Keypair::new();

let instruction = apl_token::instruction::initialize_account(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
)?;</code></pre>
<h4 id="initializemultisig"><a class="header" href="#initializemultisig">InitializeMultisig</a></h4>
<p>Creates a new multisignature authority.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InitializeMultisig {
    pub m: u8, // Number of required signers
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The multisig to initialize</li>
<li><code>[]</code> The signer accounts (1 to 11)</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let multisig = Keypair::new();
let signers = vec![&amp;signer1.pubkey(), &amp;signer2.pubkey(), &amp;signer3.pubkey()];
let min_signers = 2;

let instruction = apl_token::instruction::initialize_multisig(
    &amp;apl_token::id(),
    &amp;multisig.pubkey(),
    &amp;signers,
    min_signers,
)?;</code></pre>
<h3 id="token-operations"><a class="header" href="#token-operations">Token Operations</a></h3>
<h4 id="mintto"><a class="header" href="#mintto">MintTo</a></h4>
<p>Creates new tokens in an account.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MintTo {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The mint</li>
<li><code>[writable]</code> The account to mint to</li>
<li><code>[signer]</code> The mint authority</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 1_000_000_000; // 1 token with 9 decimals

let instruction = apl_token::instruction::mint_to(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    &amp;destination.pubkey(),
    &amp;mint_authority.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h4 id="transfer"><a class="header" href="#transfer">Transfer</a></h4>
<p>Moves tokens between accounts.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Transfer {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[writable]</code> Destination account</li>
<li><code>[signer]</code> Owner/delegate authority</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 50_000_000; // 0.05 tokens with 9 decimals

let instruction = apl_token::instruction::transfer(
    &amp;apl_token::id(),
    &amp;source.pubkey(),
    &amp;destination.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h4 id="burn"><a class="header" href="#burn">Burn</a></h4>
<p>Removes tokens from circulation.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Burn {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> The account to burn from</li>
<li><code>[writable]</code> The token mint</li>
<li><code>[signer]</code> The owner/delegate</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 1_000_000_000; // 1 token with 9 decimals

let instruction = apl_token::instruction::burn(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h3 id="delegation"><a class="header" href="#delegation">Delegation</a></h3>
<h4 id="approve"><a class="header" href="#approve">Approve</a></h4>
<p>Delegates authority over tokens.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Approve {
    pub amount: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[]</code> Delegate</li>
<li><code>[signer]</code> Source account owner</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let amount = 5_000_000_000; // 5 tokens with 9 decimals

let instruction = apl_token::instruction::approve(
    &amp;apl_token::id(),
    &amp;source.pubkey(),
    &amp;delegate.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
    amount,
)?;</code></pre>
<h4 id="revoke"><a class="header" href="#revoke">Revoke</a></h4>
<p>Removes delegated authority.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Source account</li>
<li><code>[signer]</code> Source account owner</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let instruction = apl_token::instruction::revoke(
    &amp;apl_token::id(),
    &amp;source.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
)?;</code></pre>
<h3 id="account-management"><a class="header" href="#account-management">Account Management</a></h3>
<h4 id="setauthority"><a class="header" href="#setauthority">SetAuthority</a></h4>
<p>Changes an authority on a mint or account.</p>
<pre><code class="language-rust ignore">pub struct SetAuthority {
    pub authority_type: AuthorityType,
    pub new_authority: COption&lt;Pubkey&gt;,
}</code></pre>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Mint/account to change</li>
<li><code>[signer]</code> Current authority</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let instruction = apl_token::instruction::set_authority(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    Some(&amp;new_authority.pubkey()),
    apl_token::instruction::AuthorityType::MintTokens,
    &amp;current_authority.pubkey(),
    &amp;[],
)?;</code></pre>
<h4 id="closeaccount"><a class="header" href="#closeaccount">CloseAccount</a></h4>
<p>Closes a token account with zero balance.</p>
<p>Required accounts:</p>
<ul>
<li><code>[writable]</code> Account to close</li>
<li><code>[writable]</code> Destination for rent funds</li>
<li><code>[signer]</code> Account owner</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">let instruction = apl_token::instruction::close_account(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;destination.pubkey(),
    &amp;owner.pubkey(),
    &amp;[],
)?;</code></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The program defines specific error types for common failure cases:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TokenError {
    NotRentExempt,           // Account balance too low
    InsufficientFunds,       // Not enough tokens
    InvalidMint,             // Invalid mint account
    MintMismatch,           // Mint doesn't match
    OwnerMismatch,          // Wrong account owner
    FixedSupply,            // Mint authority disabled
    AlreadyInUse,           // Account already initialized
    InvalidNumberOfProvidedSigners,
    InvalidNumberOfRequiredSigners,
    UninitializedState,     // Account not initialized
    NativeNotSupported,     // Instruction not for native tokens
    NonNativeHasBalance,    // Non-native account with balance
    InvalidInstruction,     // Invalid instruction data
    InvalidState,           // Account in invalid state
    Overflow,               // Operation overflowed
    AuthorityTypeNotSupported,
    MintCannotFreeze,       // Mint has no freeze authority
    AccountFrozen,          // Account is frozen
    // ... other errors
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="security-3"><a class="header" href="#security-3">Security</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account states before operations</li>
<li>Validate mint associations</li>
</ul>
</li>
<li>
<p><strong>Authority Management</strong></p>
<ul>
<li>Use multisig for sensitive operations</li>
<li>Carefully manage mint/freeze authorities</li>
<li>Have clear authority transfer procedures</li>
</ul>
</li>
<li>
<p><strong>Operation Safety</strong></p>
<ul>
<li>Use checked math operations</li>
<li>Handle frozen accounts appropriately</li>
<li>Implement proper error handling</li>
</ul>
</li>
</ol>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<ol>
<li>
<p><strong>Transaction Optimization</strong></p>
<ul>
<li>Combine related operations in one transaction</li>
<li>Minimize account lookups</li>
<li>Pre-allocate accounts when possible</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close unused accounts</li>
<li>Maintain rent-exempt balances</li>
<li>Use Associated Token Accounts when appropriate</li>
</ul>
</li>
</ol>
<h2 id="common-scenarios"><a class="header" href="#common-scenarios">Common Scenarios</a></h2>
<h3 id="creating-a-new-token"><a class="header" href="#creating-a-new-token">Creating a New Token</a></h3>
<pre><code class="language-rust ignore">// 1. Create mint account
let mint = Keypair::new();
let mint_rent = arch_program::account::MIN_ACCOUNT_LAMPORTS;

let create_mint_account = arch_program::system_instruction::create_account(
    &amp;payer.pubkey(),
    &amp;mint.pubkey(),
    mint_rent,
    apl_token::state::Mint::LEN as u64,
    &amp;apl_token::id(),
);

// 2. Initialize mint
let init_mint = apl_token::instruction::initialize_mint(
    &amp;apl_token::id(),
    &amp;mint.pubkey(),
    &amp;mint_authority.pubkey(),
    Some(&amp;freeze_authority.pubkey()),
    9, // decimals
)?;

// 3. Create token account
let account = Keypair::new();
let account_rent = arch_program::account::MIN_ACCOUNT_LAMPORTS;

let create_account = arch_program::system_instruction::create_account(
    &amp;payer.pubkey(),
    &amp;account.pubkey(),
    account_rent,
    apl_token::state::Account::LEN as u64,
    &amp;apl_token::id(),
);

// 4. Initialize token account
let init_account = apl_token::instruction::initialize_account(
    &amp;apl_token::id(),
    &amp;account.pubkey(),
    &amp;mint.pubkey(),
    &amp;owner.pubkey(),
)?;

// 5. Send instructions using Arch SDK
let transaction = arch_sdk::build_and_sign_transaction(
    arch_program::sanitized::ArchMessage::new(
        &amp;[
            create_mint_account,
            init_mint,
            create_account,
            init_account,
        ],
        Some(payer_pubkey),
        client.get_best_block_hash().unwrap(),
    ),
    vec![payer_keypair, mint, account],
    BITCOIN_NETWORK,
);</code></pre>
<h3 id="implementing-a-token-transfer"><a class="header" href="#implementing-a-token-transfer">Implementing a Token Transfer</a></h3>
<pre><code class="language-rust ignore">// 1. Get token accounts (these would be created beforehand)
// let source = source_token_account_pubkey;
// let destination = destination_token_account_pubkey;

// 2. Create transfer instruction
let transfer = apl_token::instruction::transfer(
    &amp;apl_token::id(),
    &amp;source,
    &amp;destination,
    &amp;source_owner,
    &amp;[],
    amount,
)?;

// 3. Send transaction using Arch SDK
let transaction = arch_sdk::build_and_sign_transaction(
    arch_program::sanitized::ArchMessage::new(
        &amp;[transfer],
        Some(source_owner_pubkey),
        client.get_best_block_hash().unwrap(),
    ),
    vec![source_owner_keypair],
    BITCOIN_NETWORK,
);</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>The Token Program includes comprehensive tests. When implementing token functionality, you should test:</p>
<ol>
<li>
<p><strong>Basic Operations</strong></p>
<ul>
<li>Mint initialization</li>
<li>Account creation</li>
<li>Token transfers</li>
<li>Balance checks</li>
</ul>
</li>
<li>
<p><strong>Authority Controls</strong></p>
<ul>
<li>Authority validation</li>
<li>Multisig operations</li>
<li>Authority transfers</li>
</ul>
</li>
<li>
<p><strong>Error Cases</strong></p>
<ul>
<li>Insufficient funds</li>
<li>Invalid authorities</li>
<li>Account state violations</li>
</ul>
</li>
</ol>
<p>Example test:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn test_transfer() {
        let mint = Keypair::new();
        let source = Keypair::new();
        let destination = Keypair::new();
        let owner = Keypair::new();

        // Initialize mint and accounts
        // ... setup code ...

        // Test transfer
        let amount = 100;
        let result = apl_token::instruction::transfer(
            &amp;apl_token::id(),
            &amp;source.pubkey(),
            &amp;destination.pubkey(),
            &amp;owner.pubkey(),
            &amp;[],
            amount,
        );

        assert!(result.is_ok());
        // Verify balances
        // ... verification code ...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-token-account-program-1"><a class="header" href="#associated-token-account-program-1">Associated Token Account Program</a></h1>
<p>The Associated Token Account (ATA) Program is a utility program in the Arch Program Library (APL) that standardizes the creation and management of token accounts. It provides a deterministic way to find and create token accounts for any wallet address and token mint combination.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The Associated Token Account Program enables:</p>
<ul>
<li>Deterministic derivation of token account addresses</li>
<li>Automatic token account creation</li>
<li>Standardized account management</li>
<li>Simplified token operations</li>
</ul>
<h2 id="program-id-1"><a class="header" href="#program-id-1">Program ID</a></h2>
<pre><code class="language-text">associated-token-account00000000
</code></pre>
<p>You can get the program ID in code:</p>
<pre><code class="language-rust ignore">let program_id = apl_associated_token_account::id();</code></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="associated-token-accounts"><a class="header" href="#associated-token-accounts">Associated Token Accounts</a></h3>
<p>An Associated Token Account is a Program Derived Address (PDA) that is deterministically derived from:</p>
<ul>
<li>The wallet owner‚Äôs public key</li>
<li>The token mint address</li>
</ul>
<p>This ensures that:</p>
<ol>
<li>Each wallet can have exactly one associated token account per token mint</li>
<li>The account address can be derived by anyone who knows the wallet and mint addresses</li>
<li>The account ownership and permissions are standardized</li>
</ol>
<h3 id="account-structure"><a class="header" href="#account-structure">Account Structure</a></h3>
<p>The Associated Token Account follows the standard Token Account structure but with additional guarantees about its address derivation and ownership.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Address Derivation</strong>: Given a wallet and token mint, the ATA address is derived deterministically</li>
<li><strong>Account Creation</strong>: If the account doesn‚Äôt exist, it can be created by calling the ATA program</li>
<li><strong>Token Operations</strong>: Once created, the ATA works like any other token account for transfers, approvals, etc.</li>
</ol>
<p>The key advantage is that applications can always find a user‚Äôs token account for any mint without needing to store addresses.</p>
<h3 id="key-functions"><a class="header" href="#key-functions">Key Functions</a></h3>
<p>The main function for working with Associated Token Accounts:</p>
<pre><code class="language-rust ignore">// Derive address and bump seed
let (address, bump_seed) = apl_associated_token_account::get_associated_token_address_and_bump_seed(
    &amp;wallet_pubkey,
    &amp;token_mint_pubkey,
    &amp;apl_associated_token_account::id(),
);</code></pre>
<h2 id="instructions-1"><a class="header" href="#instructions-1">Instructions</a></h2>
<h3 id="create-associated-token-account"><a class="header" href="#create-associated-token-account">Create Associated Token Account</a></h3>
<p>Creates a new associated token account for a wallet and token mint combination.</p>
<p>Required accounts:</p>
<ul>
<li><code>[signer]</code> Funding account (pays for account creation)</li>
<li><code>[writable]</code> New associated token account</li>
<li><code>[]</code> Wallet address (account owner)</li>
<li><code>[]</code> Token mint</li>
<li><code>[]</code> System program</li>
<li><code>[]</code> Token program</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">// Derive the associated token account address
let (associated_token_address, _bump_seed) = 
    apl_associated_token_account::get_associated_token_address_and_bump_seed(
        &amp;wallet_address,
        &amp;token_mint,
        &amp;apl_associated_token_account::id(),
    );

// Create instruction to create the associated token account
let instruction = arch_program::instruction::Instruction {
    program_id: apl_associated_token_account::id(),
    accounts: vec![
        arch_program::account::AccountMeta::new(payer_pubkey, true),
        arch_program::account::AccountMeta::new(associated_token_address, false),
        arch_program::account::AccountMeta::new(wallet_address, false),
        arch_program::account::AccountMeta::new_readonly(token_mint, false),
        arch_program::account::AccountMeta::new_readonly(arch_program::system_program::id(), false),
        arch_program::account::AccountMeta::new_readonly(apl_token::id(), false),
    ],
    data: utxo_data, // UTXO data for account creation
};</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="account-management-1"><a class="header" href="#account-management-1">Account Management</a></h3>
<ol>
<li>
<p><strong>Creation</strong></p>
<ul>
<li>Always check if an associated token account exists before creating one</li>
<li>Use the standard creation instruction to ensure proper initialization</li>
<li>Handle account creation costs appropriately</li>
</ul>
</li>
<li>
<p><strong>Usage</strong></p>
<ul>
<li>Use associated token accounts as the default choice for user wallets</li>
<li>Derive addresses deterministically rather than storing them</li>
<li>Verify account ownership and mint before operations</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations</a></h3>
<ol>
<li>
<p><strong>Address Derivation</strong></p>
<ul>
<li>Always use the official derivation function</li>
<li>Verify derived addresses match expected patterns</li>
<li>Handle creation failure cases gracefully</li>
</ul>
</li>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Verify account ownership</li>
<li>Check token mint association</li>
<li>Validate account state before operations</li>
</ul>
</li>
</ol>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="creating-an-associated-token-account"><a class="header" href="#creating-an-associated-token-account">Creating an Associated Token Account</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{build_and_sign_transaction, ArchRpcClient};
use arch_program::sanitized::ArchMessage;

// Derive the associated token account address
let (associated_token_address, _bump_seed) = 
    apl_associated_token_account::get_associated_token_address_and_bump_seed(
        &amp;wallet_address,
        &amp;token_mint,
        &amp;apl_associated_token_account::id(),
    );

// Check if account already exists
let client = ArchRpcClient::new("http://localhost:9001");
let account_info = client.get_account_info(associated_token_address);

if account_info.is_err() {
    // Account doesn't exist, create it
    let instruction = arch_program::instruction::Instruction {
        program_id: apl_associated_token_account::id(),
        accounts: vec![
            arch_program::account::AccountMeta::new(payer_pubkey, true),
            arch_program::account::AccountMeta::new(associated_token_address, false),
            arch_program::account::AccountMeta::new(wallet_address, false),
            arch_program::account::AccountMeta::new_readonly(token_mint, false),
            arch_program::account::AccountMeta::new_readonly(arch_program::system_program::id(), false),
            arch_program::account::AccountMeta::new_readonly(apl_token::id(), false),
        ],
        data: utxo_data, // UTXO data for account creation
    };

    let transaction = build_and_sign_transaction(
        ArchMessage::new(
            &amp;[instruction],
            Some(payer_pubkey),
            client.get_best_block_hash().unwrap(),
        ),
        vec![payer_keypair],
        BITCOIN_NETWORK,
    );
}</code></pre>
<h3 id="using-associated-token-accounts-in-transfers"><a class="header" href="#using-associated-token-accounts-in-transfers">Using Associated Token Accounts in Transfers</a></h3>
<pre><code class="language-rust ignore">// Get associated token accounts for source and destination
let (source_ata, _) = apl_associated_token_account::get_associated_token_address_and_bump_seed(
    &amp;source_wallet,
    &amp;token_mint,
    &amp;apl_associated_token_account::id(),
);

let (destination_ata, _) = apl_associated_token_account::get_associated_token_address_and_bump_seed(
    &amp;destination_wallet,
    &amp;token_mint,
    &amp;apl_associated_token_account::id(),
);

// Create transfer instruction using ATAs
let transfer_instruction = apl_token::instruction::transfer(
    &amp;apl_token::id(),
    &amp;source_ata,
    &amp;destination_ata,
    &amp;source_wallet,
    &amp;[],
    amount,
)?;</code></pre>
<h2 id="common-scenarios-1"><a class="header" href="#common-scenarios-1">Common Scenarios</a></h2>
<h3 id="token-distribution"><a class="header" href="#token-distribution">Token Distribution</a></h3>
<p>When airdropping or distributing tokens:</p>
<ol>
<li>Derive the recipient‚Äôs associated token account address</li>
<li>Create the account if it doesn‚Äôt exist</li>
<li>Transfer tokens to the associated account</li>
</ol>
<h3 id="wallet-integration"><a class="header" href="#wallet-integration">Wallet Integration</a></h3>
<p>When integrating with user wallets:</p>
<ol>
<li>Use associated token accounts by default</li>
<li>Create accounts on-demand when users acquire new tokens</li>
<li>Display token balances from associated accounts</li>
</ol>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Common error cases to handle:</p>
<ul>
<li>Account already exists</li>
<li>Insufficient funds for account creation</li>
<li>Invalid mint association</li>
<li>Invalid owner</li>
<li>Account creation failure</li>
</ul>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<ul>
<li><a href="apl/./token-program.html">Token Program</a> - The main token program that works with ATAs</li>
<li><a href="apl/../program/program.html">Programs</a> - Understanding Arch programs</li>
<li><a href="apl/../program/accounts.html">Accounts</a> - Account model in Arch</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h1>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<pre class="mermaid">graph TB
    subgraph &quot;Arch Network&quot;
        VM[Arch VM&lt;br/&gt;eBPF-based]
        BTC[Bitcoin Integration]
        DKG[DKG Network]
        
        subgraph &quot;Validator Network&quot;
            L[Leader Node]
            V1[Validator Node 1]
            V2[Validator Node 2]
            V3[Validator Node ...]
            B[Bootnode]
        end
        
        subgraph &quot;Core Services&quot;
            TOKEN[APL Token Program]
            ATA[Associated Token Account]
            COMPUTE[Compute Budget]
            SYSTEM[System Program]
        end
        
        VM --&gt; BTC
        VM --&gt; DKG
        L --&gt; V1
        L --&gt; V2
        L --&gt; V3
        B --&gt; V1
        B --&gt; V2
        B --&gt; V3
        VM --&gt; TOKEN
        VM --&gt; ATA
        VM --&gt; COMPUTE
        VM --&gt; SYSTEM
    end
</pre>
<h3 id="arch-vm"><a class="header" href="#arch-vm">Arch VM</a></h3>
<p>The Arch Virtual Machine (VM) is built on eBPF technology, providing a secure and efficient environment for executing programs.</p>
<p>Key features:</p>
<ul>
<li>üîÑ Manages program execution</li>
<li>‚ö° Handles state transitions</li>
<li>üéØ Ensures deterministic computation</li>
<li>üîó Provides syscalls for Bitcoin UTXO operations</li>
<li>üí∞ Supports compute budget management</li>
<li>üé≠ Handles program upgrades and migrations</li>
</ul>
<h3 id="bitcoin-integration-1"><a class="header" href="#bitcoin-integration-1">Bitcoin Integration</a></h3>
<p>Arch Network interacts directly with Bitcoin through:</p>
<ul>
<li>üíº Native UTXO management via <code>bitcoin-internal</code> crate</li>
<li>‚úÖ Transaction validation and synchronization</li>
<li>üîê Multi-signature coordination</li>
<li>üìù State commitment to Bitcoin</li>
<li>üîÑ Real-time Bitcoin network monitoring</li>
<li>üìä UTXO graph processing and rollback support</li>
</ul>
<h3 id="distributed-key-generation-dkg"><a class="header" href="#distributed-key-generation-dkg">Distributed Key Generation (DKG)</a></h3>
<p>The DKG system enables secure multi-signature operations:</p>
<ul>
<li>üîë Threshold signature schemes (t-of-n)</li>
<li>üåê Peer-to-peer key generation</li>
<li>üîÑ Dynamic participant management</li>
<li>üõ°Ô∏è Malicious participant detection</li>
<li>üì° Network message routing and validation</li>
</ul>
<h3 id="validator-network"><a class="header" href="#validator-network">Validator Network</a></h3>
<p>The validator network consists of multiple node types that work together:</p>
<h4 id="node-types"><a class="header" href="#node-types">Node Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Node Type</th><th>Primary Responsibilities</th></tr></thead><tbody>
<tr><td><strong>Leader Node</strong></td><td>‚Ä¢ Coordinates transaction signing<br/>‚Ä¢ Submits signed transactions to Bitcoin<br/>‚Ä¢ Manages validator communication<br/>‚Ä¢ Orchestrates DKG sessions</td></tr>
<tr><td><strong>Validator Nodes</strong></td><td>‚Ä¢ Execute programs in the Arch VM<br/>‚Ä¢ Validate transactions<br/>‚Ä¢ Participate in multi-signature operations<br/>‚Ä¢ Maintain network state<br/>‚Ä¢ Contribute to DKG operations</td></tr>
<tr><td><strong>Bootnode</strong></td><td>‚Ä¢ Handles initial network discovery<br/>‚Ä¢ Similar to Bitcoin DNS seeds<br/>‚Ä¢ Helps new nodes join the network<br/>‚Ä¢ Manages peer information distribution</td></tr>
</tbody></table>
</div>
<h3 id="core-programs"><a class="header" href="#core-programs">Core Programs</a></h3>
<p>Arch Network includes several built-in programs that provide essential functionality:</p>
<h4 id="apl-token-program"><a class="header" href="#apl-token-program">APL Token Program</a></h4>
<ul>
<li>ü™ô Fungible token creation and management</li>
<li>üîê Multi-signature support</li>
<li>‚ùÑÔ∏è Account freezing and thawing</li>
<li>üìä Supply management and minting</li>
<li>üé≠ Authority management and delegation</li>
</ul>
<h4 id="associated-token-account-ata"><a class="header" href="#associated-token-account-ata">Associated Token Account (ATA)</a></h4>
<ul>
<li>üîó Automatic token account creation</li>
<li>üí∞ Rent-exempt account management</li>
<li>üéØ Deterministic address derivation</li>
<li>üîÑ Account lifecycle management</li>
</ul>
<h4 id="compute-budget-program"><a class="header" href="#compute-budget-program">Compute Budget Program</a></h4>
<ul>
<li>‚ö° Transaction compute unit management</li>
<li>üí∞ Fee calculation and optimization</li>
<li>üéØ Resource allocation control</li>
<li>üìä Performance monitoring</li>
</ul>
<h4 id="system-program"><a class="header" href="#system-program">System Program</a></h4>
<ul>
<li>üèóÔ∏è Account creation and management</li>
<li>üîÑ Ownership transfers</li>
<li>üí∞ Lamport management</li>
<li>üîó UTXO anchoring</li>
</ul>
<h2 id="transaction-flow"><a class="header" href="#transaction-flow">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant DKG as DKG Network
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;DKG: 4. Multi-sig Coordination
    DKG-&gt;&gt;L: 5. Sign Results
    L-&gt;&gt;B: 6. Submit to Bitcoin
</pre>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Arch Network implements a robust multi-layered security model that directly leverages Bitcoin‚Äôs security guarantees:</p>
<h3 id="1-utxo-security"><a class="header" href="#1-utxo-security">1. UTXO Security</a></h3>
<ul>
<li>
<p>üîí <strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for secure ownership proofs</li>
<li>Double-spend prevention through UTXO consumption tracking</li>
</ul>
</li>
<li>
<p>üîó <strong>State Management</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Atomic state transitions with rollback capability</li>
<li>Cross-validator state consistency checks</li>
<li>Real-time UTXO graph validation</li>
</ul>
</li>
</ul>
<h3 id="2-transaction-security"><a class="header" href="#2-transaction-security">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">pub struct SecurityParams {
    pub min_confirmations: u32,    // Required Bitcoin confirmations
    pub signature_threshold: u32,   // Multi-sig threshold
    pub timelock_blocks: u32,      // Timelock requirement
    pub max_witness_size: usize,   // Maximum witness data size
    pub dkg_timeout: Duration,     // DKG operation timeout
    pub malicious_threshold: u32,  // Malicious participant threshold
}</code></pre>
<ul>
<li>üìù <strong>Multi-signature Validation</strong>
<ul>
<li>ROAST protocol for distributed signing</li>
<li>Threshold signature scheme (t-of-n)</li>
<li>Malicious signer detection and removal</li>
<li>Binding factor verification for signature shares</li>
<li>Dynamic participant management</li>
</ul>
</li>
</ul>
<h3 id="3-network-security"><a class="header" href="#3-network-security">3. Network Security</a></h3>
<ul>
<li>
<p>üåê <strong>Peer Validation</strong></p>
<ul>
<li>Authenticated peer discovery</li>
<li>Message integrity verification</li>
<li>Rate limiting and DoS protection</li>
<li>Network topology validation</li>
</ul>
</li>
<li>
<p>üîÑ <strong>State Synchronization</strong></p>
<ul>
<li>Consensus-driven state updates</li>
<li>Rollback capability for invalid states</li>
<li>Cross-validator state verification</li>
<li>Real-time conflict resolution</li>
</ul>
</li>
</ul>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<ul>
<li>üìà <strong>Horizontal Scaling</strong>: Add more validators for increased throughput</li>
<li>üîÑ <strong>Parallel Processing</strong>: Multiple transactions processed simultaneously</li>
<li>üíæ <strong>Efficient Storage</strong>: Optimized data structures for fast access</li>
<li>üåê <strong>Network Optimization</strong>: Efficient peer-to-peer communication</li>
</ul>
<h3 id="throughput"><a class="header" href="#throughput">Throughput</a></h3>
<ul>
<li>‚ö° <strong>High TPS</strong>: Optimized for high transaction throughput</li>
<li>üí∞ <strong>Low Latency</strong>: Fast transaction confirmation</li>
<li>üîÑ <strong>Batch Processing</strong>: Efficient handling of multiple operations</li>
<li>üìä <strong>Resource Management</strong>: Compute budget optimization</li>
</ul>
<h3 id="reliability"><a class="header" href="#reliability">Reliability</a></h3>
<ul>
<li>üõ°Ô∏è <strong>Fault Tolerance</strong>: Continues operation despite node failures</li>
<li>üîÑ <strong>Recovery</strong>: Automatic recovery from network partitions</li>
<li>üìù <strong>Audit Trail</strong>: Complete transaction history and state changes</li>
<li>üîç <strong>Monitoring</strong>: Real-time performance and health monitoring</li>
</ul>
<h2 id="development-workflow-2"><a class="header" href="#development-workflow-2">Development Workflow</a></h2>
<h3 id="local-development"><a class="header" href="#local-development">Local Development</a></h3>
<pre><code class="language-bash"># Start complete local environment
arch-cli orchestrate start --local "$(pwd)"

# Use configuration profiles for different environments
arch-cli config create-profile dev --bitcoin-node-endpoint http://127.0.0.1:18443

# Deploy and test programs
arch-cli deploy target/deploy/
</code></pre>
<h3 id="testing-and-validation"><a class="header" href="#testing-and-validation">Testing and Validation</a></h3>
<ul>
<li>üß™ <strong>Unit Testing</strong>: Individual component testing</li>
<li>üîÑ <strong>Integration Testing</strong>: End-to-end workflow validation</li>
<li>üåê <strong>Network Testing</strong>: Multi-node network simulation</li>
<li>üìä <strong>Performance Testing</strong>: Throughput and latency measurement</li>
</ul>
<h3 id="deployment"><a class="header" href="#deployment">Deployment</a></h3>
<ul>
<li>üöÄ <strong>Staged Rollouts</strong>: Gradual feature deployment</li>
<li>üîÑ <strong>Rollback Capability</strong>: Quick reversion to previous versions</li>
<li>üìä <strong>Monitoring</strong>: Real-time performance and error tracking</li>
<li>üîç <strong>Debugging</strong>: Comprehensive logging and error reporting</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-architecture"><a class="header" href="#network-architecture">Network Architecture</a></h1>
<p>Arch Network operates as a distributed system with different types of nodes working together to provide secure and efficient program execution on Bitcoin. This document details the network‚Äôs architecture and how different components interact.</p>
<h2 id="network-overview"><a class="header" href="#network-overview">Network Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph Core[&quot;Core Components&quot;]
        direction TB
        BN[Bitcoin Network]
        Boot[Bootnode]
    end

    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[MultiSig\nAggregation]
    end
    
    subgraph Validators[&quot;Validator Network&quot;]
        direction TB
        V1[Validator 1]
        V2[Validator 2]
        V3[Validator 3]
        VN[Validator N]
    end

    BN --&gt; LN[Leader Node]
    Boot --&gt; LN
    
    LN --&gt; TC
    LN --&gt; MS
    
    LN --&gt; V1
    LN --&gt; V2
    LN --&gt; V3
    LN --&gt; VN

    %% Styling
    classDef core fill:#e1f5fe,stroke:#01579b
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validators fill:#f3e5f5,stroke:#4a148c
    
    class BN,Boot core
    class TC,MS leader
    class V1,V2,V3,VN validators
</pre>
<h2 id="node-types-1"><a class="header" href="#node-types-1">Node Types</a></h2>
<h3 id="1-bootnode"><a class="header" href="#1-bootnode">1. Bootnode</a></h3>
<p>The bootnode serves as the network‚Äôs entry point, similar to DNS seeds in Bitcoin:</p>
<ul>
<li>Handles initial network discovery</li>
<li>Maintains whitelist of valid validators</li>
<li>Coordinates peer connections</li>
<li>Manages network topology</li>
</ul>
<pre class="mermaid">flowchart LR
    subgraph Bootnode[&quot;Bootnode Services&quot;]
        direction TB
        PR[Peer Registry]
        WL[Validator Whitelist]
    end

    NN[New Node]
    VN[Validator Network]

    %% Connections
    NN &lt;--&gt; PR
    PR &lt;--&gt; VN
    WL -.-&gt; PR

    %% Styling
    classDef bootnode fill:#e1f5fe,stroke:#01579b
    classDef external fill:#f5f5f5,stroke:#333
    classDef connection stroke-width:2px
    
    class PR,WL bootnode
    class NN,VN external
</pre>
<p>Configuration:</p>
<pre><code class="language-bash">cargo run -p bootnode -- \
    --network-mode localnet \
    --p2p-bind-port 19001 \
    --leader-peer-id "&lt;LEADER_ID&gt;" \
    --validator-whitelist "&lt;VALIDATOR_IDS&gt;"
</code></pre>
<h3 id="2-leader-node"><a class="header" href="#2-leader-node">2. Leader Node</a></h3>
<p>The leader node coordinates transaction processing and Bitcoin integration:</p>
<pre class="mermaid">flowchart TB
    %% Main Components
    BN[Bitcoin Network]
    LN[Leader Node]
    VN[Validator Network]
    PE[Program Execution]
    
    %% Leader Node Services
    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[Multi-sig\nAggregation]
    end
    
    %% Connections
    BN &lt;--&gt; LN
    LN --&gt; Leader
    TC --&gt; VN
    MS --&gt; VN
    VN --&gt; PE
    
    %% Styling
    classDef bitcoin fill:#f7931a,stroke:#c16c07,color:white
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validator fill:#f3e5f5,stroke:#4a148c
    classDef execution fill:#e8f5e9,stroke:#1b5e20
    
    class BN bitcoin
    class LN,TC,MS leader
    class VN validator
    class PE execution
</pre>
<p>Key responsibilities:</p>
<ul>
<li>Transaction coordination</li>
<li>Multi-signature aggregation</li>
<li>Bitcoin transaction submission</li>
<li>Network state management</li>
</ul>
<h3 id="3-validator-nodes"><a class="header" href="#3-validator-nodes">3. Validator Nodes</a></h3>
<p>Validator nodes form the core of the network‚Äôs computation and validation:</p>
<pre class="mermaid">flowchart TB
    subgraph ValidatorNode[&quot;Validator Node&quot;]
        direction TB
        
        subgraph Execution[&quot;Execution Layer&quot;]
            direction LR
            VM[&quot;Arch VM\nExecution&quot;]
            SV[&quot;State\nValidation&quot;]
        end
        
        NP[&quot;Network Protocol&quot;]
        P2P[&quot;P2P Network&quot;]
        
        %% Connections within validator
        VM --&gt; NP
        SV --&gt; NP
        NP --&gt; P2P
    end
    
    %% Styling
    classDef validator fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef execution fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
    classDef network fill:#e3f2fd,stroke:#0d47a1,stroke-width:2px
    
    class ValidatorNode validator
    class VM,SV execution
    class NP,P2P network
</pre>
<p>Types:</p>
<ol>
<li>
<p><strong>Full Validator</strong></p>
<ul>
<li>Participates in consensus</li>
<li>Executes programs</li>
<li>Maintains full state</li>
</ul>
</li>
<li>
<p><strong>Lightweight Validator</strong></p>
<ul>
<li>Local development use</li>
<li>Single-node operation</li>
<li>Simulated environment</li>
</ul>
</li>
</ol>
<h2 id="network-communication"><a class="header" href="#network-communication">Network Communication</a></h2>
<h3 id="p2p-protocol"><a class="header" href="#p2p-protocol">P2P Protocol</a></h3>
<p>The network uses libp2p for peer-to-peer communication:</p>
<pre><code class="language-rust ignore">pub const ENABLED_PROTOCOLS: [&amp;str; 2] = [
    ArchNetworkProtocol::STREAM_PROTOCOL,
    ArchNetworkProtocol::VALIDATOR_PROTOCOL,
];

// Protocol versions
pub const PROTOCOL_VERSION: &amp;str = "/arch/1.0.0";
pub const VALIDATOR_VERSION: &amp;str = "/arch/validator/1.0.0";</code></pre>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<ol>
<li>
<p><strong>Network Messages</strong></p>
<pre><code class="language-rust ignore">pub enum NetworkMessage {
    Discovery(DiscoveryMessage),
    State(StateMessage),
    Transaction(TransactionMessage),
}</code></pre>
</li>
<li>
<p><strong>ROAST Protocol Messages</strong></p>
<pre><code class="language-rust ignore">pub enum RoastMessage {
    KeyGeneration(KeyGenMessage),
    Signing(SigningMessage),
    Aggregation(AggregationMessage),
}</code></pre>
</li>
</ol>
<h2 id="network-modes"><a class="header" href="#network-modes">Network Modes</a></h2>
<h3 id="1-devnet"><a class="header" href="#1-devnet">1. Devnet</a></h3>
<ul>
<li>Local development environment</li>
<li>Single validator setup</li>
<li>Simulated Bitcoin interactions</li>
<li>Fast block confirmation</li>
</ul>
<h3 id="2-testnet"><a class="header" href="#2-testnet">2. Testnet</a></h3>
<ul>
<li>Test environment with multiple validators</li>
<li>Bitcoin testnet integration</li>
<li>Real network conditions</li>
<li>Test transaction processing</li>
</ul>
<h3 id="3-mainnet"><a class="header" href="#3-mainnet">3. Mainnet</a></h3>
<ul>
<li>Production network</li>
<li>Full security model</li>
<li>Bitcoin mainnet integration</li>
<li>Live transaction processing</li>
</ul>
<h2 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h2>
<h3 id="1-validator-selection"><a class="header" href="#1-validator-selection">1. Validator Selection</a></h3>
<pre><code class="language-rust ignore">pub struct ValidatorInfo {
    pub peer_id: PeerId,
    pub pubkey: Pubkey,
    pub stake: u64,
}

pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32,
}</code></pre>
<h3 id="2-transaction-security-1"><a class="header" href="#2-transaction-security-1">2. Transaction Security</a></h3>
<ul>
<li>Multi-signature validation using ROAST protocol</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Double-spend prevention</li>
</ul>
<h3 id="3-state-protection"><a class="header" href="#3-state-protection">3. State Protection</a></h3>
<pre><code class="language-rust ignore">pub struct StateUpdate {
    pub block_height: u64,
    pub state_root: Hash,
    pub bitcoin_height: u64,
    pub signatures: Vec&lt;Signature&gt;,
}</code></pre>
<h2 id="monitoring-and-telemetry"><a class="header" href="#monitoring-and-telemetry">Monitoring and Telemetry</a></h2>
<h3 id="1-node-metrics"><a class="header" href="#1-node-metrics">1. Node Metrics</a></h3>
<pre><code class="language-rust ignore">pub struct NodeMetrics {
    pub peer_id: PeerId,
    pub network_mode: ArchNetworkMode,
    pub bitcoin_block_height: u64,
    pub arch_block_height: u64,
    pub peers_connected: u32,
    pub transactions_processed: u64,
    pub program_count: u32,
}</code></pre>
<h3 id="2-network-health"><a class="header" href="#2-network-health">2. Network Health</a></h3>
<pre><code class="language-rust ignore">pub struct NetworkHealth {
    pub validator_count: u32,
    pub active_validators: u32,
    pub network_tps: f64,
    pub average_block_time: Duration,
    pub fork_count: u32,
}</code></pre>
<h3 id="3-monitoring-endpoints"><a class="header" href="#3-monitoring-endpoints">3. Monitoring Endpoints</a></h3>
<ul>
<li><code>/metrics</code> - Prometheus metrics</li>
<li><code>/health</code> - Node health check</li>
<li><code>/peers</code> - Connected peers</li>
<li><code>/status</code> - Network status</li>
</ul>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="1-node-operation"><a class="header" href="#1-node-operation">1. Node Operation</a></h3>
<ul>
<li>Secure key management</li>
<li>Regular state verification</li>
<li>Proper shutdown procedures</li>
<li>Log management</li>
</ul>
<h3 id="2-network-participation"><a class="header" href="#2-network-participation">2. Network Participation</a></h3>
<ul>
<li>Maintain node availability</li>
<li>Monitor Bitcoin integration</li>
<li>Handle network upgrades</li>
<li>Backup critical data</li>
</ul>
<h3 id="3-development-setup"><a class="header" href="#3-development-setup">3. Development Setup</a></h3>
<ul>
<li>Use lightweight validator for testing</li>
<li>Monitor resource usage</li>
<li>Handle network modes properly</li>
<li>Implement proper error handling</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-integration-2"><a class="header" href="#bitcoin-integration-2">Bitcoin Integration</a></h1>
<p>Arch Network provides direct integration with Bitcoin, enabling programs to interact with Bitcoin‚Äôs UTXO model while maintaining Bitcoin‚Äôs security guarantees. This document details how Arch Network integrates with Bitcoin.</p>
<h2 id="architecture-overview-2"><a class="header" href="#architecture-overview-2">Architecture Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph BN[Bitcoin Network]
        BNode[Bitcoin Node]
    end

    subgraph TC[Titan Client]
        TCNode[Titan Client]
    end

    subgraph AN[Arch Network]
        LN[Leader Node\nBitcoin Integration]
        subgraph VN[Validator Network]
            P1[Program 1]
            PN[Program N]
        end
    end

    BNode &lt;--&gt; TCNode
    TCNode &lt;--&gt; LN
    LN &lt;--&gt; VN
    P1 --- PN
</pre>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<h3 id="1-utxo-management"><a class="header" href="#1-utxo-management">1. UTXO Management</a></h3>
<p>Arch Network manages Bitcoin UTXOs through a specialized system:</p>
<pre class="mermaid">flowchart LR
    subgraph UTXO[Bitcoin UTXO]
        TxID[TransactionID]
        OutIdx[OutputIndex]
    end

    subgraph Account[Arch Account]
        Meta[UTXOMeta]
        State[ProgramState]
    end

    TxID --&gt; Meta
    OutIdx --&gt; Meta
    Meta --- State
</pre>
<pre><code class="language-rust ignore">// UTXO Metadata Structure
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Transaction ID
    pub vout: u32,       // Output index
    pub amount: u64,     // Amount in satoshis
    pub script_pubkey: Vec&lt;u8&gt;, // Output script
    pub confirmation_height: Option&lt;u32&gt;, // Block height of confirmation
}

// UTXO Account State
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: Vec&lt;u8&gt;,
    pub is_frozen: bool,
}</code></pre>
<p>Key operations:</p>
<pre><code class="language-rust ignore">// UTXO Operations
pub trait UtxoOperations {
    fn create_utxo(meta: UtxoMeta, owner: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn spend_utxo(utxo: &amp;UtxoMeta, signature: &amp;Signature) -&gt; Result&lt;()&gt;;
    fn freeze_utxo(utxo: &amp;UtxoMeta, authority: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn delegate_utxo(utxo: &amp;UtxoMeta, delegate: &amp;Pubkey) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="2-bitcoin-rpc-integration"><a class="header" href="#2-bitcoin-rpc-integration">2. Bitcoin RPC Integration</a></h3>
<pre class="mermaid">flowchart LR
    AP[Arch\nProgram]
    RPC[Bitcoin RPC\nInterface]
    BN[Bitcoin\nNode]
    Config[Configuration]
    Network[Bitcoin\nNetwork]

    AP --&gt; RPC
    RPC --&gt; BN
    AP --&gt; Config
    Config --&gt; RPC
    BN --&gt; Network

    style AP fill:#f9f9f9,stroke:#333,stroke-width:2px
    style RPC fill:#f9f9f9,stroke:#333,stroke-width:2px
    style BN fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Config fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Network fill:#f9f9f9,stroke:#333,stroke-width:2px
</pre>
<p>Programs can interact with Bitcoin through RPC calls:</p>
<pre><code class="language-rust ignore">// Bitcoin RPC Configuration
pub struct BitcoinRpcConfig {
    pub endpoint: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub wallet: Option&lt;String&gt;,
    pub network: BitcoinNetwork,
    pub timeout: Duration,
}

// RPC Interface
pub trait BitcoinRpc {
    fn get_block_count(&amp;self) -&gt; Result&lt;u64&gt;;
    fn get_block_hash(&amp;self, height: u64) -&gt; Result&lt;BlockHash&gt;;
    fn get_transaction(&amp;self, txid: &amp;Txid) -&gt; Result&lt;Transaction&gt;;
    fn send_raw_transaction(&amp;self, tx: &amp;[u8]) -&gt; Result&lt;Txid&gt;;
    fn verify_utxo(&amp;self, utxo: &amp;UtxoMeta) -&gt; Result&lt;bool&gt;;
}</code></pre>
<h2 id="transaction-flow-1"><a class="header" href="#transaction-flow-1">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Program
    participant Leader
    participant Validator
    participant Bitcoin

    Program-&gt;&gt;Leader: Create UTXO
    Leader-&gt;&gt;Validator: Validate
    Validator-&gt;&gt;Leader: Sign
    Leader-&gt;&gt;Bitcoin: Submit TX
    Bitcoin--&gt;&gt;Program: Confirmation
</pre>
<h3 id="1-transaction-creation"><a class="header" href="#1-transaction-creation">1. Transaction Creation</a></h3>
<pre><code class="language-rust ignore">// Create new UTXO transaction
pub struct UtxoCreation {
    pub amount: u64,
    pub owner: Pubkey,
    pub metadata: Option&lt;Vec&lt;u8&gt;&gt;,
}

impl UtxoCreation {
    pub fn new(amount: u64, owner: Pubkey) -&gt; Self {
        Self {
            amount,
            owner,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: Vec&lt;u8&gt;) -&gt; Self {
        self.metadata = Some(metadata);
        self
    }
}</code></pre>
<h3 id="2-transaction-validation"><a class="header" href="#2-transaction-validation">2. Transaction Validation</a></h3>
<pre><code class="language-rust ignore">// Validation rules
pub trait TransactionValidation {
    fn validate_inputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_outputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_signatures(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_script(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="3-state-management"><a class="header" href="#3-state-management">3. State Management</a></h3>
<pre><code class="language-rust ignore">// State transition
pub struct StateTransition {
    pub previous_state: Hash,
    pub next_state: Hash,
    pub utxos_created: Vec&lt;UtxoMeta&gt;,
    pub utxos_spent: Vec&lt;UtxoMeta&gt;,
    pub bitcoin_height: u64,
}</code></pre>
<h2 id="security-model-2"><a class="header" href="#security-model-2">Security Model</a></h2>
<h3 id="1-utxo-security-1"><a class="header" href="#1-utxo-security-1">1. UTXO Security</a></h3>
<ul>
<li>Ownership verification through public key cryptography</li>
<li>Double-spend prevention through UTXO consumption</li>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature requirements</li>
</ul>
<h3 id="2-transaction-security-2"><a class="header" href="#2-transaction-security-2">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">// Transaction security parameters
pub struct SecurityParams {
    pub min_confirmations: u32,
    pub signature_threshold: u32,
    pub timelock_blocks: u32,
    pub max_witness_size: usize,
}</code></pre>
<h3 id="3-network-security-1"><a class="header" href="#3-network-security-1">3. Network Security</a></h3>
<ul>
<li>Multi-signature validation</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Cross-validator consistency</li>
</ul>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="1-bitcoin-errors"><a class="header" href="#1-bitcoin-errors">1. Bitcoin Errors</a></h3>
<pre><code class="language-rust ignore">pub enum BitcoinError {
    ConnectionFailed(String),
    InvalidTransaction(String),
    InsufficientFunds(u64),
    InvalidUtxo(UtxoMeta),
    RpcError(String),
}</code></pre>
<h3 id="2-utxo-errors"><a class="header" href="#2-utxo-errors">2. UTXO Errors</a></h3>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound(UtxoMeta),
    AlreadySpent(UtxoMeta),
    InvalidOwner(Pubkey),
    InvalidSignature(Signature),
    InvalidState(Hash),
}</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-utxo-management-1"><a class="header" href="#1-utxo-management-1">1. UTXO Management</a></h3>
<ul>
<li>Always verify UTXO ownership</li>
<li>Wait for sufficient confirmations</li>
<li>Handle reorganizations gracefully</li>
<li>Implement proper error handling</li>
</ul>
<h3 id="2-transaction-processing"><a class="header" href="#2-transaction-processing">2. Transaction Processing</a></h3>
<ul>
<li>Validate all inputs and outputs</li>
<li>Check signature thresholds</li>
<li>Maintain proper state transitions</li>
<li>Monitor Bitcoin network status</li>
</ul>
<h3 id="3-security-considerations"><a class="header" href="#3-security-considerations">3. Security Considerations</a></h3>
<ul>
<li>Protect private keys</li>
<li>Validate all signatures</li>
<li>Monitor for double-spend attempts</li>
<li>Handle network partitions</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="roast-and-frost-consensus"><a class="header" href="#roast-and-frost-consensus">ROAST and FROST Consensus</a></h1>
<p>This section explores Arch‚Äôs consensus mechanism, which combines ROAST (Robust Asynchronous Schnorr Threshold Signatures) and FROST (Flexible Round-Optimized Schnorr Threshold Signatures) to create a secure, efficient, and highly scalable approach to distributed consensus that‚Äôs perfectly suited for Bitcoin-based smart contracts.</p>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p>The consensus mechanism implementation has made significant progress, particularly in the core cryptographic components:</p>
<ol>
<li>
<p><strong>Implemented Components</strong></p>
<ul>
<li>Complete Distributed Key Generation (DKG) protocol using FROST-secp256k1</li>
<li>Two-round DKG process with package handling</li>
<li>Network message protocol for DKG coordination</li>
<li>State management and status tracking</li>
<li>Integration with network layer</li>
<li>Error handling and recovery mechanisms</li>
</ul>
</li>
<li>
<p><strong>In Progress</strong></p>
<ul>
<li>Additional ROAST protocol components</li>
<li>Advanced state management features</li>
<li>Performance optimizations</li>
<li>Extended monitoring and telemetry</li>
</ul>
</li>
</ol>
<p>The subsequent sections describe both the implemented features and the complete protocol design.</p>
<h2 id="core-implementation-details"><a class="header" href="#core-implementation-details">Core Implementation Details</a></h2>
<h3 id="distributed-key-generation-dkg-1"><a class="header" href="#distributed-key-generation-dkg-1">Distributed Key Generation (DKG)</a></h3>
<pre><code class="language-rust ignore">// Core DKG message types for network coordination
pub enum DKGMessage {
    StartDKG { message: String },
    Round1Package { package: round1::Package },
    Round2Package { package: round2::Package },
    DKGStatus(DKGStatusMessage),
}

// DKG state management
pub enum DKGStatus {
    Pending(String),
    Ongoing(String),
    Failed(String, String),
    Finished(String),
    NetworkCompleted(String),
}</code></pre>
<p>The DKG implementation provides:</p>
<ul>
<li>Two-round key generation protocol</li>
<li>Secure package exchange between validators</li>
<li>State tracking and synchronization</li>
<li>Failure recovery and error handling</li>
</ul>
<h2 id="distributed-key-generation-dkg-deep-dive"><a class="header" href="#distributed-key-generation-dkg-deep-dive">Distributed Key Generation (DKG) Deep Dive</a></h2>
<h3 id="what-is-dkg"><a class="header" href="#what-is-dkg">What is DKG?</a></h3>
<p>Distributed Key Generation (DKG) is the cryptographic process that allows a group of validators to collectively generate a master key pair without any single validator knowing the complete private key. This is the foundation of Arch‚Äôs threshold signature scheme.</p>
<h3 id="why-dkg-is-critical"><a class="header" href="#why-dkg-is-critical">Why DKG is Critical</a></h3>
<p>In Arch‚Äôs consensus model:</p>
<ul>
<li><strong>No single point of failure</strong>: No validator can sign alone</li>
<li><strong>Threshold security</strong>: Only a subset of validators (e.g., 2-of-3) need to cooperate</li>
<li><strong>Distributed trust</strong>: The network‚Äôs security doesn‚Äôt depend on any single party</li>
<li><strong>Bitcoin compatibility</strong>: Uses the same secp256k1 curve as Bitcoin</li>
</ul>
<h3 id="the-dkg-process-flow"><a class="header" href="#the-dkg-process-flow">The DKG Process Flow</a></h3>
<h4 id="phase-1-network-initialization"><a class="header" href="#phase-1-network-initialization">Phase 1: Network Initialization</a></h4>
<ol>
<li><strong>Validator Startup</strong>: Each validator starts in <code>WaitingForDkg</code> state</li>
<li><strong>Peer Discovery</strong>: Validators connect to each other and the bootnode</li>
<li><strong>Whitelist Verification</strong>: All validators in the whitelist must be online</li>
<li><strong>Leader Initiation</strong>: The designated leader triggers DKG when all peers are ready</li>
</ol>
<h4 id="phase-2-round-1---commitment-generation"><a class="header" href="#phase-2-round-1---commitment-generation">Phase 2: Round 1 - Commitment Generation</a></h4>
<pre class="mermaid">sequenceDiagram
    participant L as Leader
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    
    L-&gt;&gt;V1: StartDKG message
    L-&gt;&gt;V2: StartDKG message
    L-&gt;&gt;V3: StartDKG message
    
    V1-&gt;&gt;L: Round1Package (commitments)
    V2-&gt;&gt;L: Round1Package (commitments)
    V3-&gt;&gt;L: Round1Package (commitments)
    
    L-&gt;&gt;V1: Broadcast all Round1Packages
    L-&gt;&gt;V2: Broadcast all Round1Packages
    L-&gt;&gt;V3: Broadcast all Round1Packages
</pre>
<p>Each validator:</p>
<ul>
<li>Generates a random secret share</li>
<li>Creates polynomial commitments</li>
<li>Broadcasts Round1 packages to all peers</li>
<li>Waits for Round1 packages from all other validators</li>
</ul>
<h4 id="phase-3-round-2---key-generation"><a class="header" href="#phase-3-round-2---key-generation">Phase 3: Round 2 - Key Generation</a></h4>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    
    V1-&gt;&gt;V2: Round2Package (signed shares)
    V1-&gt;&gt;V3: Round2Package (signed shares)
    V2-&gt;&gt;V1: Round2Package (signed shares)
    V2-&gt;&gt;V3: Round2Package (signed shares)
    V3-&gt;&gt;V1: Round2Package (signed shares)
    V3-&gt;&gt;V2: Round2Package (signed shares)
</pre>
<p>Each validator:</p>
<ul>
<li>Receives Round1 packages from all peers</li>
<li>Computes their contribution to the final key</li>
<li>Generates Round2 packages with signed shares</li>
<li>Exchanges Round2 packages with all peers</li>
</ul>
<h4 id="phase-4-finalization"><a class="header" href="#phase-4-finalization">Phase 4: Finalization</a></h4>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    
    V1-&gt;&gt;V1: Compute final key packages
    V2-&gt;&gt;V2: Compute final key packages
    V3-&gt;&gt;V3: Compute final key packages
    
    V1-&gt;&gt;V1: Save pubkey_package.json
    V2-&gt;&gt;V2: Save pubkey_package.json
    V3-&gt;&gt;V3: Save pubkey_package.json
</pre>
<p>Each validator:</p>
<ul>
<li>Combines all Round2 packages</li>
<li>Computes the final <code>PublicKeyPackage</code></li>
<li>Saves the <code>pubkey_package.json</code> file</li>
<li>Transitions to <code>Ready</code> state</li>
</ul>
<h3 id="the-pubkey_packagejson-file"><a class="header" href="#the-pubkey_packagejson-file">The <code>pubkey_package.json</code> File</a></h3>
<h4 id="location-and-structure"><a class="header" href="#location-and-structure">Location and Structure</a></h4>
<p>The <code>pubkey_package.json</code> file is automatically created in:</p>
<pre><code class="language-text">{data_dir}/{network_mode}/pubkey_package.json
</code></pre>
<p>For example: <code>./.arch_data/devnet/pubkey_package.json</code></p>
<h4 id="file-format"><a class="header" href="#file-format">File Format</a></h4>
<pre><code class="language-json">{
  "verifying_key": {
    "element": "02a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7"
  },
  "verifying_shares": {
    "0000000000000000000000000000000000000000000000000000000000000001": {
      "element": "02b8d9aa7c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0"
    },
    "0000000000000000000000000000000000000000000000000000000000000002": {
      "element": "03c9eabb8d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1"
    }
  }
}
</code></pre>
<h4 id="what-each-field-represents"><a class="header" href="#what-each-field-represents">What Each Field Represents</a></h4>
<ul>
<li><strong><code>verifying_key</code></strong>: The master public key for the entire validator set</li>
<li><strong><code>verifying_shares</code></strong>: Individual public keys for each validator‚Äôs share</li>
<li><strong><code>element</code> fields</strong>: secp256k1 curve points in compressed format</li>
</ul>
<h3 id="key-security-properties"><a class="header" href="#key-security-properties">Key Security Properties</a></h3>
<h4 id="threshold-signing"><a class="header" href="#threshold-signing">Threshold Signing</a></h4>
<ul>
<li><strong>2-of-3 example</strong>: With 3 validators, only 2 need to cooperate to sign</li>
<li><strong>No single point of failure</strong>: No validator can sign alone</li>
<li><strong>Flexible thresholds</strong>: Can be configured for different security levels</li>
</ul>
<h4 id="cryptographic-guarantees"><a class="header" href="#cryptographic-guarantees">Cryptographic Guarantees</a></h4>
<ul>
<li><strong>Information theoretic security</strong>: Based on proven cryptographic principles</li>
<li><strong>Forward secrecy</strong>: Compromised shares don‚Äôt reveal past signatures</li>
<li><strong>Verifiable</strong>: All participants can verify the correctness of the process</li>
</ul>
<h3 id="dkg-failure-scenarios"><a class="header" href="#dkg-failure-scenarios">DKG Failure Scenarios</a></h3>
<h4 id="network-partition"><a class="header" href="#network-partition">Network Partition</a></h4>
<ul>
<li>If validators can‚Äôt communicate, DKG fails</li>
<li>Network must be restored before consensus can proceed</li>
<li>Validators remain in <code>WaitingForDkg</code> state</li>
</ul>
<h4 id="insufficient-participation"><a class="header" href="#insufficient-participation">Insufficient Participation</a></h4>
<ul>
<li>If not enough validators are online, DKG cannot complete</li>
<li>Minimum threshold must be met (e.g., 2 out of 3 validators)</li>
<li>System waits for more validators to come online</li>
</ul>
<h4 id="malicious-behavior"><a class="header" href="#malicious-behavior">Malicious Behavior</a></h4>
<ul>
<li>Byzantine validators can cause DKG to fail</li>
<li>System detects inconsistencies and aborts the process</li>
<li>Failed DKG attempts are logged and can be investigated</li>
</ul>
<h3 id="resharing-and-key-rotation"><a class="header" href="#resharing-and-key-rotation">Resharing and Key Rotation</a></h3>
<h4 id="when-resharing-occurs"><a class="header" href="#when-resharing-occurs">When Resharing Occurs</a></h4>
<ul>
<li><strong>Validator set changes</strong>: Adding or removing validators</li>
<li><strong>Security concerns</strong>: Suspected compromise of existing shares</li>
<li><strong>Regular rotation</strong>: Periodic key updates for security</li>
</ul>
<h4 id="resharing-process"><a class="header" href="#resharing-process">Resharing Process</a></h4>
<ol>
<li><strong>Initiation</strong>: Leader initiates resharing with new parameters</li>
<li><strong>Share Distribution</strong>: Existing validators distribute new shares</li>
<li><strong>Verification</strong>: New shares are verified against commitments</li>
<li><strong>Update</strong>: New <code>pubkey_package.json</code> is generated and distributed</li>
</ol>
<h3 id="monitoring-and-debugging"><a class="header" href="#monitoring-and-debugging">Monitoring and Debugging</a></h3>
<h4 id="dkg-status-tracking"><a class="header" href="#dkg-status-tracking">DKG Status Tracking</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DKGStatus {
    Pending(String),           // Waiting to start
    Ongoing(String),           // In progress
    Failed(String, String),    // Failed with reason
    Finished(String),          // Completed locally
    NetworkCompleted(String),  // Completed globally
}
<span class="boring">}</span></code></pre></pre>
<h4 id="common-issues-and-solutions"><a class="header" href="#common-issues-and-solutions">Common Issues and Solutions</a></h4>
<ul>
<li><strong>‚ÄúWaiting for DKG‚Äù</strong>: Ensure all validators are online and connected</li>
<li><strong>‚ÄúDKG failed‚Äù</strong>: Check network connectivity and validator logs</li>
<li><strong>Missing pubkey_package.json</strong>: DKG hasn‚Äôt completed successfully</li>
</ul>
<h3 id="integration-with-consensus"><a class="header" href="#integration-with-consensus">Integration with Consensus</a></h3>
<h4 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h4>
<pre><code class="language-text">WaitingForDkg -&gt; Ready (after successful DKG)
</code></pre>
<h4 id="block-production"><a class="header" href="#block-production">Block Production</a></h4>
<ul>
<li>DKG must complete before any blocks can be produced</li>
<li>The <code>verifying_key</code> is used to verify threshold signatures</li>
<li>All validators must have identical <code>pubkey_package.json</code> files</li>
</ul>
<h4 id="epoch-management"><a class="header" href="#epoch-management">Epoch Management</a></h4>
<ul>
<li>DKG results are stored in the blockchain state</li>
<li>Epoch transitions can trigger resharing operations</li>
<li>Historical key packages are preserved for verification</li>
</ul>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>Arch‚Äôs consensus mechanism combines ROAST and FROST to provide a robust, Bitcoin-native consensus solution. Validators participate in a threshold signature scheme where blocks are produced by designated leaders and finalized through collective signing. The system maintains both safety and liveness through careful economic incentives and cryptographic guarantees, while ensuring complete compatibility with Bitcoin‚Äôs Schnorr signature scheme.</p>
<h2 id="block-production-process"><a class="header" href="#block-production-process">Block Production Process</a></h2>
<h3 id="1-leader-selection"><a class="header" href="#1-leader-selection">1. Leader Selection</a></h3>
<pre class="mermaid">graph TD
    A[Epoch Start] --&gt; B[Calculate Leader Schedule]
    B --&gt; C[Distribute Schedule to Validators]
    C --&gt; D[Leaders Prepare for Slots]
    D --&gt; E[Next Leader Takes Turn]
    E --&gt; F[Block Production]
    F --&gt; G[Block Distribution]
    G --&gt; E
</pre>
<p>The block production process begins with leader selection:</p>
<ul>
<li>Each epoch (fixed time period) has a predetermined leader schedule</li>
<li>Leaders are selected based on their stake weight</li>
<li>The schedule is deterministic and known to all validators</li>
<li>Multiple backup leaders are selected for fault tolerance</li>
</ul>
<h3 id="2-transaction-collection-and-verification"><a class="header" href="#2-transaction-collection-and-verification">2. Transaction Collection and Verification</a></h3>
<pre class="mermaid">graph LR
    A[Transaction Pool] --&gt; B[Leader]
    C[Mempool] --&gt; B
    B --&gt; D[Transaction Verification]
    D --&gt; E[Block Formation]
    E --&gt; F[Block Proposal]
</pre>
<p>When a validator becomes the leader:</p>
<ol>
<li>Collects pending transactions from the mempool</li>
<li>Verifies transaction signatures and validity</li>
<li>Orders transactions based on priority and fees</li>
<li>Prepares them for inclusion in the next block</li>
</ol>
<h3 id="3-block-formation"><a class="header" href="#3-block-formation">3. Block Formation</a></h3>
<pre class="mermaid">sequenceDiagram
    participant L as Leader
    participant B as Block
    participant V as Validators
    L-&gt;&gt;B: Create Block Header
    L-&gt;&gt;B: Add Transactions
    L-&gt;&gt;B: Add State Updates
    L-&gt;&gt;B: Sign Block
    L-&gt;&gt;V: Broadcast Block
</pre>
<p>The block structure includes:</p>
<ul>
<li>Previous block reference</li>
<li>Timestamp</li>
<li>Transaction merkle root</li>
<li>UTXO state updates</li>
<li>Leader‚Äôs signature</li>
</ul>
<h2 id="consensus-process"><a class="header" href="#consensus-process">Consensus Process</a></h2>
<h3 id="1-block-validation"><a class="header" href="#1-block-validation">1. Block Validation</a></h3>
<pre class="mermaid">graph TD
    A[Receive Block] --&gt; B[Verify Leader]
    B --&gt; C[Verify Signatures]
    C --&gt; D[Execute Transactions]
    D --&gt; E[Verify UTXO States]
    E --&gt; F[Vote Decision]
</pre>
<p>When validators receive a new block:</p>
<ol>
<li>Verify the block producer is the designated leader</li>
<li>Validate all transaction signatures</li>
<li>Execute transactions and verify UTXO states</li>
<li>Check for any consensus rule violations</li>
</ol>
<h3 id="2-utxo-based-state-management"><a class="header" href="#2-utxo-based-state-management">2. UTXO-Based State Management</a></h3>
<pre class="mermaid">graph TD
    A[Transaction] --&gt; B[UTXO Validation]
    B --&gt; C[State Update]
    C --&gt; D[Bitcoin Transaction]
    D --&gt; E[Validator Signatures]

    B --&gt; F[Ownership Verification]
    B --&gt; G[Double-spend Check]
    B --&gt; H[Confirmation Check]

    C --&gt; I[Account Updates]
    C --&gt; J[Program State]
    C --&gt; K[UTXO Set Changes]
</pre>
<p>Arch‚Äôs unique approach to state management leverages Bitcoin‚Äôs UTXO model while extending it for smart contract functionality:</p>
<h4 id="utxo-state-tracking"><a class="header" href="#utxo-state-tracking">UTXO State Tracking</a></h4>
<pre><code class="language-rust ignore">pub struct UtxoState {
    pub meta: UtxoMeta,          // UTXO identification
    pub status: UtxoStatus,      // Current UTXO status
    pub owner: Pubkey,           // UTXO owner
    pub created_at: i64,         // Creation timestamp
    pub spent_at: Option&lt;i64&gt;,   // Spend timestamp if spent
}

pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h4 id="state-transition-process"><a class="header" href="#state-transition-process">State Transition Process</a></h4>
<ol>
<li>
<p><strong>UTXO Validation</strong></p>
<ul>
<li>Verify UTXO existence on Bitcoin</li>
<li>Check confirmation requirements (typically 6+)</li>
<li>Validate ownership and spending conditions</li>
<li>Prevent double-spending attempts</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Atomic account data modifications</li>
<li>Program state transitions</li>
<li>UTXO set updates</li>
<li>Cross-validator state consistency</li>
</ul>
</li>
<li>
<p><strong>Bitcoin Integration</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature aggregation</li>
<li>Transaction finality through Bitcoin confirmations</li>
<li>Reorg handling and state rollbacks</li>
</ul>
</li>
</ol>
<h4 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h4>
<ul>
<li>
<p><strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for ownership proofs</li>
<li>Threshold signature requirements</li>
</ul>
</li>
<li>
<p><strong>Double-spend Prevention</strong></p>
<ul>
<li>UTXO consumption tracking</li>
<li>Cross-validator consistency checks</li>
<li>Bitcoin-based finality guarantees</li>
</ul>
</li>
<li>
<p><strong>State Protection</strong></p>
<ul>
<li>Atomic state transitions</li>
<li>Rollback capability for reorgs</li>
<li>State root commitments</li>
<li>Multi-stage verification</li>
</ul>
</li>
</ul>
<h4 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h4>
<ul>
<li>UTXO caching for frequent access</li>
<li>Batch processing of state updates</li>
<li>Parallel transaction validation</li>
<li>Efficient UTXO lookup mechanisms</li>
</ul>
<p>This UTXO-based approach provides several advantages:</p>
<ol>
<li>Direct compatibility with Bitcoin‚Äôs security model</li>
<li>Natural support for atomic operations</li>
<li>Clear ownership and state transition rules</li>
<li>Built-in protection against double-spending</li>
<li>Simplified state verification and rollback</li>
</ol>
<h3 id="3-frost-signing-process"><a class="header" href="#3-frost-signing-process">3. FROST Signing Process</a></h3>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant C as Consensus
    V1-&gt;&gt;C: Share 1
    V2-&gt;&gt;C: Share 2
    V3-&gt;&gt;C: Share 3
    C-&gt;&gt;C: Aggregate Shares
    C-&gt;&gt;All: Final Signature
</pre>
<p>The FROST signing process involves:</p>
<ol>
<li>Each validator generates their partial signature</li>
<li>Signatures are shared among the threshold group</li>
<li>Partial signatures are aggregated into a final signature</li>
<li>The aggregated signature is verified against the group public key</li>
</ol>
<h3 id="4-roast-enhancement-layer"><a class="header" href="#4-roast-enhancement-layer">4. ROAST Enhancement Layer</a></h3>
<pre class="mermaid">graph TD
    A[Block Proposal] --&gt; B[FROST Signing]
    B --&gt; C[ROAST Protocol]
    C --&gt; D[Asynchronous Consensus]
    D --&gt; E[Block Finalization]
    E --&gt; F[Chain Extension]
</pre>
<p>ROAST transforms FROST into a production-ready consensus mechanism by adding several crucial enhancements:</p>
<h4 id="asynchronous-operation-guarantees"><a class="header" href="#asynchronous-operation-guarantees">Asynchronous Operation Guarantees</a></h4>
<pre class="mermaid">sequenceDiagram
    participant V1 as Validator 1
    participant V2 as Validator 2
    participant V3 as Validator 3
    participant N as Network

    Note over V1,N: Validator 1 experiences delay
    V2-&gt;&gt;N: Sign Share (t=1)
    V3-&gt;&gt;N: Sign Share (t=1)
    V1-&gt;&gt;N: Sign Share (t=3)
    Note over N: Protocol continues despite delay
    N-&gt;&gt;V1: Aggregate &amp; Finalize
    N-&gt;&gt;V2: Aggregate &amp; Finalize
    N-&gt;&gt;V3: Aggregate &amp; Finalize
</pre>
<p>Unlike traditional consensus mechanisms that require strict synchronization:</p>
<ul>
<li>Validators can participate in signing rounds without tight timing constraints</li>
<li>The protocol progresses even when some validators are temporarily delayed</li>
<li>Network partitions and varying message delivery times are handled gracefully</li>
<li>No assumptions about network synchrony are required for safety</li>
</ul>
<h4 id="byzantine-fault-tolerance"><a class="header" href="#byzantine-fault-tolerance">Byzantine Fault Tolerance</a></h4>
<pre class="mermaid">graph TD
    A[Validator Set] --&gt; B[Honest Majority]
    A --&gt; C[Byzantine Nodes]
    B --&gt; D[Valid Signatures]
    C --&gt; E[Detection System]
    E --&gt; F[Isolation]
    F --&gt; G[Protocol Progress]
</pre>
<p>ROAST maintains safety and liveness even in the presence of malicious actors:</p>
<ul>
<li>Tolerates up to f Byzantine validators where f &lt; n/3</li>
<li>Malicious behavior is detected and isolated</li>
<li>Signature shares from Byzantine validators can be identified and excluded</li>
<li>The protocol remains secure even if Byzantine validators:
<ul>
<li>Submit invalid signature shares</li>
<li>Attempt to sign conflicting blocks</li>
<li>Try to delay or prevent consensus</li>
<li>Collude with other malicious validators</li>
</ul>
</li>
</ul>
<h4 id="leader-rotation-mechanism"><a class="header" href="#leader-rotation-mechanism">Leader Rotation Mechanism</a></h4>
<pre class="mermaid">sequenceDiagram
    participant VS as Validator Set
    participant L1 as Leader 1
    participant L2 as Leader 2
    participant L3 as Leader 3

    Note over VS: Round r
    VS-&gt;&gt;L1: Select Leader
    Note over L1: Leader Timeout/Failure
    VS-&gt;&gt;L2: Backup Leader Takes Over
    Note over L2: Successful Block
    Note over VS: Round r+1
    VS-&gt;&gt;L3: New Leader Selection
</pre>
<p>ROAST implements a robust leader rotation system that:</p>
<ul>
<li>Deterministically selects leaders based on stake weight and randomness</li>
<li>Automatically rotates leaders to prevent centralization</li>
<li>Provides backup leaders in case of primary leader failure</li>
<li>Ensures fair distribution of block production opportunities</li>
<li>Maintains progress even when leaders fail or misbehave</li>
</ul>
<h4 id="liveness-guarantees"><a class="header" href="#liveness-guarantees">Liveness Guarantees</a></h4>
<pre class="mermaid">graph TD
    A[Network State] --&gt; B{Leader Active?}
    B --&gt;|Yes| C[Normal Operation]
    B --&gt;|No| D[Backup Leader]
    C --&gt; E[Progress]
    D --&gt; E
    E --&gt; F{Sufficient Signatures?}
    F --&gt;|Yes| G[Block Finalization]
    F --&gt;|No| H[Continue Collection]
    H --&gt; F
</pre>
<p>ROAST ensures the network continues to make progress through several mechanisms:</p>
<ol>
<li>
<p><strong>View Synchronization</strong></p>
<ul>
<li>Validators maintain a consistent view of network state</li>
<li>Recovery procedures for missed blocks or state updates</li>
<li>Automatic resynchronization after network partitions</li>
</ul>
</li>
<li>
<p><strong>Failure Recovery</strong></p>
<ul>
<li>Automatic detection of failed validators</li>
<li>Seamless transition to backup leaders</li>
<li>Recovery from temporary network failures</li>
<li>Rejoining procedures for validators that fall behind</li>
</ul>
</li>
<li>
<p><strong>Progress Conditions</strong></p>
<ul>
<li>Guaranteed block finalization when sufficient honest validators participate</li>
<li>No single validator can prevent progress</li>
<li>Continued operation during validator churn</li>
<li>Resilient to temporary network issues</li>
</ul>
</li>
<li>
<p><strong>Deadlock Prevention</strong></p>
<ul>
<li>No waiting for specific validators</li>
<li>Timeout mechanisms for unresponsive participants</li>
<li>Alternative paths for consensus when optimal path fails</li>
<li>Dynamic adjustment of protocol parameters</li>
</ul>
</li>
</ol>
<p>These enhancements make ROAST particularly well-suited for production environments where:</p>
<ul>
<li>Network conditions are unpredictable</li>
<li>Validators may join or leave the network</li>
<li>Malicious actors may attempt to disrupt consensus</li>
<li>High availability and reliability are required</li>
</ul>
<h2 id="fork-resolution"><a class="header" href="#fork-resolution">Fork Resolution</a></h2>
<pre class="mermaid">graph TD
    A[Fork Detection] --&gt; B[Weight Calculation]
    B --&gt; C[Heaviest Chain]
    C --&gt; D[Switch Decision]
    D --&gt; E[Chain Reorganization]
</pre>
<p>When forks occur:</p>
<ol>
<li>Validators identify competing chains</li>
<li>Calculate the weight of each fork based on stake</li>
<li>Apply the heaviest-chain rule</li>
<li>Coordinate chain reorganization if needed</li>
</ol>
<h2 id="understanding-frost"><a class="header" href="#understanding-frost">Understanding FROST</a></h2>
<p>FROST is a threshold signature scheme that enables a group of participants to collectively generate Schnorr signatures. This foundational protocol is crucial for Arch‚Äôs consensus mechanism because it provides a way to achieve distributed agreement while maintaining compatibility with Bitcoin‚Äôs native signature scheme.</p>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<ul>
<li><strong>Distributed Key Generation</strong>: Validators collectively participate in a process that generates a shared public key while keeping individual private key shares separate and secure.</li>
<li><strong>Threshold Signatures</strong>: The system requires a specific number of validators (t-of-n) to cooperate in order to produce valid signatures, balancing security with fault tolerance.</li>
<li><strong>Share Management</strong>: Each validator maintains their own private key share, contributing to the system‚Äôs security through distribution of trust.</li>
<li><strong>Signature Aggregation</strong>: Multiple partial signatures are combined into a single Schnorr signature that‚Äôs indistinguishable from a standard single-signer signature.</li>
</ul>
<h3 id="benefits-of-frost"><a class="header" href="#benefits-of-frost">Benefits of FROST</a></h3>
<ol>
<li>
<p><strong>Enhanced Security</strong></p>
<ul>
<li>No single validator can compromise the system</li>
<li>Distributed trust model eliminates single points of failure</li>
<li>Cryptographic guarantees of signature validity</li>
</ul>
</li>
<li>
<p><strong>Bitcoin Compatibility</strong></p>
<ul>
<li>Native integration with Bitcoin‚Äôs Schnorr signature scheme</li>
<li>No additional on-chain overhead</li>
<li>Seamless interaction with Bitcoin‚Äôs transaction validation</li>
</ul>
</li>
<li>
<p><strong>Efficiency</strong></p>
<ul>
<li>Constant-size signatures regardless of validator count</li>
<li>Optimized communication patterns</li>
<li>Reduced blockchain space usage</li>
</ul>
</li>
</ol>
<h2 id="roast-enhancing-frost-for-production"><a class="header" href="#roast-enhancing-frost-for-production">ROAST: Enhancing FROST for Production</a></h2>
<p>While FROST provides the cryptographic foundation, ROAST adds crucial properties needed for real-world deployment in adversarial environments. ROAST transforms FROST from a theoretical protocol into a production-ready consensus mechanism.</p>
<h3 id="key-enhancements"><a class="header" href="#key-enhancements">Key Enhancements</a></h3>
<ol>
<li>
<p><strong>Asynchronous Operation</strong></p>
<ul>
<li>Validators can participate without strict timing requirements</li>
<li>Resilient to network delays and partitions</li>
<li>Maintains liveness in real-world conditions</li>
</ul>
</li>
<li>
<p><strong>Robustness Against Attacks</strong></p>
<ul>
<li>Continues operating even with malicious participants</li>
<li>Detects and handles various forms of validator misbehavior</li>
<li>Provides provable security guarantees</li>
</ul>
</li>
<li>
<p><strong>Leader Selection</strong></p>
<ul>
<li>Efficient and fair leader rotation mechanism</li>
<li>Prevents centralization of power</li>
<li>Maintains system progress even if leaders fail</li>
</ul>
</li>
<li>
<p><strong>Liveness Guarantees</strong></p>
<ul>
<li>Ensures forward progress under adverse conditions</li>
<li>Handles validator churn gracefully</li>
<li>Recovers automatically from temporary failures</li>
</ul>
</li>
</ol>
<h2 id="archs-novel-implementation"><a class="header" href="#archs-novel-implementation">Arch‚Äôs Novel Implementation</a></h2>
<p>Arch‚Äôs implementation of ROAST/FROST represents a significant innovation in the blockchain space, particularly for Bitcoin-based smart contract platforms.</p>
<h3 id="unique-features"><a class="header" href="#unique-features">Unique Features</a></h3>
<ol>
<li>
<p><strong>Bitcoin-Native Design</strong></p>
<ul>
<li>Optimized for Bitcoin‚Äôs specific constraints and capabilities</li>
<li>Leverages Bitcoin‚Äôs security model</li>
<li>Minimizes on-chain footprint</li>
</ul>
</li>
<li>
<p><strong>Smart Contract Integration</strong></p>
<ul>
<li>Seamless combination with programmable logic</li>
<li>Maintains Bitcoin‚Äôs security guarantees</li>
<li>Enables complex decentralized applications</li>
</ul>
</li>
<li>
<p><strong>Scalable State Management</strong></p>
<ul>
<li>Efficient handling of state transitions</li>
<li>Parallel transaction processing where possible</li>
<li>Optimized validator resource usage</li>
</ul>
</li>
<li>
<p><strong>Economic Security</strong></p>
<ul>
<li>Carefully designed incentive structure</li>
<li>Slashing conditions for misbehavior</li>
<li>Aligned validator and network interests</li>
</ul>
</li>
</ol>
<h3 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h3>
<ul>
<li><strong>Throughput</strong>: High transaction processing capacity without sacrificing decentralization</li>
<li><strong>Latency</strong>: Optimized confirmation times while maintaining security</li>
<li><strong>Resource Usage</strong>: Efficient use of network and computational resources</li>
<li><strong>Scalability</strong>: Linear scaling with validator count for most operations</li>
</ul>
<h2 id="security-considerations-3"><a class="header" href="#security-considerations-3">Security Considerations</a></h2>
<h3 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h3>
<ul>
<li><strong>Byzantine Validators</strong>: System remains secure with up to f Byzantine validators (where f &lt; n/3)</li>
<li><strong>Network Adversaries</strong>: Resilient against various network-level attacks</li>
<li><strong>Cryptographic Security</strong>: Based on well-studied cryptographic assumptions</li>
</ul>
<h3 id="security-properties-1"><a class="header" href="#security-properties-1">Security Properties</a></h3>
<ol>
<li>
<p><strong>Safety</strong></p>
<ul>
<li>No conflicting transactions can be confirmed</li>
<li>Cryptographic guarantees of transaction finality</li>
<li>Protection against double-spending</li>
</ul>
</li>
<li>
<p><strong>Liveness</strong></p>
<ul>
<li>System continues to make progress</li>
<li>Recovers from temporary failures</li>
<li>Handles validator set changes</li>
</ul>
</li>
<li>
<p><strong>Fault Tolerance</strong></p>
<ul>
<li>Continues operating with partial validator failures</li>
<li>Graceful degradation under attack</li>
<li>Automatic recovery mechanisms</li>
</ul>
</li>
</ol>
<h2 id="future-directions"><a class="header" href="#future-directions">Future Directions</a></h2>
<p>The ROAST/FROST consensus mechanism in Arch provides a solid foundation for future enhancements:</p>
<ol>
<li>
<p><strong>Scalability Improvements</strong></p>
<ul>
<li>Research into further optimization of signature aggregation</li>
<li>Investigation of layer-2 scaling solutions</li>
<li>Exploration of parallel processing techniques</li>
</ul>
</li>
<li>
<p><strong>Security Enhancements</strong></p>
<ul>
<li>Ongoing cryptographic research</li>
<li>Additional protection against emerging threats</li>
<li>Enhanced monitoring and detection systems</li>
</ul>
</li>
<li>
<p><strong>Feature Extensions</strong></p>
<ul>
<li>Support for more complex smart contract patterns</li>
<li>Enhanced cross-chain interoperability</li>
<li>Advanced state management techniques</li>
</ul>
</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<h3 id="academic-papers-and-research"><a class="header" href="#academic-papers-and-research">Academic Papers and Research</a></h3>
<h4 id="frost-flexible-round-optimized-schnorr-threshold-signatures"><a class="header" href="#frost-flexible-round-optimized-schnorr-threshold-signatures">FROST (Flexible Round-Optimized Schnorr Threshold Signatures)</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2020/852.pdf">FROST: Flexible Round-Optimized Schnorr Threshold Signatures</a> - The original FROST paper by Chelsea Komlo and Ian Goldberg</li>
<li><a href="https://eprint.iacr.org/2021/1110.pdf">Two-Round Threshold Schnorr Signatures with FROST</a> - An optimized two-round variant of FROST</li>
<li><a href="https://github.com/ZcashFoundation/frost">Implementing FROST</a> - Reference implementation by the Zcash Foundation</li>
</ul>
<h4 id="roast-robust-asynchronous-schnorr-threshold-signatures"><a class="header" href="#roast-robust-asynchronous-schnorr-threshold-signatures">ROAST (Robust Asynchronous Schnorr Threshold Signatures)</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2022/550.pdf">ROAST: Robust Asynchronous Schnorr Threshold Signatures</a> - The foundational ROAST paper</li>
<li><a href="https://medium.com/blockstream/implementing-threshold-signatures-for-bitcoin-8d3b63831325">Practical Threshold Signatures for Bitcoin</a> - Implementation insights for Bitcoin-based threshold signatures</li>
</ul>
<h4 id="threshold-cryptography-and-consensus"><a class="header" href="#threshold-cryptography-and-consensus">Threshold Cryptography and Consensus</a></h4>
<ul>
<li><a href="https://arxiv.org/pdf/1904.04098.pdf">A Survey of Distributed Consensus Protocols for Blockchain Networks</a> - Comprehensive overview of consensus mechanisms</li>
<li><a href="https://eprint.iacr.org/2019/1157.pdf">Threshold Signatures: The Future of Consensus?</a> - Analysis of threshold signatures in consensus protocols</li>
<li><a href="https://eprint.iacr.org/2018/068.pdf">Schnorr Multi-Signatures and Applications</a> - Foundational work on Schnorr multi-signatures</li>
</ul>
<h3 id="technical-resources"><a class="header" href="#technical-resources">Technical Resources</a></h3>
<h4 id="implementation-guides"><a class="header" href="#implementation-guides">Implementation Guides</a></h4>
<ul>
<li><a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP 340: Schnorr Signatures for secp256k1</a> - Bitcoin Improvement Proposal for Schnorr signatures</li>
<li><a href="https://tlu.tarilabs.com/cryptography/threshold-signatures">Implementing Threshold Signatures</a> - Technical guide on threshold signature implementation</li>
<li><a href="https://github.com/ZcashFoundation/redjubjub">Multi-Party Computation for Distributed Key Generation</a> - Reference implementation of distributed key generation</li>
</ul>
<h4 id="security-analysis"><a class="header" href="#security-analysis">Security Analysis</a></h4>
<ul>
<li><a href="https://eprint.iacr.org/2019/114.pdf">Security Analysis of Threshold Signature Schemes</a> - Comprehensive security analysis</li>
<li><a href="https://eprint.iacr.org/2021/1559.pdf">Formal Verification of FROST</a> - Formal security proofs for FROST</li>
<li><a href="https://arxiv.org/pdf/1908.01738.pdf">Byzantine Fault Tolerance in Distributed Systems</a> - Analysis of BFT in consensus protocols</li>
</ul>
<h3 id="community-resources"><a class="header" href="#community-resources">Community Resources</a></h3>
<ul>
<li><a href="https://frost.zfnd.org">FROST Working Group</a> - Community working group on FROST implementation</li>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/">Bitcoin Dev Mailing List</a> - Discussions on threshold signatures in Bitcoin</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The combination of ROAST and FROST in Arch represents a significant advancement in Bitcoin-based smart contract platforms. This consensus mechanism enables sophisticated applications while maintaining the security and decentralization principles that make Bitcoin valuable. Through careful design and implementation, Arch has created a system that is not just theoretically sound but practically deployable and scalable for real-world applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validator-state-machine"><a class="header" href="#validator-state-machine">Validator State Machine</a></h1>
<p>This document describes the complete state machine for Arch Network validators, including all possible states and their transitions.</p>
<h2 id="-state-diagram-overview"><a class="header" href="#-state-diagram-overview">üìä State Diagram Overview</a></h2>
<p>The validator follows two main paths depending on whether Distributed Key Generation (DKG) has been completed:</p>
<ul>
<li><strong>DKG Path</strong>: For new validators that need to generate keys</li>
<li><strong>Sync Path</strong>: For existing validators that need to synchronize with the network</li>
</ul>
<p>Both paths converge at the <code>Ready</code> state where validators can participate in consensus.</p>
<h2 id="-validator-states"><a class="header" href="#-validator-states">üîÑ Validator States</a></h2>
<h3 id="initial-states"><a class="header" href="#initial-states">Initial States</a></h3>
<h4 id="init"><a class="header" href="#init"><code>Init</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Starting state when validator first boots up</li>
<li><strong>Transitions to</strong>: <code>ConnectedToNetwork</code></li>
<li><strong>Trigger</strong>: Network connection is established</li>
</ul>
<h4 id="connectedtonetwork"><a class="header" href="#connectedtonetwork"><code>ConnectedToNetwork</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Network connection established, preparing for peer discovery</li>
<li><strong>Transitions to</strong>: <code>WaitingForNetworkPeerId</code></li>
<li><strong>Trigger</strong>: Peers discovered and topics subscribed</li>
</ul>
<h4 id="waitingfornetworkpeerid"><a class="header" href="#waitingfornetworkpeerid"><code>WaitingForNetworkPeerId</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Waiting for network peer information from bootnode</li>
<li><strong>Transitions to</strong>:
<ul>
<li><code>WaitingForWhitelistPeers</code> (if DKG not completed)</li>
<li><code>WaitingForCurrentBlockHeight</code> (if DKG already completed)</li>
<li><code>WaitingForNetworkPeerId</code> (retry on timeout)</li>
</ul>
</li>
<li><strong>Trigger</strong>: Bootnode responds with network peer information</li>
</ul>
<h3 id="dkg-path-network-just-started"><a class="header" href="#dkg-path-network-just-started">DKG Path (Network just started)</a></h3>
<h4 id="waitingforwhitelistpeers"><a class="header" href="#waitingforwhitelistpeers"><code>WaitingForWhitelistPeers</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Waiting for all required whitelist peers to connect, this is required since DKG requires a full mesh network</li>
<li><strong>Transitions to</strong>: <code>WaitingForDkg</code></li>
<li><strong>Trigger</strong>: All whitelist peers are connected</li>
</ul>
<h4 id="waitingfordkg"><a class="header" href="#waitingfordkg"><code>WaitingForDkg</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Distributed Key Generation process is running</li>
<li><strong>Transitions to</strong>: <code>Ready</code></li>
<li><strong>Trigger</strong>: DKG completes successfully and keys are generated</li>
</ul>
<h3 id="synchronization-module-block-generation-is-already-in-progress"><a class="header" href="#synchronization-module-block-generation-is-already-in-progress">Synchronization Module (Block generation is already in progress)</a></h3>
<h4 id="waitingforcurrentblockheight"><a class="header" href="#waitingforcurrentblockheight"><code>WaitingForCurrentBlockHeight</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Requesting and analyzing current block height from network peers</li>
<li><strong>Transitions to</strong>:
<ul>
<li><code>Ready</code> (if already synchronized)</li>
<li><code>ApplyingFullSnapshot</code> (if full sync needed)</li>
<li><code>ApplyingIncrementalSnapshot</code> (if incremental sync needed)</li>
<li><code>WaitingForCurrentBlockHeight</code> (retry on failure)</li>
</ul>
</li>
<li><strong>Trigger</strong>: All peers sent responses, or request timed out</li>
</ul>
<h4 id="applyingfullsnapshot"><a class="header" href="#applyingfullsnapshot"><code>ApplyingFullSnapshot</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Downloading and applying a complete network snapshot</li>
<li><strong>Transitions to</strong>:
<ul>
<li><code>Ready</code> (if sync completes successfully)</li>
<li><code>ApplyingIncrementalSnapshot</code> (if incremental sync needed after)</li>
<li><code>ApplyingFullSnapshot</code> (retry/continue same snapshot)</li>
</ul>
</li>
<li><strong>Trigger</strong>: Snapshot application completes or full snapshot acquisition fails</li>
</ul>
<h4 id="applyingincrementalsnapshot"><a class="header" href="#applyingincrementalsnapshot"><code>ApplyingIncrementalSnapshot</code></a></h4>
<ul>
<li><strong>Purpose</strong>: Downloading and applying incremental block data</li>
<li><strong>Transitions to</strong>:
<ul>
<li><code>Ready</code> (if sync completes successfully)</li>
<li><code>ApplyingIncrementalSnapshot</code> (continue syncing)</li>
<li><code>WaitingForCurrentBlockHeight</code> (retry/restart sync)</li>
</ul>
</li>
<li><strong>Trigger</strong>: Incremental sync completes or requires restart</li>
</ul>
<h3 id="final-states"><a class="header" href="#final-states">Final States</a></h3>
<h4 id="ready"><a class="header" href="#ready"><code>Ready</code></a></h4>
<ul>
<li><strong>Purpose</strong>: üéØ <strong>FINAL STATE</strong> - Validator is synchronized and can participate in consensus</li>
<li><strong>Transitions to</strong>:
<ul>
<li><code>WaitingForCurrentBlockHeight</code> (if the validator somehow falls out of sync)</li>
<li><code>Ready</code> (state refresh)</li>
</ul>
</li>
<li><strong>Trigger</strong>: Node falls behind network or needs re-synchronization</li>
</ul>
<h4 id="listening"><a class="header" href="#listening"><code>Listening</code></a></h4>
<ul>
<li><strong>Purpose</strong>: üéØ <strong>FINAL STATE FOR LISTENER NODES</strong> - Non-participating node that only observes</li>
<li><strong>Transitions to</strong>:
<ul>
<li><code>WaitingForCurrentBlockHeight</code> (if sync required)</li>
<li><code>Ready</code> (if promoted to full validator)</li>
</ul>
</li>
<li><strong>Note</strong>: ‚ö†Ô∏è <strong>For listener nodes, <code>Listening</code> is the final state instead of <code>Ready</code></strong></li>
</ul>
<h2 id="-retry-and-recovery-patterns"><a class="header" href="#-retry-and-recovery-patterns">üîÑ Retry and Recovery Patterns</a></h2>
<h3 id="automatic-retries"><a class="header" href="#automatic-retries">Automatic Retries</a></h3>
<ul>
<li><strong><code>WaitingForNetworkPeerId</code></strong>: Retries on timeout</li>
<li><strong><code>WaitingForCurrentBlockHeight</code></strong>: Retries on sync strategy failure</li>
<li><strong><code>ApplyingFullSnapshot</code></strong>: Can retry or switch to incremental</li>
<li><strong><code>ApplyingIncrementalSnapshot</code></strong>: Can retry or restart sync</li>
</ul>
<h3 id="recovery-strategies"><a class="header" href="#recovery-strategies">Recovery Strategies</a></h3>
<ul>
<li><strong>Network Failures</strong>: Automatic reconnection and peer rediscovery</li>
<li><strong>Sync Failures</strong>: Fallback to full snapshot if incremental fails</li>
<li><strong>DKG Failures</strong>: Restart DKG process with current peer set</li>
<li><strong>State Corruption</strong>: Reset to last known good state</li>
</ul>
<h2 id="-state-transition-examples"><a class="header" href="#-state-transition-examples">üöÄ State Transition Examples</a></h2>
<h3 id="new-validator-joining-network"><a class="header" href="#new-validator-joining-network">New Validator Joining Network</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Init
    Init --&gt; ConnectedToNetwork
    ConnectedToNetwork --&gt; WaitingForNetworkPeerId
    WaitingForNetworkPeerId --&gt; WaitingForWhitelistPeers
    WaitingForWhitelistPeers --&gt; WaitingForDkg
    WaitingForDkg --&gt; Ready
    Ready --&gt; [*]
</pre>
<h3 id="existing-validator-reconnecting"><a class="header" href="#existing-validator-reconnecting">Existing Validator Reconnecting</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Init
    Init --&gt; ConnectedToNetwork
    ConnectedToNetwork --&gt; WaitingForNetworkPeerId
    WaitingForNetworkPeerId --&gt; WaitingForCurrentBlockHeight
    WaitingForCurrentBlockHeight --&gt; ApplyingIncrementalSnapshot
    ApplyingIncrementalSnapshot --&gt; Ready
    Ready --&gt; [*]
</pre>
<h2 id="-monitoring-and-debugging"><a class="header" href="#-monitoring-and-debugging">üîß Monitoring and Debugging</a></h2>
<h3 id="state-monitoring"><a class="header" href="#state-monitoring">State Monitoring</a></h3>
<pre><code class="language-bash"># Check validator status
arch-cli orchestrate validator-status

# View validator logs
docker logs arch-validator

# Check network connectivity
arch-cli get-block-height
</code></pre>
<h3 id="common-state-issues"><a class="header" href="#common-state-issues">Common State Issues</a></h3>
<h4 id="stuck-in-waitingfornetworkpeerid"><a class="header" href="#stuck-in-waitingfornetworkpeerid">Stuck in <code>WaitingForNetworkPeerId</code></a></h4>
<ul>
<li><strong>Cause</strong>: Bootnode not responding or network issues</li>
<li><strong>Solution</strong>: Check network connectivity and bootnode status</li>
</ul>
<h4 id="stuck-in-waitingforwhitelistpeers"><a class="header" href="#stuck-in-waitingforwhitelistpeers">Stuck in <code>WaitingForWhitelistPeers</code></a></h4>
<ul>
<li><strong>Cause</strong>: Not all required peers are connected</li>
<li><strong>Solution</strong>: Verify peer configuration and network topology</li>
</ul>
<h4 id="stuck-in-waitingfordkg"><a class="header" href="#stuck-in-waitingfordkg">Stuck in <code>WaitingForDkg</code></a></h4>
<ul>
<li><strong>Cause</strong>: DKG process hanging or failing</li>
<li><strong>Solution</strong>: Check DKG logs and peer connectivity</li>
</ul>
<h4 id="stuck-in-sync-states"><a class="header" href="#stuck-in-sync-states">Stuck in Sync States</a></h4>
<ul>
<li><strong>Cause</strong>: Network partition or corrupted state</li>
<li><strong>Solution</strong>: Reset validator and restart sync process</li>
</ul>
<h2 id="-performance-characteristics"><a class="header" href="#-performance-characteristics">üìä Performance Characteristics</a></h2>
<h3 id="state-transition-times"><a class="header" href="#state-transition-times">State Transition Times</a></h3>
<ul>
<li><strong><code>Init</code> ‚Üí <code>ConnectedToNetwork</code></strong>: &lt; 1 second</li>
<li><strong><code>ConnectedToNetwork</code> ‚Üí <code>WaitingForNetworkPeerId</code></strong>: 1-5 seconds</li>
<li><strong><code>WaitingForNetworkPeerId</code> ‚Üí <code>WaitingForWhitelistPeers</code></strong>: 5-30 seconds</li>
<li><strong><code>WaitingForWhitelistPeers</code> ‚Üí <code>WaitingForDkg</code></strong>: 10-60 seconds</li>
<li><strong><code>WaitingForDkg</code> ‚Üí <code>Ready</code></strong>: 1-5 minutes</li>
<li><strong>Sync states</strong>: Variable based on network size and state</li>
</ul>
<h3 id="resource-requirements"><a class="header" href="#resource-requirements">Resource Requirements</a></h3>
<ul>
<li><strong>Memory</strong>: Increases during sync, stabilizes at <code>Ready</code></li>
<li><strong>CPU</strong>: High during DKG and sync, low at <code>Ready</code></li>
<li><strong>Network</strong>: High bandwidth during sync, moderate at <code>Ready</code></li>
<li><strong>Storage</strong>: Grows with network state size</li>
</ul>
<h2 id="-security-considerations"><a class="header" href="#-security-considerations">üõ°Ô∏è Security Considerations</a></h2>
<h3 id="state-validation"><a class="header" href="#state-validation">State Validation</a></h3>
<ul>
<li><strong>Peer Authentication</strong>: Verify peer identities before state transitions</li>
<li><strong>State Integrity</strong>: Validate all received state data</li>
<li><strong>DKG Security</strong>: Ensure proper threshold signature setup</li>
</ul>
<h3 id="attack-prevention"><a class="header" href="#attack-prevention">Attack Prevention</a></h3>
<ul>
<li><strong>Sybil Attacks</strong>: Whitelist-based peer validation</li>
<li><strong>State Corruption</strong>: Cryptographic verification of snapshots</li>
<li><strong>Network Partition</strong>: Automatic detection and recovery</li>
</ul>
<h2 id="-best-practices"><a class="header" href="#-best-practices">üîÑ Best Practices</a></h2>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<ol>
<li><strong>Peer Configuration</strong>: Set appropriate whitelist peers</li>
<li><strong>Timeout Values</strong>: Configure reasonable timeout values</li>
<li><strong>Retry Limits</strong>: Set appropriate retry limits for each state</li>
<li><strong>Logging</strong>: Enable detailed logging for debugging</li>
</ol>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<ol>
<li><strong>State Tracking</strong>: Monitor state transitions</li>
<li><strong>Performance Metrics</strong>: Track transition times</li>
<li><strong>Error Rates</strong>: Monitor failure rates for each state</li>
<li><strong>Resource Usage</strong>: Track resource consumption</li>
</ol>
<h3 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h3>
<ol>
<li><strong>Log Analysis</strong>: Review logs for error patterns</li>
<li><strong>Network Diagnosis</strong>: Check network connectivity</li>
<li><strong>Peer Validation</strong>: Verify peer configuration</li>
<li><strong>State Reset</strong>: Reset validator if stuck in bad state</li>
</ol>
<h2 id="-related-documentation"><a class="header" href="#-related-documentation">üìö Related Documentation</a></h2>
<ul>
<li><a href="concepts/network-architecture.html">Network Architecture</a> - Understanding network topology</li>
<li><a href="concepts/bitcoin-integration.html">Bitcoin Integration</a> - Bitcoin network integration</li>
<li><a href="concepts/consensus.html">Consensus Protocol</a> - ROAST and FROST consensus</li>
<li><a href="concepts/../getting-started/bitcoin-and-titan-setup.html">Validator Setup</a> - Setting up validators</li>
<li><a href="concepts/../guides/arch-cli-reference.html">CLI Reference</a> - Managing validators via CLI</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program"><a class="header" href="#program">Program</a></h1>
<p>A program is a special kind of <a href="program/./accounts.html">account</a> that contains executable <a href="https://ebpf.io">eBPF</a> bytecode, denoted by the <code>Account.is_executable: true</code> field. This allows an account to receive arbitrary <a href="program/./instructions-and-messages.html#instructions">instruction</a> data via a <a href="program/./transaction.html">transaction</a> to be processed by the runtime.</p>
<p>Every program is stateless, meaning that it can only read/write data to other accounts and that it <strong>cannot</strong> write to its own account; this, in-part, is how parallelized execution is made possible (see <a href="program/program.html#4-state">State</a> for more info).</p>
<blockquote>
<p>üí° Additionally, programs can send instructions to other programs which, in turn, receive instructions and thus extend program composability further. This is known as cross-program invocation (CPI) and will be detailed in future sections.</p>
</blockquote>
<h3 id="components"><a class="header" href="#components">Components:</a></h3>
<h4 id="1-entrypoint"><a class="header" href="#1-entrypoint">1. <a href="program/./entrypoint.html">Entrypoint</a></a></h4>
<p>Every Arch program includes a single entrypoint used to invoke the program. A <a href="program/./entrypoint.html#handler-function">handler function</a>, often named <code>process_instruction</code>, is then used to handle the data passed into the entrypoint.</p>
<p><em>These parameters are required for every <a href="program/./instructions-and-messages.html#instructions">instruction</a> to be processed.</em>_</p>
<pre><code class="language-rust ignore">use arch_program::entrypoint;
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    // Program logic here
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<h4 id="2-instruction"><a class="header" href="#2-instruction">2. <a href="program/./instructions-and-messages.html#instructions">Instruction</a></a></h4>
<p>The <code>instruction_data</code> is deserialized after being passed into the entrypoint. From there, if there are multiple instructions, a <code>match</code> statement can be utilized to point the logic flow to the appropriate handler function previously defined within the program which can continue processing the instruction.</p>
<h4 id="3-process-instruction"><a class="header" href="#3-process-instruction">3. Process Instruction</a></h4>
<p>If a program has multiple instructions, a corresponding <a href="program/./entrypoint.html#handler-function">handler function</a> should be defined to include the specific logic unique to the instruction.</p>
<h4 id="4-state"><a class="header" href="#4-state">4. State</a></h4>
<p>Since programs are stateless, a ‚Äúdata‚Äù <a href="program/./accounts.html">account</a> is needed to hold state for a user. This is a non-executable account that holds program data.</p>
<p>If a program receives instruction that results in a user‚Äôs state being altered, the program would manage this user‚Äôs state via a mapping within the program‚Äôs logic. This mapping would link the user‚Äôs <a href="program/./pubkey.html">pubkey</a> with a data <a href="program/./accounts.html">account</a> where the state would live for that specific program.</p>
<p>The program will likely include a struct to define the structure of its state and make it easier to work with. The deserialization of account data occurs during program invocation. After an update is made, state data gets re-serialized into a byte array and stored within the <code>data</code> field of the <a href="program/./accounts.html">account</a>.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-unspent-transaction-output"><a class="header" href="#utxo-unspent-transaction-output">UTXO (Unspent Transaction Output)</a></h1>
<p>UTXOs (Unspent Transaction Outputs) are fundamental to Bitcoin‚Äôs transaction model and serve as the foundation for state management in Arch Network. Unlike account-based systems that track balances, UTXOs represent discrete ‚Äúcoins‚Äù that must be consumed entirely in transactions.</p>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="what-is-a-utxo"><a class="header" href="#what-is-a-utxo">What is a UTXO?</a></h3>
<ul>
<li>A UTXO represents an unspent output from a previous transaction</li>
<li>Each UTXO is uniquely identified by a transaction ID (txid) and output index (vout)</li>
<li>UTXOs are immutable - they can only be created or spent, never modified</li>
<li>Once spent, a UTXO cannot be reused (prevents double-spending)</li>
</ul>
<h3 id="role-in-arch-network"><a class="header" href="#role-in-arch-network">Role in Arch Network</a></h3>
<ul>
<li>UTXOs anchor program state to Bitcoin‚Äôs security model</li>
<li>They provide deterministic state transitions</li>
<li>Enable atomic operations across the network</li>
<li>Allow for provable ownership and state validation</li>
</ul>
<h2 id="utxo-structure"><a class="header" href="#utxo-structure">UTXO Structure</a></h2>
<p>The <code>UtxoMeta</code> struct encapsulates the core UTXO identification data:</p>
<pre><code class="language-rust ignore">use arch_program::utxo::UtxoMeta;
use bitcoin::Txid;

#[derive(Debug, Clone, PartialEq)]
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Bitcoin transaction ID (32 bytes)
    pub vout: u32,       // Output index in the transaction
}

impl UtxoMeta {
    /// Creates a new UTXO metadata instance
    pub fn new(txid: [u8; 32], vout: u32) -&gt; Self {
        Self { txid, vout }
    }

    /// Deserializes UTXO metadata from a byte slice
    /// Format: [txid(32 bytes)][vout(4 bytes)]
    pub fn from_slice(data: &amp;[u8]) -&gt; Self {
        let mut txid = [0u8; 32];
        txid.copy_from_slice(&amp;data[0..32]);
        let vout = u32::from_le_bytes([
            data[32], data[33], data[34], data[35]
        ]);
        Self { txid, vout }
    }
}</code></pre>
<h2 id="utxo-lifecycle"><a class="header" href="#utxo-lifecycle">UTXO Lifecycle</a></h2>
<h3 id="1-creation-process"><a class="header" href="#1-creation-process">1. Creation Process</a></h3>
<h4 id="creating-a-utxo-with-bitcoin-rpc"><a class="header" href="#creating-a-utxo-with-bitcoin-rpc">Creating a UTXO with Bitcoin RPC</a></h4>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client as RpcClient, RpcApi};
use bitcoin::{Amount, Address};
use arch_program::pubkey::Pubkey;

// Initialize Bitcoin RPC client
let rpc = RpcClient::new(
    "http://localhost:18443",  // Bitcoin node RPC endpoint
    Auth::UserPass(
        "user".to_string(),
        "pass".to_string()
    )
).expect("Failed to create RPC client");

// Generate a new account address
let account_address = Pubkey::new_unique();
let btc_address = Address::from_pubkey(&amp;account_address);

// Create UTXO by sending Bitcoin
// Parameters explained:
// - address: Destination Bitcoin address
// - amount: Amount in satoshis (3000 sats = 0.00003 BTC)
// - comment: Optional transaction comment
// - replaceable: Whether the tx can be replaced (RBF)
let txid = rpc.send_to_address(
    &amp;btc_address,
    Amount::from_sat(3000),
    Some("Create Arch UTXO"),  // Comment
    None,                      // Comment_to
    Some(true),               // Replaceable
    None,                     // Fee rate
    None,                     // Fee estimate mode
    None                      // Avoid reuse
)?;

// Wait for confirmation (recommended)
rpc.wait_for_confirmation(&amp;txid, 1)?;</code></pre>
<h4 id="creating-an-arch-account-with-utxo"><a class="header" href="#creating-an-arch-account-with-utxo">Creating an Arch Account with UTXO</a></h4>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction::SystemInstruction,
    pubkey::Pubkey,
    transaction::Transaction,
};

// Create new program account backed by UTXO
let account_pubkey = Pubkey::new_unique();
let instruction = SystemInstruction::new_create_account_instruction(
    txid.try_into().unwrap(),
    0,  // vout index
    account_pubkey,
    // Additional parameters like:
    // - space: Amount of space to allocate
    // - owner: Program that owns the account
);

// Build and sign transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[instruction],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer],
    recent_blockhash
);</code></pre>
<h3 id="2-state-management"><a class="header" href="#2-state-management">2. State Management</a></h3>
<pre><code class="language-rust ignore">// Example UTXO state tracking
#[derive(Debug)]
pub struct UtxoState {
    pub meta: UtxoMeta,
    pub status: UtxoStatus,
    pub owner: Pubkey,
    pub created_at: i64,
    pub spent_at: Option&lt;i64&gt;,
}

#[derive(Debug)]
pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<p>Common UTXO-related errors to handle:</p>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound,                    // UTXO doesn't exist
    AlreadySpent,               // UTXO was already consumed
    InsufficientConfirmations,  // Not enough confirmations
    InvalidOwner,               // Unauthorized attempt to spend
    Reorged,                    // UTXO invalidated by reorg
    InvalidVout,                // Output index doesn't exist
    SerializationError,         // Data serialization failed
}</code></pre>
<h2 id="related-topics-1"><a class="header" href="#related-topics-1">Related Topics</a></h2>
<ul>
<li><a href="program/account.html">Account Model</a> - How UTXOs relate to Arch accounts</li>
<li><a href="program/program.html">Program State</a> - Using UTXOs for program state</li>
<li><a href="program/../system-program/system-program.html">System Program</a> - Core UTXO operations</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-guide"><a class="header" href="#account-guide">Account Guide</a></h1>
<blockquote>
<p><strong>Navigation</strong>: <a href="program/../SUMMARY.html#reference">Reference</a> ‚Üí <a href="program/./program.html">Program</a> ‚Üí Account Guide</p>
<p>For the core account structure and data types, see <a href="program/./account.html">Account Structure</a>.</p>
</blockquote>
<p>Accounts are the fundamental building blocks for state management and program interaction in Arch Network. They serve as containers for both program code and state data, bridging the gap between Bitcoin‚Äôs UTXO model and modern programmable state machines.</p>
<blockquote>
<p><strong>Note</strong>: For detailed documentation on core system functions used to interact with accounts (like <code>invoke</code>, <code>new_create_account_instruction</code>, <code>add_state_transition</code>, and <code>set_transaction_to_sign</code>), see <a href="program/./system-functions.html">System Functions</a>.</p>
</blockquote>
<pre class="mermaid">flowchart TD
    A[Account] --&gt; B[Program Account]
    A --&gt; C[Data Account]
    A --&gt; D[Native Account]
    B --&gt; E[Executable Code]
    C --&gt; F[Program State]
    C --&gt; G[UTXOs]
    D --&gt; H[System Operations]

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#f5f5f5,stroke:#666
    style C fill:#f5f5f5,stroke:#666
    style D fill:#f5f5f5,stroke:#666
</pre>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<h3 id="account-fundamentals"><a class="header" href="#account-fundamentals">Account Fundamentals</a></h3>
<p>Every account in Arch Network is uniquely identified by a public key (pubkey) and contains four essential components:</p>
<pre><code class="language-rust ignore">pub struct Account {
    /// The program that owns this account
    pub owner: Pubkey,
    /// Number of lamports assigned to this account
    pub lamports: u64,
    /// Data held in this account
    pub data: Vec&lt;u8&gt;,
    /// Whether this account can process instructions
    pub executable: bool,
}</code></pre>
<h4 id="component-details"><a class="header" href="#component-details">Component Details:</a></h4>
<ol>
<li>
<p><strong>Owner (Pubkey)</strong></p>
<ul>
<li>Controls account modifications</li>
<li>Determines which program can modify data</li>
<li>Can be transferred to new programs</li>
<li>Required for all accounts</li>
</ul>
</li>
<li>
<p><strong>Lamports (u64)</strong></p>
<ul>
<li>Native token balance</li>
<li>Used for:
<ul>
<li>Transaction fees</li>
<li>Rent payments</li>
<li>State storage costs</li>
<li>Program execution fees</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Data (Vec<u8>)</strong></p>
<ul>
<li>Flexible byte array for state storage</li>
<li>Common uses:
<ul>
<li>Program code (if executable)</li>
<li>Program state</li>
<li>UTXO metadata</li>
<li>Configuration data</li>
</ul>
</li>
<li>Size determined at creation</li>
</ul>
</li>
<li>
<p><strong>Executable Flag (bool)</strong></p>
<ul>
<li>Determines if account contains program code</li>
<li>Immutable after deployment</li>
<li>Controls instruction processing capability</li>
</ul>
</li>
</ol>
<pre class="mermaid">flowchart LR
    A[Account Creation] --&gt; B[Initial State]
    B --&gt; C[Runtime Operations]
    C --&gt; D[State Updates]
    D --&gt; E[Account Closure]
    
    subgraph Lifecycle
        A -. Initialize .-&gt; B
        B -. Process Instructions .-&gt; C
        C -. Modify State .-&gt; D
        D -. Cleanup .-&gt; E
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#9ff,stroke:#333,stroke-width:2px
    style Lifecycle fill:#f5f5f5,stroke:#666,stroke-width:1px
</pre>
<h2 id="account-types--use-cases"><a class="header" href="#account-types--use-cases">Account Types &amp; Use Cases</a></h2>
<h3 id="1-program-accounts"><a class="header" href="#1-program-accounts">1. Program Accounts</a></h3>
<p>Program accounts contain executable code and form the backbone of Arch Network‚Äôs programmable functionality.</p>
<pre><code class="language-rust ignore">// Example program account creation
let program_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(program_data.len()),
    space: program_data.len() as u64,
    owner: bpf_loader::id(),  // BPF Loader owns program accounts
    executable: true,
    data: program_data,
};</code></pre>
<p>Key characteristics:</p>
<ul>
<li>Immutable after deployment</li>
<li>Owned by BPF loader</li>
<li>Contains verified program code</li>
<li>Processes instructions</li>
</ul>
<h3 id="2-data-accounts"><a class="header" href="#2-data-accounts">2. Data Accounts</a></h3>
<p>Data accounts store program state and user data. They‚Äôre highly flexible and can be structured to meet various needs.</p>
<pre><code class="language-rust ignore">// Example data structure for a game account
#[derive(BorshSerialize, BorshDeserialize)]
pub struct GameAccount {
    pub player: Pubkey,
    pub score: u64,
    pub level: u8,
    pub achievements: Vec&lt;Achievement&gt;,
    pub last_played: i64,
}

// Creating a data account
let game_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;GameAccount&gt;()),
    space: size_of::&lt;GameAccount&gt;() as u64,
    owner: game_program::id(),
    executable: false,
    data: Vec::new(),  // Will be initialized by program
};</code></pre>
<p>Common use cases:</p>
<ul>
<li>Player profiles</li>
<li>Game state</li>
<li>DeFi positions</li>
<li>NFT metadata</li>
<li>Configuration settings</li>
</ul>
<h3 id="3-utxo-accounts"><a class="header" href="#3-utxo-accounts">3. UTXO Accounts</a></h3>
<p>Special data accounts that bridge Bitcoin UTXOs with Arch Network state.</p>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: UtxoState,
    pub created_at: i64,
    pub last_updated: i64,
    pub constraints: Vec&lt;UtxoConstraint&gt;,
}

// Example UTXO account creation
let utxo_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;UtxoAccount&gt;()),
    space: size_of::&lt;UtxoAccount&gt;() as u64,
    owner: utxo_program::id(),
    executable: false,
    data: Vec::new(),
};</code></pre>
<h2 id="account-interactions"><a class="header" href="#account-interactions">Account Interactions</a></h2>
<p>Account interactions in Arch Network are facilitated through a set of core system functions. These functions handle everything from account creation to state transitions and are documented in detail in <a href="program/./system-functions.html">System Functions</a>. Below are common patterns for account interactions:</p>
<h3 id="1-creation-patterns"><a class="header" href="#1-creation-patterns">1. Creation Patterns</a></h3>
<pre><code class="language-rust ignore">// 1. Basic account creation
pub fn create_basic_account(
    payer: &amp;Keypair,
    space: u64,
    owner: &amp;Pubkey,
) -&gt; Result&lt;Keypair, Error&gt; {
    let account = Keypair::new();
    let rent = banks_client.get_rent().await?;
    let lamports = rent.minimum_balance(space as usize);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;account.pubkey(),
        lamports,
        space,
        owner,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[ix],
        Some(&amp;payer.pubkey()),
        &amp;[payer, &amp;account],
        recent_blockhash,
    );
    
    banks_client.process_transaction(tx).await?;
    Ok(account)
}

// 2. PDA (Program Derived Address) creation
pub fn create_pda_account(
    program_id: &amp;Pubkey,
    seeds: &amp;[&amp;[u8]],
    space: u64,
) -&gt; Result&lt;Pubkey, Error&gt; {
    let (pda, bump) = Pubkey::find_program_address(seeds, program_id);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;pda,
        lamports,
        space,
        program_id,
    );
    
    // Include the bump seed for deterministic address
    let seeds_with_bump = &amp;[&amp;seeds[..], &amp;[&amp;[bump]]].concat();
    let signer_seeds = &amp;[&amp;seeds_with_bump[..]];
    
    invoke_signed(&amp;ix, &amp;[payer, pda], signer_seeds)?;
    Ok(pda)
}</code></pre>
<h3 id="2-state-management-1"><a class="header" href="#2-state-management-1">2. State Management</a></h3>
<pre><code class="language-rust ignore">// Example of managing account state
pub trait AccountState: Sized {
    fn try_from_slice(data: &amp;[u8]) -&gt; Result&lt;Self, Error&gt;;
    fn try_serialize(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
    
    fn load(account: &amp;AccountInfo) -&gt; Result&lt;Self, Error&gt; {
        Self::try_from_slice(&amp;account.data.borrow())
    }
    
    fn save(&amp;self, account: &amp;AccountInfo) -&gt; Result&lt;(), Error&gt; {
        let data = self.try_serialize()?;
        let mut account_data = account.data.borrow_mut();
        account_data[..data.len()].copy_from_slice(&amp;data);
        Ok(())
    }
}

// Implementation example
impl AccountState for GameAccount {
    fn update_score(&amp;mut self, new_score: u64) -&gt; Result&lt;(), Error&gt; {
        self.score = new_score;
        self.last_played = Clock::get()?.unix_timestamp;
        Ok(())
    }
}</code></pre>
<h3 id="3-cross-program-invocation-cpi"><a class="header" href="#3-cross-program-invocation-cpi">3. Cross-Program Invocation (CPI)</a></h3>
<pre><code class="language-rust ignore">// Example of one program calling another
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    // Deserialize accounts
    let account_info_iter = &amp;mut accounts.iter();
    let source_info = next_account_info(account_info_iter)?;
    let dest_info = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;
    
    // Create CPI context
    let cpi_accounts = Transfer {
        from: source_info.clone(),
        to: dest_info.clone(),
    };
    let cpi_program = system_program.clone();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    
    // Perform cross-program invocation
    transfer(cpi_ctx, amount)?;
    
    Ok(())
}</code></pre>
<h2 id="security-considerations-4"><a class="header" href="#security-considerations-4">Security Considerations</a></h2>
<h3 id="1-access-control"><a class="header" href="#1-access-control">1. Access Control</a></h3>
<pre><code class="language-rust ignore">fn verify_account_access(
    account: &amp;AccountInfo,
    expected_owner: &amp;Pubkey,
    writable: bool,
) -&gt; ProgramResult {
    // Check account ownership
    if account.owner != expected_owner {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Verify write permission if needed
    if writable &amp;&amp; !account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Additional checks...
    Ok(())
}</code></pre>
<h3 id="2-data-validation"><a class="header" href="#2-data-validation">2. Data Validation</a></h3>
<pre><code class="language-rust ignore">fn validate_account_data&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    validate_fn: impl Fn(&amp;T) -&gt; bool,
) -&gt; ProgramResult {
    // Load and validate account data
    let data = T::load(account)?;
    if !validate_fn(&amp;data) {
        return Err(ProgramError::InvalidAccountData);
    }
    Ok(())
}</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="1-account-management"><a class="header" href="#1-account-management">1. Account Management</a></h3>
<ul>
<li>Always validate account ownership before modifications</li>
<li>Use PDAs for deterministic addresses</li>
<li>Implement proper error handling</li>
<li>Close unused accounts to reclaim rent</li>
</ul>
<h3 id="2-data-safety"><a class="header" href="#2-data-safety">2. Data Safety</a></h3>
<ul>
<li>Validate all input data</li>
<li>Use proper serialization</li>
<li>Handle account size limits</li>
<li>Implement atomic operations</li>
</ul>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<ul>
<li>Minimize account creations</li>
<li>Batch operations when possible</li>
<li>Use appropriate data structures</li>
<li>Cache frequently accessed data</li>
</ul>
<h3 id="4-upgrades"><a class="header" href="#4-upgrades">4. Upgrades</a></h3>
<ul>
<li>Plan for version management</li>
<li>Implement migration strategies</li>
<li>Use flexible data structures</li>
<li>Document state changes</li>
</ul>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="1-account-initialization"><a class="header" href="#1-account-initialization">1. Account Initialization</a></h3>
<pre><code class="language-rust ignore">pub fn initialize_account&lt;T: AccountState&gt;(
    program_id: &amp;Pubkey,
    account: &amp;AccountInfo,
    initial_state: T,
) -&gt; ProgramResult {
    // Verify account is uninitialized
    if !account.data_is_empty() {
        return Err(ProgramError::AccountAlreadyInitialized);
    }
    
    // Set account owner
    account.set_owner(program_id)?;
    
    // Initialize state
    initial_state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="2-account-updates"><a class="header" href="#2-account-updates">2. Account Updates</a></h3>
<pre><code class="language-rust ignore">pub fn update_account&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    update_fn: impl FnOnce(&amp;mut T) -&gt; ProgramResult,
) -&gt; ProgramResult {
    // Load current state
    let mut state = T::load(account)?;
    
    // Apply update
    update_fn(&amp;mut state)?;
    
    // Save updated state
    state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="3-account-closure"><a class="header" href="#3-account-closure">3. Account Closure</a></h3>
<pre><code class="language-rust ignore">pub fn close_account(
    account: &amp;AccountInfo,
    destination: &amp;AccountInfo,
) -&gt; ProgramResult {
    // Transfer lamports
    let dest_starting_lamports = destination.lamports();
    **destination.lamports.borrow_mut() = dest_starting_lamports
        .checked_add(account.lamports())
        .ok_or(ProgramError::Overflow)?;
    **account.lamports.borrow_mut() = 0;
    
    // Clear data
    account.data.borrow_mut().fill(0);
    
    Ok(())
}</code></pre>
<h2 id="related-topics-2"><a class="header" href="#related-topics-2">Related Topics</a></h2>
<ul>
<li><a href="program/./utxo.html">UTXOs</a> - How UTXOs integrate with accounts</li>
<li><a href="program/./program.html">Programs</a> - Programs that own and modify accounts</li>
<li><a href="program/./instructions-and-messages.html">Instructions</a> - How to interact with accounts</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructions-and-messages"><a class="header" href="#instructions-and-messages">Instructions and Messages</a></h1>
<p>Instructions and messages are fundamental components of Arch‚Äôs transaction processing system that enable communication between clients and <a href="program/./program.html">programs</a>. They form the basis for all state changes and interactions within the Arch network.</p>
<h3 id="instructions-2"><a class="header" href="#instructions-2">Instructions</a></h3>
<p>An instruction is the basic unit of program execution in Arch. It contains all the information needed for a <a href="program/./program.html">program</a> to execute a specific operation. Instructions are processed atomically, meaning they either complete entirely or have no effect.</p>
<h4 id="structure"><a class="header" href="#structure">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Instruction {
    /// Program ID that executes this instruction
    pub program_id: Pubkey,
    /// Accounts required for this instruction
    pub accounts: Vec&lt;AccountMeta&gt;,
    /// Instruction data
    pub data: Vec&lt;u8&gt;,
}</code></pre>
<h4 id="components-1"><a class="header" href="#components-1">Components:</a></h4>
<ol>
<li><strong>Program ID</strong>: The <a href="program/./pubkey.html">pubkey</a> of the <a href="program/./program.html">program</a> that will process the instruction</li>
<li><strong>Accounts</strong>: List of accounts required for the instruction, with their metadata</li>
<li><strong>Instruction Data</strong>: Custom data specific to the instruction, typically serialized using Borsh or another format</li>
</ol>
<h4 id="account-metadata"><a class="header" href="#account-metadata">Account Metadata</a></h4>
<pre><code class="language-rust ignore">pub struct AccountMeta {
    pub pubkey: Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
}</code></pre>
<ul>
<li><code>pubkey</code>: The account‚Äôs public key</li>
<li><code>is_signer</code>: Whether the account must sign the transaction</li>
<li><code>is_writable</code>: Whether the account‚Äôs data can be modified</li>
</ul>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>A message is a collection of instructions that form a <a href="program/./transaction.html">transaction</a>. Messages ensure atomic execution of multiple instructions, meaning either all instructions succeed or none take effect.</p>
<h4 id="structure-1"><a class="header" href="#structure-1">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Message {
    /// List of account keys referenced by the instructions
    pub account_keys: Vec&lt;Pubkey&gt;,
    /// Recent blockhash
    pub recent_blockhash: Hash,
    /// List of instructions to execute
    pub instructions: Vec&lt;CompiledInstruction&gt;,
}</code></pre>
<h4 id="components-2"><a class="header" href="#components-2">Components:</a></h4>
<ol>
<li><strong>Account Keys</strong>: All unique accounts referenced across instructions</li>
<li><strong>Recent Blockhash</strong>: Used for transaction uniqueness and timeout</li>
<li><strong>Instructions</strong>: List of instructions to execute in sequence</li>
</ol>
<h3 id="instruction-processing-flow"><a class="header" href="#instruction-processing-flow">Instruction Processing Flow:</a></h3>
<ol>
<li>
<p>Client creates an instruction with:</p>
<ul>
<li><a href="program/./program.html">Program</a> ID to execute the instruction</li>
<li>Required accounts with appropriate permissions</li>
<li>Instruction-specific data (serialized parameters)</li>
</ul>
</li>
<li>
<p>Instruction(s) are bundled into a message:</p>
<ul>
<li>Multiple instructions can be atomic</li>
<li>Account permissions are consolidated</li>
<li>Blockhash is included for uniqueness</li>
</ul>
</li>
<li>
<p>Message is signed to create a <a href="program/./transaction.html">transaction</a>:</p>
<ul>
<li>All required signers must sign</li>
<li>Transaction size limits apply</li>
<li>Fees are calculated</li>
</ul>
</li>
<li>
<p>Transaction is sent to the network:</p>
<ul>
<li>Validated by validators</li>
<li>Processed in parallel when possible</li>
<li>Results are confirmed</li>
</ul>
</li>
<li>
<p>Program processes the instruction:</p>
<ul>
<li>Deserializes instruction data</li>
<li>Validates accounts and permissions</li>
<li>Executes operation</li>
<li>Updates account state</li>
</ul>
</li>
</ol>
<h3 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices:</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account permissions</li>
<li>Validate account relationships</li>
</ul>
</li>
<li>
<p><strong>Data Serialization</strong></p>
<ul>
<li>Use consistent serialization format (preferably Borsh)</li>
<li>Include version information</li>
<li>Handle errors gracefully</li>
<li>Validate data lengths</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Return specific error types</li>
<li>Provide clear error messages</li>
<li>Handle all edge cases</li>
<li>Implement proper cleanup</li>
</ul>
</li>
</ol>
<h3 id="cross-program-invocation-cpi-1"><a class="header" href="#cross-program-invocation-cpi-1">Cross-Program Invocation (CPI)</a></h3>
<p>Instructions can invoke other <a href="program/./program.html">programs</a> through CPI, enabling composability:</p>
<ol>
<li>
<p>Create new instruction for target program:</p>
<ul>
<li>Specify program ID</li>
<li>Include required accounts</li>
<li>Prepare instruction data</li>
</ul>
</li>
<li>
<p>Pass required accounts:</p>
<ul>
<li>Include all necessary accounts</li>
<li>Set proper permissions</li>
<li>Handle PDA derivation</li>
</ul>
</li>
<li>
<p>Invoke using <code>invoke</code> or <code>invoke_signed</code>:</p>
<ul>
<li>For regular accounts: <code>invoke</code></li>
<li>For PDAs: <code>invoke_signed</code></li>
<li>Handle return values</li>
</ul>
</li>
<li>
<p>Handle results:</p>
<ul>
<li>Check return status</li>
<li>Process any returned data</li>
<li>Handle errors appropriately</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-5"><a class="header" href="#security-considerations-5">Security Considerations:</a></h3>
<ol>
<li>
<p><strong>Account Verification</strong></p>
<ul>
<li>Verify all account permissions</li>
<li>Check ownership and signatures</li>
<li>Validate account relationships</li>
<li>Prevent privilege escalation</li>
</ul>
</li>
<li>
<p><strong>Data Validation</strong></p>
<ul>
<li>Sanitize all input data</li>
<li>Check buffer lengths</li>
<li>Validate numerical ranges</li>
<li>Prevent integer overflow</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Maintain atomic operations</li>
<li>Handle partial failures</li>
<li>Prevent race conditions</li>
<li>Ensure consistent state</li>
</ul>
</li>
</ol>
<h3 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns:</a></h3>
<ol>
<li>
<p><strong>Initialization</strong></p>
<ul>
<li>Create necessary accounts</li>
<li>Set initial state</li>
<li>Assign proper ownership</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Validate permissions</li>
<li>Update account data</li>
<li>Maintain invariants</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close accounts when done</li>
<li>Manage PDAs properly</li>
</ul>
</li>
</ol>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscalls"><a class="header" href="#syscalls">Syscalls</a></h1>
<p>A syscall is a function that can be used to obtain information from the underlying virtual machine.</p>
<pre><code class="language-rust ignore">// Used for cross-program invocation (CPI)

// Invokes a cross-program call
define_syscall!(fn sol_invoke_signed_rust(instruction_addr: *const u8, account_infos_addr: *const u8, account_infos_len: u64) -&gt; u64);

// Sets the data to be returned for the cross-program invocation
define_syscall!(fn sol_set_return_data(data: *const u8, length: u64));

// Returns the cross-program invocation data
define_syscall!(fn sol_get_return_data(data: *mut u8, length: u64, program_id: *mut Pubkey) -&gt; u64);

// Arch

// Validates and sets up transaction for being signed
define_syscall!(fn arch_set_transaction_to_sign(transaction_to_sign: *const TransactionToSign));

// Retrieves raw Bitcoin transaction from RPC and copies into memory buffer
define_syscall!(fn arch_get_bitcoin_tx(data: *mut u8, length: u64, txid: &amp;[u8; 32]) -&gt; u64);

// Retrieves the multi-sig public key and copies into memory buffer
define_syscall!(fn arch_get_network_xonly_pubkey(data: *mut u8) -&gt; u64);

// Validates ownership of a Bitcoin UTXO against a public key
define_syscall!(fn arch_validate_utxo_ownership(utxo: *const UtxoMeta, owner: *const Pubkey) -&gt; u64);

// Generates a Bitcoin script public key and copies into memory buffer
define_syscall!(fn arch_get_account_script_pubkey(script: *mut u8, pubkey: *const Pubkey) -&gt; u64);

// Retrieves the latest Bitcoin block height
define_syscall!(fn arch_get_bitcoin_block_height() -&gt; u64);

// logs

// Prints the hexidecimal representation of a string slice to stdout
define_syscall!(fn sol_log_(message: *const u8, len: u64));

// Prints 64-bit values represented as hexadecimal to stdout
define_syscall!(fn sol_log_64_(arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64));

// Prints the hexidecimal representation of a public key to stdout
define_syscall!(fn sol_log_pubkey(pubkey_addr: *const u8));

// Prints the base64 representation of a data array to stdout
define_syscall!(fn sol_log_data(data: *const u8, data_len: u64));</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/syscalls/definitions.rs">syscalls/definition.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Let‚Äôs introduce the nodes that comprise the Arch Network stack in greater detail.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Bootnode</a></p>
<div style="display: flex; align-items: flex-start; gap: 20px;">
<div>
The bootnode works similarly to DNS seeds in Bitcoin whereby the server handles the first connection to nodes joining the Arch Network.
</div>
<img src="concepts/../images/bootnode.png" alt="Bootnode" style="width: 200px; flex-shrink: 0;" />
</div>
<p><a href="https://github.com/Arch-Network/arch-node">Leader</a></p>
<p>All signing is coordinated by the leader. Ultimately, the leader submits signed Bitcoin transactions to the Bitcoin network following program execution.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Validator</a></p>
<p>This node represents a generic node operated by another party. It performs the validator role and has a share in the network‚Äôs distributed signing key. The leader node passes transactions to validator nodes to validate and sign. After enough signatures have been collected (a threshold has been met), the leader can then submit a fully signed Bitcoin transaction to the Bitcoin network.</p>
<p>The validator node also runs the <a href="https://ebpf.io/">eBPF</a> virtual machine and executes the transactions asynchronously alongside the other validator nodes in the network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a></p>
<p>This validator is a lightweight server that only serves as an RPC for developers to get up and running quickly with the least amount of overhead. It simulates a single-node blockchain environment that is meant for efficient, rapid development.</p>
<blockquote>
<p>Note: the <a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a> node uses the same image as the <a href="https://github.com/Arch-Network/arch-node">Validator</a> node though operates singularly for maximum efficiency. You can start a lightweight validator using the <code>arch-cli validator start</code> command.</p>
</blockquote>
<p>More can be read about the Arch Network architecture in our <a href="https://docs.arch.network">docs</a>.</p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-reference"><a class="header" href="#sdk-reference">SDK Reference</a></h1>
<p>The Arch Network ecosystem provides two distinct SDKs for building applications. Each SDK serves different use cases and development environments. This page will help you choose the right SDK for your project.</p>
<h2 id="available-sdks"><a class="header" href="#available-sdks">Available SDKs</a></h2>
<h3 id="1-typescript-sdk-by-saturn"><a class="header" href="#1-typescript-sdk-by-saturn">1. TypeScript SDK (by Saturn)</a></h3>
<p>The <strong>TypeScript SDK</strong> is developed and maintained by Saturn (@saturnbtc) and provides a comprehensive JavaScript/TypeScript interface for interacting with the Arch Network.</p>
<p><strong>Package</strong>: <code>@saturnbtcio/arch-sdk</code><br />
<strong>Repository</strong>: <a href="https://github.com/saturnbtc/arch-typescript-sdk">arch-typescript-sdk</a><br />
<strong>Language</strong>: TypeScript/JavaScript<br />
<strong>Best for</strong>:</p>
<ul>
<li>Frontend applications (React, Vue, Angular)</li>
<li>Node.js backend services</li>
<li>Web3 applications</li>
<li>Rapid prototyping</li>
<li>JavaScript/TypeScript developers</li>
</ul>
<h3 id="2-rust-sdk"><a class="header" href="#2-rust-sdk">2. Rust SDK</a></h3>
<p>The <strong>Rust SDK</strong> is the native SDK included in the main Arch Network repository. It provides low-level access to all network features and is used for building high-performance applications and programs.</p>
<p><strong>Package</strong>: <code>arch_sdk</code><br />
<strong>Repository</strong>: Part of <a href="https://github.com/Arch-Network/arch-network">arch-network</a><br />
<strong>Language</strong>: Rust<br />
<strong>Best for</strong>:</p>
<ul>
<li>On-chain programs (smart contracts)</li>
<li>High-performance applications</li>
<li>System-level integrations</li>
<li>Validator/node development</li>
<li>Rust developers</li>
</ul>
<h2 id="choosing-the-right-sdk"><a class="header" href="#choosing-the-right-sdk">Choosing the Right SDK</a></h2>
<h3 id="use-the-typescript-sdk-when"><a class="header" href="#use-the-typescript-sdk-when">Use the TypeScript SDK when:</a></h3>
<ul>
<li>Building web applications or dApps</li>
<li>Working with Node.js backends</li>
<li>Integrating Arch Network into existing JavaScript projects</li>
<li>You need quick development cycles</li>
<li>Your team is more familiar with JavaScript/TypeScript</li>
</ul>
<h3 id="use-the-rust-sdk-when"><a class="header" href="#use-the-rust-sdk-when">Use the Rust SDK when:</a></h3>
<ul>
<li>Writing on-chain programs for Arch Network</li>
<li>Building high-performance applications</li>
<li>Developing system-level tools or validators</li>
<li>You need maximum control and efficiency</li>
<li>Your team is comfortable with Rust</li>
</ul>
<h2 id="quick-start-comparison"><a class="header" href="#quick-start-comparison">Quick Start Comparison</a></h2>
<h3 id="typescript-sdk-installation"><a class="header" href="#typescript-sdk-installation">TypeScript SDK Installation</a></h3>
<pre><code class="language-bash">npm install @saturnbtcio/arch-sdk
# or
yarn add @saturnbtcio/arch-sdk
</code></pre>
<h3 id="rust-sdk-installation"><a class="header" href="#rust-sdk-installation">Rust SDK Installation</a></h3>
<pre><code class="language-toml"># In your Cargo.toml
[dependencies]
arch_sdk = "0.5.4"
</code></pre>
<h3 id="basic-connection-example"><a class="header" href="#basic-connection-example">Basic Connection Example</a></h3>
<p><strong>TypeScript SDK:</strong></p>
<pre><code class="language-typescript">import { Connection, Keypair } from '@saturnbtcio/arch-sdk';

const connection = new Connection('http://localhost:9002');
const keypair = Keypair.generate();

const isReady = await connection.isNodeReady();
console.log('Node ready:', isReady);
</code></pre>
<p><strong>Rust SDK:</strong></p>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Keypair};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let connection = Connection::new("http://localhost:9002");
    let keypair = Keypair::new();
    
    let is_ready = connection.is_node_ready().await?;
    println!("Node ready: {}", is_ready);
    
    Ok(())
}</code></pre>
<h2 id="documentation-structure"><a class="header" href="#documentation-structure">Documentation Structure</a></h2>
<h3 id="typescript-sdk-documentation"><a class="header" href="#typescript-sdk-documentation">TypeScript SDK Documentation</a></h3>
<ul>
<li><a href="sdk/typescript/getting-started.html">Getting Started with TypeScript SDK</a></li>
<li><a href="sdk/typescript/api-reference.html">TypeScript API Reference</a></li>
<li><a href="sdk/typescript/examples.html">TypeScript Examples</a></li>
<li><a href="sdk/typescript/web3-integration.html">Web3 Integration Guide</a></li>
</ul>
<h3 id="rust-sdk-documentation"><a class="header" href="#rust-sdk-documentation">Rust SDK Documentation</a></h3>
<ul>
<li><a href="sdk/rust/getting-started.html">Getting Started with Rust SDK</a></li>
<li><a href="sdk/rust/api-reference.html">Rust API Reference</a></li>
<li><a href="sdk/rust/program-development.html">Program Development Guide</a></li>
<li><a href="sdk/rust/examples.html">Rust Examples</a></li>
</ul>
<h3 id="shared-concepts"><a class="header" href="#shared-concepts">Shared Concepts</a></h3>
<p>These concepts apply to both SDKs:</p>
<ul>
<li><a href="sdk/pubkey.html">Pubkey</a> - Public key type for identifying accounts</li>
<li><a href="sdk/account.html">Account</a> - Account structure and management</li>
<li><a href="sdk/instructions-and-messages.html">Instructions and Messages</a> - Transaction building</li>
<li><a href="sdk/runtime-transaction.html">Runtime Transaction</a> - Transaction format</li>
<li><a href="sdk/processed-transaction.html">Processed Transaction</a> - Transaction results</li>
<li><a href="sdk/signature.html">Signature</a> - Digital signatures</li>
</ul>
<h2 id="feature-comparison"><a class="header" href="#feature-comparison">Feature Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>TypeScript SDK</th><th>Rust SDK</th></tr></thead><tbody>
<tr><td>Language</td><td>TypeScript/JavaScript</td><td>Rust</td></tr>
<tr><td>Installation</td><td>npm/yarn</td><td>Cargo</td></tr>
<tr><td>Async Support</td><td>Promises/async-await</td><td>Tokio async</td></tr>
<tr><td>Program Development</td><td>Client-side only</td><td>Full support</td></tr>
<tr><td>Browser Support</td><td>‚úÖ Full</td><td>‚ùå No</td></tr>
<tr><td>Node.js Support</td><td>‚úÖ Full</td><td>‚úÖ Full</td></tr>
<tr><td>Performance</td><td>Good</td><td>Excellent</td></tr>
<tr><td>Type Safety</td><td>TypeScript types</td><td>Rust type system</td></tr>
<tr><td>Bundle Size</td><td>~200KB</td><td>N/A</td></tr>
<tr><td>Learning Curve</td><td>Moderate</td><td>Steep</td></tr>
</tbody></table>
</div>
<h2 id="migration-between-sdks"><a class="header" href="#migration-between-sdks">Migration Between SDKs</a></h2>
<p>While both SDKs interact with the same Arch Network, they have different APIs and patterns. Here are key differences to consider:</p>
<h3 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h3>
<ul>
<li><strong>TypeScript</strong>: Uses promise-based async patterns</li>
<li><strong>Rust</strong>: Uses Tokio-based async runtime</li>
</ul>
<h3 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h3>
<ul>
<li><strong>TypeScript</strong>: Try-catch with custom error types</li>
<li><strong>Rust</strong>: Result&lt;T, E&gt; pattern with detailed error types</li>
</ul>
<h3 id="data-serialization"><a class="header" href="#data-serialization">Data Serialization</a></h3>
<ul>
<li><strong>TypeScript</strong>: JSON and Buffer-based serialization</li>
<li><strong>Rust</strong>: Borsh and custom serialization</li>
</ul>
<h2 id="getting-help-3"><a class="header" href="#getting-help-3">Getting Help</a></h2>
<h3 id="typescript-sdk-support"><a class="header" href="#typescript-sdk-support">TypeScript SDK Support</a></h3>
<ul>
<li><strong>Issues</strong>: <a href="https://github.com/saturnbtc/arch-typescript-sdk/issues">Saturn SDK GitHub Issues</a></li>
<li><strong>Documentation</strong>: <a href="sdk/typescript/getting-started.html">TypeScript SDK Docs</a></li>
<li><strong>Examples</strong>: <a href="https://github.com/saturnbtc/arch-typescript-sdk/tree/main/examples">TypeScript Examples</a></li>
</ul>
<h3 id="rust-sdk-support"><a class="header" href="#rust-sdk-support">Rust SDK Support</a></h3>
<ul>
<li><strong>Issues</strong>: <a href="https://github.com/arch-network/arch-network/issues">Arch Network GitHub Issues</a></li>
<li><strong>Documentation</strong>: <a href="sdk/rust/getting-started.html">Rust SDK Docs</a></li>
<li><strong>Examples</strong>: <a href="https://github.com/arch-network/arch-network/examples">Rust Examples</a></li>
</ul>
<h3 id="general-support"><a class="header" href="#general-support">General Support</a></h3>
<ul>
<li><strong>Discord</strong>: <a href="https://discord.gg/archnetwork">Arch Network Discord</a></li>
<li><strong>Forum</strong>: <a href="https://forum.arch.network">Arch Network Forum</a></li>
<li><strong>Stack Overflow</strong>: Tag with <code>arch-network</code></li>
</ul>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>Choose your SDK and get started:</p>
<ul>
<li><strong><a href="sdk/typescript/getting-started.html">Get Started with TypeScript SDK ‚Üí</a></strong></li>
<li><strong><a href="sdk/rust/getting-started.html">Get Started with Rust SDK ‚Üí</a></strong></li>
</ul>
<p>For a general introduction to Arch Network concepts, visit our <a href="sdk/../getting-started/quick-start.html">Getting Started Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-the-typescript-sdk"><a class="header" href="#getting-started-with-the-typescript-sdk">Getting Started with the TypeScript SDK</a></h1>
<p>This guide will walk you through setting up and using the Arch Network TypeScript SDK (developed by Saturn) to build your first application.</p>
<blockquote>
<p><strong>Note</strong>: The Arch TypeScript SDK is a low-level SDK that provides direct RPC access to Arch nodes. It does not include high-level abstractions like transaction builders or wallet management.</p>
</blockquote>
<h2 id="prerequisites-8"><a class="header" href="#prerequisites-8">Prerequisites</a></h2>
<ul>
<li><strong>Node.js 16+</strong> and npm or yarn</li>
<li><strong>Basic understanding</strong> of blockchain concepts and JavaScript/TypeScript</li>
<li><strong>Arch Network node</strong> running locally or access to a remote node</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="create-a-new-project"><a class="header" href="#create-a-new-project">Create a New Project</a></h3>
<pre><code class="language-bash"># Create a new project
mkdir my-arch-app
cd my-arch-app
npm init -y

# Install the Saturn TypeScript SDK
npm install @saturnbtcio/arch-sdk

# Install TypeScript (optional but recommended)
npm install -D typescript @types/node
npx tsc --init
</code></pre>
<h3 id="for-existing-projects"><a class="header" href="#for-existing-projects">For Existing Projects</a></h3>
<pre><code class="language-bash"># Using npm
npm install @saturnbtcio/arch-sdk

# Using yarn
yarn add @saturnbtcio/arch-sdk

# Using pnpm
pnpm add @saturnbtcio/arch-sdk
</code></pre>
<h2 id="your-first-connection"><a class="header" href="#your-first-connection">Your First Connection</a></h2>
<p>Create a file named <code>connect.ts</code> (or <code>connect.js</code> for JavaScript):</p>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function main() {
  // Connect to local validator
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    console.log('üîå Connecting to Arch node at http://localhost:9002...\n');
    
    // Get current block count
    const blockCount = await connection.getBlockCount();
    console.log('‚úì Current block count:', blockCount);
    
    // Get best block hash
    const bestBlockHash = await connection.getBestBlockHash();
    console.log('‚úì Best block hash:', bestBlockHash);
    
    // Get block hash for a specific height
    if (blockCount &gt; 0) {
      const blockHeight = blockCount - 1;
      const blockHash = await connection.getBlockHash(blockHeight);
      console.log(`‚úì Block hash at height ${blockHeight}:`, blockHash);
    }
    
    console.log('\n‚úÖ Successfully connected to Arch node!');
    console.log('üìä Network is active with', blockCount, 'blocks');
    
  } catch (error) {
    console.error('‚ùå Error connecting to Arch node:', error);
    console.log('\nüí° Make sure your Arch node is running at http://localhost:9002');
    console.log('   You can start it with: arch-node --network=testnet');
  }
}

// Run the main function
main().catch(console.error);
</code></pre>
<p>Run the script:</p>
<pre><code class="language-bash"># TypeScript
npx ts-node connect.ts

# JavaScript
node connect.js
</code></pre>
<p>Example output:</p>
<pre><code class="language-text">Connecting to Arch node at http://localhost:9002...

‚úì Current block count: 57230
‚úì Best block hash: 349e8a42cdc98d05d427ba8fe8efcfd13e875591f1f1f111960a991f3add8105
‚úì Block hash at height 57229: 349e8a42cdc98d05d427ba8fe8efcfd13e875591f1f1f111960a991f3add8105

‚úÖ Successfully connected to Arch node!
üìä Network is active with 57230 blocks
</code></pre>
<h2 id="creating-accounts"><a class="header" href="#creating-accounts">Creating Accounts</a></h2>
<p>The SDK provides utilities for creating accounts using secp256k1 cryptography:</p>
<pre><code class="language-typescript">import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

async function createAccount() {
  const connection = new RpcConnection('http://localhost:9002');
  const arch = ArchConnection(connection);
  
  // Create a new account
  const account = await arch.createNewAccount();
  
  console.log('üîë New Account Created:');
  console.log('Private Key:', account.privkey);
  console.log('Public Key:', account.pubkey);
  console.log('Address:', account.address);
  
  return account;
}

createAccount().catch(console.error);
</code></pre>
<h3 id="create-account-with-faucet-funding"><a class="header" href="#create-account-with-faucet-funding">Create Account with Faucet Funding</a></h3>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';
import { randomBytes } from 'node:crypto';

// Helper function to wait for a specified time
const wait = (ms: number) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

async function createAndFundAccount() {
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    console.log('üîå Connecting to Arch node...\n');
    
    // Check the current block height
    const initialBlockCount = await connection.getBlockCount();
    console.log('üìä Current block height:', initialBlockCount);
    
    // Generate a random 32-byte public key
    const pubkey = randomBytes(32);
    console.log('üîë Generated public key:', pubkey.toString('hex'));
    
    // Create account with faucet
    console.log('\nüí∞ Step 1: Creating account with faucet...');
    await connection.createAccountWithFaucet(pubkey);
    console.log('‚úÖ Faucet account creation initiated');
    
    // Get the Arch address
    const archAddress = await connection.getAccountAddress(pubkey);
    console.log('üìç Arch address:', archAddress);
    
    // Request airdrop to fund the account
    console.log('\nüí∞ Step 2: Requesting airdrop...');
    await connection.requestAirdrop(pubkey);
    console.log('‚úÖ Airdrop requested');
    
    // Wait for account to be created and funded
    console.log('\n‚è≥ Waiting for account to be confirmed on chain...');
    console.log('   (This may take 5-10 seconds)');
    
    let accountFound = false;
    const maxAttempts = 6;
    
    for (let attempt = 1; attempt &lt;= maxAttempts; attempt++) {
      const waitTime = attempt * 2000; // Increase wait time each attempt
      console.log(`\nüîÑ Attempt ${attempt}/${maxAttempts}: Waiting ${waitTime / 1000} seconds...`);
      await wait(waitTime);
      
      // Check block progress
      const currentBlockCount = await connection.getBlockCount();
      console.log(`üìà Blocks produced: ${currentBlockCount - initialBlockCount}`);
      
      try {
        const accountInfo = await connection.readAccountInfo(pubkey);
        console.log('\n‚úÖ Account successfully created and funded!');
        console.log('\nüìä Account Details:');
        console.log('   Address:', archAddress);
        console.log('   Full info:', JSON.stringify(accountInfo, null, 2));
        
        // Access properties safely
        const info = accountInfo as any;
        if (info.lamports !== undefined) {
          console.log('   Balance:', info.lamports, 'lamports');
        }
        if (info.owner) {
          console.log('   Owner:', Buffer.from(Object.values(info.owner)).toString('hex'));
        }
        if (info.utxo) {
          console.log('   UTXO:', info.utxo);
        }
        if (info.is_executable !== undefined) {
          console.log('   Executable:', info.is_executable);
        }
        
        accountFound = true;
        break;
      } catch (error) {
        if (attempt === maxAttempts) {
          console.log('‚ùå Account not found after maximum attempts');
        } else {
          console.log('‚è≥ Account not ready yet, continuing to wait...');
        }
      }
    }
    
    if (accountFound) {
      console.log('\nüéâ Success! Your Arch account is ready to use.');
      console.log('üí° You can now:');
      console.log('   - Send transactions from this account');
      console.log('   - Interact with Arch programs');
      console.log('   - Deploy smart contracts');
      console.log('\nüìù Save these for future reference:');
      console.log('   Pubkey:', pubkey.toString('hex'));
      console.log('   Address:', archAddress);
    }
    
  } catch (error) {
    console.error('‚ùå Error:', error);
    console.log('\nüí° Troubleshooting:');
    console.log('   - Make sure your Arch node is running at http://localhost:9002');
    console.log('   - Ensure the node has faucet functionality enabled');
    console.log('   - Check that the node is syncing and producing blocks');
  }
}

createAndFundAccount();
</code></pre>
<h2 id="reading-account-information"><a class="header" href="#reading-account-information">Reading Account Information</a></h2>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function readAccount() {
  const connection = new RpcConnection('http://localhost:9002');
  
  // Example: System program pubkey (32 zero bytes with last byte as 1)
  const systemProgramPubkey = new Uint8Array(32);
  systemProgramPubkey[31] = 1;
  
  try {
    const accountInfo = await connection.readAccountInfo(systemProgramPubkey);
    console.log('Account Info:', accountInfo);
    
    // Get account address
    const address = await connection.getAccountAddress(systemProgramPubkey);
    console.log('Account Address:', address);
  } catch (error) {
    console.error('Error reading account:', error);
  }
}
</code></pre>
<h2 id="working-with-messages-and-instructions"><a class="header" href="#working-with-messages-and-instructions">Working with Messages and Instructions</a></h2>
<p>The SDK uses a low-level message format for transactions:</p>
<pre><code class="language-typescript">import { RpcConnection, InstructionUtil, MessageUtil, PubkeyUtil } from '@saturnbtcio/arch-sdk';
import type { Message, Instruction } from '@saturnbtcio/arch-sdk';

// Create a simple instruction
const instruction: Instruction = {
  program_id: PubkeyUtil.systemProgram(), // Returns system program pubkey
  accounts: [
    {
      pubkey: new Uint8Array(32), // Your account pubkey
      is_signer: true,
      is_writable: true,
    },
  ],
  data: new Uint8Array([1, 2, 3, 4]), // Instruction data
};

// Create a message
const message: Message = {
  signers: [new Uint8Array(32)], // Array of signer pubkeys
  instructions: [instruction],
};

// Serialize the message for sending
const serializedMessage = MessageUtil.serialize(message);
console.log('Serialized message:', serializedMessage);
</code></pre>
<h2 id="sending-transactions"><a class="header" href="#sending-transactions">Sending Transactions</a></h2>
<p>To send transactions, you need to create a <code>RuntimeTransaction</code>:</p>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';
import type { RuntimeTransaction, SanitizedMessage } from '@saturnbtcio/arch-sdk';

async function sendTransaction() {
  const connection = new RpcConnection('http://localhost:9002');
  
  // Note: Creating valid transactions requires proper message construction
  // and cryptographic signatures. This is a simplified example.
  
  const sanitizedMessage: SanitizedMessage = {
    header: {
      num_required_signatures: 1,
      num_readonly_signed_accounts: 0,
      num_readonly_unsigned_accounts: 0,
    },
    account_keys: [
      new Uint8Array(32), // Signer pubkey
      PubkeyUtil.systemProgram(), // System program
    ],
    recent_blockhash: new Uint8Array(32), // Recent blockhash
    instructions: [
      {
        program_id_index: 1, // Index into account_keys
        accounts: [0], // Indexes into account_keys
        data: new Uint8Array([1, 2, 3, 4]),
      },
    ],
  };
  
  const transaction: RuntimeTransaction = {
    version: 0,
    signatures: [new Uint8Array(64)], // 64-byte signatures
    message: sanitizedMessage,
  };
  
  try {
    const txId = await connection.sendTransaction(transaction);
    console.log('Transaction sent:', txId);
  } catch (error) {
    console.error('Error sending transaction:', error);
  }
}
</code></pre>
<h2 id="querying-blocks"><a class="header" href="#querying-blocks">Querying Blocks</a></h2>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function queryBlocks() {
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    // Get the latest block
    const bestBlockHash = await connection.getBestBlockHash();
    const block = await connection.getBlock(bestBlockHash);
    
    if (block) {
      console.log('Block:', block);
      console.log('Number of transactions:', block.transactions?.length || 0);
    }
  } catch (error) {
    console.error('Error querying blocks:', error);
  }
}
</code></pre>
<h2 id="get-processed-transaction"><a class="header" href="#get-processed-transaction">Get Processed Transaction</a></h2>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function getTransaction(txId: string) {
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    const processedTx = await connection.getProcessedTransaction(txId);
    
    if (processedTx) {
      console.log('Transaction found:', processedTx);
      console.log('Status:', processedTx.status);
    } else {
      console.log('Transaction not found');
    }
  } catch (error) {
    console.error('Error getting transaction:', error);
  }
}
</code></pre>
<h2 id="get-program-accounts"><a class="header" href="#get-program-accounts">Get Program Accounts</a></h2>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function getProgramAccounts() {
  const connection = new RpcConnection('http://localhost:9002');
  
  // Example: Get all accounts owned by a program
  const programId = new Uint8Array(32); // Your program ID
  
  try {
    const accounts = await connection.getProgramAccounts(programId);
    console.log(`Found ${accounts.length} accounts for program`);
    
    accounts.forEach((account, index) =&gt; {
      console.log(`Account ${index}:`, account);
    });
  } catch (error) {
    console.error('Error getting program accounts:', error);
  }
}
</code></pre>
<h2 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h2>
<p>The SDK provides several utility modules for working with Arch data structures:</p>
<pre><code class="language-typescript">import { 
  PubkeyUtil,
  MessageUtil,
  InstructionUtil,
  AccountUtil,
  SignatureUtil 
} from '@saturnbtcio/arch-sdk';

// Get system program pubkey
const systemProgram = PubkeyUtil.systemProgram();

// Work with public keys
const pubkeyBytes = new Uint8Array(32);
const pubkeyHex = PubkeyUtil.toHex(pubkeyBytes);
const pubkeyFromHex = PubkeyUtil.fromHex(pubkeyHex);

// Serialize/deserialize messages
const serializedMsg = MessageUtil.serialize(message);
const deserializedMsg = MessageUtil.deserialize(serializedMsg);
</code></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<p>The SDK provides custom error types:</p>
<pre><code class="language-typescript">import { RpcConnection, ArchRpcError } from '@saturnbtcio/arch-sdk';

async function handleErrors() {
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    await connection.getBlock('invalid-hash');
  } catch (error) {
    if (error instanceof ArchRpcError) {
      console.error('RPC Error:', error.error);
      console.error('Error code:', error.error.code);
      console.error('Error message:', error.error.message);
    } else {
      console.error('Unexpected error:', error);
    }
  }
}
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here‚Äôs a complete example showing how to connect and query the network:</p>
<pre><code class="language-typescript">import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

async function completeExample() {
  // 1. Setup connection
  const connection = new RpcConnection('http://localhost:9002');
  const arch = ArchConnection(connection);
  
  try {
    // 2. Get network info
    console.log('üìä Network Information:');
    const blockCount = await connection.getBlockCount();
    console.log('Block count:', blockCount);
    
    const bestBlockHash = await connection.getBestBlockHash();
    console.log('Best block hash:', bestBlockHash);
    
    // 3. Create a new account
    console.log('\nüîë Creating new account...');
    const account = await arch.createNewAccount();
    console.log('Address:', account.address);
    
    // 4. Get block information
    if (blockCount &gt; 0) {
      const blockHash = await connection.getBlockHash(blockCount - 1);
      const block = await connection.getBlock(blockHash);
      
      if (block) {
        console.log('\nüì¶ Latest block:');
        console.log('Hash:', blockHash);
        console.log('Transactions:', block.transactions?.length || 0);
      }
    }
    
    console.log('\n‚úÖ Example completed successfully!');
    
  } catch (error) {
    console.error('‚ùå Error:', error);
  }
}

completeExample().catch(console.error);
</code></pre>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h2>
<ol>
<li>
<p><strong>Low-Level SDK</strong>: This SDK provides low-level RPC access. High-level features like transaction building, wallet management, and program deployment helpers are not included.</p>
</li>
<li>
<p><strong>Message Construction</strong>: Creating valid transactions requires proper understanding of Arch‚Äôs message format and cryptographic signatures.</p>
</li>
<li>
<p><strong>Type Safety</strong>: The SDK is written in TypeScript and provides type definitions for all data structures.</p>
</li>
<li>
<p><strong>Error Handling</strong>: Always wrap RPC calls in try-catch blocks as network operations can fail.</p>
</li>
</ol>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li>Learn about <a href="sdk/typescript/../account.html">Arch‚Äôs account model</a></li>
<li>Understand <a href="sdk/typescript/../instructions-and-messages.html">message and instruction formats</a></li>
<li>Explore the <a href="sdk/typescript/../../rpc/rpc.html">RPC API</a> for all available methods</li>
<li>Check the <a href="https://github.com/saturnbtc/arch-typescript-sdk">TypeScript SDK source</a> for implementation details</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><strong>NPM Package</strong>: <a href="https://www.npmjs.com/package/@saturnbtcio/arch-sdk">@saturnbtcio/arch-sdk</a></li>
<li><strong>GitHub Repository</strong>: <a href="https://github.com/saturnbtc/arch-typescript-sdk">saturnbtc/arch-typescript-sdk</a></li>
<li><strong>Discord</strong>: <a href="https://discord.gg/archnetwork">Arch Network Discord</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-sdk-api-reference"><a class="header" href="#typescript-sdk-api-reference">TypeScript SDK API Reference</a></h1>
<p>This page provides a comprehensive API reference for the Arch Network TypeScript SDK developed by Saturn.</p>
<blockquote>
<p><strong>Note</strong>: The Arch TypeScript SDK is a low-level SDK that provides direct RPC access to Arch nodes. It does not include high-level abstractions like transaction builders or wallet management.</p>
</blockquote>
<h2 id="core-classes"><a class="header" href="#core-classes">Core Classes</a></h2>
<h3 id="rpcconnection"><a class="header" href="#rpcconnection">RpcConnection</a></h3>
<p>The main class for interacting with an Arch Network node via RPC.</p>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

const connection = new RpcConnection('http://localhost:9002');
</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<ul>
<li><code>sendTransaction(params: RuntimeTransaction): Promise&lt;string&gt;</code> - Send a transaction</li>
<li><code>sendTransactions(params: RuntimeTransaction[]): Promise&lt;string[]&gt;</code> - Send multiple transactions</li>
<li><code>readAccountInfo(pubkey: Pubkey): Promise&lt;AccountInfoResult&gt;</code> - Read account information</li>
<li><code>getAccountAddress(pubkey: Pubkey): Promise&lt;string&gt;</code> - Get account address from pubkey</li>
<li><code>getBestBlockHash(): Promise&lt;string&gt;</code> - Get the best block hash</li>
<li><code>getBlock(blockHash: string): Promise&lt;Block | undefined&gt;</code> - Get block by hash</li>
<li><code>getBlockCount(): Promise&lt;number&gt;</code> - Get current block count</li>
<li><code>getBlockHash(blockHeight: number): Promise&lt;string&gt;</code> - Get block hash by height</li>
<li><code>getProcessedTransaction(txid: string): Promise&lt;ProcessedTransaction | undefined&gt;</code> - Get transaction info</li>
<li><code>getProgramAccounts(programId: Pubkey, filters?: AccountFilter[]): Promise&lt;ProgramAccount[]&gt;</code> - Get program accounts</li>
<li><code>requestAirdrop(pubkey: Pubkey): Promise&lt;void&gt;</code> - Request airdrop (testnet only)</li>
<li><code>createAccountWithFaucet(pubkey: Pubkey): Promise&lt;void&gt;</code> - Create and fund account (testnet only)</li>
</ul>
<h3 id="archconnection"><a class="header" href="#archconnection">ArchConnection</a></h3>
<p>A wrapper that adds additional functionality to any Provider implementation.</p>
<pre><code class="language-typescript">import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

const connection = new RpcConnection('http://localhost:9002');
const arch = ArchConnection(connection);
</code></pre>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<ul>
<li><code>createNewAccount(): Promise&lt;CreatedAccount&gt;</code> - Create a new account with secp256k1 keypair</li>
</ul>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="pubkey"><a class="header" href="#pubkey">Pubkey</a></h3>
<pre><code class="language-typescript">type Pubkey = Uint8Array; // 32 bytes
</code></pre>
<h3 id="message"><a class="header" href="#message">Message</a></h3>
<pre><code class="language-typescript">interface Message {
  signers: Pubkey[];
  instructions: Instruction[];
}
</code></pre>
<h3 id="instruction"><a class="header" href="#instruction">Instruction</a></h3>
<pre><code class="language-typescript">interface Instruction {
  program_id: Pubkey;
  accounts: AccountMeta[];
  data: Uint8Array;
}
</code></pre>
<h3 id="accountmeta"><a class="header" href="#accountmeta">AccountMeta</a></h3>
<pre><code class="language-typescript">interface AccountMeta {
  pubkey: Pubkey;
  is_signer: boolean;
  is_writable: boolean;
}
</code></pre>
<h3 id="runtimetransaction"><a class="header" href="#runtimetransaction">RuntimeTransaction</a></h3>
<pre><code class="language-typescript">interface RuntimeTransaction {
  version: number;
  signatures: Signature[]; // Array of 64-byte signatures
  message: SanitizedMessage;
}
</code></pre>
<h3 id="sanitizedmessage"><a class="header" href="#sanitizedmessage">SanitizedMessage</a></h3>
<pre><code class="language-typescript">interface SanitizedMessage {
  header: MessageHeader;
  account_keys: Pubkey[];
  recent_blockhash: Uint8Array;
  instructions: SanitizedInstruction[];
}
</code></pre>
<h3 id="messageheader"><a class="header" href="#messageheader">MessageHeader</a></h3>
<pre><code class="language-typescript">interface MessageHeader {
  num_required_signatures: number;
  num_readonly_signed_accounts: number;
  num_readonly_unsigned_accounts: number;
}
</code></pre>
<h3 id="sanitizedinstruction"><a class="header" href="#sanitizedinstruction">SanitizedInstruction</a></h3>
<pre><code class="language-typescript">interface SanitizedInstruction {
  program_id_index: number;
  accounts: number[];
  data: Uint8Array;
}
</code></pre>
<h3 id="accountinforesult"><a class="header" href="#accountinforesult">AccountInfoResult</a></h3>
<pre><code class="language-typescript">interface AccountInfoResult {
  lamports: number;
  data: Uint8Array;
  owner: Pubkey;
  executable: boolean;
  rent_epoch: number;
}
</code></pre>
<h3 id="createdaccount"><a class="header" href="#createdaccount">CreatedAccount</a></h3>
<pre><code class="language-typescript">interface CreatedAccount {
  privkey: string; // Hex-encoded private key
  pubkey: string;  // Hex-encoded public key
  address: string; // Bitcoin-style address
}
</code></pre>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<pre><code class="language-typescript">interface Block {
  hash: string;
  previous_blockhash: string;
  parent_slot: number;
  transactions?: ProcessedTransaction[];
  block_time?: number;
  block_height?: number;
}
</code></pre>
<h3 id="processedtransaction"><a class="header" href="#processedtransaction">ProcessedTransaction</a></h3>
<pre><code class="language-typescript">interface ProcessedTransaction {
  txid: string;
  status: ProcessedTransactionStatus;
  bitcoin_txids: string[];
}

interface ProcessedTransactionStatus {
  Processed?: {
    runtime_transaction: RuntimeTransaction;
    execution_result: any;
    bitcoin_txids: string[];
  };
}
</code></pre>
<h2 id="utility-modules"><a class="header" href="#utility-modules">Utility Modules</a></h2>
<h3 id="pubkeyutil"><a class="header" href="#pubkeyutil">PubkeyUtil</a></h3>
<pre><code class="language-typescript">import { PubkeyUtil } from '@saturnbtcio/arch-sdk';

// Get system program pubkey
const systemProgram = PubkeyUtil.systemProgram();

// Convert to/from hex
const hex = PubkeyUtil.toHex(pubkey);
const pubkey = PubkeyUtil.fromHex(hex);
</code></pre>
<h3 id="messageutil"><a class="header" href="#messageutil">MessageUtil</a></h3>
<pre><code class="language-typescript">import { MessageUtil } from '@saturnbtcio/arch-sdk';

// Serialize/deserialize messages
const serialized = MessageUtil.serialize(message);
const message = MessageUtil.deserialize(serialized);
</code></pre>
<h3 id="sanitizedmessageutil"><a class="header" href="#sanitizedmessageutil">SanitizedMessageUtil</a></h3>
<pre><code class="language-typescript">import { SanitizedMessageUtil } from '@saturnbtcio/arch-sdk';

// Work with sanitized messages
const serialized = SanitizedMessageUtil.serialize(sanitizedMessage);
const sanitizedMessage = SanitizedMessageUtil.deserialize(serialized);
</code></pre>
<h3 id="instructionutil"><a class="header" href="#instructionutil">InstructionUtil</a></h3>
<pre><code class="language-typescript">import { InstructionUtil } from '@saturnbtcio/arch-sdk';

// Serialize/deserialize instructions
const serialized = InstructionUtil.serialize(instruction);
const instruction = InstructionUtil.deserialize(serialized);
</code></pre>
<h3 id="accountutil"><a class="header" href="#accountutil">AccountUtil</a></h3>
<pre><code class="language-typescript">import { AccountUtil } from '@saturnbtcio/arch-sdk';

// Work with account data
const serialized = AccountUtil.serialize(accountInfo);
const accountInfo = AccountUtil.deserialize(serialized);
</code></pre>
<h3 id="signatureutil"><a class="header" href="#signatureutil">SignatureUtil</a></h3>
<pre><code class="language-typescript">import { SignatureUtil } from '@saturnbtcio/arch-sdk';

// Signature utilities (implementation details vary)
</code></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="archrpcerror"><a class="header" href="#archrpcerror">ArchRpcError</a></h3>
<pre><code class="language-typescript">import { ArchRpcError } from '@saturnbtcio/arch-sdk';

try {
  await connection.getBlock('invalid-hash');
} catch (error) {
  if (error instanceof ArchRpcError) {
    console.error('RPC Error:', error.error);
    // error.error.code - Error code
    // error.error.message - Error message
  }
}
</code></pre>
<h2 id="schema-exports"><a class="header" href="#schema-exports">Schema Exports</a></h2>
<p>The SDK exports Borsh schemas for serialization:</p>
<ul>
<li><code>PubkeySchema</code></li>
<li><code>MessageSchema</code></li>
<li><code>SanitizedMessageSchema</code></li>
<li><code>InstructionSchema</code></li>
<li><code>SanitizedInstructionSchema</code></li>
<li><code>MessageHeaderSchema</code></li>
<li><code>UtxoMetaSchema</code></li>
</ul>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<h3 id="action"><a class="header" href="#action">Action</a></h3>
<pre><code class="language-typescript">import { Action } from '@saturnbtcio/arch-sdk';

// RPC action constants used internally
</code></pre>
<h2 id="complete-api-documentation"><a class="header" href="#complete-api-documentation">Complete API Documentation</a></h2>
<p>For the most up-to-date API reference and implementation details:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@saturnbtcio/arch-sdk">NPM Package</a></li>
<li><a href="https://github.com/saturnbtc/arch-typescript-sdk">GitHub Repository</a></li>
<li><a href="https://github.com/saturnbtc/arch-typescript-sdk/tree/main/src">Source Code</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript-sdk-examples"><a class="header" href="#typescript-sdk-examples">TypeScript SDK Examples</a></h1>
<p>This page provides practical examples of using the Arch Network TypeScript SDK (by Saturn) for common tasks.</p>
<blockquote>
<p><strong>Note</strong>: These examples demonstrate the low-level RPC API. The SDK does not include high-level abstractions like transaction builders or wallet management.</p>
</blockquote>
<h2 id="basic-examples"><a class="header" href="#basic-examples">Basic Examples</a></h2>
<h3 id="connecting-and-querying-network"><a class="header" href="#connecting-and-querying-network">Connecting and Querying Network</a></h3>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function networkExample() {
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    // Get network status
    const blockCount = await connection.getBlockCount();
    console.log('Current block count:', blockCount);
    
    // Get latest block
    const bestBlockHash = await connection.getBestBlockHash();
    const block = await connection.getBlock(bestBlockHash);
    
    if (block) {
      console.log('Latest block:', {
        hash: block.hash,
        height: block.block_height,
        transactions: block.transactions?.length || 0
      });
    }
  } catch (error) {
    console.error('Network error:', error);
  }
}
</code></pre>
<h3 id="account-management-2"><a class="header" href="#account-management-2">Account Management</a></h3>
<pre><code class="language-typescript">import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

async function accountExample() {
  const connection = new RpcConnection('http://localhost:9002');
  const arch = ArchConnection(connection);
  
  // Create a new account with private key
  const newAccount = await arch.createNewAccount();
  console.log('New account created:');
  console.log('  Private key:', newAccount.privkey);
  console.log('  Public key:', newAccount.pubkey);
  console.log('  Address:', newAccount.address);
  
  // Convert hex pubkey to Uint8Array for RPC calls
  const pubkeyBytes = new Uint8Array(
    newAccount.pubkey.match(/.{1,2}/g)!.map(byte =&gt; parseInt(byte, 16))
  );
  
  // Read account info
  try {
    const accountInfo = await connection.readAccountInfo(pubkeyBytes);
    console.log('Account info:', accountInfo);
  } catch (error) {
    console.log('Account not found (expected for new account)');
  }
}
</code></pre>
<h3 id="creating-and-funding-accounts"><a class="header" href="#creating-and-funding-accounts">Creating and Funding Accounts</a></h3>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function fundAccountExample() {
  const connection = new RpcConnection('http://localhost:9002');
  
  // Generate a random pubkey (in practice, derive from private key)
  const pubkey = new Uint8Array(32);
  crypto.getRandomValues(pubkey);
  
  try {
    // Create and fund account (testnet only)
    await connection.createAccountWithFaucet(pubkey);
    console.log('Account created and funded');
    
    // Read the funded account
    const accountInfo = await connection.readAccountInfo(pubkey);
    console.log('Account balance:', accountInfo.lamports);
  } catch (error) {
    console.error('Failed to create account:', error);
  }
}
</code></pre>
<h2 id="working-with-messages-and-instructions-1"><a class="header" href="#working-with-messages-and-instructions-1">Working with Messages and Instructions</a></h2>
<h3 id="creating-a-simple-message"><a class="header" href="#creating-a-simple-message">Creating a Simple Message</a></h3>
<pre><code class="language-typescript">import { MessageUtil, PubkeyUtil } from '@saturnbtcio/arch-sdk';
import type { Message, Instruction } from '@saturnbtcio/arch-sdk';

function createSimpleMessage() {
  // Create account pubkeys
  const signer = new Uint8Array(32);
  crypto.getRandomValues(signer);
  
  // Create an instruction
  const instruction: Instruction = {
    program_id: PubkeyUtil.systemProgram(),
    accounts: [
      {
        pubkey: signer,
        is_signer: true,
        is_writable: true,
      },
    ],
    data: new Uint8Array([1, 2, 3, 4]), // Instruction data
  };
  
  // Create a message
  const message: Message = {
    signers: [signer],
    instructions: [instruction],
  };
  
  // Serialize for sending
  const serialized = MessageUtil.serialize(message);
  console.log('Serialized message:', serialized);
  
  // Deserialize back
  const deserialized = MessageUtil.deserialize(serialized);
  console.log('Deserialized:', deserialized);
}
</code></pre>
<h3 id="creating-a-runtime-transaction"><a class="header" href="#creating-a-runtime-transaction">Creating a Runtime Transaction</a></h3>
<pre><code class="language-typescript">import { RpcConnection, SanitizedMessageUtil } from '@saturnbtcio/arch-sdk';
import type { RuntimeTransaction, SanitizedMessage } from '@saturnbtcio/arch-sdk';

async function createTransaction() {
  const connection = new RpcConnection('http://localhost:9002');
  
  // Create account keys
  const signer = new Uint8Array(32);
  crypto.getRandomValues(signer);
  
  // Create a sanitized message
  const sanitizedMessage: SanitizedMessage = {
    header: {
      num_required_signatures: 1,
      num_readonly_signed_accounts: 0,
      num_readonly_unsigned_accounts: 1,
    },
    account_keys: [
      signer,                          // Index 0: Signer
      PubkeyUtil.systemProgram(),      // Index 1: System program
    ],
    recent_blockhash: new Uint8Array(32), // You need a real blockhash
    instructions: [
      {
        program_id_index: 1,           // System program
        accounts: [0],                 // Signer account
        data: new Uint8Array([0, 0, 0, 0]), // Transfer instruction
      },
    ],
  };
  
  // Create the runtime transaction
  const transaction: RuntimeTransaction = {
    version: 0,
    signatures: [new Uint8Array(64)], // Need real signature
    message: sanitizedMessage,
  };
  
  // Note: This example doesn't include proper signing
  // In practice, you need to sign the message with the private key
  
  console.log('Transaction created (unsigned)');
}
</code></pre>
<h2 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h2>
<h3 id="querying-blocks-and-transactions"><a class="header" href="#querying-blocks-and-transactions">Querying Blocks and Transactions</a></h3>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function blockExplorer() {
  const connection = new RpcConnection('http://localhost:9002');
  
  try {
    // Get recent blocks
    const blockCount = await connection.getBlockCount();
    console.log(`\nExploring last 5 blocks (current height: ${blockCount})`);
    
    for (let i = 0; i &lt; 5 &amp;&amp; blockCount - i &gt; 0; i++) {
      const height = blockCount - i - 1;
      const hash = await connection.getBlockHash(height);
      const block = await connection.getBlock(hash);
      
      if (block) {
        console.log(`\nBlock ${height}:`);
        console.log(`  Hash: ${hash}`);
        console.log(`  Transactions: ${block.transactions?.length || 0}`);
        
        // Check transactions in the block
        if (block.transactions &amp;&amp; block.transactions.length &gt; 0) {
          for (const tx of block.transactions) {
            console.log(`  TX: ${tx.txid}`);
          }
        }
      }
    }
  } catch (error) {
    console.error('Error exploring blocks:', error);
  }
}
</code></pre>
<h3 id="getting-program-accounts"><a class="header" href="#getting-program-accounts">Getting Program Accounts</a></h3>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';

async function getProgramAccountsExample() {
  const connection = new RpcConnection('http://localhost:9002');
  
  // Example program ID (replace with actual program)
  const programId = new Uint8Array(32);
  programId[31] = 2; // Example program ID
  
  try {
    // Get all accounts owned by the program
    const accounts = await connection.getProgramAccounts(programId);
    
    console.log(`Found ${accounts.length} accounts for program`);
    
    accounts.forEach((account, index) =&gt; {
      console.log(`\nAccount ${index}:`);
      console.log('  Pubkey:', account.pubkey);
      console.log('  Account:', account.account);
    });
    
    // With filters (if supported)
    const filteredAccounts = await connection.getProgramAccounts(
      programId,
      [
        // Filter examples would go here
        // The actual filter format depends on implementation
      ]
    );
  } catch (error) {
    console.error('Error getting program accounts:', error);
  }
}
</code></pre>
<h3 id="error-handling-with-retry"><a class="header" href="#error-handling-with-retry">Error Handling with Retry</a></h3>
<pre><code class="language-typescript">import { RpcConnection, ArchRpcError } from '@saturnbtcio/arch-sdk';

async function robustRpcCall&lt;T&gt;(
  fn: () =&gt; Promise&lt;T&gt;,
  maxRetries: number = 3
): Promise&lt;T&gt; {
  let lastError: Error | undefined;
  
  for (let i = 0; i &lt; maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (error instanceof ArchRpcError) {
        console.error(`RPC Error (attempt ${i + 1}):`, error.error);
        
        // Don't retry on certain errors
        if (error.error.code === 404) {
          throw error; // Not found - don't retry
        }
      }
      
      // Wait before retry (exponential backoff)
      if (i &lt; maxRetries - 1) {
        await new Promise(resolve =&gt; 
          setTimeout(resolve, 1000 * Math.pow(2, i))
        );
      }
    }
  }
  
  throw lastError;
}

// Usage example
async function example() {
  const connection = new RpcConnection('http://localhost:9002');
  
  const blockCount = await robustRpcCall(
    () =&gt; connection.getBlockCount()
  );
  console.log('Block count:', blockCount);
}
</code></pre>
<h2 id="integration-examples-1"><a class="header" href="#integration-examples-1">Integration Examples</a></h2>
<h3 id="nodejs-service-example"><a class="header" href="#nodejs-service-example">Node.js Service Example</a></h3>
<pre><code class="language-typescript">import express from 'express';
import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

const app = express();
app.use(express.json());

const connection = new RpcConnection(process.env.ARCH_RPC_URL || 'http://localhost:9002');
const arch = ArchConnection(connection);

// Get network status endpoint
app.get('/api/status', async (req, res) =&gt; {
  try {
    const blockCount = await connection.getBlockCount();
    const bestBlockHash = await connection.getBestBlockHash();
    
    res.json({
      success: true,
      data: {
        blockCount,
        bestBlockHash,
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Create new account endpoint
app.post('/api/account/new', async (req, res) =&gt; {
  try {
    const account = await arch.createNewAccount();
    
    // In production, you'd want to securely store the private key
    res.json({
      success: true,
      data: {
        address: account.address,
        pubkey: account.pubkey,
        // Don't return private key in production!
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.listen(3000, () =&gt; {
  console.log('Server running on port 3000');
});
</code></pre>
<h3 id="react-hook-example"><a class="header" href="#react-hook-example">React Hook Example</a></h3>
<pre><code class="language-typescript">import { useState, useEffect } from 'react';
import { RpcConnection } from '@saturnbtcio/arch-sdk';

function useArchBlockCount() {
  const [blockCount, setBlockCount] = useState&lt;number | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  useEffect(() =&gt; {
    const connection = new RpcConnection('https://api.arch.network');
    let mounted = true;
    
    async function fetchBlockCount() {
      try {
        const count = await connection.getBlockCount();
        if (mounted) {
          setBlockCount(count);
          setError(null);
        }
      } catch (err) {
        if (mounted) {
          setError(err.message);
          setBlockCount(null);
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    }
    
    fetchBlockCount();
    
    // Set up polling
    const interval = setInterval(fetchBlockCount, 10000);
    
    return () =&gt; {
      mounted = false;
      clearInterval(interval);
    };
  }, []);
  
  return { blockCount, loading, error };
}

// Usage in component
function BlockCounter() {
  const { blockCount, loading, error } = useArchBlockCount();
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return &lt;div&gt;Current block: {blockCount}&lt;/div&gt;;
}
</code></pre>
<h2 id="utility-functions-1"><a class="header" href="#utility-functions-1">Utility Functions</a></h2>
<h3 id="working-with-public-keys"><a class="header" href="#working-with-public-keys">Working with Public Keys</a></h3>
<pre><code class="language-typescript">import { PubkeyUtil } from '@saturnbtcio/arch-sdk';

// Convert between formats
function pubkeyExamples() {
  // Create a pubkey from hex string
  const hexPubkey = '0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20';
  const pubkeyBytes = PubkeyUtil.fromHex(hexPubkey);
  
  // Convert back to hex
  const hexAgain = PubkeyUtil.toHex(pubkeyBytes);
  console.log('Hex match:', hexPubkey === hexAgain);
  
  // Get system program pubkey
  const systemProgram = PubkeyUtil.systemProgram();
  console.log('System program:', PubkeyUtil.toHex(systemProgram));
}
</code></pre>
<h2 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h2>
<p>For more examples and implementation details:</p>
<ul>
<li><a href="https://github.com/arch-network/arch-network/tree/main/examples">Arch Network Examples</a></li>
<li><a href="https://github.com/saturnbtc/arch-typescript-sdk/tree/main/src">TypeScript SDK Source</a></li>
</ul>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="sdk/typescript/api-reference.html">TypeScript API Reference</a></li>
<li><a href="sdk/typescript/getting-started.html">Getting Started Guide</a></li>
<li><a href="sdk/typescript/../../rpc/rpc.html">RPC Methods Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web3-integration-guide"><a class="header" href="#web3-integration-guide">Web3 Integration Guide</a></h1>
<p>This guide covers how to integrate the Arch Network TypeScript SDK (by Saturn) with Web3 applications, wallets, and dApps.</p>
<blockquote>
<p><strong>Important</strong>: The Arch TypeScript SDK is a low-level RPC client. It does not include wallet adapters, transaction builders, or other high-level abstractions. This guide shows how you could build these features on top of the SDK.</p>
</blockquote>
<h2 id="understanding-the-limitations"><a class="header" href="#understanding-the-limitations">Understanding the Limitations</a></h2>
<p>The current TypeScript SDK provides:</p>
<ul>
<li>Low-level RPC connection (<code>RpcConnection</code>)</li>
<li>Basic account creation with secp256k1 (<code>ArchConnection</code>)</li>
<li>Message/transaction serialization utilities</li>
<li>Type definitions for Arch data structures</li>
</ul>
<p>It does <strong>NOT</strong> provide:</p>
<ul>
<li>Wallet adapters or browser wallet integration</li>
<li>High-level transaction builders</li>
<li>React/Vue components or hooks</li>
<li>State management solutions</li>
</ul>
<h2 id="building-wallet-integration"><a class="header" href="#building-wallet-integration">Building Wallet Integration</a></h2>
<p>Since the SDK doesn‚Äôt include wallet adapters, you‚Äôll need to build your own. Here‚Äôs a conceptual approach:</p>
<h3 id="defining-a-wallet-interface"><a class="header" href="#defining-a-wallet-interface">Defining a Wallet Interface</a></h3>
<pre><code class="language-typescript">import { RpcConnection } from '@saturnbtcio/arch-sdk';
import type { RuntimeTransaction, SanitizedMessage } from '@saturnbtcio/arch-sdk';

// Define what a wallet adapter might look like
interface ArchWallet {
  publicKey: Uint8Array | null;
  connected: boolean;
  connect(): Promise&lt;{ publicKey: string }&gt;;
  disconnect(): Promise&lt;void&gt;;
  signMessage(message: Uint8Array): Promise&lt;Uint8Array&gt;;
  signTransaction(tx: SanitizedMessage): Promise&lt;Uint8Array&gt;;
}

// Example implementation skeleton
class BrowserWalletAdapter implements ArchWallet {
  publicKey: Uint8Array | null = null;
  connected: boolean = false;
  
  async connect(): Promise&lt;{ publicKey: string }&gt; {
    // This would interface with actual browser wallet
    // For now, this is just a placeholder
    throw new Error('Wallet integration not implemented');
  }
  
  async disconnect(): Promise&lt;void&gt; {
    this.publicKey = null;
    this.connected = false;
  }
  
  async signMessage(message: Uint8Array): Promise&lt;Uint8Array&gt; {
    // Would call wallet's signing method
    throw new Error('Message signing not implemented');
  }
  
  async signTransaction(tx: SanitizedMessage): Promise&lt;Uint8Array&gt; {
    // Would call wallet's transaction signing
    throw new Error('Transaction signing not implemented');
  }
}
</code></pre>
<h3 id="creating-transactions-with-external-signing"><a class="header" href="#creating-transactions-with-external-signing">Creating Transactions with External Signing</a></h3>
<pre><code class="language-typescript">import { RpcConnection, SanitizedMessageUtil, PubkeyUtil } from '@saturnbtcio/arch-sdk';
import type { RuntimeTransaction, SanitizedMessage, SanitizedInstruction } from '@saturnbtcio/arch-sdk';

async function createAndSignTransaction(
  connection: RpcConnection,
  signer: Uint8Array,
  signFunction: (message: Uint8Array) =&gt; Promise&lt;Uint8Array&gt;
) {
  // Build a sanitized message
  const message: SanitizedMessage = {
    header: {
      num_required_signatures: 1,
      num_readonly_signed_accounts: 0,
      num_readonly_unsigned_accounts: 1,
    },
    account_keys: [
      signer,                      // Signer pubkey
      PubkeyUtil.systemProgram(),  // System program
    ],
    recent_blockhash: new Uint8Array(32), // Need actual blockhash
    instructions: [
      {
        program_id_index: 1,
        accounts: [0],
        data: new Uint8Array([0, 0, 0, 0]),
      },
    ],
  };
  
  // Serialize message for signing
  const serializedMessage = SanitizedMessageUtil.serialize(message);
  
  // Sign with external wallet
  const signature = await signFunction(serializedMessage);
  
  // Create runtime transaction
  const transaction: RuntimeTransaction = {
    version: 0,
    signatures: [signature],
    message: message,
  };
  
  // Send transaction
  const txId = await connection.sendTransaction(transaction);
  return txId;
}
</code></pre>
<h2 id="react-integration-pattern"><a class="header" href="#react-integration-pattern">React Integration Pattern</a></h2>
<p>Here‚Äôs how you might structure a React integration:</p>
<h3 id="basic-context-provider"><a class="header" href="#basic-context-provider">Basic Context Provider</a></h3>
<pre><code class="language-typescript">import React, { createContext, useContext, useState } from 'react';
import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

interface ArchContextState {
  connection: RpcConnection;
  arch: ReturnType&lt;typeof ArchConnection&gt;;
  // Add your wallet adapter here when implemented
}

const ArchContext = createContext&lt;ArchContextState | null&gt;(null);

export function ArchProvider({ children, endpoint }: { children: React.ReactNode, endpoint: string }) {
  const connection = new RpcConnection(endpoint);
  const arch = ArchConnection(connection);
  
  const value = {
    connection,
    arch,
  };
  
  return (
    &lt;ArchContext.Provider value={value}&gt;
      {children}
    &lt;/ArchContext.Provider&gt;
  );
}

export function useArch() {
  const context = useContext(ArchContext);
  if (!context) {
    throw new Error('useArch must be used within ArchProvider');
  }
  return context;
}
</code></pre>
<h3 id="custom-hooks"><a class="header" href="#custom-hooks">Custom Hooks</a></h3>
<pre><code class="language-typescript">import { useState, useEffect } from 'react';
import { RpcConnection } from '@saturnbtcio/arch-sdk';

// Hook for monitoring block count
export function useBlockCount(endpoint: string) {
  const [blockCount, setBlockCount] = useState&lt;number | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  useEffect(() =&gt; {
    const connection = new RpcConnection(endpoint);
    let mounted = true;
    
    const fetchBlockCount = async () =&gt; {
      try {
        const count = await connection.getBlockCount();
        if (mounted) {
          setBlockCount(count);
          setError(null);
        }
      } catch (err) {
        if (mounted) {
          setError(err as Error);
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };
    
    fetchBlockCount();
    const interval = setInterval(fetchBlockCount, 10000);
    
    return () =&gt; {
      mounted = false;
      clearInterval(interval);
    };
  }, [endpoint]);
  
  return { blockCount, loading, error };
}

// Hook for account information
export function useAccountInfo(pubkey: Uint8Array | null) {
  const { connection } = useArch();
  const [accountInfo, setAccountInfo] = useState&lt;any&gt;(null);
  const [loading, setLoading] = useState(false);
  
  useEffect(() =&gt; {
    if (!pubkey) return;
    
    let cancelled = false;
    
    const fetchAccount = async () =&gt; {
      setLoading(true);
      try {
        const info = await connection.readAccountInfo(pubkey);
        if (!cancelled) {
          setAccountInfo(info);
        }
      } catch (error) {
        console.error('Failed to fetch account:', error);
        if (!cancelled) {
          setAccountInfo(null);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchAccount();
    
    return () =&gt; {
      cancelled = true;
    };
  }, [pubkey, connection]);
  
  return { accountInfo, loading };
}
</code></pre>
<h2 id="building-transaction-helpers"><a class="header" href="#building-transaction-helpers">Building Transaction Helpers</a></h2>
<p>Since the SDK doesn‚Äôt include transaction builders, here‚Äôs how you might create your own:</p>
<pre><code class="language-typescript">import { PubkeyUtil } from '@saturnbtcio/arch-sdk';
import type { SanitizedMessage, SanitizedInstruction } from '@saturnbtcio/arch-sdk';

class TransactionBuilder {
  private accountKeys: Uint8Array[] = [];
  private instructions: SanitizedInstruction[] = [];
  private signerCount = 0;
  
  addSigner(pubkey: Uint8Array): number {
    const index = this.accountKeys.length;
    this.accountKeys.push(pubkey);
    this.signerCount++;
    return index;
  }
  
  addAccount(pubkey: Uint8Array): number {
    const index = this.accountKeys.length;
    this.accountKeys.push(pubkey);
    return index;
  }
  
  addInstruction(
    programId: Uint8Array,
    accounts: number[],
    data: Uint8Array
  ): void {
    // Ensure program ID is in account keys
    let programIdIndex = this.accountKeys.findIndex(
      key =&gt; this.arraysEqual(key, programId)
    );
    
    if (programIdIndex === -1) {
      programIdIndex = this.addAccount(programId);
    }
    
    this.instructions.push({
      program_id_index: programIdIndex,
      accounts,
      data,
    });
  }
  
  build(recentBlockhash: Uint8Array): SanitizedMessage {
    return {
      header: {
        num_required_signatures: this.signerCount,
        num_readonly_signed_accounts: 0,
        num_readonly_unsigned_accounts: this.accountKeys.length - this.signerCount,
      },
      account_keys: this.accountKeys,
      recent_blockhash: recentBlockhash,
      instructions: this.instructions,
    };
  }
  
  private arraysEqual(a: Uint8Array, b: Uint8Array): boolean {
    if (a.length !== b.length) return false;
    for (let i = 0; i &lt; a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
}

// Usage example
function createTransferMessage(from: Uint8Array, to: Uint8Array, amount: bigint): SanitizedMessage {
  const builder = new TransactionBuilder();
  
  // Add accounts
  const fromIndex = builder.addSigner(from);
  const toIndex = builder.addAccount(to);
  
  // Create transfer instruction data
  // Note: This is a simplified example - actual encoding depends on the program
  const data = new Uint8Array(8);
  new DataView(data.buffer).setBigUint64(0, amount, true);
  
  // Add instruction
  builder.addInstruction(
    PubkeyUtil.systemProgram(),
    [fromIndex, toIndex],
    data
  );
  
  // Build with a recent blockhash (you need to fetch this)
  const recentBlockhash = new Uint8Array(32); // Placeholder
  return builder.build(recentBlockhash);
}
</code></pre>
<h2 id="security-considerations-6"><a class="header" href="#security-considerations-6">Security Considerations</a></h2>
<p>When building Web3 integrations with the low-level SDK:</p>
<ol>
<li><strong>Key Management</strong>: Never handle private keys directly in browser code</li>
<li><strong>Message Validation</strong>: Always validate message contents before signing</li>
<li><strong>Error Handling</strong>: Implement robust error handling for RPC calls</li>
<li><strong>Type Safety</strong>: Use TypeScript strictly to catch errors at compile time</li>
<li><strong>Input Validation</strong>: Validate all user inputs, especially addresses and amounts</li>
</ol>
<h2 id="example-simple-dapp-structure"><a class="header" href="#example-simple-dapp-structure">Example: Simple dApp Structure</a></h2>
<pre><code class="language-typescript">// services/arch.ts
import { RpcConnection, ArchConnection } from '@saturnbtcio/arch-sdk';

export class ArchService {
  private connection: RpcConnection;
  private arch: ReturnType&lt;typeof ArchConnection&gt;;
  
  constructor(endpoint: string) {
    this.connection = new RpcConnection(endpoint);
    this.arch = ArchConnection(this.connection);
  }
  
  async getNetworkStatus() {
    const blockCount = await this.connection.getBlockCount();
    const bestBlockHash = await this.connection.getBestBlockHash();
    return { blockCount, bestBlockHash };
  }
  
  async createAccount() {
    return await this.arch.createNewAccount();
  }
  
  async getAccountInfo(pubkey: Uint8Array) {
    return await this.connection.readAccountInfo(pubkey);
  }
}

// components/NetworkStatus.tsx
import React from 'react';
import { useBlockCount } from '../hooks/useBlockCount';

export function NetworkStatus() {
  const { blockCount, loading, error } = useBlockCount('http://localhost:9002');
  
  if (loading) return &lt;div&gt;Loading network status...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h3&gt;Network Status&lt;/h3&gt;
      &lt;p&gt;Current block: {blockCount}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>Since the TypeScript SDK is low-level, you‚Äôll need to:</p>
<ol>
<li>Implement your own wallet integration layer</li>
<li>Build transaction construction utilities</li>
<li>Create state management solutions</li>
<li>Develop UI components for common operations</li>
</ol>
<p>For more information:</p>
<ul>
<li><a href="sdk/typescript/api-reference.html">TypeScript SDK API Reference</a></li>
<li><a href="sdk/typescript/examples.html">Low-Level Examples</a></li>
<li><a href="sdk/typescript/../../rpc/rpc.html">RPC Documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-the-rust-sdk"><a class="header" href="#getting-started-with-the-rust-sdk">Getting Started with the Rust SDK</a></h1>
<p>This guide will walk you through setting up and using the native Arch Network Rust SDK to build high-performance applications and on-chain programs.</p>
<h2 id="prerequisites-9"><a class="header" href="#prerequisites-9">Prerequisites</a></h2>
<ul>
<li><strong>Rust 1.70+</strong> with Cargo</li>
<li><strong>Basic understanding</strong> of Rust and blockchain concepts</li>
<li><strong>Arch Network node</strong> running locally or access to a remote node</li>
<li><strong>Rust development environment</strong> set up</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="create-a-new-rust-project"><a class="header" href="#create-a-new-rust-project">Create a New Rust Project</a></h3>
<pre><code class="language-bash"># Create a new binary project
cargo new my-arch-app --bin
cd my-arch-app

# Or create a library for on-chain programs
cargo new my-arch-program --lib
cd my-arch-program
</code></pre>
<h3 id="add-the-sdk-dependency"><a class="header" href="#add-the-sdk-dependency">Add the SDK Dependency</a></h3>
<p>Edit your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
arch_sdk = "0.5.4"
arch_program = "0.5.4"  # For on-chain program development

# Required for async operations
tokio = { version = "1.38", features = ["full"] }

# Optional dependencies commonly used
anyhow = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</code></pre>
<h2 id="your-first-connection-1"><a class="header" href="#your-first-connection-1">Your First Connection</a></h2>
<p>Create <code>src/main.rs</code>:</p>
<pre><code class="language-rust ignore">use arch_sdk::Connection;
use anyhow::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Connect to local validator
    let connection = Connection::new("http://localhost:9002");
    
    // Check if node is ready
    let is_ready = connection.is_node_ready().await?;
    println!("Node ready: {}", is_ready);
    
    // Get current block count
    let block_count = connection.get_block_count().await?;
    println!("Current block count: {}", block_count);
    
    Ok(())
}</code></pre>
<p>Run the program:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="working-with-keypairs"><a class="header" href="#working-with-keypairs">Working with Keypairs</a></h2>
<h3 id="generate-a-new-keypair"><a class="header" href="#generate-a-new-keypair">Generate a New Keypair</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::Keypair;
use arch_program::pubkey::Pubkey;

fn create_keypair() {
    // Generate a new keypair
    let keypair = Keypair::new();
    
    // Get the public key
    let pubkey: Pubkey = keypair.pubkey();
    println!("Public key: {}", pubkey);
    
    // Get the secret key bytes
    let secret_key_bytes = keypair.secret_key();
    println!("Secret key length: {} bytes", secret_key_bytes.len());
    
    // Save keypair to file (be careful with security!)
    keypair.save_to_file("keypair.json").expect("Failed to save keypair");
    
    // Load keypair from file
    let loaded_keypair = Keypair::load_from_file("keypair.json")
        .expect("Failed to load keypair");
}</code></pre>
<h3 id="create-keypair-from-seed"><a class="header" href="#create-keypair-from-seed">Create Keypair from Seed</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::Keypair;

fn create_from_seed() {
    // Create from seed phrase or bytes
    let seed_bytes = b"your-seed-phrase-here-32-bytes!!"; // Must be 32 bytes
    let keypair = Keypair::from_seed(seed_bytes);
    
    println!("Pubkey from seed: {}", keypair.pubkey());
}</code></pre>
<h2 id="reading-account-information-1"><a class="header" href="#reading-account-information-1">Reading Account Information</a></h2>
<h3 id="get-account-info"><a class="header" href="#get-account-info">Get Account Info</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Account};
use arch_program::pubkey::Pubkey;
use std::str::FromStr;

async fn read_account(connection: &amp;Connection) -&gt; Result&lt;()&gt; {
    // Parse a public key from string
    let account_pubkey = Pubkey::from_str("YourAccountAddress...")?;
    
    // Get account info
    match connection.get_account(&amp;account_pubkey).await? {
        Some(account) =&gt; {
            println!("Owner: {}", account.owner);
            println!("Lamports: {}", account.lamports);
            println!("Data length: {}", account.data.len());
            println!("Executable: {}", account.executable);
        }
        None =&gt; {
            println!("Account not found");
        }
    }
    
    Ok(())
}</code></pre>
<h3 id="get-multiple-accounts"><a class="header" href="#get-multiple-accounts">Get Multiple Accounts</a></h3>
<pre><code class="language-rust ignore">async fn read_multiple_accounts(connection: &amp;Connection) -&gt; Result&lt;()&gt; {
    let pubkeys = vec![
        Pubkey::from_str("Address1...")?,
        Pubkey::from_str("Address2...")?,
        Pubkey::from_str("Address3...")?,
    ];
    
    let accounts = connection.get_multiple_accounts(&amp;pubkeys).await?;
    
    for (i, account) in accounts.iter().enumerate() {
        match account {
            Some(acc) =&gt; println!("Account {}: {} lamports", i, acc.lamports),
            None =&gt; println!("Account {}: Not found", i),
        }
    }
    
    Ok(())
}</code></pre>
<h2 id="building-and-sending-transactions"><a class="header" href="#building-and-sending-transactions">Building and Sending Transactions</a></h2>
<h3 id="simple-transfer"><a class="header" href="#simple-transfer">Simple Transfer</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Keypair, Transaction};
use arch_program::{
    instruction::Instruction,
    system_instruction,
    pubkey::Pubkey,
};

async fn transfer_lamports(connection: &amp;Connection) -&gt; Result&lt;()&gt; {
    // Create or load keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();
    
    // Create transfer instruction
    let transfer_ix = system_instruction::transfer(
        &amp;sender.pubkey(),
        &amp;recipient.pubkey(),
        1_000_000, // 1 SOL equivalent in lamports
    );
    
    // Build transaction
    let mut transaction = Transaction::new_with_payer(
        &amp;[transfer_ix],
        Some(&amp;sender.pubkey()),
    );
    
    // Get recent blockhash
    let recent_blockhash = connection.get_latest_blockhash().await?;
    transaction.message.recent_blockhash = recent_blockhash;
    
    // Sign transaction
    transaction.sign(&amp;[&amp;sender], recent_blockhash);
    
    // Send and confirm
    let signature = connection.send_and_confirm_transaction(&amp;transaction).await?;
    println!("Transaction signature: {}", signature);
    
    Ok(())
}</code></pre>
<h3 id="create-account"><a class="header" href="#create-account">Create Account</a></h3>
<pre><code class="language-rust ignore">use arch_program::system_instruction;

async fn create_account(
    connection: &amp;Connection,
    payer: &amp;Keypair,
    new_account: &amp;Keypair,
    space: u64,
    owner: &amp;Pubkey,
) -&gt; Result&lt;()&gt; {
    // Calculate rent-exempt amount
    let rent = connection.get_minimum_balance_for_rent_exemption(space).await?;
    
    // Create account instruction
    let create_account_ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;new_account.pubkey(),
        rent,
        space,
        owner,
    );
    
    // Build and send transaction
    let mut transaction = Transaction::new_with_payer(
        &amp;[create_account_ix],
        Some(&amp;payer.pubkey()),
    );
    
    let recent_blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&amp;[payer, new_account], recent_blockhash);
    
    let signature = connection.send_and_confirm_transaction(&amp;transaction).await?;
    println!("Account created: {}", new_account.pubkey());
    println!("Transaction: {}", signature);
    
    Ok(())
}</code></pre>
<h2 id="developing-on-chain-programs"><a class="header" href="#developing-on-chain-programs">Developing On-Chain Programs</a></h2>
<h3 id="basic-program-structure"><a class="header" href="#basic-program-structure">Basic Program Structure</a></h3>
<p>Create <code>src/lib.rs</code> for your on-chain program:</p>
<pre><code class="language-rust ignore">use arch_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    pubkey::Pubkey,
};

// Declare the program's entrypoint
entrypoint!(process_instruction);

// Program entrypoint implementation
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    msg!("Hello from Arch program!");
    
    // Parse accounts
    let accounts_iter = &amp;mut accounts.iter();
    let account = next_account_info(accounts_iter)?;
    
    // Check account ownership
    if account.owner != program_id {
        msg!("Account does not have the correct program id");
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Process instruction data
    match instruction_data.get(0) {
        Some(0) =&gt; process_initialize(account, instruction_data),
        Some(1) =&gt; process_update(account, instruction_data),
        _ =&gt; Err(ProgramError::InvalidInstructionData),
    }
}

fn process_initialize(account: &amp;AccountInfo, data: &amp;[u8]) -&gt; ProgramResult {
    msg!("Initializing account");
    // Implementation here
    Ok(())
}

fn process_update(account: &amp;AccountInfo, data: &amp;[u8]) -&gt; ProgramResult {
    msg!("Updating account");
    // Implementation here
    Ok(())
}</code></pre>
<h3 id="building-programs"><a class="header" href="#building-programs">Building Programs</a></h3>
<p>Add to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib", "lib"]

[features]
no-entrypoint = []

[dependencies]
arch_program = "0.5.4"
</code></pre>
<p>Build the program:</p>
<pre><code class="language-bash">cargo build-bpf
</code></pre>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h2>
<h3 id="using-result-types"><a class="header" href="#using-result-types">Using Result Types</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::ArchError;
use anyhow::{Result, Context};

async fn robust_operation(connection: &amp;Connection) -&gt; Result&lt;()&gt; {
    // Use ? operator for automatic error propagation
    let block_count = connection.get_block_count().await
        .context("Failed to get block count")?;
    
    // Pattern match on specific errors
    match connection.get_account(&amp;some_pubkey).await {
        Ok(Some(account)) =&gt; {
            println!("Account found: {} lamports", account.lamports);
        }
        Ok(None) =&gt; {
            println!("Account not found");
        }
        Err(e) =&gt; {
            eprintln!("Error fetching account: {}", e);
            return Err(e.into());
        }
    }
    
    Ok(())
}</code></pre>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<pre><code class="language-rust ignore">use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyProgramError {
    #[error("Invalid instruction data")]
    InvalidInstruction,
    
    #[error("Insufficient funds: needed {needed}, available {available}")]
    InsufficientFunds { needed: u64, available: u64 },
    
    #[error("Account not initialized")]
    UninitializedAccount,
}

// Use in your program
fn validate_account(account: &amp;AccountInfo) -&gt; Result&lt;(), MyProgramError&gt; {
    if account.data_is_empty() {
        return Err(MyProgramError::UninitializedAccount);
    }
    Ok(())
}</code></pre>
<h2 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h2>
<h3 id="parallel-account-processing"><a class="header" href="#parallel-account-processing">Parallel Account Processing</a></h3>
<pre><code class="language-rust ignore">use futures::future::join_all;

async fn process_accounts_parallel(connection: &amp;Connection, pubkeys: Vec&lt;Pubkey&gt;) -&gt; Result&lt;()&gt; {
    // Create futures for all account fetches
    let futures: Vec&lt;_&gt; = pubkeys
        .iter()
        .map(|pubkey| connection.get_account(pubkey))
        .collect();
    
    // Execute all fetches in parallel
    let results = join_all(futures).await;
    
    // Process results
    for (i, result) in results.into_iter().enumerate() {
        match result {
            Ok(Some(account)) =&gt; {
                println!("Account {}: {} lamports", i, account.lamports);
            }
            Ok(None) =&gt; {
                println!("Account {}: Not found", i);
            }
            Err(e) =&gt; {
                eprintln!("Error fetching account {}: {}", i, e);
            }
        }
    }
    
    Ok(())
}</code></pre>
<h3 id="custom-serialization"><a class="header" href="#custom-serialization">Custom Serialization</a></h3>
<pre><code class="language-rust ignore">use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct MyAccountData {
    pub counter: u64,
    pub owner: Pubkey,
    pub timestamp: i64,
}

impl MyAccountData {
    pub fn save(&amp;self, account: &amp;AccountInfo) -&gt; ProgramResult {
        self.serialize(&amp;mut &amp;mut account.data.borrow_mut()[..])?;
        Ok(())
    }
    
    pub fn load(account: &amp;AccountInfo) -&gt; Result&lt;Self, ProgramError&gt; {
        Self::try_from_slice(&amp;account.data.borrow())
            .map_err(|_| ProgramError::InvalidAccountData)
    }
}</code></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::clock::Epoch;
    
    #[test]
    fn test_keypair_generation() {
        let keypair = Keypair::new();
        assert_eq!(keypair.secret_key().len(), 64);
        
        let pubkey = keypair.pubkey();
        assert_eq!(pubkey.to_bytes().len(), 32);
    }
    
    #[tokio::test]
    async fn test_connection() {
        let connection = Connection::new("http://localhost:9002");
        
        // This will fail if no local node is running
        match connection.is_node_ready().await {
            Ok(ready) =&gt; assert!(ready),
            Err(_) =&gt; println!("No local node available for testing"),
        }
    }
}</code></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Create <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Keypair};
use anyhow::Result;

#[tokio::test]
async fn test_full_transaction_flow() -&gt; Result&lt;()&gt; {
    let connection = Connection::new("http://localhost:9002");
    
    // Only run if node is available
    if !connection.is_node_ready().await.unwrap_or(false) {
        println!("Skipping integration test - no node available");
        return Ok(());
    }
    
    // Your integration test logic here
    
    Ok(())
}</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<h3 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h3>
<pre><code class="language-rust ignore">// 1. Reuse connections
lazy_static::lazy_static! {
    static ref CONNECTION: Connection = Connection::new("http://localhost:9002");
}

// 2. Batch operations when possible
pub async fn get_all_token_accounts(mint: &amp;Pubkey) -&gt; Result&lt;Vec&lt;Account&gt;&gt; {
    CONNECTION.get_program_accounts_with_config(
        &amp;token_program_id(),
        RpcProgramAccountsConfig {
            filters: Some(vec![
                RpcFilterType::Memcmp(Memcmp {
                    offset: 0,
                    bytes: MemcmpEncodedBytes::Base58(mint.to_string()),
                    encoding: None,
                }),
            ]),
            ..Default::default()
        },
    ).await
}

// 3. Use appropriate data structures
use std::collections::HashMap;
use dashmap::DashMap; // For concurrent access

type AccountCache = DashMap&lt;Pubkey, Account&gt;;</code></pre>
<h3 id="security-considerations-7"><a class="header" href="#security-considerations-7">Security Considerations</a></h3>
<pre><code class="language-rust ignore">// 1. Always validate inputs
pub fn validate_pubkey(input: &amp;str) -&gt; Result&lt;Pubkey&gt; {
    Pubkey::from_str(input)
        .map_err(|e| anyhow::anyhow!("Invalid public key: {}", e))
}

// 2. Check account ownership
pub fn verify_owner(account: &amp;AccountInfo, expected_owner: &amp;Pubkey) -&gt; ProgramResult {
    if account.owner != expected_owner {
        msg!("Account has wrong owner");
        return Err(ProgramError::IncorrectProgramId);
    }
    Ok(())
}

// 3. Prevent arithmetic overflows
pub fn safe_add(a: u64, b: u64) -&gt; Option&lt;u64&gt; {
    a.checked_add(b)
}</code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<p>Here‚Äôs a complete example combining multiple concepts:</p>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Keypair, Transaction};
use arch_program::{
    instruction::Instruction,
    pubkey::Pubkey,
    system_instruction,
};
use anyhow::Result;
use std::str::FromStr;

const LAMPORTS_PER_SOL: u64 = 1_000_000_000;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 1. Setup connection
    let connection = Connection::new("http://localhost:9002");
    println!("Connecting to Arch Network...");
    
    // 2. Create or load keypairs
    let payer = Keypair::new();
    let recipient = Keypair::new();
    
    println!("Payer: {}", payer.pubkey());
    println!("Recipient: {}", recipient.pubkey());
    
    // 3. Check initial balances
    let payer_balance = connection.get_balance(&amp;payer.pubkey()).await?;
    println!("Payer balance: {} SOL", payer_balance as f64 / LAMPORTS_PER_SOL as f64);
    
    // 4. Create transfer instruction
    let transfer_amount = LAMPORTS_PER_SOL / 10; // 0.1 SOL
    let transfer_ix = system_instruction::transfer(
        &amp;payer.pubkey(),
        &amp;recipient.pubkey(),
        transfer_amount,
    );
    
    // 5. Build transaction
    let mut transaction = Transaction::new_with_payer(
        &amp;[transfer_ix],
        Some(&amp;payer.pubkey()),
    );
    
    // 6. Get recent blockhash and sign
    let recent_blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&amp;[&amp;payer], recent_blockhash);
    
    // 7. Send transaction
    println!("Sending transaction...");
    match connection.send_and_confirm_transaction(&amp;transaction).await {
        Ok(signature) =&gt; {
            println!("Transaction successful!");
            println!("Signature: {}", signature);
            
            // 8. Verify the transfer
            let recipient_balance = connection.get_balance(&amp;recipient.pubkey()).await?;
            println!("Recipient balance: {} SOL", 
                recipient_balance as f64 / LAMPORTS_PER_SOL as f64);
        }
        Err(e) =&gt; {
            eprintln!("Transaction failed: {}", e);
        }
    }
    
    Ok(())
}</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>Now that you understand the basics of the Rust SDK:</p>
<ol>
<li><strong><a href="sdk/rust/program-development.html">Program Development Guide</a></strong> - Build on-chain programs</li>
<li><strong><a href="sdk/rust/api-reference.html">Rust API Reference</a></strong> - Complete API documentation</li>
<li><strong><a href="sdk/rust/examples.html">Advanced Examples</a></strong> - Complex use cases</li>
<li><strong><a href="sdk/rust/../../program/program.html">Program Development</a></strong> - General program concepts</li>
<li><strong><a href="sdk/rust/../../program/syscall.html">System Calls</a></strong> - System-level operations</li>
</ol>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<ul>
<li><strong>Crate</strong>: <a href="https://crates.io/crates/arch_sdk">arch_sdk on crates.io</a></li>
<li><strong>Documentation</strong>: <a href="https://docs.rs/arch_sdk">docs.rs/arch_sdk</a></li>
<li><strong>GitHub</strong>: <a href="https://github.com/arch-network/arch-network">arch-network/arch-network</a></li>
<li><strong>Examples</strong>: <a href="https://github.com/arch-network/arch-network/tree/main/examples">Arch Network Examples</a></li>
<li><strong>Discord</strong>: <a href="https://discord.gg/archnetwork">Arch Network Discord</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk-api-reference"><a class="header" href="#rust-sdk-api-reference">Rust SDK API Reference</a></h1>
<p>This page provides a comprehensive API reference for the native Arch Network Rust SDK.</p>
<blockquote>
<p><strong>Note</strong>: For the most complete and up-to-date API documentation, please visit <a href="https://docs.rs/arch_sdk">docs.rs/arch_sdk</a>.</p>
</blockquote>
<h2 id="core-modules"><a class="header" href="#core-modules">Core Modules</a></h2>
<h3 id="connection"><a class="header" href="#connection">Connection</a></h3>
<p>The main struct for interacting with an Arch Network node.</p>
<h3 id="keypair"><a class="header" href="#keypair">Keypair</a></h3>
<p>Manages Ed25519 keypairs for transaction signing.</p>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>Builds and signs transactions for the network.</p>
<h3 id="account"><a class="header" href="#account">Account</a></h3>
<p>Represents account data on the network.</p>
<h3 id="instruction-1"><a class="header" href="#instruction-1">Instruction</a></h3>
<p>Defines instructions for programs.</p>
<h2 id="key-traits"><a class="header" href="#key-traits">Key Traits</a></h2>
<h3 id="signer"><a class="header" href="#signer">Signer</a></h3>
<p>Trait for types that can sign transactions.</p>
<h3 id="serializedeserialize"><a class="header" href="#serializedeserialize">Serialize/Deserialize</a></h3>
<p>Borsh serialization support for on-chain data.</p>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<h3 id="archerror"><a class="header" href="#archerror">ArchError</a></h3>
<p>Main error type for SDK operations.</p>
<h3 id="programerror"><a class="header" href="#programerror">ProgramError</a></h3>
<p>Errors returned by on-chain programs.</p>
<h2 id="complete-api-documentation-1"><a class="header" href="#complete-api-documentation-1">Complete API Documentation</a></h2>
<p>For complete API documentation, please refer to:</p>
<ul>
<li><a href="https://docs.rs/arch_sdk">docs.rs Documentation</a></li>
<li><a href="https://crates.io/crates/arch_sdk">Crates.io Package</a></li>
<li><a href="https://github.com/arch-network/arch-network/tree/main/sdk">Source Code</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk-examples"><a class="header" href="#rust-sdk-examples">Rust SDK Examples</a></h1>
<p>This page provides practical examples of using the native Arch Network Rust SDK for building high-performance applications and on-chain programs.</p>
<h2 id="basic-examples-1"><a class="header" href="#basic-examples-1">Basic Examples</a></h2>
<h3 id="account-management-3"><a class="header" href="#account-management-3">Account Management</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Keypair, Account};
use arch_program::pubkey::Pubkey;
use anyhow::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let connection = Connection::new("http://localhost:9002");
    
    // Create new account
    let new_account = Keypair::new();
    println!("New account: {}", new_account.pubkey());
    
    // Check if account exists
    match connection.get_account(&amp;new_account.pubkey()).await? {
        Some(account) =&gt; {
            println!("Account exists with {} lamports", account.lamports);
        }
        None =&gt; {
            println!("Account does not exist yet");
        }
    }
    
    // Get multiple accounts efficiently
    let pubkeys = vec![
        Pubkey::new_unique(),
        Pubkey::new_unique(),
        new_account.pubkey(),
    ];
    
    let accounts = connection.get_multiple_accounts(&amp;pubkeys).await?;
    for (i, account) in accounts.iter().enumerate() {
        match account {
            Some(acc) =&gt; println!("Account {}: {} lamports", i, acc.lamports),
            None =&gt; println!("Account {}: Not found", i),
        }
    }
    
    Ok(())
}</code></pre>
<h3 id="utxo-operations"><a class="header" href="#utxo-operations">UTXO Operations</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Utxo};
use arch_program::pubkey::Pubkey;
use std::str::FromStr;

async fn utxo_operations() -&gt; Result&lt;()&gt; {
    let connection = Connection::new("http://localhost:9002");
    let address = Pubkey::from_str("YourBitcoinAddress...")?;
    
    // Get UTXOs for an address
    let utxos = connection.get_utxos(&amp;address).await?;
    
    println!("Found {} UTXOs", utxos.len());
    
    // Process UTXOs
    let total_value: u64 = utxos.iter()
        .map(|utxo| utxo.value)
        .sum();
    
    println!("Total value: {} satoshis", total_value);
    
    // Find spendable UTXOs above threshold
    let threshold = 10_000; // satoshis
    let spendable: Vec&lt;&amp;Utxo&gt; = utxos.iter()
        .filter(|utxo| utxo.value &gt;= threshold)
        .collect();
    
    println!("Spendable UTXOs: {}", spendable.len());
    
    Ok(())
}</code></pre>
<h3 id="transaction-building"><a class="header" href="#transaction-building">Transaction Building</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{Connection, Keypair, Transaction};
use arch_program::{
    instruction::Instruction,
    system_instruction,
    pubkey::Pubkey,
    message::Message,
};

async fn build_complex_transaction() -&gt; Result&lt;()&gt; {
    let connection = Connection::new("http://localhost:9002");
    let payer = Keypair::new();
    
    // Create multiple instructions
    let mut instructions = vec![];
    
    // 1. Create a new account
    let new_account = Keypair::new();
    let space = 1024;
    let rent = connection.get_minimum_balance_for_rent_exemption(space).await?;
    
    instructions.push(system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;new_account.pubkey(),
        rent,
        space,
        &amp;my_program_id(),
    ));
    
    // 2. Initialize the account
    instructions.push(Instruction::new_with_bytes(
        my_program_id(),
        &amp;[0], // Initialize instruction
        vec![
            AccountMeta::new(new_account.pubkey(), true),
            AccountMeta::new_readonly(payer.pubkey(), true),
        ],
    ));
    
    // 3. Transfer some lamports
    instructions.push(system_instruction::transfer(
        &amp;payer.pubkey(),
        &amp;new_account.pubkey(),
        1_000_000,
    ));
    
    // Build and sign transaction
    let message = Message::new(&amp;instructions, Some(&amp;payer.pubkey()));
    let mut transaction = Transaction::new_unsigned(message);
    
    let recent_blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&amp;[&amp;payer, &amp;new_account], recent_blockhash);
    
    // Send transaction
    let signature = connection.send_and_confirm_transaction(&amp;transaction).await?;
    println!("Transaction successful: {}", signature);
    
    Ok(())
}</code></pre>
<h2 id="on-chain-program-examples"><a class="header" href="#on-chain-program-examples">On-Chain Program Examples</a></h2>
<h3 id="state-management-program"><a class="header" href="#state-management-program">State Management Program</a></h3>
<pre><code class="language-rust ignore">use arch_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct Counter {
    pub count: u64,
    pub authority: Pubkey,
    pub last_updated: i64,
}

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)?;
    
    match instruction {
        CounterInstruction::Initialize { authority } =&gt; {
            process_initialize(program_id, accounts, authority)
        }
        CounterInstruction::Increment =&gt; {
            process_increment(program_id, accounts)
        }
        CounterInstruction::Reset =&gt; {
            process_reset(program_id, accounts)
        }
    }
}

fn process_initialize(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    authority: Pubkey,
) -&gt; ProgramResult {
    let accounts_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;
    let payer = next_account_info(accounts_iter)?;
    
    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Initialize counter
    let counter = Counter {
        count: 0,
        authority,
        last_updated: Clock::get()?.unix_timestamp,
    };
    
    counter.serialize(&amp;mut &amp;mut counter_account.data.borrow_mut()[..])?;
    msg!("Counter initialized with authority: {}", authority);
    
    Ok(())
}

fn process_increment(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
) -&gt; ProgramResult {
    let accounts_iter = &amp;mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;
    let authority = next_account_info(accounts_iter)?;
    
    // Deserialize counter
    let mut counter = Counter::try_from_slice(&amp;counter_account.data.borrow())?;
    
    // Verify authority
    if !authority.is_signer || *authority.key != counter.authority {
        return Err(ProgramError::MissingRequiredSignature);
    }
    
    // Increment counter
    counter.count = counter.count
        .checked_add(1)
        .ok_or(ProgramError::ArithmeticOverflow)?;
    counter.last_updated = Clock::get()?.unix_timestamp;
    
    // Save state
    counter.serialize(&amp;mut &amp;mut counter_account.data.borrow_mut()[..])?;
    msg!("Counter incremented to: {}", counter.count);
    
    Ok(())
}</code></pre>
<h3 id="cross-program-invocation-cpi-2"><a class="header" href="#cross-program-invocation-cpi-2">Cross-Program Invocation (CPI)</a></h3>
<pre><code class="language-rust ignore">use arch_program::{
    account_info::AccountInfo,
    program::{invoke, invoke_signed},
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
};

pub fn transfer_via_cpi(
    from: &amp;AccountInfo,
    to: &amp;AccountInfo,
    amount: u64,
    signer_seeds: &amp;[&amp;[&amp;[u8]]],
) -&gt; ProgramResult {
    let transfer_instruction = system_instruction::transfer(
        from.key,
        to.key,
        amount,
    );
    
    // If the from account is a PDA, use invoke_signed
    if signer_seeds.is_empty() {
        invoke(
            &amp;transfer_instruction,
            &amp;[from.clone(), to.clone()],
        )
    } else {
        invoke_signed(
            &amp;transfer_instruction,
            &amp;[from.clone(), to.clone()],
            signer_seeds,
        )
    }
}

// Example: Escrow program using CPI
pub fn release_escrow(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
) -&gt; ProgramResult {
    let accounts_iter = &amp;mut accounts.iter();
    let escrow_account = next_account_info(accounts_iter)?;
    let recipient = next_account_info(accounts_iter)?;
    let escrow_pda = next_account_info(accounts_iter)?;
    
    // Verify PDA
    let (pda, bump) = Pubkey::find_program_address(
        &amp;[b"escrow", escrow_account.key.as_ref()],
        program_id,
    );
    
    if pda != *escrow_pda.key {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Transfer funds from PDA to recipient
    transfer_via_cpi(
        escrow_pda,
        recipient,
        escrow_pda.lamports(),
        &amp;[&amp;[b"escrow", escrow_account.key.as_ref(), &amp;[bump]]],
    )?;
    
    Ok(())
}</code></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="concurrent-operations"><a class="header" href="#concurrent-operations">Concurrent Operations</a></h3>
<pre><code class="language-rust ignore">use futures::future::{join_all, try_join_all};
use std::sync::Arc;
use tokio::task::JoinHandle;

async fn concurrent_account_processing(
    connection: Arc&lt;Connection&gt;,
    pubkeys: Vec&lt;Pubkey&gt;,
) -&gt; Result&lt;Vec&lt;Option&lt;Account&gt;&gt;&gt; {
    // Create tasks for concurrent fetching
    let tasks: Vec&lt;JoinHandle&lt;Result&lt;Option&lt;Account&gt;&gt;&gt;&gt; = pubkeys
        .into_iter()
        .map(|pubkey| {
            let conn = connection.clone();
            tokio::spawn(async move {
                conn.get_account(&amp;pubkey).await
            })
        })
        .collect();
    
    // Wait for all tasks to complete
    let results = join_all(tasks).await;
    
    // Handle results
    let mut accounts = Vec::new();
    for result in results {
        match result {
            Ok(Ok(account)) =&gt; accounts.push(account),
            Ok(Err(e)) =&gt; return Err(e),
            Err(e) =&gt; return Err(anyhow::anyhow!("Task failed: {}", e)),
        }
    }
    
    Ok(accounts)
}

// Batch processing with rate limiting
use tokio::time::{sleep, Duration};

async fn batch_process_with_rate_limit&lt;T, F, Fut&gt;(
    items: Vec&lt;T&gt;,
    batch_size: usize,
    delay_ms: u64,
    process_fn: F,
) -&gt; Result&lt;Vec&lt;Result&lt;(), anyhow::Error&gt;&gt;&gt;
where
    F: Fn(T) -&gt; Fut + Clone,
    Fut: std::future::Future&lt;Output = Result&lt;()&gt;&gt;,
    T: Send + 'static,
{
    let mut results = Vec::new();
    
    for chunk in items.chunks(batch_size) {
        let futures: Vec&lt;_&gt; = chunk
            .iter()
            .map(|item| {
                let f = process_fn.clone();
                f(item.clone())
            })
            .collect();
        
        let batch_results = try_join_all(futures).await;
        results.extend(batch_results);
        
        // Rate limit between batches
        sleep(Duration::from_millis(delay_ms)).await;
    }
    
    Ok(results)
}</code></pre>
<h3 id="custom-error-handling"><a class="header" href="#custom-error-handling">Custom Error Handling</a></h3>
<pre><code class="language-rust ignore">use thiserror::Error;

#[derive(Error, Debug)]
pub enum ArchAppError {
    #[error("Connection error: {0}")]
    Connection(#[from] arch_sdk::ArchError),
    
    #[error("Invalid account: {0}")]
    InvalidAccount(String),
    
    #[error("Insufficient balance: needed {needed}, available {available}")]
    InsufficientBalance { needed: u64, available: u64 },
    
    #[error("Transaction failed: {0}")]
    TransactionFailed(String),
}

// Retry logic with exponential backoff
async fn retry_with_backoff&lt;T, F, Fut&gt;(
    operation: F,
    max_retries: u32,
) -&gt; Result&lt;T, ArchAppError&gt;
where
    F: Fn() -&gt; Fut,
    Fut: std::future::Future&lt;Output = Result&lt;T, ArchAppError&gt;&gt;,
{
    let mut delay = Duration::from_millis(100);
    
    for attempt in 0..max_retries {
        match operation().await {
            Ok(result) =&gt; return Ok(result),
            Err(e) =&gt; {
                if attempt == max_retries - 1 {
                    return Err(e);
                }
                
                println!("Attempt {} failed: {}. Retrying...", attempt + 1, e);
                sleep(delay).await;
                delay *= 2; // Exponential backoff
            }
        }
    }
    
    unreachable!()
}</code></pre>
<h2 id="testing-patterns"><a class="header" href="#testing-patterns">Testing Patterns</a></h2>
<h3 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_sdk::test_utils::{TestValidator, TestValidatorGenesis};
    
    #[tokio::test]
    async fn test_program_deployment() {
        // Start test validator
        let mut genesis = TestValidatorGenesis::default();
        genesis.add_program("my_program", my_program_id());
        
        let validator = TestValidator::with_genesis(genesis).await;
        let connection = validator.connection();
        
        // Test program functionality
        let payer = validator.payer();
        let account = Keypair::new();
        
        // Create and initialize account
        let ix = create_initialize_instruction(
            &amp;my_program_id(),
            &amp;account.pubkey(),
            &amp;payer.pubkey(),
        );
        
        let mut transaction = Transaction::new_with_payer(
            &amp;[ix],
            Some(&amp;payer.pubkey()),
        );
        
        let recent_blockhash = connection.get_latest_blockhash().await.unwrap();
        transaction.sign(&amp;[&amp;payer, &amp;account], recent_blockhash);
        
        let result = connection.send_and_confirm_transaction(&amp;transaction).await;
        assert!(result.is_ok());
    }
}</code></pre>
<h2 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h2>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<pre><code class="language-rust ignore">use std::sync::Arc;
use dashmap::DashMap;

pub struct ConnectionPool {
    connections: DashMap&lt;String, Arc&lt;Connection&gt;&gt;,
}

impl ConnectionPool {
    pub fn new() -&gt; Self {
        Self {
            connections: DashMap::new(),
        }
    }
    
    pub fn get_connection(&amp;self, endpoint: &amp;str) -&gt; Arc&lt;Connection&gt; {
        self.connections
            .entry(endpoint.to_string())
            .or_insert_with(|| Arc::new(Connection::new(endpoint)))
            .clone()
    }
}

// Usage
lazy_static::lazy_static! {
    static ref POOL: ConnectionPool = ConnectionPool::new();
}

async fn use_pooled_connection() -&gt; Result&lt;()&gt; {
    let connection = POOL.get_connection("http://localhost:9002");
    let block_count = connection.get_block_count().await?;
    println!("Block count: {}", block_count);
    Ok(())
}</code></pre>
<h2 id="resources-2"><a class="header" href="#resources-2">Resources</a></h2>
<p>For more examples and patterns:</p>
<ul>
<li><a href="https://github.com/arch-network/arch-network/tree/main/examples">Arch Network Examples</a></li>
<li><a href="https://docs.rs/arch_sdk">Rust SDK Documentation</a></li>
<li><a href="sdk/rust/../../program/program.html">Program Examples</a></li>
<li><a href="https://github.com/arch-network/arch-network/tree/main/tests">Integration Test Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-development-guide"><a class="header" href="#program-development-guide">Program Development Guide</a></h1>
<p>This guide covers developing on-chain programs (smart contracts) for the Arch Network using the Rust SDK.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>Arch Network programs are compiled Rust code that runs on the network‚Äôs runtime. Programs can:</p>
<ul>
<li>Manage account state</li>
<li>Process transactions</li>
<li>Interact with other programs</li>
<li>Interface with Bitcoin UTXOs</li>
</ul>
<h2 id="setting-up-your-development-environment"><a class="header" href="#setting-up-your-development-environment">Setting Up Your Development Environment</a></h2>
<h3 id="prerequisites-10"><a class="header" href="#prerequisites-10">Prerequisites</a></h3>
<pre><code class="language-bash"># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install Arch CLI tools
cargo install arch-cli

# Install BPF tools
arch install
</code></pre>
<h3 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h3>
<pre><code class="language-bash">my-program/
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs         # Program entrypoint
‚îÇ   ‚îú‚îÄ‚îÄ instruction.rs # Instruction definitions
‚îÇ   ‚îú‚îÄ‚îÄ processor.rs   # Processing logic
‚îÇ   ‚îú‚îÄ‚îÄ state.rs      # State structures
‚îÇ   ‚îî‚îÄ‚îÄ error.rs      # Custom errors
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ integration.rs # Integration tests
‚îî‚îÄ‚îÄ deploy/
    ‚îî‚îÄ‚îÄ deploy.ts      # Deployment scripts
</code></pre>
<h2 id="your-first-program"><a class="header" href="#your-first-program">Your First Program</a></h2>
<h3 id="basic-program-structure-1"><a class="header" href="#basic-program-structure-1">Basic Program Structure</a></h3>
<pre><code class="language-rust ignore">// src/lib.rs
use arch_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    pubkey::Pubkey,
};

// Declare the program's entrypoint
entrypoint!(process_instruction);

// Program entrypoint implementation
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    msg!("Program entrypoint");
    
    // Your program logic here
    Ok(())
}</code></pre>
<h3 id="cargotoml-configuration"><a class="header" href="#cargotoml-configuration">Cargo.toml Configuration</a></h3>
<pre><code class="language-toml">[package]
name = "my_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[features]
no-entrypoint = []
test-bpf = []

[dependencies]
arch_program = "0.5.4"
borsh = "1.5.1"
thiserror = "1.0"

[dev-dependencies]
arch_sdk = "0.5.4"
tokio = { version = "1", features = ["full"] }
</code></pre>
<h2 id="instruction-processing"><a class="header" href="#instruction-processing">Instruction Processing</a></h2>
<h3 id="define-instructions"><a class="header" href="#define-instructions">Define Instructions</a></h3>
<pre><code class="language-rust ignore">// src/instruction.rs
use borsh::{BorshDeserialize, BorshSerialize};
use arch_program::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    system_program,
};

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub enum MyInstruction {
    /// Initialize a new account
    /// Accounts:
    /// 0. `[writable]` The account to initialize
    /// 1. `[signer]` The account's authority
    Initialize {
        seed: u64,
    },
    
    /// Update account data
    /// Accounts:
    /// 0. `[writable]` The account to update
    /// 1. `[signer]` The account's authority
    Update {
        data: Vec&lt;u8&gt;,
    },
    
    /// Transfer ownership
    /// Accounts:
    /// 0. `[writable]` The account to transfer
    /// 1. `[signer]` Current authority
    /// 2. `[]` New authority
    Transfer,
}

impl MyInstruction {
    pub fn unpack(input: &amp;[u8]) -&gt; Result&lt;Self, ProgramError&gt; {
        MyInstruction::try_from_slice(input)
            .map_err(|_| ProgramError::InvalidInstructionData)
    }
}</code></pre>
<h3 id="process-instructions"><a class="header" href="#process-instructions">Process Instructions</a></h3>
<pre><code class="language-rust ignore">// src/processor.rs
use arch_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
};
use crate::{instruction::MyInstruction, state::MyState};

pub struct Processor;

impl Processor {
    pub fn process(
        program_id: &amp;Pubkey,
        accounts: &amp;[AccountInfo],
        instruction_data: &amp;[u8],
    ) -&gt; ProgramResult {
        let instruction = MyInstruction::unpack(instruction_data)?;
        
        match instruction {
            MyInstruction::Initialize { seed } =&gt; {
                msg!("Instruction: Initialize");
                Self::process_initialize(accounts, seed, program_id)
            }
            MyInstruction::Update { data } =&gt; {
                msg!("Instruction: Update");
                Self::process_update(accounts, data, program_id)
            }
            MyInstruction::Transfer =&gt; {
                msg!("Instruction: Transfer");
                Self::process_transfer(accounts, program_id)
            }
        }
    }
    
    fn process_initialize(
        accounts: &amp;[AccountInfo],
        seed: u64,
        program_id: &amp;Pubkey,
    ) -&gt; ProgramResult {
        let account_info_iter = &amp;mut accounts.iter();
        let account = next_account_info(account_info_iter)?;
        let authority = next_account_info(account_info_iter)?;
        
        // Verify account ownership
        if account.owner != program_id {
            return Err(ProgramError::IncorrectProgramId);
        }
        
        // Verify authority is signer
        if !authority.is_signer {
            return Err(ProgramError::MissingRequiredSignature);
        }
        
        // Initialize state
        let state = MyState {
            is_initialized: true,
            authority: *authority.key,
            seed,
            data: vec![],
        };
        
        state.serialize(&amp;mut &amp;mut account.data.borrow_mut()[..])?;
        msg!("Account initialized successfully");
        
        Ok(())
    }
}</code></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<h3 id="define-state-structures"><a class="header" href="#define-state-structures">Define State Structures</a></h3>
<pre><code class="language-rust ignore">// src/state.rs
use borsh::{BorshDeserialize, BorshSerialize};
use arch_program::{
    program_error::ProgramError,
    pubkey::Pubkey,
};

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct MyState {
    pub is_initialized: bool,
    pub authority: Pubkey,
    pub seed: u64,
    pub data: Vec&lt;u8&gt;,
}

impl MyState {
    pub const LEN: usize = 1 + 32 + 8 + 4; // Base size without dynamic data
    
    pub fn unpack(input: &amp;[u8]) -&gt; Result&lt;Self, ProgramError&gt; {
        MyState::try_from_slice(input)
            .map_err(|_| ProgramError::InvalidAccountData)
    }
    
    pub fn pack(&amp;self, dst: &amp;mut [u8]) -&gt; Result&lt;(), ProgramError&gt; {
        self.serialize(&amp;mut &amp;mut dst[..])
            .map_err(|_| ProgramError::InvalidAccountData)
    }
}

// Account size calculation helper
impl MyState {
    pub fn get_packed_len(data_len: usize) -&gt; usize {
        Self::LEN + data_len
    }
}</code></pre>
<h3 id="program-derived-addresses-pdas-1"><a class="header" href="#program-derived-addresses-pdas-1">Program-Derived Addresses (PDAs)</a></h3>
<pre><code class="language-rust ignore">use arch_program::{
    pubkey::Pubkey,
    program_error::ProgramError,
};

pub fn find_program_address(
    seeds: &amp;[&amp;[u8]],
    program_id: &amp;Pubkey,
) -&gt; (Pubkey, u8) {
    Pubkey::find_program_address(seeds, program_id)
}

// Example: Creating a PDA for user data
pub fn get_user_pda(
    user: &amp;Pubkey,
    program_id: &amp;Pubkey,
) -&gt; (Pubkey, u8) {
    find_program_address(
        &amp;[b"user", user.as_ref()],
        program_id,
    )
}

// Using PDAs in instructions
fn process_create_pda(
    accounts: &amp;[AccountInfo],
    program_id: &amp;Pubkey,
) -&gt; ProgramResult {
    let account_info_iter = &amp;mut accounts.iter();
    let user = next_account_info(account_info_iter)?;
    let pda_account = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;
    
    let (pda, bump) = get_user_pda(user.key, program_id);
    
    if pda != *pda_account.key {
        return Err(ProgramError::InvalidSeeds);
    }
    
    // Create PDA account
    let rent = Rent::get()?;
    let space = MyState::LEN;
    let lamports = rent.minimum_balance(space);
    
    invoke_signed(
        &amp;system_instruction::create_account(
            user.key,
            &amp;pda,
            lamports,
            space as u64,
            program_id,
        ),
        &amp;[user.clone(), pda_account.clone(), system_program.clone()],
        &amp;[&amp;[b"user", user.key.as_ref(), &amp;[bump]]],
    )?;
    
    Ok(())
}</code></pre>
<h2 id="cross-program-invocation-cpi-3"><a class="header" href="#cross-program-invocation-cpi-3">Cross-Program Invocation (CPI)</a></h2>
<h3 id="making-cpi-calls"><a class="header" href="#making-cpi-calls">Making CPI Calls</a></h3>
<pre><code class="language-rust ignore">use arch_program::{
    account_info::AccountInfo,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey,
};

// Simple CPI
pub fn transfer_tokens_cpi(
    token_program_id: &amp;Pubkey,
    source: &amp;AccountInfo,
    destination: &amp;AccountInfo,
    authority: &amp;AccountInfo,
    amount: u64,
) -&gt; ProgramResult {
    let accounts = vec![
        AccountMeta::new(*source.key, false),
        AccountMeta::new(*destination.key, false),
        AccountMeta::new_readonly(*authority.key, true),
    ];
    
    let instruction = Instruction::new_with_bytes(
        *token_program_id,
        &amp;[3, amount.to_le_bytes()].concat(), // Transfer instruction
        accounts,
    );
    
    invoke(
        &amp;instruction,
        &amp;[source.clone(), destination.clone(), authority.clone()],
    )
}

// CPI with PDA signer
pub fn transfer_from_pda(
    source_pda: &amp;AccountInfo,
    destination: &amp;AccountInfo,
    amount: u64,
    pda_seeds: &amp;[&amp;[u8]],
    program_id: &amp;Pubkey,
) -&gt; ProgramResult {
    let instruction = system_instruction::transfer(
        source_pda.key,
        destination.key,
        amount,
    );
    
    invoke_signed(
        &amp;instruction,
        &amp;[source_pda.clone(), destination.clone()],
        &amp;[pda_seeds],
    )
}</code></pre>
<h2 id="error-handling-9"><a class="header" href="#error-handling-9">Error Handling</a></h2>
<h3 id="custom-errors"><a class="header" href="#custom-errors">Custom Errors</a></h3>
<pre><code class="language-rust ignore">// src/error.rs
use thiserror::Error;
use arch_program::program_error::ProgramError;

#[derive(Error, Debug, Copy, Clone)]
pub enum MyError {
    #[error("Invalid instruction")]
    InvalidInstruction,
    
    #[error("Account not initialized")]
    NotInitialized,
    
    #[error("Unauthorized")]
    Unauthorized,
    
    #[error("Arithmetic overflow")]
    Overflow,
    
    #[error("Invalid seed value")]
    InvalidSeed,
}

impl From&lt;MyError&gt; for ProgramError {
    fn from(e: MyError) -&gt; Self {
        ProgramError::Custom(e as u32)
    }
}</code></pre>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<h3 id="account-validation"><a class="header" href="#account-validation">Account Validation</a></h3>
<pre><code class="language-rust ignore">pub fn check_account_owner(
    account: &amp;AccountInfo,
    expected_owner: &amp;Pubkey,
) -&gt; ProgramResult {
    if account.owner != expected_owner {
        msg!("Account owner mismatch");
        return Err(ProgramError::IncorrectProgramId);
    }
    Ok(())
}

pub fn check_signer(account: &amp;AccountInfo) -&gt; ProgramResult {
    if !account.is_signer {
        msg!("Missing required signature");
        return Err(ProgramError::MissingRequiredSignature);
    }
    Ok(())
}

pub fn check_writable(account: &amp;AccountInfo) -&gt; ProgramResult {
    if !account.is_writable {
        msg!("Account is not writable");
        return Err(ProgramError::InvalidAccountData);
    }
    Ok(())
}</code></pre>
<h3 id="arithmetic-safety"><a class="header" href="#arithmetic-safety">Arithmetic Safety</a></h3>
<pre><code class="language-rust ignore">pub fn safe_add(a: u64, b: u64) -&gt; Result&lt;u64, ProgramError&gt; {
    a.checked_add(b)
        .ok_or_else(|| MyError::Overflow.into())
}

pub fn safe_sub(a: u64, b: u64) -&gt; Result&lt;u64, ProgramError&gt; {
    a.checked_sub(b)
        .ok_or_else(|| MyError::Overflow.into())
}

pub fn safe_mul(a: u64, b: u64) -&gt; Result&lt;u64, ProgramError&gt; {
    a.checked_mul(b)
        .ok_or_else(|| MyError::Overflow.into())
}</code></pre>
<h2 id="testing-your-program-1"><a class="header" href="#testing-your-program-1">Testing Your Program</a></h2>
<h3 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::clock::Epoch;
    
    #[test]
    fn test_state_packing() {
        let state = MyState {
            is_initialized: true,
            authority: Pubkey::new_unique(),
            seed: 42,
            data: vec![1, 2, 3, 4],
        };
        
        let mut packed = vec![0; state.get_packed_len(4)];
        state.pack(&amp;mut packed).unwrap();
        
        let unpacked = MyState::unpack(&amp;packed).unwrap();
        assert_eq!(state.is_initialized, unpacked.is_initialized);
        assert_eq!(state.authority, unpacked.authority);
        assert_eq!(state.seed, unpacked.seed);
        assert_eq!(state.data, unpacked.data);
    }
}</code></pre>
<h3 id="integration-tests-2"><a class="header" href="#integration-tests-2">Integration Tests</a></h3>
<pre><code class="language-rust ignore">// tests/integration.rs
use arch_sdk::{
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use arch_program_test::*;

#[tokio::test]
async fn test_initialize() {
    let program_id = Pubkey::new_unique();
    let mut program_test = ProgramTest::new(
        "my_program",
        program_id,
        processor!(process_instruction),
    );
    
    let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
    
    let account = Keypair::new();
    let authority = Keypair::new();
    
    let mut transaction = Transaction::new_with_payer(
        &amp;[
            // Create account
            system_instruction::create_account(
                &amp;payer.pubkey(),
                &amp;account.pubkey(),
                1_000_000,
                MyState::LEN as u64,
                &amp;program_id,
            ),
            // Initialize
            Instruction::new_with_borsh(
                program_id,
                &amp;MyInstruction::Initialize { seed: 42 },
                vec![
                    AccountMeta::new(account.pubkey(), false),
                    AccountMeta::new_readonly(authority.pubkey(), true),
                ],
            ),
        ],
        Some(&amp;payer.pubkey()),
    );
    
    transaction.sign(&amp;[&amp;payer, &amp;account, &amp;authority], recent_blockhash);
    banks_client.process_transaction(transaction).await.unwrap();
}</code></pre>
<h2 id="building-and-deploying"><a class="header" href="#building-and-deploying">Building and Deploying</a></h2>
<h3 id="build-your-program"><a class="header" href="#build-your-program">Build Your Program</a></h3>
<pre><code class="language-bash"># Build for BPF target
cargo build-bpf

# Output will be in target/deploy/my_program.so
</code></pre>
<h3 id="deploy-to-network"><a class="header" href="#deploy-to-network">Deploy to Network</a></h3>
<pre><code class="language-bash"># Deploy using Arch CLI
arch program deploy target/deploy/my_program.so

# Or using custom deployment script
arch program deploy \
    --program target/deploy/my_program.so \
    --keypair ~/.config/arch/id.json \
    --url http://localhost:9002
</code></pre>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="upgradeable-programs"><a class="header" href="#upgradeable-programs">Upgradeable Programs</a></h3>
<p>Programs can be made upgradeable by using a proxy pattern:</p>
<pre><code class="language-rust ignore">// Proxy program that delegates to implementation
pub fn process_proxy(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    let account_info_iter = &amp;mut accounts.iter();
    let program_data = next_account_info(account_info_iter)?;
    
    // Load implementation address from program data
    let impl_program_id = get_implementation_id(program_data)?;
    
    // Forward call to implementation
    invoke(
        &amp;Instruction::new_with_bytes(
            impl_program_id,
            instruction_data,
            accounts[1..].iter()
                .map(|acc| AccountMeta {
                    pubkey: *acc.key,
                    is_signer: acc.is_signer,
                    is_writable: acc.is_writable,
                })
                .collect(),
        ),
        accounts,
    )
}</code></pre>
<h2 id="resources-3"><a class="header" href="#resources-3">Resources</a></h2>
<ul>
<li><a href="sdk/rust/../../program/program.html">Program Examples</a></li>
<li><a href="https://docs.rs/arch_program">Arch Program Crate Docs</a></li>
<li><a href="https://github.com/arch-network/arch-network/tree/main/examples">Example Programs</a></li>
<li><a href="sdk/rust/../../guides/testing-guide.html">Testing Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-types-1"><a class="header" href="#core-types-1">Core Types</a></h1>
<p>These core types and concepts are shared by both SDKs and used throughout the docs:</p>
<ul>
<li><a href="sdk/pubkey.html">Pubkey</a> - Public key type for identifying accounts</li>
<li><a href="sdk/account.html">Account</a> - Account structure and management</li>
<li><a href="sdk/instructions-and-messages.html">Instructions and Messages</a> - Transaction building</li>
<li><a href="sdk/runtime-transaction.html">Runtime Transaction</a> - Transaction format</li>
<li><a href="sdk/processed-transaction.html">Processed Transaction</a> - Transaction results</li>
<li><a href="sdk/signature.html">Signature</a> - Digital signatures</li>
</ul>
<p>See also: <a href="sdk/sdk.html">SDK Overview</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubkey-public-key"><a class="header" href="#pubkey-public-key">Pubkey (Public Key)</a></h1>
<p>A <code>Pubkey</code> represents a public key in the Arch Network, serving as a unique identifier for accounts, programs, and other entities. It‚Äôs a fundamental type you‚Äôll use throughout your development with the Arch SDK.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct Pubkey([u8; 32]);</code></pre>
<p>A <code>Pubkey</code> is a 32-byte (256-bit) value derived from a private key using elliptic curve cryptography. Every account, program, and other entity on the Arch Network has a unique <code>Pubkey</code> that serves as its address.</p>
<h2 id="creating-public-keys"><a class="header" href="#creating-public-keys">Creating Public Keys</a></h2>
<h3 id="from-a-private-key"><a class="header" href="#from-a-private-key">From a Private Key</a></h3>
<pre><code class="language-typescript">import { Keypair } from '@saturnbtcio/arch-sdk';

// Generate a new keypair
const keypair = Keypair.generate();
const publicKey = keypair.publicKey;

// From existing private key
const keypair2 = Keypair.fromSecretKey(secretKeyBytes);
const publicKey2 = keypair2.publicKey;
</code></pre>
<h3 id="from-a-string"><a class="header" href="#from-a-string">From a String</a></h3>
<pre><code class="language-typescript">import { Pubkey } from '@saturnbtcio/arch-sdk';

// From base58 string
const publicKey = new Pubkey('11111111111111111111111111111112');

// From hex string
const publicKey2 = new Pubkey('0x1234567890abcdef...');
</code></pre>
<h3 id="from-bytes"><a class="header" href="#from-bytes">From Bytes</a></h3>
<pre><code class="language-typescript">import { Pubkey } from '@saturnbtcio/arch-sdk';

// From 32-byte array
const bytes = new Uint8Array(32);
// ... fill with your bytes
const publicKey = new Pubkey(bytes);
</code></pre>
<h2 id="common-operations"><a class="header" href="#common-operations">Common Operations</a></h2>
<h3 id="converting-to-different-formats"><a class="header" href="#converting-to-different-formats">Converting to Different Formats</a></h3>
<pre><code class="language-typescript">// Convert to base58 string
const base58String = publicKey.toBase58();

// Convert to hex string
const hexString = publicKey.toHex();

// Convert to bytes
const bytes = publicKey.toBytes();

// Convert to JSON
const json = publicKey.toJSON();
</code></pre>
<h3 id="comparison"><a class="header" href="#comparison">Comparison</a></h3>
<pre><code class="language-typescript">// Check equality
const isEqual = publicKey1.equals(publicKey2);

// Compare public keys
const comparison = publicKey1.compare(publicKey2);

// Check if valid
const isValid = Pubkey.isValid(publicKeyString);
</code></pre>
<h2 id="special-public-keys"><a class="header" href="#special-public-keys">Special Public Keys</a></h2>
<h3 id="system-program-1"><a class="header" href="#system-program-1">System Program</a></h3>
<pre><code class="language-typescript">import { Pubkey } from '@saturnbtcio/arch-sdk';

// System program public key
const systemProgram = Pubkey.systemProgram();
</code></pre>
<h3 id="token-program-2"><a class="header" href="#token-program-2">Token Program</a></h3>
<pre><code class="language-typescript">// Token program public key
const tokenProgram = Pubkey.tokenProgram();
</code></pre>
<h3 id="associated-token-account-program-2"><a class="header" href="#associated-token-account-program-2">Associated Token Account Program</a></h3>
<pre><code class="language-typescript">// Associated token account program public key
const ataProgram = Pubkey.associatedTokenAccountProgram();
</code></pre>
<h2 id="program-derived-addresses-pdas-2"><a class="header" href="#program-derived-addresses-pdas-2">Program Derived Addresses (PDAs)</a></h2>
<p>Program Derived Addresses are special public keys that are derived deterministically from a program ID and seeds, but have no corresponding private key.</p>
<pre><code class="language-typescript">import { Pubkey } from '@saturnbtcio/arch-sdk';

// Create a PDA
const [pda, bump] = Pubkey.findProgramAddressSync(
  [
    Buffer.from('my-seed'),
    userPublicKey.toBuffer(),
    Buffer.from('additional-seed')
  ],
  programId
);

console.log('PDA:', pda.toBase58());
console.log('Bump:', bump);
</code></pre>
<h3 id="using-pdas-in-programs"><a class="header" href="#using-pdas-in-programs">Using PDAs in Programs</a></h3>
<pre><code class="language-rust ignore">use arch_sdk::{Pubkey, ProgramError};

// Derive PDA in program
let (pda, bump) = Pubkey::find_program_address(
    &amp;[
        b"my-seed",
        user_pubkey.as_ref(),
        b"additional-seed"
    ],
    program_id
);

// Verify PDA
if pda != expected_pda {
    return Err(ProgramError::InvalidArgument);
}</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<pre><code class="language-typescript">// Validate public key format
function validatePublicKey(input: string): boolean {
  try {
    const pubkey = new Pubkey(input);
    return true;
  } catch (error) {
    return false;
  }
}

// Check if string is valid public key
const isValidKey = Pubkey.isValid(userInput);
</code></pre>
<h3 id="security-considerations-8"><a class="header" href="#security-considerations-8">Security Considerations</a></h3>
<pre><code class="language-typescript">// Always validate public keys from user input
function processUserAccount(accountString: string) {
  if (!Pubkey.isValid(accountString)) {
    throw new Error('Invalid public key format');
  }
  
  const publicKey = new Pubkey(accountString);
  // ... process the account
}
</code></pre>
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="account-management-4"><a class="header" href="#account-management-4">Account Management</a></h3>
<pre><code class="language-typescript">// Store public keys in your application
interface UserAccount {
  publicKey: Pubkey;
  balance: number;
  isProgram: boolean;
}

// Create account references
const accounts: UserAccount[] = [
  {
    publicKey: new Pubkey('11111111111111111111111111111112'),
    balance: 1000,
    isProgram: false
  }
];
</code></pre>
<h3 id="transaction-building-1"><a class="header" href="#transaction-building-1">Transaction Building</a></h3>
<pre><code class="language-typescript">// Use public keys in transactions
const instruction = new Instruction({
  programId: myProgramId,
  accounts: [
    { pubkey: userPublicKey, isSigner: true, isWritable: true },
    { pubkey: recipientPublicKey, isSigner: false, isWritable: true }
  ],
  data: instructionData
});
</code></pre>
<h2 id="error-handling-10"><a class="header" href="#error-handling-10">Error Handling</a></h2>
<pre><code class="language-typescript">try {
  const publicKey = new Pubkey(userInput);
} catch (error) {
  if (error instanceof PublicKeyError) {
    console.error('Invalid public key:', error.message);
  } else {
    console.error('Unexpected error:', error);
  }
}
</code></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<h3 id="security-4"><a class="header" href="#security-4">Security</a></h3>
<ul>
<li><strong>Always validate input</strong>: Never trust user-provided public key strings</li>
<li><strong>Use type safety</strong>: Take advantage of TypeScript/Rust type systems</li>
<li><strong>Verify ownership</strong>: Check that accounts are owned by expected programs</li>
</ul>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<ul>
<li><strong>Cache public keys</strong>: Avoid recreating the same public key objects</li>
<li><strong>Use constants</strong>: Define well-known public keys as constants</li>
<li><strong>Batch operations</strong>: Process multiple public keys together when possible</li>
</ul>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<ul>
<li><strong>Use meaningful names</strong>: Give public key variables descriptive names</li>
<li><strong>Document usage</strong>: Explain what each public key represents</li>
<li><strong>Test edge cases</strong>: Test with invalid and edge-case public keys</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>For complete examples using public keys, see:</p>
<ul>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/helloworld">Hello World</a></strong> - Basic public key usage</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/account">Account Management</a></strong> - Working with accounts</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/pda">PDA Examples</a></strong> - Program derived addresses</li>
</ul>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The <code>Pubkey</code> implementation is available in the <a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/pubkey.rs">Arch Examples Repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-1"><a class="header" href="#account-1">Account</a></h1>
<p>Accounts are the fundamental data storage unit in the Arch Network. They hold state, store data, and define ownership relationships. Understanding accounts is crucial for building applications on Arch.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>Every piece of data on the Arch Network is stored in an account. Accounts can hold:</p>
<ul>
<li><strong>Program code</strong> (executable accounts)</li>
<li><strong>Application data</strong> (data accounts)</li>
<li><strong>User balances</strong> (token accounts)</li>
<li><strong>Configuration settings</strong> (configuration accounts)</li>
</ul>
<h2 id="account-structure-1"><a class="header" href="#account-structure-1">Account Structure</a></h2>
<h3 id="accountinfo"><a class="header" href="#accountinfo">AccountInfo</a></h3>
<p>The <code>AccountInfo</code> struct provides a view into an account during program execution:</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
#[repr(C)]
pub struct AccountInfo&lt;'a&gt; {
    pub key: &amp;'a Pubkey,           // Account's public key (address)
    pub utxo: &amp;'a UtxoMeta,        // Associated UTXO metadata
    pub data: Rc&lt;RefCell&lt;&amp;'a mut [u8]&gt;&gt;, // Account data
    pub owner: &amp;'a Pubkey,         // Program that owns this account
    pub is_signer: bool,           // Whether account signed the transaction
    pub is_writable: bool,         // Whether account data can be modified
    pub is_executable: bool,       // Whether account contains executable code
}</code></pre>
<h3 id="accountmeta-1"><a class="header" href="#accountmeta-1">AccountMeta</a></h3>
<p>The <code>AccountMeta</code> struct describes how an account is used in a transaction:</p>
<pre><code class="language-rust ignore">#[derive(Debug, PartialEq, Eq, Clone, Serialize, Deserialize)]
#[repr(C)]
pub struct AccountMeta {
    pub pubkey: Pubkey,    // Account's public key
    pub is_signer: bool,   // Must the account sign the transaction?
    pub is_writable: bool, // Can the account's data be modified?
}</code></pre>
<h2 id="creating-accounts-1"><a class="header" href="#creating-accounts-1">Creating Accounts</a></h2>
<h3 id="using-the-sdk"><a class="header" href="#using-the-sdk">Using the SDK</a></h3>
<pre><code class="language-typescript">import { Connection, Keypair, SystemProgram } from '@saturnbtcio/arch-sdk';

// Generate a new account keypair
const newAccount = Keypair.generate();

// Create account instruction
const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: payer.publicKey,
  newAccountPubkey: newAccount.publicKey,
  lamports: 1000000, // Rent-exempt balance
  space: 256,        // Account data size
  programId: myProgramId
});

// Send transaction
const transaction = new Transaction()
  .add(createAccountInstruction);

const signature = await connection.sendAndConfirmTransaction(
  transaction,
  [payer, newAccount]
);
</code></pre>
<h3 id="using-the-faucet-development"><a class="header" href="#using-the-faucet-development">Using the Faucet (Development)</a></h3>
<pre><code class="language-typescript">// Create and fund account with faucet (testnet/devnet only)
const newAccount = Keypair.generate();

const transaction = await connection.createAccountWithFaucet(
  newAccount.publicKey
);

console.log('Account created and funded:', newAccount.publicKey.toBase58());
</code></pre>
<h2 id="reading-account-data"><a class="header" href="#reading-account-data">Reading Account Data</a></h2>
<h3 id="get-account-information"><a class="header" href="#get-account-information">Get Account Information</a></h3>
<pre><code class="language-typescript">// Get basic account info
const accountInfo = await connection.getAccountInfo(publicKey);

if (accountInfo) {
  console.log('Owner:', accountInfo.owner.toBase58());
  console.log('Balance:', accountInfo.lamports);
  console.log('Data length:', accountInfo.data.length);
  console.log('Is executable:', accountInfo.executable);
}
</code></pre>
<h3 id="get-multiple-accounts-1"><a class="header" href="#get-multiple-accounts-1">Get Multiple Accounts</a></h3>
<pre><code class="language-typescript">// Get multiple accounts at once
const accounts = await connection.getMultipleAccountsInfo([
  publicKey1,
  publicKey2,
  publicKey3
]);

accounts.forEach((account, index) =&gt; {
  if (account) {
    console.log(`Account ${index}:`, account.owner.toBase58());
  } else {
    console.log(`Account ${index}: Not found`);
  }
});
</code></pre>
<h3 id="query-program-accounts"><a class="header" href="#query-program-accounts">Query Program Accounts</a></h3>
<pre><code class="language-typescript">// Get all accounts owned by a program
const programAccounts = await connection.getProgramAccounts(programId);

// With filters
const filteredAccounts = await connection.getProgramAccounts(programId, {
  filters: [
    {
      dataSize: 165 // Only accounts with exactly 165 bytes
    },
    {
      memcmp: {
        offset: 0,
        bytes: '3Mc6vR'  // Base58 encoded bytes to match at offset 0
      }
    }
  ]
});
</code></pre>
<h2 id="account-ownership"><a class="header" href="#account-ownership">Account Ownership</a></h2>
<h3 id="system-program-accounts"><a class="header" href="#system-program-accounts">System Program Accounts</a></h3>
<p>By default, all accounts are owned by the System Program:</p>
<pre><code class="language-typescript">import { SystemProgram } from '@saturnbtcio/arch-sdk';

// Check if account is owned by system program
const isSystemAccount = accountInfo.owner.equals(SystemProgram.programId);
</code></pre>
<h3 id="program-owned-accounts"><a class="header" href="#program-owned-accounts">Program-Owned Accounts</a></h3>
<p>Programs can own accounts to store their data:</p>
<pre><code class="language-typescript">// Check if account is owned by your program
const isOwnedByMyProgram = accountInfo.owner.equals(myProgramId);

// Transfer ownership (only the current owner can do this)
const transferInstruction = SystemProgram.assign({
  accountPubkey: accountPublicKey,
  programId: newOwnerProgramId
});
</code></pre>
<h2 id="working-with-account-data"><a class="header" href="#working-with-account-data">Working with Account Data</a></h2>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<pre><code class="language-typescript">// Serialize data to store in account
import { serialize, deserialize } from 'borsh';

// Define your data structure
class MyAccountData {
  constructor(public value: number, public name: string) {}
  
  static schema = new Map([
    [MyAccountData, {
      kind: 'struct',
      fields: [
        ['value', 'u64'],
        ['name', 'string']
      ]
    }]
  ]);
}

// Serialize for storage
const data = new MyAccountData(42, 'Hello');
const serialized = serialize(MyAccountData.schema, data);

// Deserialize from account
const deserialized = deserialize(MyAccountData.schema, accountData);
</code></pre>
<h3 id="updating-account-data"><a class="header" href="#updating-account-data">Updating Account Data</a></h3>
<pre><code class="language-rust ignore">// In your program
use arch_sdk::{AccountInfo, ProgramResult};

pub fn update_account_data(
    account_info: &amp;AccountInfo,
    new_value: u64
) -&gt; ProgramResult {
    // Check ownership
    if account_info.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Check if writable
    if !account_info.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Update data
    let mut data = account_info.data.borrow_mut();
    // ... update data
    
    Ok(())
}</code></pre>
<h2 id="account-security"><a class="header" href="#account-security">Account Security</a></h2>
<h3 id="validation-1"><a class="header" href="#validation-1">Validation</a></h3>
<pre><code class="language-typescript">// Always validate account ownership
function validateAccountOwnership(
  account: AccountInfo,
  expectedOwner: Pubkey
): boolean {
  return account.owner.equals(expectedOwner);
}

// Check account signatures
function validateAccountSignature(
  account: AccountInfo,
  requiredSigner: Pubkey
): boolean {
  return account.is_signer &amp;&amp; account.key.equals(requiredSigner);
}
</code></pre>
<h3 id="access-control"><a class="header" href="#access-control">Access Control</a></h3>
<pre><code class="language-rust ignore">// Program-side validation
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8]
) -&gt; ProgramResult {
    let account_info = &amp;accounts[0];
    
    // Verify ownership
    if account_info.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Verify signer
    if !account_info.is_signer {
        return Err(ProgramError::MissingRequiredSignature);
    }
    
    // Verify writable
    if !account_info.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Process the instruction
    Ok(())
}</code></pre>
<h2 id="common-patterns-4"><a class="header" href="#common-patterns-4">Common Patterns</a></h2>
<h3 id="account-initialization"><a class="header" href="#account-initialization">Account Initialization</a></h3>
<pre><code class="language-typescript">// Initialize account with default data
const initializeInstruction = new Instruction({
  programId: myProgramId,
  accounts: [
    { pubkey: newAccount.publicKey, isSigner: true, isWritable: true },
    { pubkey: payer.publicKey, isSigner: true, isWritable: false }
  ],
  data: Buffer.from([0]) // Initialize instruction
});
</code></pre>
<h3 id="account-closure"><a class="header" href="#account-closure">Account Closure</a></h3>
<pre><code class="language-typescript">// Close account and reclaim rent
const closeInstruction = new Instruction({
  programId: myProgramId,
  accounts: [
    { pubkey: accountToClose.publicKey, isSigner: true, isWritable: true },
    { pubkey: destination.publicKey, isSigner: false, isWritable: true }
  ],
  data: Buffer.from([255]) // Close instruction
});
</code></pre>
<h2 id="error-handling-11"><a class="header" href="#error-handling-11">Error Handling</a></h2>
<pre><code class="language-typescript">try {
  const accountInfo = await connection.getAccountInfo(publicKey);
  
  if (!accountInfo) {
    throw new Error('Account not found');
  }
  
  if (!accountInfo.executable) {
    throw new Error('Account is not executable');
  }
  
} catch (error) {
  if (error instanceof AccountNotFoundError) {
    console.error('Account does not exist');
  } else {
    console.error('Error fetching account:', error);
  }
}
</code></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<h3 id="security-5"><a class="header" href="#security-5">Security</a></h3>
<ul>
<li><strong>Always validate ownership</strong>: Check that accounts are owned by expected programs</li>
<li><strong>Verify signatures</strong>: Ensure required accounts have signed the transaction</li>
<li><strong>Check permissions</strong>: Verify accounts have appropriate read/write permissions</li>
<li><strong>Validate data</strong>: Always validate account data before processing</li>
</ul>
<h3 id="performance-3"><a class="header" href="#performance-3">Performance</a></h3>
<ul>
<li><strong>Batch account queries</strong>: Use <code>getMultipleAccountsInfo</code> for multiple accounts</li>
<li><strong>Use filters</strong>: Apply filters when querying program accounts</li>
<li><strong>Cache account data</strong>: Cache frequently accessed account information</li>
<li><strong>Monitor account changes</strong>: Subscribe to account changes for real-time updates</li>
</ul>
<h3 id="development-1"><a class="header" href="#development-1">Development</a></h3>
<ul>
<li><strong>Use TypeScript</strong>: Take advantage of type safety for account structures</li>
<li><strong>Document account layouts</strong>: Clearly document your account data structures</li>
<li><strong>Test edge cases</strong>: Test with empty accounts, invalid data, etc.</li>
<li><strong>Handle errors gracefully</strong>: Provide meaningful error messages</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>For complete examples working with accounts, see:</p>
<ul>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/account">Account Management</a></strong> - Creating and managing accounts</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/storage">Data Storage</a></strong> - Storing and retrieving data</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/token">Token Accounts</a></strong> - Working with token accounts</li>
</ul>
<h2 id="source-code-1"><a class="header" href="#source-code-1">Source Code</a></h2>
<p>The account implementation is available in the <a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/account.rs">Arch Examples Repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructions-and-messages-1"><a class="header" href="#instructions-and-messages-1">Instructions and Messages</a></h1>
<p>Instructions and messages are the core building blocks for interacting with programs on the Arch Network. They define what operations to perform and how to execute them atomically.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<ul>
<li><strong>Instructions</strong> define individual operations to be performed by a program</li>
<li><strong>Messages</strong> group instructions together for atomic execution</li>
<li><strong>Transactions</strong> contain messages with signatures for network submission</li>
</ul>
<h2 id="instructions-3"><a class="header" href="#instructions-3">Instructions</a></h2>
<p>An instruction specifies a program to call, accounts to use, and data to pass.</p>
<h3 id="structure-2"><a class="header" href="#structure-2">Structure</a></h3>
<pre><code class="language-rust ignore">pub struct Instruction {
    pub program_id: Pubkey,        // Program to execute
    pub accounts: Vec&lt;AccountMeta&gt;, // Required accounts
    pub data: Vec&lt;u8&gt;,             // Instruction data
}</code></pre>
<h3 id="creating-instructions"><a class="header" href="#creating-instructions">Creating Instructions</a></h3>
<pre><code class="language-typescript">import { Instruction, AccountMeta } from '@saturnbtcio/arch-sdk';

// Create a basic instruction
const instruction = new Instruction({
  programId: myProgramId,
  accounts: [
    {
      pubkey: userAccount,
      isSigner: true,
      isWritable: true
    },
    {
      pubkey: dataAccount,
      isSigner: false,
      isWritable: true
    }
  ],
  data: Buffer.from([1, 2, 3, 4]) // Serialized instruction data
});
</code></pre>
<h3 id="account-metadata-1"><a class="header" href="#account-metadata-1">Account Metadata</a></h3>
<p>Each instruction must specify how accounts will be used:</p>
<pre><code class="language-typescript">interface AccountMeta {
  pubkey: Pubkey;    // Account's public key
  isSigner: boolean; // Must the account sign the transaction?
  isWritable: boolean; // Can the account's data be modified?
}
</code></pre>
<h4 id="permission-examples"><a class="header" href="#permission-examples">Permission Examples</a></h4>
<pre><code class="language-typescript">// Signer and writable (user's main account)
{
  pubkey: userPublicKey,
  isSigner: true,
  isWritable: true
}

// Read-only reference (program or config account)
{
  pubkey: configAccount,
  isSigner: false,
  isWritable: false
}

// Writable but not signer (data account owned by program)
{
  pubkey: dataAccount,
  isSigner: false,
  isWritable: true
}
</code></pre>
<h3 id="instruction-data"><a class="header" href="#instruction-data">Instruction Data</a></h3>
<p>Instruction data is typically serialized using Borsh or similar formats:</p>
<pre><code class="language-typescript">// Define instruction enum
enum MyProgramInstruction {
  Initialize = 0,
  UpdateValue = 1,
  Close = 2
}

// Serialize instruction data
function createUpdateInstruction(newValue: number): Buffer {
  const data = Buffer.alloc(9); // 1 byte for instruction + 8 bytes for u64
  data.writeUInt8(MyProgramInstruction.UpdateValue, 0);
  data.writeBigUInt64LE(BigInt(newValue), 1);
  return data;
}

// Use in instruction
const instruction = new Instruction({
  programId: myProgramId,
  accounts: [/* ... */],
  data: createUpdateInstruction(42)
});
</code></pre>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<p>Messages group instructions for atomic execution and include transaction metadata.</p>
<h3 id="structure-3"><a class="header" href="#structure-3">Structure</a></h3>
<pre><code class="language-rust ignore">pub struct Message {
    pub signers: Vec&lt;Pubkey&gt;,              // Required signers
    pub instructions: Vec&lt;Instruction&gt;,     // Instructions to execute
}</code></pre>
<h3 id="creating-messages"><a class="header" href="#creating-messages">Creating Messages</a></h3>
<pre><code class="language-typescript">import { Message, Transaction } from '@saturnbtcio/arch-sdk';

// Create transaction with multiple instructions
const transaction = new Transaction()
  .add(instruction1)
  .add(instruction2)
  .add(instruction3);

// The transaction internally creates a message
const message = transaction.compileMessage();
</code></pre>
<h3 id="atomic-execution"><a class="header" href="#atomic-execution">Atomic Execution</a></h3>
<p>All instructions in a message execute atomically - if any instruction fails, the entire transaction fails:</p>
<pre><code class="language-typescript">// These instructions will all succeed or all fail together
const transaction = new Transaction()
  .add(transferInstruction)      // Transfer tokens
  .add(updateAccountInstruction) // Update account data
  .add(logInstruction);         // Log the operation
</code></pre>
<h2 id="building-transactions"><a class="header" href="#building-transactions">Building Transactions</a></h2>
<h3 id="simple-transaction"><a class="header" href="#simple-transaction">Simple Transaction</a></h3>
<pre><code class="language-typescript">// Single instruction transaction
const transaction = new Transaction()
  .add(instruction);

// Sign and send
const signature = await connection.sendAndConfirmTransaction(
  transaction,
  [keypair]
);
</code></pre>
<h3 id="multi-instruction-transaction"><a class="header" href="#multi-instruction-transaction">Multi-Instruction Transaction</a></h3>
<pre><code class="language-typescript">// Complex transaction with multiple operations
const transaction = new Transaction()
  .add(createAccountInstruction)
  .add(initializeAccountInstruction)
  .add(transferInstruction);

// Sign with multiple keypairs if needed
const signature = await connection.sendAndConfirmTransaction(
  transaction,
  [payer, newAccount, authority]
);
</code></pre>
<h3 id="transaction-limits"><a class="header" href="#transaction-limits">Transaction Limits</a></h3>
<pre><code class="language-typescript">// Check transaction size before sending
const messageSize = transaction.compileMessage().serialize().length;
const maxSize = 1232; // Current limit

if (messageSize &gt; maxSize) {
  throw new Error(`Transaction too large: ${messageSize} bytes`);
}
</code></pre>
<h2 id="common-patterns-5"><a class="header" href="#common-patterns-5">Common Patterns</a></h2>
<h3 id="system-program-operations"><a class="header" href="#system-program-operations">System Program Operations</a></h3>
<pre><code class="language-typescript">import { SystemProgram } from '@saturnbtcio/arch-sdk';

// Create account
const createInstruction = SystemProgram.createAccount({
  fromPubkey: payer.publicKey,
  newAccountPubkey: newAccount.publicKey,
  lamports: 1000000,
  space: 256,
  programId: myProgramId
});

// Transfer lamports
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 1000000
});
</code></pre>
<h3 id="program-specific-instructions"><a class="header" href="#program-specific-instructions">Program-Specific Instructions</a></h3>
<pre><code class="language-typescript">// Create helper functions for your program
class MyProgram {
  static initialize(
    account: Pubkey,
    authority: Pubkey,
    initialValue: number
  ): Instruction {
    return new Instruction({
      programId: MY_PROGRAM_ID,
      accounts: [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: authority, isSigner: true, isWritable: false }
      ],
      data: Buffer.from([0, ...new BN(initialValue).toArray('le', 8)])
    });
  }

  static updateValue(
    account: Pubkey,
    authority: Pubkey,
    newValue: number
  ): Instruction {
    return new Instruction({
      programId: MY_PROGRAM_ID,
      accounts: [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: authority, isSigner: true, isWritable: false }
      ],
      data: Buffer.from([1, ...new BN(newValue).toArray('le', 8)])
    });
  }
}

// Use the helper functions
const initInstruction = MyProgram.initialize(
  dataAccount.publicKey,
  authority.publicKey,
  100
);
</code></pre>
<h2 id="cross-program-invocation-cpi-4"><a class="header" href="#cross-program-invocation-cpi-4">Cross-Program Invocation (CPI)</a></h2>
<p>Programs can call other programs using CPI:</p>
<pre><code class="language-rust ignore">// In your program
use arch_sdk::{invoke, invoke_signed};

// Invoke another program
invoke(
    &amp;instruction,
    &amp;[account1, account2, program_account]
)?;

// Invoke with program-derived address
invoke_signed(
    &amp;instruction,
    &amp;[account1, account2, program_account],
    &amp;[&amp;[b"seed", &amp;[bump]]]
)?;</code></pre>
<h2 id="error-handling-12"><a class="header" href="#error-handling-12">Error Handling</a></h2>
<h3 id="client-side-validation"><a class="header" href="#client-side-validation">Client-Side Validation</a></h3>
<pre><code class="language-typescript">// Validate instruction before sending
function validateInstruction(instruction: Instruction): void {
  if (!instruction.programId) {
    throw new Error('Program ID is required');
  }
  
  if (instruction.accounts.length === 0) {
    throw new Error('At least one account is required');
  }
  
  // Check for required signers
  const hasRequiredSigner = instruction.accounts.some(
    account =&gt; account.isSigner
  );
  
  if (!hasRequiredSigner) {
    throw new Error('At least one signer is required');
  }
}
</code></pre>
<h3 id="transaction-errors"><a class="header" href="#transaction-errors">Transaction Errors</a></h3>
<pre><code class="language-typescript">try {
  const signature = await connection.sendAndConfirmTransaction(
    transaction,
    [keypair]
  );
} catch (error) {
  if (error instanceof TransactionError) {
    console.error('Transaction failed:', error.message);
    console.error('Logs:', error.logs);
  } else {
    console.error('Unexpected error:', error);
  }
}
</code></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<h3 id="security-6"><a class="header" href="#security-6">Security</a></h3>
<ul>
<li><strong>Validate all accounts</strong>: Ensure accounts have correct permissions</li>
<li><strong>Check program ownership</strong>: Verify accounts are owned by expected programs</li>
<li><strong>Sanitize instruction data</strong>: Validate all input parameters</li>
<li><strong>Use type-safe serialization</strong>: Prefer Borsh or similar libraries</li>
</ul>
<h3 id="performance-4"><a class="header" href="#performance-4">Performance</a></h3>
<ul>
<li><strong>Batch operations</strong>: Group related instructions in single transactions</li>
<li><strong>Minimize account usage</strong>: Only include necessary accounts</li>
<li><strong>Cache program IDs</strong>: Store frequently used program IDs as constants</li>
<li><strong>Optimize instruction data</strong>: Use efficient serialization formats</li>
</ul>
<h3 id="development-2"><a class="header" href="#development-2">Development</a></h3>
<ul>
<li><strong>Create instruction builders</strong>: Build helper functions for common operations</li>
<li><strong>Document instruction formats</strong>: Clearly document expected data formats</li>
<li><strong>Test edge cases</strong>: Test with invalid accounts, insufficient funds, etc.</li>
<li><strong>Use TypeScript</strong>: Take advantage of type safety</li>
</ul>
<h2 id="advanced-patterns-1"><a class="header" href="#advanced-patterns-1">Advanced Patterns</a></h2>
<h3 id="conditional-instructions"><a class="header" href="#conditional-instructions">Conditional Instructions</a></h3>
<pre><code class="language-typescript">// Build instructions based on conditions
const instructions: Instruction[] = [];

// Always initialize
instructions.push(initializeInstruction);

// Conditionally add operations
if (shouldTransfer) {
  instructions.push(transferInstruction);
}

if (shouldClose) {
  instructions.push(closeInstruction);
}

// Build transaction
const transaction = new Transaction();
instructions.forEach(ix =&gt; transaction.add(ix));
</code></pre>
<h3 id="instruction-factories"><a class="header" href="#instruction-factories">Instruction Factories</a></h3>
<pre><code class="language-typescript">// Create reusable instruction factories
interface TokenTransferParams {
  source: Pubkey;
  destination: Pubkey;
  authority: Pubkey;
  amount: number;
}

function createTokenTransferInstruction(
  params: TokenTransferParams
): Instruction {
  return new Instruction({
    programId: TOKEN_PROGRAM_ID,
    accounts: [
      { pubkey: params.source, isSigner: false, isWritable: true },
      { pubkey: params.destination, isSigner: false, isWritable: true },
      { pubkey: params.authority, isSigner: true, isWritable: false }
    ],
    data: encodeTokenTransferData(params.amount)
  });
}
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>For complete examples using instructions and messages, see:</p>
<ul>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/helloworld">Hello World</a></strong> - Basic instruction usage</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/counter">Counter</a></strong> - State management instructions</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/token">Token Program</a></strong> - Complex instruction patterns</li>
<li><strong><a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/escrow">Escrow</a></strong> - Multi-party transaction coordination</li>
</ul>
<h2 id="source-code-2"><a class="header" href="#source-code-2">Source Code</a></h2>
<p>The instruction and message implementations are available in the <a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/instruction.rs">Arch Examples Repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-transaction"><a class="header" href="#runtime-transaction">Runtime Transaction</a></h1>
<p>A runtime transaction includes a version number, a slice of <a href="sdk/./signature.html">signatures</a> included on the transaction and a <a href="sdk/../program/message.html">message</a> field, which details a list of <a href="sdk/../program/instructions-and-messages.html#instructions">instructions</a> to be processed atomically.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
pub struct RuntimeTransaction {
    pub version: u32,
    pub signatures: Vec&lt;Signature&gt;,
    pub message: Message,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/runtime_transaction.rs">runtime_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="processed-transaction"><a class="header" href="#processed-transaction">Processed Transaction</a></h1>
<p>A processed transaction is a custom data type that contains a <a href="sdk/./runtime-transaction.html">runtime transaction</a>, a status, denoting the result of executing this runtime transaction, as well as a collection of Bitcoin transaction IDs.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Deserialize, Serialize, BorshDeserialize, BorshSerialize)]
pub enum Status {
    Processing,
    Processed,
}

#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct ProcessedTransaction {
    pub runtime_transaction: RuntimeTransaction,
    pub status: Status,
    pub bitcoin_txids: Vec&lt;String&gt;,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/processed_transaction.rs">processed_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature"><a class="header" href="#signature">Signature</a></h1>
<p>A signature is a custom data type that holds a slice of 64 bytes.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct Signature(pub Vec&lt;u8&gt;);</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/signature.rs">signature.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="arch-cli-reference-guide-1"><a class="header" href="#arch-cli-reference-guide-1">Arch CLI Reference Guide</a></h1>
<p>This comprehensive guide covers all available commands and options in the Arch Network CLI tool.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="guides/arch-cli-reference.html#global-options">Global Options</a></li>
<li><a href="guides/arch-cli-reference.html#configuration-management">Configuration Management</a></li>
<li><a href="guides/arch-cli-reference.html#validator-management">Validator Management</a></li>
<li><a href="guides/arch-cli-reference.html#account-operations">Account Operations</a></li>
<li><a href="guides/arch-cli-reference.html#program-deployment">Program Deployment</a></li>
<li><a href="guides/arch-cli-reference.html#transaction-operations">Transaction Operations</a></li>
<li><a href="guides/arch-cli-reference.html#block-and-network-info">Block and Network Info</a></li>
<li><a href="guides/arch-cli-reference.html#apl-token-operations">APL Token Operations</a></li>
<li><a href="guides/arch-cli-reference.html#orchestration-commands">Orchestration Commands</a></li>
<li><a href="guides/arch-cli-reference.html#error-reference">Error Reference</a></li>
</ul>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<p>These options can be used with any command:</p>
<pre><code class="language-bash"># Specify network mode
arch-cli --network-mode devnet|testnet|mainnet|localnet

# Use configuration profile
arch-cli --profile &lt;PROFILE_NAME&gt;

# Show help
arch-cli --help

# Show version
arch-cli --version
</code></pre>
<blockquote>
<p>Note: All user-facing identifiers in arch-cli (addresses, public keys, transaction IDs, block hashes) are base58.</p>
</blockquote>
<p><strong>Network Modes:</strong></p>
<ul>
<li><code>devnet</code>: Development network (default)</li>
<li><code>testnet</code>: Test network</li>
<li><code>mainnet</code>: Production network</li>
<li><code>localnet</code>: Local development network</li>
</ul>
<h2 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h2>
<h3 id="create-profile"><a class="header" href="#create-profile">Create Profile</a></h3>
<p>Create a new configuration profile for connecting to Bitcoin and Arch Network nodes:</p>
<pre><code class="language-bash">arch-cli config create-profile &lt;NAME&gt; \
    --bitcoin-node-endpoint &lt;URL&gt; \
    --bitcoin-node-username &lt;USERNAME&gt; \
    --bitcoin-node-password &lt;PASSWORD&gt; \
    --bitcoin-network &lt;NETWORK&gt; \
    --arch-node-url &lt;URL&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code>: Name of the profile</li>
<li><code>--bitcoin-node-endpoint</code>: Bitcoin node endpoint URL (e.g., ‚Äúhttp://127.0.0.1:18443‚Äù)</li>
<li><code>--bitcoin-node-username</code>: Bitcoin node RPC username</li>
<li><code>--bitcoin-node-password</code>: Bitcoin node RPC password</li>
<li><code>--bitcoin-network</code>: Bitcoin network (‚Äúmainnet‚Äù, ‚Äútestnet‚Äù, or ‚Äúregtest‚Äù)</li>
<li><code>--arch-node-url</code>: Arch Network node URL</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">arch-cli config create-profile testnet \
    --bitcoin-node-endpoint http://bitcoin-rpc.test.arch.network:80 \
    --bitcoin-node-username bitcoin \
    --bitcoin-node-password 0F_Ed53o4kR7nxh3xNaSQx-2M3TY16L55mz5y9fjdrk \
    --bitcoin-network testnet \
    --arch-node-url http://localhost:9002
</code></pre>
<h3 id="list-profiles"><a class="header" href="#list-profiles">List Profiles</a></h3>
<p>List all available configuration profiles:</p>
<pre><code class="language-bash">arch-cli config list-profiles
</code></pre>
<h3 id="show-profile"><a class="header" href="#show-profile">Show Profile</a></h3>
<p>Display detailed information about a specific profile:</p>
<pre><code class="language-bash">arch-cli config show-profile &lt;NAME&gt;
</code></pre>
<h3 id="update-profile"><a class="header" href="#update-profile">Update Profile</a></h3>
<p>Update an existing profile‚Äôs settings:</p>
<pre><code class="language-bash">arch-cli config update-profile &lt;NAME&gt; \
    [--bitcoin-node-endpoint &lt;URL&gt;] \
    [--bitcoin-node-username &lt;USERNAME&gt;] \
    [--bitcoin-node-password &lt;PASSWORD&gt;] \
    [--bitcoin-network &lt;NETWORK&gt;] \
    [--arch-node-url &lt;URL&gt;]
</code></pre>
<p>All update arguments are optional. Only specified fields will be updated.</p>
<h3 id="delete-profile"><a class="header" href="#delete-profile">Delete Profile</a></h3>
<p>Delete a configuration profile:</p>
<pre><code class="language-bash">arch-cli config delete-profile &lt;NAME&gt;
</code></pre>
<p><strong>Note:</strong> The default profile cannot be deleted.</p>
<h3 id="set-default-profile"><a class="header" href="#set-default-profile">Set Default Profile</a></h3>
<p>Set which profile is used by default:</p>
<pre><code class="language-bash">arch-cli config set-default-profile &lt;NAME&gt;
</code></pre>
<h2 id="account-operations"><a class="header" href="#account-operations">Account Operations</a></h2>
<h3 id="create-account-1"><a class="header" href="#create-account-1">Create Account</a></h3>
<p>Create a new account:</p>
<pre><code class="language-bash">arch-cli account create \
    --keypair-path &lt;PATH&gt; \
    --owner &lt;OWNER&gt; \
    --lamports &lt;LAMPORTS&gt; \
    --space &lt;SPACE&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--keypair-path</code>: Path to the keypair file</li>
<li><code>--owner</code>: Public key of the program that will own the account</li>
<li><code>--lamports</code>: Initial balance in lamports</li>
<li><code>--space</code>: Account size in bytes</li>
</ul>
<h3 id="fund-account"><a class="header" href="#fund-account">Fund Account</a></h3>
<p>Fund an existing account using the faucet:</p>
<pre><code class="language-bash">arch-cli account airdrop \
    --keypair-path &lt;PATH&gt; \
    [--lamports &lt;LAMPORTS&gt;]
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--keypair-path</code>: Path to the keypair file</li>
<li><code>--lamports</code>: Amount to airdrop (default: 1000000000 lamports)</li>
</ul>
<h3 id="change-account-owner"><a class="header" href="#change-account-owner">Change Account Owner</a></h3>
<p>Change the owner of an account:</p>
<pre><code class="language-bash">arch-cli account change-owner \
    --keypair-path &lt;PATH&gt; \
    --account &lt;ACCOUNT&gt; \
    --new-owner &lt;NEW_OWNER&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--keypair-path</code>: Path to the payer‚Äôs keypair file</li>
<li><code>--account</code>: Public key of the account to change</li>
<li><code>--new-owner</code>: Public key of the new owner</li>
</ul>
<h3 id="assign-utxos"><a class="header" href="#assign-utxos">Assign UTXOs</a></h3>
<p>Assign UTXOs to an account:</p>
<pre><code class="language-bash">arch-cli account assign-utxo \
    --keypair-path &lt;PATH&gt; \
    --utxo &lt;UTXO&gt; \
    --account &lt;ACCOUNT&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--keypair-path</code>: Path to the keypair file</li>
<li><code>--utxo</code>: UTXO identifier</li>
<li><code>--account</code>: Public key of the account</li>
</ul>
<h2 id="program-deployment"><a class="header" href="#program-deployment">Program Deployment</a></h2>
<h3 id="deploy-program-1"><a class="header" href="#deploy-program-1">Deploy Program</a></h3>
<p>Deploy a compiled program to the network:</p>
<pre><code class="language-bash">arch-cli deploy &lt;PROGRAM_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;PROGRAM_PATH&gt;</code>: Path to the directory containing the compiled program (.so file)</li>
</ul>
<p>Notes:</p>
<ul>
<li>If keypairs are missing, you can use <code>--generate-if-missing</code> to auto-generate them.</li>
<li>By default (non-mainnet), the deploy command automatically creates and funds the authority account if it does not exist, or funds it if its balance is insufficient for deployment. On mainnet, auto-funding is disabled and the authority must be pre-funded. You can disable auto-funding explicitly with <code>--no-autofund</code>.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">arch-cli deploy examples/helloworld/
</code></pre>
<h2 id="transaction-operations"><a class="header" href="#transaction-operations">Transaction Operations</a></h2>
<h3 id="get-transaction"><a class="header" href="#get-transaction">Get Transaction</a></h3>
<p>Retrieve transaction information:</p>
<pre><code class="language-bash">arch-cli tx get &lt;TX_ID&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;TX_ID&gt;</code>: Transaction ID (base58, 32 bytes)</li>
</ul>
<h3 id="confirm-transaction"><a class="header" href="#confirm-transaction">Confirm Transaction</a></h3>
<p>Check if a transaction is confirmed:</p>
<pre><code class="language-bash">arch-cli tx confirm &lt;TX_ID&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;TX_ID&gt;</code>: Transaction ID (base58, 32 bytes)</li>
</ul>
<h3 id="log-program-messages"><a class="header" href="#log-program-messages">Log Program Messages</a></h3>
<p>Log program messages for a transaction:</p>
<pre><code class="language-bash">arch-cli tx log-program-messages &lt;TX_ID&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;TX_ID&gt;</code>: Transaction ID (base58, 32 bytes)</li>
</ul>
<h2 id="block-and-network-info"><a class="header" href="#block-and-network-info">Block and Network Info</a></h2>
<h3 id="get-block"><a class="header" href="#get-block">Get Block</a></h3>
<p>Retrieve block information:</p>
<pre><code class="language-bash">arch-cli get-block &lt;BLOCK_HASH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;BLOCK_HASH&gt;</code>: Block hash (base58, 32 bytes)</li>
</ul>
<h3 id="get-block-height"><a class="header" href="#get-block-height">Get Block Height</a></h3>
<p>Get the current block height:</p>
<pre><code class="language-bash">arch-cli get-block-height
</code></pre>
<h3 id="get-group-key"><a class="header" href="#get-group-key">Get Group Key</a></h3>
<p>Fetch the network‚Äôs account address:</p>
<pre><code class="language-bash">arch-cli get-group-key &lt;PUBKEY&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;PUBKEY&gt;</code>: Public key to use for group key calculation</li>
</ul>
<h3 id="show-account"><a class="header" href="#show-account">Show Account</a></h3>
<p>Display account information:</p>
<pre><code class="language-bash">arch-cli show &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Public key of the account to display</li>
</ul>
<h2 id="apl-token-operations"><a class="header" href="#apl-token-operations">APL Token Operations</a></h2>
<p>The Arch CLI provides comprehensive token management capabilities for APL (Arch Program Library) tokens. All token commands support the same global options as other CLI commands.</p>
<h3 id="mint-management"><a class="header" href="#mint-management">Mint Management</a></h3>
<h4 id="create-mint"><a class="header" href="#create-mint">Create Mint</a></h4>
<p>Create a new token mint:</p>
<pre><code class="language-bash">arch-cli token create-mint \
  --decimals &lt;DECIMALS&gt; \
  --mint-authority &lt;MINT_AUTHORITY_KEYPAIR_PATH&gt; \
  [--freeze-authority &lt;FREEZE_AUTHORITY_KEYPAIR_PATH&gt;] \
  [--mint-keypair-path &lt;MINT_KEYPAIR_PATH&gt;] \
  --keypair-path &lt;PAYER_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--decimals</code>: Number of decimal places (0-9)</li>
<li><code>--mint-authority</code>: Keypair path for the mint authority</li>
<li><code>--freeze-authority</code>: Keypair path for the freeze authority (optional)</li>
<li><code>--mint-keypair-path</code>: Keypair path for the mint account (optional; if omitted, generated in-memory)</li>
<li><code>--keypair-path</code>: Keypair path for the fee payer</li>
</ul>
<h4 id="show-mint"><a class="header" href="#show-mint">Show Mint</a></h4>
<p>Display mint information:</p>
<pre><code class="language-bash">arch-cli token show-mint &lt;MINT_ADDRESS_OR_MINT_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;MINT_ADDRESS_OR_MINT_KEYPAIR_PATH&gt;</code>: Base58 mint address (32 bytes) or a keypair file path from which the address is derived</li>
</ul>
<h3 id="account-management-5"><a class="header" href="#account-management-5">Account Management</a></h3>
<h4 id="create-account-2"><a class="header" href="#create-account-2">Create Account</a></h4>
<p>Create a new token account (Associated Token Account for an owner and mint):</p>
<pre><code class="language-bash">arch-cli token create-account \
  --mint &lt;MINT_ADDRESS&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt; \
  --keypair-path &lt;PAYER_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--mint</code>: Base58 public key of the mint (32 bytes)</li>
<li><code>--owner</code>: Keypair path for the wallet that will own the token account</li>
<li><code>--keypair-path</code>: Keypair path for the fee payer</li>
</ul>
<h4 id="show-account-1"><a class="header" href="#show-account-1">Show Account</a></h4>
<p>Display token account information:</p>
<pre><code class="language-bash">arch-cli token show-account &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Public key of the token account</li>
</ul>
<h3 id="token-operations-1"><a class="header" href="#token-operations-1">Token Operations</a></h3>
<h4 id="mint-tokens"><a class="header" href="#mint-tokens">Mint Tokens</a></h4>
<p>Mint tokens to an account:</p>
<pre><code class="language-bash">arch-cli token mint &lt;MINT_ADDRESS&gt; &lt;AMOUNT&gt; \
  --authority &lt;MINT_AUTHORITY_KEYPAIR_PATH&gt; \
  [--account-address &lt;ACCOUNT_ADDRESS&gt;] \
  [--auto-create-ata] \
  [--multisig &lt;MULTISIG_ADDRESS&gt;] \
  [--signers &lt;SIGNER1_KEYPAIR_PATH,SIGNER2_KEYPAIR_PATH,...&gt;] \
  [--keypair-path &lt;FEE_PAYER_KEYPAIR_PATH&gt;]
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;MINT_ADDRESS&gt;</code>: Base58 public key of the mint (32 bytes)</li>
<li><code>&lt;AMOUNT&gt;</code>: Amount to mint (raw units)</li>
<li><code>--authority</code>: Keypair path for the mint authority</li>
<li><code>--account-address</code>: Base58 token account address; if omitted, mints to the mint authority‚Äôs ATA</li>
<li><code>--auto-create-ata</code>: Create the ATA if it does not exist</li>
<li><code>--multisig</code>: Base58 multisig authority address (when mint authority is multisig)</li>
<li><code>--signers</code>: Comma-separated list of signer keypair paths for multisig</li>
<li><code>--keypair-path</code>: Fee payer keypair path (optional)</li>
</ul>
<h4 id="transfer-tokens"><a class="header" href="#transfer-tokens">Transfer Tokens</a></h4>
<p>Transfer tokens between accounts:</p>
<pre><code class="language-bash">arch-cli token transfer &lt;SOURCE_ACCOUNT&gt; &lt;DESTINATION_ACCOUNT&gt; &lt;AMOUNT&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt; \
  [--multisig &lt;MULTISIG_ADDRESS&gt;] \
  [--signers &lt;SIGNER1_KEYPAIR_PATH,SIGNER2_KEYPAIR_PATH,...&gt;] \
  [--keypair-path &lt;FEE_PAYER_KEYPAIR_PATH&gt;]
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;SOURCE_ACCOUNT&gt;</code>: Base58 token account address</li>
<li><code>&lt;DESTINATION_ACCOUNT&gt;</code>: Base58 token account address</li>
<li><code>&lt;AMOUNT&gt;</code>: Amount to transfer (raw units)</li>
<li><code>--owner</code>: Keypair path for the source account owner</li>
<li><code>--multisig</code>, <code>--signers</code>, <code>--keypair-path</code>: As described above</li>
</ul>
<h4 id="burn-tokens"><a class="header" href="#burn-tokens">Burn Tokens</a></h4>
<p>Burn tokens from an account:</p>
<pre><code class="language-bash">arch-cli token burn &lt;ACCOUNT_ADDRESS&gt; &lt;AMOUNT&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt; \
  [--multisig &lt;MULTISIG_ADDRESS&gt;] \
  [--signers &lt;SIGNER1_KEYPAIR_PATH,SIGNER2_KEYPAIR_PATH,...&gt;] \
  [--keypair-path &lt;FEE_PAYER_KEYPAIR_PATH&gt;]
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Base58 token account address</li>
<li><code>&lt;AMOUNT&gt;</code>: Amount to burn (raw units)</li>
<li><code>--owner</code>: Keypair path for the account owner</li>
</ul>
<h3 id="delegation-1"><a class="header" href="#delegation-1">Delegation</a></h3>
<h4 id="approve-delegate"><a class="header" href="#approve-delegate">Approve Delegate</a></h4>
<p>Approve a delegate for spending:</p>
<pre><code class="language-bash">arch-cli token approve &lt;ACCOUNT_ADDRESS&gt; &lt;DELEGATE_ADDRESS&gt; &lt;AMOUNT&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Base58 token account address</li>
<li><code>&lt;DELEGATE_ADDRESS&gt;</code>: Base58 public key of the delegate (32 bytes)</li>
<li><code>&lt;AMOUNT&gt;</code>: Allowance (raw units)</li>
<li><code>--owner</code>: Keypair path for the account owner</li>
</ul>
<h4 id="revoke-delegate"><a class="header" href="#revoke-delegate">Revoke Delegate</a></h4>
<p>Revoke delegate authority:</p>
<pre><code class="language-bash">arch-cli token revoke &lt;ACCOUNT_ADDRESS&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Base58 token account address</li>
<li><code>--owner</code>: Keypair path for the account owner</li>
</ul>
<h3 id="account-control-1"><a class="header" href="#account-control-1">Account Control</a></h3>
<h4 id="freeze-account"><a class="header" href="#freeze-account">Freeze Account</a></h4>
<p>Freeze a token account:</p>
<pre><code class="language-bash">arch-cli token freeze-account &lt;ACCOUNT_ADDRESS&gt; \
  --authority &lt;FREEZE_AUTHORITY_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Base58 token account address</li>
<li><code>--authority</code>: Keypair path for the freeze authority</li>
</ul>
<h4 id="thaw-account"><a class="header" href="#thaw-account">Thaw Account</a></h4>
<p>Thaw a frozen account:</p>
<pre><code class="language-bash">arch-cli token thaw-account &lt;ACCOUNT_ADDRESS&gt; \
  --authority &lt;FREEZE_AUTHORITY_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Base58 token account address</li>
<li><code>--authority</code>: Keypair path for the freeze authority</li>
</ul>
<h3 id="multisignature-operations-1"><a class="header" href="#multisignature-operations-1">Multisignature Operations</a></h3>
<h4 id="create-multisig"><a class="header" href="#create-multisig">Create Multisig</a></h4>
<p>Create a multisignature authority:</p>
<pre><code class="language-bash">arch-cli token create-multisig &lt;M_OF_N&gt; \
  --signers &lt;SIGNER1_KEYPAIR_PATH,SIGNER2_KEYPAIR_PATH,...&gt; \
  --keypair-path &lt;PAYER_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;M_OF_N&gt;</code>: Number of signatures required</li>
<li><code>--signers</code>: Comma-separated list of signer keypair paths</li>
<li><code>--keypair-path</code>: Fee payer keypair path</li>
</ul>
<h4 id="sign-multisig"><a class="header" href="#sign-multisig">Sign Multisig</a></h4>
<p>Sign a transaction with multisig:</p>
<pre><code class="language-bash">arch-cli token multisig-sign \
    --keypair-path &lt;PATH&gt; \
    --multisig &lt;MULTISIG&gt; \
    --transaction &lt;TRANSACTION&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--keypair-path</code>: Path to the signer‚Äôs keypair file</li>
<li><code>--multisig</code>: Public key of the multisig account</li>
<li><code>--transaction</code>: Transaction to sign</li>
</ul>
<h4 id="execute-multisig"><a class="header" href="#execute-multisig">Execute Multisig</a></h4>
<p>Execute a signed multisig transaction:</p>
<pre><code class="language-bash">arch-cli token multisig-execute \
    --keypair-path &lt;PATH&gt; \
    --multisig &lt;MULTISIG&gt; \
    --transaction &lt;TRANSACTION&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--keypair-path</code>: Path to the executor‚Äôs keypair file</li>
<li><code>--multisig</code>: Public key of the multisig account</li>
<li><code>--transaction</code>: Signed transaction to execute</li>
</ul>
<h4 id="show-multisig"><a class="header" href="#show-multisig">Show Multisig</a></h4>
<p>Display multisig account information:</p>
<pre><code class="language-bash">arch-cli token multisig-show &lt;MULTISIG_ADDRESS&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;MULTISIG_ADDRESS&gt;</code>: Public key of the multisig account</li>
</ul>
<h3 id="utility-commands-1"><a class="header" href="#utility-commands-1">Utility Commands</a></h3>
<h4 id="balance"><a class="header" href="#balance">Balance</a></h4>
<p>Display token balance:</p>
<pre><code class="language-bash">arch-cli token balance &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Public key of the token account</li>
</ul>
<h4 id="supply"><a class="header" href="#supply">Supply</a></h4>
<p>Display mint supply:</p>
<pre><code class="language-bash">arch-cli token supply &lt;MINT_ADDRESS&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;MINT_ADDRESS&gt;</code>: Public key of the mint</li>
</ul>
<h4 id="list-accounts"><a class="header" href="#list-accounts">List Accounts</a></h4>
<p>List token accounts for a mint:</p>
<pre><code class="language-bash">arch-cli token accounts &lt;MINT_ADDRESS&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;MINT_ADDRESS&gt;</code>: Public key of the mint</li>
</ul>
<h4 id="list-mints"><a class="header" href="#list-mints">List Mints</a></h4>
<p>List all mints:</p>
<pre><code class="language-bash">arch-cli token mints
</code></pre>
<h4 id="amount-conversion"><a class="header" href="#amount-conversion">Amount Conversion</a></h4>
<p>Convert between raw and UI amounts:</p>
<pre><code class="language-bash"># Convert raw amount to UI format
arch-cli token amount-to-ui &lt;MINT_ADDRESS&gt; &lt;RAW_AMOUNT&gt;

# Convert UI amount to raw format
arch-cli token ui-to-amount &lt;MINT_ADDRESS&gt; &lt;UI_AMOUNT&gt;
</code></pre>
<h3 id="advanced-token-features"><a class="header" href="#advanced-token-features">Advanced Token Features</a></h3>
<h4 id="checked-operations"><a class="header" href="#checked-operations">Checked Operations</a></h4>
<p>Perform operations with decimal verification:</p>
<pre><code class="language-bash"># Transfer with decimal verification
arch-cli token transfer-checked &lt;SOURCE_ACCOUNT&gt; &lt;DESTINATION_ACCOUNT&gt; &lt;AMOUNT&gt; &lt;DECIMALS&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt;

# Approve with decimal verification
arch-cli token approve-checked &lt;ACCOUNT_ADDRESS&gt; &lt;DELEGATE_ADDRESS&gt; &lt;AMOUNT&gt; &lt;DECIMALS&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt;

# Mint with decimal verification
arch-cli token mint-to-checked &lt;MINT_ADDRESS&gt; &lt;ACCOUNT_ADDRESS&gt; &lt;AMOUNT&gt; &lt;DECIMALS&gt; \
  --authority &lt;MINT_AUTHORITY_KEYPAIR_PATH&gt;

# Burn with decimal verification
arch-cli token burn-checked &lt;ACCOUNT_ADDRESS&gt; &lt;AMOUNT&gt; &lt;DECIMALS&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt;
</code></pre>
<h4 id="authority-management-1"><a class="header" href="#authority-management-1">Authority Management</a></h4>
<p>Set authority on a mint or account:</p>
<pre><code class="language-bash">arch-cli token set-authority &lt;TARGET_ADDRESS&gt; \
  --authority-type &lt;mint|freeze|account_owner|close_account&gt; \
  --new-authority &lt;NEW_AUTHORITY_BASE58|none&gt; \
  --current-authority &lt;CURRENT_AUTHORITY_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;TARGET_ADDRESS&gt;</code>: Base58 mint or account address</li>
<li><code>--authority-type</code>: Type of authority to set</li>
<li><code>--new-authority</code>: Base58 address of new authority, or <code>none</code></li>
<li><code>--current-authority</code>: Keypair path for the current authority</li>
</ul>
<h4 id="account-management-6"><a class="header" href="#account-management-6">Account Management</a></h4>
<p>Close a token account:</p>
<pre><code class="language-bash">arch-cli token close-account &lt;ACCOUNT_ADDRESS&gt; &lt;DESTINATION_PUBKEY&gt; \
  --owner &lt;OWNER_KEYPAIR_PATH&gt;
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;ACCOUNT_ADDRESS&gt;</code>: Base58 token account address</li>
<li><code>&lt;DESTINATION_PUBKEY&gt;</code>: Base58 public key to receive reclaimed lamports</li>
<li><code>--owner</code>: Keypair path for the account owner</li>
</ul>
<h4 id="batch-operations-1"><a class="header" href="#batch-operations-1">Batch Operations</a></h4>
<p>Perform multiple operations at once:</p>
<pre><code class="language-bash"># Batch transfer tokens (JSON file path)
arch-cli token batch-transfer &lt;TRANSFERS_JSON_PATH&gt; \
  --keypair-path &lt;PAYER_KEYPAIR_PATH&gt;

# Batch mint tokens (JSON file path)
arch-cli token batch-mint &lt;MINTS_JSON_PATH&gt; \
  --keypair-path &lt;PAYER_KEYPAIR_PATH&gt;
</code></pre>
<h2 id="orchestration-commands"><a class="header" href="#orchestration-commands">Orchestration Commands</a></h2>
<h3 id="start-local-environment"><a class="header" href="#start-local-environment">Start Local Environment</a></h3>
<p>Start the complete local development environment:</p>
<pre><code class="language-bash">arch-cli orchestrate start [--local &lt;PATH&gt;] [--no-bitcoind]
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--local &lt;PATH&gt;</code>: Path to local source code for building images</li>
<li><code>--no-bitcoind</code>: Skip starting local Bitcoin node (use remote RPC)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Start with remote Bitcoin RPC
arch-cli orchestrate start

# Start with local source code
arch-cli orchestrate start --local "$(pwd)"

# Start without local bitcoind
arch-cli orchestrate start --local "$(pwd)" --no-bitcoind
</code></pre>
<h3 id="stop-local-environment"><a class="header" href="#stop-local-environment">Stop Local Environment</a></h3>
<p>Stop all local services:</p>
<pre><code class="language-bash">arch-cli orchestrate stop
</code></pre>
<h3 id="validator-management"><a class="header" href="#validator-management">Validator Management</a></h3>
<p>Manage the local validator service:</p>
<pre><code class="language-bash"># Start only the validator
arch-cli orchestrate validator-start

# Stop only the validator
arch-cli orchestrate validator-stop

# Restart only the validator
arch-cli orchestrate validator-restart

# Show validator status
arch-cli orchestrate validator-status
</code></pre>
<h3 id="reset-environment"><a class="header" href="#reset-environment">Reset Environment</a></h3>
<p>Reset the development environment:</p>
<pre><code class="language-bash"># Reset entire environment
arch-cli orchestrate reset

# Reset only validator
arch-cli orchestrate validator-reset
</code></pre>
<h3 id="bitcoin-mining"><a class="header" href="#bitcoin-mining">Bitcoin Mining</a></h3>
<p>Mine Bitcoin blocks in regtest mode:</p>
<pre><code class="language-bash">arch-cli orchestrate mine-blocks [--num-blocks &lt;COUNT&gt;]
</code></pre>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>--num-blocks &lt;COUNT&gt;</code>: Number of blocks to mine (default: 1)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Mine 1 block
arch-cli orchestrate mine-blocks

# Mine 10 blocks
arch-cli orchestrate mine-blocks --num-blocks 10
</code></pre>
<h2 id="error-reference"><a class="header" href="#error-reference">Error Reference</a></h2>
<h3 id="general-errors"><a class="header" href="#general-errors">General Errors</a></h3>
<ul>
<li><code>Invalid length</code>: Input data is not the correct length (usually for base58 strings encoding 32 bytes)</li>
<li><code>Failed to process result: &lt;operation&gt;</code>: Failed to process RPC response</li>
<li><code>Failed to change account owner</code>: Failed to change the account‚Äôs owner</li>
</ul>
<h3 id="profile-errors"><a class="header" href="#profile-errors">Profile Errors</a></h3>
<ul>
<li><code>Profile not found</code>: The specified profile does not exist</li>
<li><code>Invalid URL format</code>: The provided URL is not properly formatted</li>
<li><code>Invalid Bitcoin network</code>: Bitcoin network must be one of: mainnet, testnet, regtest</li>
<li><code>Cannot delete default profile</code>: The default profile cannot be deleted</li>
</ul>
<h3 id="deploy-command-errors"><a class="header" href="#deploy-command-errors">Deploy Command Errors</a></h3>
<ul>
<li><code>Invalid deploy path '&lt;PATH&gt;'</code>: The specified directory does not exist</li>
<li><code>No .so file found in &lt;PATH&gt;</code>: No compiled program file found in the deploy directory</li>
<li><code>Keypair file '&lt;PROGRAM_NAME&gt;-keypair.json' not found in &lt;PATH&gt;</code>: Missing keypair file</li>
</ul>
<h3 id="account-creation-errors"><a class="header" href="#account-creation-errors">Account Creation Errors</a></h3>
<ul>
<li><code>Missing required fields</code>: One or more required fields are missing</li>
<li><code>Failed to create account</code>: General account creation failure</li>
<li><code>Faucet funding failed</code>: Could not fund the account using the faucet</li>
</ul>
<h3 id="token-operation-errors"><a class="header" href="#token-operation-errors">Token Operation Errors</a></h3>
<ul>
<li><code>Invalid mint address</code>: The specified mint address is not valid</li>
<li><code>Insufficient balance</code>: Account does not have enough tokens for the operation</li>
<li><code>Invalid authority</code>: The provided authority is not valid for this operation</li>
<li><code>Multisig validation failed</code>: Multisig operation validation failed</li>
</ul>
<h3 id="orchestration-errors"><a class="header" href="#orchestration-errors">Orchestration Errors</a></h3>
<ul>
<li><code>Docker not running</code>: Docker daemon is not running</li>
<li><code>Port already in use</code>: Required ports are already occupied</li>
<li><code>Image build failed</code>: Failed to build Docker image from local source</li>
<li><code>Service startup failed</code>: Failed to start one or more services</li>
</ul>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<h3 id="configuration-profiles"><a class="header" href="#configuration-profiles">Configuration Profiles</a></h3>
<ol>
<li><strong>Use descriptive names</strong>: Name profiles based on their purpose (e.g., <code>dev-local</code>, <code>testnet-remote</code>)</li>
<li><strong>Match network modes</strong>: Ensure profile‚Äôs Bitcoin network matches your CLI network mode</li>
<li><strong>Secure credentials</strong>: Store sensitive information in profiles rather than command line</li>
<li><strong>Environment variables</strong>: Use <code>ARCH_PROFILE</code> for automation scripts</li>
</ol>
<h3 id="token-operations-2"><a class="header" href="#token-operations-2">Token Operations</a></h3>
<ol>
<li><strong>Verify decimals</strong>: Always use the correct decimal places for your mint</li>
<li><strong>Check authorities</strong>: Ensure you have the correct authority for operations</li>
<li><strong>Use multisig</strong>: Implement multisig for high-value operations</li>
<li><strong>Batch operations</strong>: Use batch commands for multiple similar operations</li>
</ol>
<h3 id="development-workflow-3"><a class="header" href="#development-workflow-3">Development Workflow</a></h3>
<ol>
<li><strong>Local development</strong>: Use <code>orchestrate start --local</code> for testing local changes</li>
<li><strong>Profile management</strong>: Create separate profiles for different environments</li>
<li><strong>Reset when needed</strong>: Use <code>orchestrate reset</code> to start with a clean state</li>
</ol>
<h3 id="security-considerations-9"><a class="header" href="#security-considerations-9">Security Considerations</a></h3>
<ol>
<li><strong>Key management</strong>: Store keypairs securely and never share private keys</li>
<li><strong>Network isolation</strong>: Use appropriate network modes for different use cases</li>
<li><strong>Authority limits</strong>: Limit authority access to only what‚Äôs necessary</li>
<li><strong>Regular updates</strong>: Keep arch-cli and dependencies updated</li>
</ol>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="common-issues-4"><a class="header" href="#common-issues-4">Common Issues</a></h3>
<h4 id="validator-wont-start"><a class="header" href="#validator-wont-start">Validator Won‚Äôt Start</a></h4>
<pre><code class="language-bash"># Check if ports are available
netstat -an | grep 9002

# Check Docker status
docker ps -a

# Reset environment
arch-cli orchestrate reset
</code></pre>
<h4 id="token-operations-fail"><a class="header" href="#token-operations-fail">Token Operations Fail</a></h4>
<pre><code class="language-bash"># Verify mint exists
arch-cli token show-mint &lt;MINT_ADDRESS&gt;

# Check account balance
arch-cli token balance &lt;ACCOUNT_ADDRESS&gt;

# Verify authority
arch-cli token show-account &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<h4 id="profile-issues"><a class="header" href="#profile-issues">Profile Issues</a></h4>
<pre><code class="language-bash"># List all profiles
arch-cli config list-profiles

# Check profile details
arch-cli config show-profile &lt;NAME&gt;

# Test profile connection
arch-cli --profile &lt;NAME&gt; get-block-height
</code></pre>
<h3 id="getting-help-4"><a class="header" href="#getting-help-4">Getting Help</a></h3>
<ul>
<li><strong>Discord Community</strong>: <a href="https://discord.gg/archnetwork">https://discord.gg/archnetwork</a></li>
<li><strong>GitHub Issues</strong>: <a href="https://github.com/Arch-Network/arch-node/issues">https://github.com/Arch-Network/arch-node/issues</a></li>
<li><strong>Documentation</strong>: <a href="https://docs.arch.network">https://docs.arch.network</a></li>
</ul>
<h2 id="version-compatibility"><a class="header" href="#version-compatibility">Version Compatibility</a></h2>
<p>This guide covers arch-cli version 0.5.6 and later. For older versions, please refer to the appropriate release documentation.</p>
<p><strong>Minimum Requirements:</strong></p>
<ul>
<li>Rust: 1.84.1+</li>
<li>Solana CLI: 2.2.14+</li>
<li>Docker: 20.10+ (for orchestration features)</li>
<li>OS: Linux, macOS, or Windows (WSL2)</li>
</ul>
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<h3 id="common-commands"><a class="header" href="#common-commands">Common Commands</a></h3>
<pre><code class="language-bash"># Create and configure profile
arch-cli config create-profile dev --bitcoin-node-endpoint http://127.0.0.1:18443 --bitcoin-node-username bitcoin --bitcoin-node-password password --bitcoin-network regtest --arch-node-url http://localhost:9002

# Start local environment
arch-cli orchestrate start --local "$(pwd)"

# Create token mint
arch-cli token create-mint --keypair-path ~/my-keypair.json --decimals 6

# Deploy program
arch-cli deploy examples/helloworld/

# Check account
arch-cli show &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<ul>
<li><code>ARCH_PROFILE</code>: Set default profile</li>
<li><code>NETWORK_MODE</code>: Set default network mode</li>
<li><code>PUBKEY</code>: Set default public key for some commands</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-api-reference"><a class="header" href="#rpc-api-reference">RPC API Reference</a></h1>
<p>The Arch Network provides a comprehensive JSON-RPC API for interacting with validator nodes. This API allows you to:</p>
<ul>
<li>Query account information and balances</li>
<li>Submit transactions to the network</li>
<li>Retrieve block and transaction data</li>
<li>Monitor network state and readiness</li>
<li>Manage validator operations</li>
</ul>
<blockquote>
<p><strong>üìã RPC Method Availability</strong>: For a complete list of which RPC methods are available in the <code>validator</code> vs <code>local_validator</code> crates, along with their correct parameter formats, see the <a href="rpc/./rpc-method-availability.html">RPC Method Availability Guide</a>.</p>
</blockquote>
<h2 id="api-endpoints"><a class="header" href="#api-endpoints">API Endpoints</a></h2>
<h3 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h3>
<ul>
<li><strong>Default Port</strong>: <code>9001</code> for validator nodes, <code>9002</code> for local validators</li>
<li><strong>Endpoint URL</strong>: <code>http://localhost:9002</code> (or your node‚Äôs IP address)</li>
<li><strong>Protocol</strong>: HTTP POST with JSON-RPC 2.0</li>
</ul>
<h3 id="request-format"><a class="header" href="#request-format">Request Format</a></h3>
<p>All RPC requests must be sent as HTTP <code>POST</code> requests with:</p>
<ul>
<li><strong>Content-Type</strong>: <code>application/json</code></li>
<li><strong>JSON-RPC Version</strong>: <code>"2.0"</code></li>
</ul>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "method_name",
  "params": [/* parameters */]
}
</code></pre>
<h3 id="response-format"><a class="header" href="#response-format">Response Format</a></h3>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {/* response data */}
}
</code></pre>
<h2 id="available-methods"><a class="header" href="#available-methods">Available Methods</a></h2>
<h3 id="account-operations-1"><a class="header" href="#account-operations-1">Account Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#read_account_info"><code>read_account_info</code></a> - Get account information</li>
<li><a href="rpc/rpc.html#get_account_address"><code>get_account_address</code></a> - Get Bitcoin address for account</li>
<li><a href="rpc/rpc.html#get_program_accounts"><code>get_program_accounts</code></a> - Query accounts by program ID</li>
<li><a href="rpc/rpc.html#get_multiple_accounts"><code>get_multiple_accounts</code></a> - Get multiple accounts at once</li>
<li><a href="rpc/rpc.html#request_airdrop"><code>request_airdrop</code></a> - Request airdrop of lamports (dev networks only)</li>
<li><a href="rpc/rpc.html#create_account_with_faucet"><code>create_account_with_faucet</code></a> - Create and fund account with faucet (dev networks only)</li>
</ul>
<h3 id="transaction-operations-1"><a class="header" href="#transaction-operations-1">Transaction Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#send_transaction"><code>send_transaction</code></a> - Submit a single transaction</li>
<li><a href="rpc/rpc.html#send_transactions"><code>send_transactions</code></a> - Submit multiple transactions</li>
<li><a href="rpc/rpc.html#get_processed_transaction"><code>get_processed_transaction</code></a> - Get transaction status and details</li>
<li><a href="rpc/rpc.html#recent_transactions"><code>recent_transactions</code></a> - Get recent transactions with filtering</li>
<li><a href="rpc/rpc.html#get_transactions_by_block"><code>get_transactions_by_block</code></a> - Get transactions from specific block</li>
<li><a href="rpc/rpc.html#get_transactions_by_ids"><code>get_transactions_by_ids</code></a> - Get multiple transactions by their IDs</li>
</ul>
<h3 id="block-operations"><a class="header" href="#block-operations">Block Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#get_block"><code>get_block</code></a> - Get block by hash</li>
<li><a href="rpc/rpc.html#get_block_by_height"><code>get_block_by_height</code></a> - Get block by height</li>
<li><a href="rpc/rpc.html#get_block_count"><code>get_block_count</code></a> - Get current block count</li>
<li><a href="rpc/rpc.html#get_block_hash"><code>get_block_hash</code></a> - Get block hash by height</li>
<li><a href="rpc/rpc.html#get_best_block_hash"><code>get_best_block_hash</code></a> - Get latest block hash</li>
<li><a href="rpc/rpc.html#get_best_finalized_block_hash"><code>get_best_finalized_block_hash</code></a> - Get latest finalized block hash</li>
</ul>
<h3 id="network-operations"><a class="header" href="#network-operations">Network Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#is_node_ready"><code>is_node_ready</code></a> - Check node readiness</li>
<li><a href="rpc/rpc.html#get_peers"><code>get_peers</code></a> - Get connected network peers</li>
<li><a href="rpc/rpc.html#get_current_state"><code>get_current_state</code></a> - Get current validator node state</li>
<li><a href="rpc/rpc.html#get_network_pubkey"><code>get_network_pubkey</code></a> - Get the network verifying key</li>
</ul>
<h3 id="system-operations"><a class="header" href="#system-operations">System Operations</a></h3>
<ul>
<li><a href="rpc/rpc.html#get_version"><code>get_version</code></a> - Get node version information</li>
</ul>
<h3 id="local-validator-specific-methods"><a class="header" href="#local-validator-specific-methods">Local Validator Specific Methods</a></h3>
<ul>
<li><a href="rpc/rpc.html#get_arch_txid_from_btc_txid"><code>get_arch_txid_from_btc_txid</code></a> - Map Bitcoin txid to Arch txid</li>
<li><a href="rpc/rpc.html#get_transaction_report"><code>get_transaction_report</code></a> - Get detailed transaction processing report</li>
<li><a href="rpc/rpc.html#get_latest_tx_using_account"><code>get_latest_tx_using_account</code></a> - Find most recent transaction for account</li>
<li><a href="rpc/rpc.html#get_all_accounts"><code>get_all_accounts</code></a> - Get all account public keys</li>
<li><a href="rpc/rpc.html#get_transactions_by_block"><code>get_transactions_by_block</code></a> - Get transactions from specific block</li>
<li><a href="rpc/rpc.html#get_transactions_by_ids"><code>get_transactions_by_ids</code></a> - Get multiple transactions by their IDs</li>
</ul>
<hr />
<h2 id="account-operations-2"><a class="header" href="#account-operations-2">Account Operations</a></h2>
<h3 id="read_account_info"><a class="header" href="#read_account_info">read_account_info</a></h3>
<p>Retrieves information for a specified account.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> Account information object with <code>data</code>, <code>owner</code>, <code>utxo</code>, <code>is_executable</code>, and <code>tag</code> fields.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"read_account_info",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_account_address"><a class="header" href="#get_account_address">get_account_address</a></h3>
<p>Retrieves the Bitcoin address for a given account public key.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>account_pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> Bitcoin address string (format depends on network mode)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_account_address",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32] 
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_program_accounts"><a class="header" href="#get_program_accounts">get_program_accounts</a></h3>
<p>Fetches all accounts owned by a specified program ID.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>program_id</code> - Program public key as a 32-byte array</li>
<li><code>filters</code> (optional) - Array of filter objects:
<ul>
<li><code>{ "DataSize": &lt;size&gt; }</code> - Filter by account data size</li>
<li><code>{ "DataContent": { "offset": &lt;offset&gt;, "bytes": &lt;byte_array&gt; } }</code> - Filter by data content</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of account objects with <code>pubkey</code> and <code>account</code> information.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
  "jsonrpc":"2.0",
  "id":1,
  "method": "get_program_accounts",
  "params": [
    [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
    [
      {
        "DataSize": 165
      },
      {
        "DataContent": {
          "offset": 0,
          "bytes": [1, 2, 3, 4]
        }
      }
    ]
  ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_multiple_accounts"><a class="header" href="#get_multiple_accounts">get_multiple_accounts</a></h3>
<p>Retrieves information for multiple accounts in a single request.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkeys</code> - Array of account public keys (32-byte arrays)</li>
</ol>
<p><strong>Returns:</strong> Array of account information objects.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_multiple_accounts",
    "params":[
        [
            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
            [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]
        ]
    ]
}' http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    {
      "data": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
      "owner": [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
      "utxo": "txid:vout",
      "is_executable": false
    },
    {
      "data": [65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96],
      "owner": [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
      "utxo": "txid:vout",
      "is_executable": false
    }
  ],
  "id": "1"
}
</code></pre>
<h3 id="request_airdrop"><a class="header" href="#request_airdrop">request_airdrop</a></h3>
<p>Requests airdrop of lamports to a specified account.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> Transaction ID string of the airdrop transaction</p>
<p><strong>Note:</strong> Only available on non-mainnet networks (testnet, devnet, regtest).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"request_airdrop",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="create_account_with_faucet"><a class="header" href="#create_account_with_faucet">create_account_with_faucet</a></h3>
<p>Creates a new account and funds it using the faucet.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>pubkey</code> - Account public key as a 32-byte array</li>
</ol>
<p><strong>Returns:</strong> RuntimeTransaction object for the account creation</p>
<p><strong>Note:</strong> Only available on non-mainnet networks (testnet, devnet, regtest).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"create_account_with_faucet",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' http://localhost:9002/
</code></pre>
<h2 id="transaction-operations-2"><a class="header" href="#transaction-operations-2">Transaction Operations</a></h2>
<h3 id="send_transaction"><a class="header" href="#send_transaction">send_transaction</a></h3>
<p>Submits a single transaction to the network.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>transaction</code> - RuntimeTransaction object containing:
<ul>
<li><code>version</code> - Transaction version (currently 0)</li>
<li><code>signatures</code> - Array of transaction signatures</li>
<li><code>message</code> - Transaction message with signers and instructions</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Transaction ID (txid) string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"send_transaction",
    "params":[{
        "version": 0,
        "signatures": [
            {"0": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]}
        ],
        "message": {
            "signers": [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]],
            "instructions": [
                {
                    "program_id": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
                    "accounts": [
                        {
                            "pubkey": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
                            "is_signer": true,
                            "is_writable": true
                        }
                    ],
                    "data": [1,2,3,4]
                }
            ]
        }
    }]
}' http://localhost:9002/
</code></pre>
<h3 id="send_transactions"><a class="header" href="#send_transactions">send_transactions</a></h3>
<p>Submits multiple transactions to the network.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>transactions</code> - Array of serialized transactions (byte arrays)</li>
</ol>
<p><strong>Returns:</strong> Array of transaction ID strings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"send_transactions",
    "params": [
        [
            [1,2,3,4,5,6,7,8,9,10],
            [11,12,13,14,15,16,17,18,19,20]
        ]
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_processed_transaction"><a class="header" href="#get_processed_transaction">get_processed_transaction</a></h3>
<p>Retrieves a processed transaction and its status.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>transaction_id</code> - Transaction ID string</li>
</ol>
<p><strong>Returns:</strong> Object containing <code>runtime_transaction</code>, <code>status</code>, and <code>bitcoin_txids</code></p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_processed_transaction",
    "params":[
        "3q2uY8ZkW7x6v5t4s3r2q1p0n9m8l7k6j5h4g3f2e1d0c9b8a7Z"
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="recent_transactions"><a class="header" href="#recent_transactions">recent_transactions</a></h3>
<p>Retrieves recent transactions with optional filtering.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>params</code> - Object with optional fields:
<ul>
<li><code>limit</code> (optional) - Maximum number of transactions to return</li>
<li><code>offset</code> (optional) - Number of transactions to skip</li>
<li><code>account</code> (optional) - Filter by account involvement (32-byte array)</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of ProcessedTransaction objects</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"recent_transactions",
    "params":[{
        "limit": 10,
        "offset": 0,
        "account": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    }]
}' http://localhost:9002/
</code></pre>
<h3 id="get_transactions_by_block"><a class="header" href="#get_transactions_by_block">get_transactions_by_block</a></h3>
<p>Retrieves transactions from a specific block.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>params</code> - Object with required and optional fields:
<ul>
<li><code>block_hash</code> - Block hash string</li>
<li><code>limit</code> (optional) - Maximum number of transactions to return</li>
<li><code>offset</code> (optional) - Number of transactions to skip</li>
<li><code>account</code> (optional) - Filter by account involvement (32-byte array)</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of ProcessedTransaction objects</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_transactions_by_block",
    "params":[{
        "block_hash": "4D2u8Yx7Wv6T5R4E3Q2W1E2R3T4Y5U6I7O8P9A0S1D2F3G4H5J6K7L8",
        "limit": 50,
        "offset": 0
    }]
}' http://localhost:9002/
</code></pre>
<h3 id="get_transactions_by_ids"><a class="header" href="#get_transactions_by_ids">get_transactions_by_ids</a></h3>
<p>Retrieves multiple transactions by their IDs.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>params</code> - Object with required field:
<ul>
<li><code>txids</code> - Array of transaction ID strings</li>
</ul>
</li>
</ol>
<p><strong>Returns:</strong> Array of ProcessedTransaction objects (null for missing transactions)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_transactions_by_ids",
    "params":[{
        "txids": [
            "5H3K2L1M9N8B7V6C5X4Z3A2S1D0F9G8H7J6K5L4M3N2B1V0C9X",
            "7Y6T5R4E3W2Q1A2S3D4F5G6H7J8K9L0P1Q2W3E4R5T6Y7U8I9O"
        ]
    }]
}' http://localhost:9002/
</code></pre>
<h2 id="block-operations-1"><a class="header" href="#block-operations-1">Block Operations</a></h2>
<h3 id="get_block"><a class="header" href="#get_block">get_block</a></h3>
<p>Retrieves a block by its hash.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>block_hash</code> - Block hash string</li>
<li><code>filter</code> (optional) - Block transaction filter</li>
</ol>
<p><strong>Returns:</strong> Block object with transaction data</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block",
    "params":[
        "4D2u8Yx7Wv6T5R4E3Q2W1E2R3T4Y5U6I7O8P9A0S1D2F3G4H5J6K7L8" 
    ]
}' http://localhost:9002/
</code></pre>
<h3 id="get_block_by_height"><a class="header" href="#get_block_by_height">get_block_by_height</a></h3>
<p>Retrieves a block by its height.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>block_height</code> - Block height number</li>
<li><code>filter</code> (optional) - Block transaction filter</li>
</ol>
<p><strong>Returns:</strong> Block object with transaction data</p>
<h3 id="get_block_count"><a class="header" href="#get_block_count">get_block_count</a></h3>
<p>Retrieves the current block count.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Current block count as a number</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block_count",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_block_hash"><a class="header" href="#get_block_hash">get_block_hash</a></h3>
<p>Retrieves the block hash for a given height.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>block_height</code> - Block height number</li>
</ol>
<p><strong>Returns:</strong> Block hash string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block_hash",
    "params":[680000]
}' http://localhost:9002/
</code></pre>
<h3 id="get_best_block_hash"><a class="header" href="#get_best_block_hash">get_best_block_hash</a></h3>
<p>Retrieves the hash of the latest block.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Latest block hash string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_best_block_hash",
    "params":[]
}' http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "9xB3oYqYq2y8pHsmwqZkD4pKQyP6b6m7x8Q2F3G5H7J9K2M4N6P8Q0R2T4V6X8Z",
  "id": "1"
}
</code></pre>
<h3 id="get_best_finalized_block_hash"><a class="header" href="#get_best_finalized_block_hash">get_best_finalized_block_hash</a></h3>
<p>Retrieves the hash of the latest finalized block.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Latest finalized block hash string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_best_finalized_block_hash",
    "params":[]
}' http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "9xB3oYqYq2y8pHsmwqZkD4pKQyP6b6m7x8Q2F3G5H7J9K2M4N6P8Q0R2T4V6X8Z",
  "id": "1"
}
</code></pre>
<h2 id="system-operations-1"><a class="header" href="#system-operations-1">System Operations</a></h2>
<h3 id="get_version"><a class="header" href="#get_version">get_version</a></h3>
<p>Retrieves the version information of the node.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Version information object containing node version details.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_version",
    "params":[]
}' http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "version": "0.5.0",
    "build": "dev"
  },
  "id": "1"
}
</code></pre>
<h2 id="network-operations-1"><a class="header" href="#network-operations-1">Network Operations</a></h2>
<h3 id="is_node_ready"><a class="header" href="#is_node_ready">is_node_ready</a></h3>
<p>Checks if the node is ready to process requests.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Boolean indicating readiness</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_peers"><a class="header" href="#get_peers">get_peers</a></h3>
<p>Retrieves information about connected network peers.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Array of peer statistics objects</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_peers",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_current_state"><a class="header" href="#get_current_state">get_current_state</a></h3>
<p>Retrieves the current state of the validator node.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> CurrentState object containing validator state information</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_current_state",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h3 id="get_network_pubkey"><a class="header" href="#get_network_pubkey">get_network_pubkey</a></h3>
<p>Returns the current network verifying key as a hex string.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Hex-encoded verifying key string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_network_pubkey",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h2 id="local-validator-specific-methods-1"><a class="header" href="#local-validator-specific-methods-1">Local Validator Specific Methods</a></h2>
<p>The following methods are available only when using the local validator (for development):</p>
<h3 id="get_arch_txid_from_btc_txid"><a class="header" href="#get_arch_txid_from_btc_txid">get_arch_txid_from_btc_txid</a></h3>
<p>Maps a Bitcoin transaction ID to its corresponding Arch transaction ID.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>btc_txid</code> - Bitcoin transaction ID string</li>
</ol>
<p><strong>Returns:</strong> Optional Arch transaction ID string (null if not found)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_arch_txid_from_btc_txid",
    "params":["1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"]
}' http://localhost:9002/
</code></pre>
<h3 id="get_transaction_report"><a class="header" href="#get_transaction_report">get_transaction_report</a></h3>
<p>Retrieves detailed transaction processing report for debugging.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>txid</code> - Transaction ID string</li>
</ol>
<p><strong>Returns:</strong> Transaction report string with processing details</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_transaction_report",
    "params":["1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"]
}' http://localhost:9002/
</code></pre>
<h3 id="get_latest_tx_using_account"><a class="header" href="#get_latest_tx_using_account">get_latest_tx_using_account</a></h3>
<p>Finds the most recent transaction involving a specific account.</p>
<p><strong>Parameters:</strong></p>
<ol>
<li><code>account_pubkey</code> - Account public key as base58 string (32 bytes)</li>
</ol>
<p><strong>Returns:</strong> Optional transaction ID string (null if not found)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_latest_tx_using_account",
    "params":["0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"]
}' http://localhost:9002/
</code></pre>
<h3 id="get_all_accounts"><a class="header" href="#get_all_accounts">get_all_accounts</a></h3>
<p>Retrieves all account public keys in the database.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong> Array of account public keys (base58 strings)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">curl -X POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_all_accounts",
    "params":[]
}' http://localhost:9002/
</code></pre>
<h2 id="sdk-integration"><a class="header" href="#sdk-integration">SDK Integration</a></h2>
<p>For easier integration, use the official SDK:</p>
<ul>
<li><strong>TypeScript/JavaScript</strong>: <code>@saturnbtcio/arch-sdk</code></li>
<li><strong>Rust</strong>: <code>arch_sdk</code> crate</li>
</ul>
<h2 id="cli-alternative"><a class="header" href="#cli-alternative">CLI Alternative</a></h2>
<p>Most RPC operations can also be performed using the <a href="rpc/../getting-started/quick-start.html#cli-alternative">Arch Network CLI</a>:</p>
<pre><code class="language-bash"># Deploy a program
arch-cli deploy &lt;ELF_PATH&gt;

# Check transaction status  
arch-cli confirm &lt;TX_ID&gt;

# Get account information
arch-cli account &lt;ACCOUNT_ADDRESS&gt;

# Get block information
arch-cli get-block &lt;BLOCK_HASH&gt;

# Get current block height
arch-cli get-block-height

# Get program messages from transaction
arch-cli log-program-messages &lt;TX_ID&gt;

# Change account owner
arch-cli change-owner &lt;ACCOUNT_ADDRESS&gt; &lt;NEW_OWNER&gt;
</code></pre>
<h2 id="error-handling-13"><a class="header" href="#error-handling-13">Error Handling</a></h2>
<p>All RPC methods return JSON-RPC 2.0 compliant error responses:</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32600,
    "message": "Invalid Request",
    "data": "Additional error details"
  }
}
</code></pre>
<p>Common error codes:</p>
<ul>
<li><code>-32600</code>: Invalid Request</li>
<li><code>-32601</code>: Method not found</li>
<li><code>-32602</code>: Invalid params</li>
<li><code>-32603</code>: Internal error</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-method-availability-and-parameter-formats"><a class="header" href="#rpc-method-availability-and-parameter-formats">RPC Method Availability and Parameter Formats</a></h1>
<p>This document provides a comprehensive overview of which RPC methods are available in the <code>validator</code> vs <code>local_validator</code> crates, along with their correct parameter formats.</p>
<h2 id="method-availability"><a class="header" href="#method-availability">Method Availability</a></h2>
<h3 id="available-in-both-crates"><a class="header" href="#available-in-both-crates">Available in Both Crates</a></h3>
<p>The following RPC methods are available in both <code>validator</code> and <code>local_validator</code> crates:</p>
<ul>
<li><code>is_node_ready</code> - No parameters</li>
<li><code>get_account_address</code> - Single byte array parameter</li>
<li><code>request_airdrop</code> - Single Pubkey parameter</li>
<li><code>create_account_with_faucet</code> - Single Pubkey parameter</li>
<li><code>read_account_info</code> - Single Pubkey parameter</li>
<li><code>get_multiple_accounts</code> - Single array of Pubkeys parameter</li>
<li><code>send_transaction</code> - Single RuntimeTransaction parameter</li>
<li><code>send_transactions</code> - Single array of RuntimeTransactions parameter</li>
<li><code>get_block_count</code> - No parameters</li>
<li><code>get_best_block_hash</code> - No parameters</li>
<li><code>get_best_finalized_block_hash</code> - No parameters</li>
<li><code>get_block_hash</code> - Single u64 parameter (block height)</li>
<li><code>get_block</code> - Array with block hash string and optional filter</li>
<li><code>get_block_by_height</code> - Array with block height u64 and optional filter</li>
<li><code>get_processed_transaction</code> - Single string parameter (transaction ID)</li>
<li><code>get_program_accounts</code> - Array with program_id Pubkey and optional filters</li>
<li><code>recent_transactions</code> - Single TransactionListParams object</li>
<li><code>get_transactions_by_block</code> - Single BlockTransactionsParams object</li>
<li><code>get_transactions_by_ids</code> - Single TransactionsByIdsParams object</li>
<li><code>get_version</code> - No parameters</li>
<li><code>get_network_pubkey</code> - No parameters</li>
</ul>
<h3 id="available-only-in-validator-crate"><a class="header" href="#available-only-in-validator-crate">Available Only in Validator Crate</a></h3>
<p>The following RPC methods are <strong>only available</strong> in the <code>validator</code> crate:</p>
<ul>
<li><code>get_peers</code> - No parameters</li>
<li><code>get_current_state</code> - No parameters</li>
</ul>
<h3 id="available-only-in-local-validator-crate"><a class="header" href="#available-only-in-local-validator-crate">Available Only in Local Validator Crate</a></h3>
<p>The following RPC methods are available only in the <code>local_validator</code> crate (development/debug helpers):</p>
<ul>
<li><code>get_arch_txid_from_btc_txid</code> - Single string parameter (Bitcoin transaction ID)</li>
<li><code>get_transaction_report</code> - Single string parameter (transaction ID)</li>
<li><code>get_latest_tx_using_account</code> - Single string parameter (account public key)</li>
<li><code>get_all_accounts</code> - No parameters</li>
</ul>
<h3 id="deprecated-or-not-exposed"><a class="header" href="#deprecated-or-not-exposed">Deprecated or Not Exposed</a></h3>
<p>The following legacy methods are not currently exposed via RPC in the validator:</p>
<ul>
<li><code>start_dkg</code></li>
<li><code>reset_network</code></li>
</ul>
<h2 id="parameter-format-patterns"><a class="header" href="#parameter-format-patterns">Parameter Format Patterns</a></h2>
<h3 id="single-parameter-methods"><a class="header" href="#single-parameter-methods">Single Parameter Methods</a></h3>
<p>Methods that use <code>params.parse::&lt;Type&gt;()</code> expect a single parameter of the specified type:</p>
<ul>
<li><strong>String parameters</strong>: <code>"value"</code> (not <code>["value"]</code>)</li>
<li><strong>Number parameters</strong>: <code>123</code> (not <code>[123]</code>)</li>
<li><strong>Byte array parameters</strong>: <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]</code> (not <code>[[1,2,3,...]]</code>)</li>
<li><strong>Object parameters</strong>: <code>{"key": "value"}</code> (not <code>[{"key": "value"}]</code>)</li>
</ul>
<h3 id="array-parameter-methods"><a class="header" href="#array-parameter-methods">Array Parameter Methods</a></h3>
<p>Methods that use <code>parse_block_params</code> or similar expect an array with specific structure:</p>
<ul>
<li><strong>Block methods</strong>: <code>["block_hash_string", optional_filter_object]</code></li>
<li><strong>Program accounts</strong>: <code>[program_id_pubkey, optional_filters_object]</code></li>
</ul>
<h3 id="no-parameter-methods"><a class="header" href="#no-parameter-methods">No Parameter Methods</a></h3>
<p>Methods that use <code>_params</code> expect no parameters and should be called with <code>"params": []</code> or omit the params field entirely.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="correct-single-string-parameter"><a class="header" href="#correct-single-string-parameter">Correct: Single String Parameter</a></h3>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "get_processed_transaction",
    "params": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
}
</code></pre>
<h3 id="correct-single-byte-array-parameter"><a class="header" href="#correct-single-byte-array-parameter">Correct: Single Byte Array Parameter</a></h3>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "get_account_address",
    "params": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
}
</code></pre>
<h3 id="correct-array-with-block-hash-and-filter"><a class="header" href="#correct-array-with-block-hash-and-filter">Correct: Array with Block Hash and Filter</a></h3>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "get_block",
    "params": [
        "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
        {"include_transactions": "signatures"}
    ]
}
</code></pre>
<h3 id="correct-no-parameters"><a class="header" href="#correct-no-parameters">Correct: No Parameters</a></h3>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "get_block_count",
    "params": []
}
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>The <code>validator</code> crate is designed for production network nodes</li>
<li>The <code>local_validator</code> crate is designed for local development and testing</li>
<li>Most RPC methods are available in both crates for consistency</li>
<li>Methods like <code>get_peers</code> and <code>get_current_state</code> are only available in the validator crate as they require network state information</li>
<li>All parameter formats follow JSON-RPC 2.0 specification</li>
<li>When in doubt, check the method implementation in the source code to confirm the expected parameter format</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-program-2"><a class="header" href="#system-program-2">System Program</a></h1>
<p>The Arch System Program is the core program that manages fundamental account operations on the Arch Network. This program provides essential functionality for account creation, ownership management, UTXO anchoring, and lamport transfers.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>The System Program handles:</p>
<ul>
<li><strong>Account Creation</strong>: Creating new accounts with specified ownership and data allocation</li>
<li><strong>UTXO Integration</strong>: Anchoring accounts to Bitcoin UTXOs for native Bitcoin integration</li>
<li><strong>Ownership Management</strong>: Transferring account ownership between programs</li>
<li><strong>Lamport Transfers</strong>: Moving lamports (the base unit of value) between accounts</li>
<li><strong>Space Allocation</strong>: Allocating data storage space for accounts</li>
</ul>
<h2 id="built-in-programs"><a class="header" href="#built-in-programs">Built-in Programs</a></h2>
<p>Arch Network includes several built-in programs that provide essential functionality:</p>
<h3 id="system-program-3"><a class="header" href="#system-program-3">System Program</a></h3>
<p>The core system program for account management and basic operations.</p>
<h3 id="apl-token-program-1"><a class="header" href="#apl-token-program-1">APL Token Program</a></h3>
<p>Comprehensive token management with SPL token compatibility.</p>
<h3 id="associated-token-account-ata-program"><a class="header" href="#associated-token-account-ata-program">Associated Token Account (ATA) Program</a></h3>
<p>Automatic token account creation and management.</p>
<h3 id="compute-budget-program-1"><a class="header" href="#compute-budget-program-1">Compute Budget Program</a></h3>
<p>Transaction compute unit management and fee optimization.</p>
<h3 id="stake-program"><a class="header" href="#stake-program">Stake Program</a></h3>
<p>Validator staking and delegation management.</p>
<h3 id="vote-program"><a class="header" href="#vote-program">Vote Program</a></h3>
<p>Governance and voting mechanisms.</p>
<h3 id="loader-program"><a class="header" href="#loader-program">Loader Program</a></h3>
<p>Program deployment and upgrade management.</p>
<h2 id="available-instructions"><a class="header" href="#available-instructions">Available Instructions</a></h2>
<h3 id="createaccount"><a class="header" href="#createaccount">CreateAccount</a></h3>
<p>Creates a new account with the specified parameters.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>lamports: u64</code> - Number of lamports to transfer to the new account</li>
<li><code>space: u64</code> - Number of bytes of memory to allocate</li>
<li><code>owner: Pubkey</code> - Address of the program that will own the new account</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Funding account (payer)</li>
<li><code>[WRITE, SIGNER]</code> New account to create</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction,
    pubkey::Pubkey,
};

let instruction = system_instruction::create_account(
    &amp;from_pubkey,
    &amp;to_pubkey,
    1_000_000,  // lamports
    165,        // space in bytes
    &amp;owner_pubkey,
);</code></pre>
<h3 id="createaccountwithanchor"><a class="header" href="#createaccountwithanchor">CreateAccountWithAnchor</a></h3>
<p>Creates a new account and anchors it to a specific Bitcoin UTXO.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>lamports: u64</code> - Number of lamports to transfer</li>
<li><code>space: u64</code> - Number of bytes to allocate</li>
<li><code>owner: Pubkey</code> - Program that will own the account</li>
<li><code>txid: [u8; 32]</code> - Bitcoin transaction ID</li>
<li><code>vout: u32</code> - Output index in the Bitcoin transaction</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Funding account</li>
<li><code>[WRITE, SIGNER]</code> New account to create</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">let instruction = system_instruction::create_account_with_anchor(
    &amp;from_pubkey,
    &amp;to_pubkey,
    1_000_000,  // lamports
    165,        // space
    &amp;owner_pubkey,
    txid,       // Bitcoin transaction ID
    vout,       // Bitcoin output index
);</code></pre>
<h3 id="assign"><a class="header" href="#assign">Assign</a></h3>
<p>Changes the owner of an existing account.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>owner: Pubkey</code> - New owner program</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Account to reassign</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">let instruction = system_instruction::assign(
    &amp;account_pubkey,
    &amp;new_owner_pubkey,
);</code></pre>
<h3 id="anchor"><a class="header" href="#anchor">Anchor</a></h3>
<p>Anchors an existing account to a Bitcoin UTXO.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>txid: [u8; 32]</code> - Bitcoin transaction ID</li>
<li><code>vout: u32</code> - Output index</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Account to anchor</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">let instruction = system_instruction::anchor(
    &amp;account_pubkey,
    txid,       // Bitcoin transaction ID
    vout,       // Bitcoin output index
);</code></pre>
<h3 id="transfer-1"><a class="header" href="#transfer-1">Transfer</a></h3>
<p>Transfers lamports between accounts.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>lamports: u64</code> - Number of lamports to transfer</li>
</ul>
<p><strong>Account References:</strong></p>
<ol>
<li><code>[WRITE, SIGNER]</code> Source account</li>
<li><code>[WRITE]</code> Destination account</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">let instruction = system_instruction::transfer(
    &amp;from_pubkey,
    &amp;to_pubkey,
    1_000_000,  // lamports
);</code></pre>
<h2 id="program-interaction"><a class="header" href="#program-interaction">Program Interaction</a></h2>
<h3 id="using-built-in-programs"><a class="header" href="#using-built-in-programs">Using Built-in Programs</a></h3>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction,
    system_program,
    pubkey::Pubkey,
};

// Create a new account
let create_account_ix = system_instruction::create_account(
    &amp;payer_pubkey,
    &amp;new_account_pubkey,
    rent_exemption_amount,
    space,
    &amp;owner_program_pubkey,
);

// Transfer lamports
let transfer_ix = system_instruction::transfer(
    &amp;source_pubkey,
    &amp;destination_pubkey,
    amount,
);

// Assign new owner
let assign_ix = system_instruction::assign(
    &amp;account_pubkey,
    &amp;new_owner_pubkey,
);</code></pre>
<h3 id="program-addresses"><a class="header" href="#program-addresses">Program Addresses</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Program</th><th>Address</th><th>Description</th></tr></thead><tbody>
<tr><td>System</td><td><code>11111111111111111111111111111111</code></td><td>Core system operations</td></tr>
<tr><td>APL Token</td><td><code>AplToken111111111111111111111111</code></td><td>Token management</td></tr>
<tr><td>ATA</td><td><code>AssociatedTokenAccount1111111111</code></td><td>Associated token accounts</td></tr>
<tr><td>Compute Budget</td><td><code>ComputeBudget111111111111111111111111111111</code></td><td>Compute unit management</td></tr>
<tr><td>Stake</td><td><code>Stake1111111111111111111111111111111111111111</code></td><td>Staking operations</td></tr>
<tr><td>Vote</td><td><code>Vote111111111111111111111111111111111111111111</code></td><td>Voting operations</td></tr>
<tr><td>Loader</td><td><code>BPFLoader1111111111111111111111111111111111</code></td><td>Program deployment</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<h3 id="account-management-7"><a class="header" href="#account-management-7">Account Management</a></h3>
<ol>
<li><strong>Proper Sizing</strong>: Allocate appropriate space for account data</li>
<li><strong>Rent Exemption</strong>: Ensure accounts have sufficient lamports for rent exemption</li>
<li><strong>Ownership</strong>: Carefully manage account ownership transfers</li>
<li><strong>UTXO Anchoring</strong>: Use UTXO anchoring for Bitcoin integration</li>
</ol>
<h3 id="security-considerations-10"><a class="header" href="#security-considerations-10">Security Considerations</a></h3>
<ol>
<li><strong>Authority Validation</strong>: Always verify account authorities</li>
<li><strong>Input Validation</strong>: Validate all input parameters</li>
<li><strong>Error Handling</strong>: Implement proper error handling for failed operations</li>
<li><strong>Access Control</strong>: Restrict access to sensitive operations</li>
</ol>
<h3 id="performance-optimization-3"><a class="header" href="#performance-optimization-3">Performance Optimization</a></h3>
<ol>
<li><strong>Batch Operations</strong>: Group related operations when possible</li>
<li><strong>Space Efficiency</strong>: Minimize account space allocation</li>
<li><strong>Compute Budget</strong>: Use compute budget program for optimization</li>
<li><strong>Caching</strong>: Cache frequently accessed account data</li>
</ol>
<h2 id="error-handling-14"><a class="header" href="#error-handling-14">Error Handling</a></h2>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Error</th><th>Description</th><th>Resolution</th></tr></thead><tbody>
<tr><td><code>InsufficientFunds</code></td><td>Account has insufficient lamports</td><td>Fund the account or reduce amount</td></tr>
<tr><td><code>InvalidAccountData</code></td><td>Account data is invalid</td><td>Reinitialize the account</td></tr>
<tr><td><code>InvalidOwner</code></td><td>Invalid account owner</td><td>Check ownership requirements</td></tr>
<tr><td><code>AccountInUse</code></td><td>Account is already in use</td><td>Use a different account or wait</td></tr>
</tbody></table>
</div>
<h3 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h3>
<pre><code class="language-rust ignore">use arch_program::system_instruction;

match system_instruction::create_account(/* params */) {
    Ok(instruction) =&gt; {
        // Process instruction
    }
    Err(SystemError::InsufficientFunds) =&gt; {
        // Handle insufficient funds
    }
    Err(SystemError::InvalidAccountData) =&gt; {
        // Handle invalid account data
    }
    Err(e) =&gt; {
        // Handle other errors
    }
}</code></pre>
<h2 id="integration-examples-2"><a class="header" href="#integration-examples-2">Integration Examples</a></h2>
<h3 id="creating-a-token-mint"><a class="header" href="#creating-a-token-mint">Creating a Token Mint</a></h3>
<pre><code class="language-rust ignore">// Create mint account
let create_mint_ix = system_instruction::create_account(
    &amp;payer_pubkey,
    &amp;mint_pubkey,
    rent_exemption_amount,
    Mint::LEN as u64,
    &amp;apl_token::id(),
);

// Initialize mint (using APL token program)
let init_mint_ix = apl_token::instruction::initialize_mint(
    &amp;apl_token::id(),
    &amp;mint_pubkey,
    &amp;mint_authority_pubkey,
    None,
    decimals,
)?;</code></pre>
<h3 id="setting-up-associated-token-account"><a class="header" href="#setting-up-associated-token-account">Setting Up Associated Token Account</a></h3>
<pre><code class="language-rust ignore">// Create ATA account
let create_ata_ix = associated_token_account::instruction::create(
    &amp;payer_pubkey,
    &amp;owner_pubkey,
    &amp;mint_pubkey,
    &amp;token_program_id,
);

// Fund ATA account
let fund_ata_ix = system_instruction::transfer(
    &amp;payer_pubkey,
    &amp;ata_pubkey,
    rent_exemption_amount,
);</code></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><strong>Token Operations</strong>: Learn about <a href="system-program/../guides/how-to-create-a-fungible-token.html">APL Token Management</a></li>
<li><strong>Program Development</strong>: Explore <a href="system-program/../guides/writing-your-first-program.html">Writing Your First Program</a></li>
<li><strong>Advanced Features</strong>: Discover <a href="system-program/../concepts/architecture.html#core-programs">Core Programs</a></li>
<li><strong>Integration</strong>: Understand <a href="system-program/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="createaccount-1"><a class="header" href="#createaccount-1"><code>CreateAccount</code></a></h1>
<p><strong>Index:</strong> <code>0</code></p>
<p>Create a new account.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![0]</code>, the correct index for making a call to <code>SystemProgram::CreateAccount</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![0];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="makeexecutable"><a class="header" href="#makeexecutable"><code>MakeExecutable</code></a></h1>
<p><strong>Index:</strong> <code>2</code></p>
<p>Sets the account as executable, marking it as a program.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![2]</code>, the correct index for making a call to <code>SystemProgram::MakeExecutable</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![2];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<p>We can proceed to confirm that the program is executable with <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L368">read_account_info</a> which returns an <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L358">AccountInfoResult</a> that gets parsed to obtain the <code>is_executable</code> value.</p>
<pre><code class="language-rust ignore">assert!(
    read_account_info("node_url", program_pubkey)
        .unwrap()
        .is_executable
);</code></pre>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h1>
<p>This guide helps you diagnose and resolve common issues you might encounter while developing on the Arch Network.</p>
<h2 id="common-issues-5"><a class="header" href="#common-issues-5">Common Issues</a></h2>
<h3 id="build-errors"><a class="header" href="#build-errors">Build Errors</a></h3>
<h4 id="1-cargo-build-failures"><a class="header" href="#1-cargo-build-failures">1. Cargo Build Failures</a></h4>
<pre><code class="language-bash">error: failed to run custom build command for `arch-sdk v0.1.0`
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Ensure you have the latest Rust toolchain installed</li>
<li>Check that you‚Äôre using a compatible version of the Arch SDK</li>
<li>Try cleaning your build directory:
<pre><code class="language-bash">cargo clean
cargo build
</code></pre>
</li>
</ul>
<h4 id="2-program-compilation-errors"><a class="header" href="#2-program-compilation-errors">2. Program Compilation Errors</a></h4>
<pre><code class="language-bash">error: linking with `cc` failed: exit status: 1
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify you have the required system dependencies</li>
<li>Update your Arch SDK to the latest version</li>
<li>Check your program‚Äôs target architecture:
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
</li>
</ul>
<h3 id="deployment-issues"><a class="header" href="#deployment-issues">Deployment Issues</a></h3>
<h4 id="1-program-deployment-failures"><a class="header" href="#1-program-deployment-failures">1. Program Deployment Failures</a></h4>
<pre><code class="language-bash">Error: Program deployment failed: Transaction simulation failed
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check your account has sufficient balance</li>
<li>Verify the program binary size is within limits</li>
<li>Ensure you‚Äôre connected to the correct network:
<pre><code class="language-bash">arch-cli config get
</code></pre>
</li>
</ul>
<h4 id="2-transaction-errors"><a class="header" href="#2-transaction-errors">2. Transaction Errors</a></h4>
<pre><code class="language-bash">Error: Transaction failed: Custom program error: 0x1
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check program logs for detailed error information</li>
<li>Verify instruction data format</li>
<li>Ensure all required accounts are provided</li>
</ul>
<h3 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h3>
<h4 id="1-account-creation-failures"><a class="header" href="#1-account-creation-failures">1. Account Creation Failures</a></h4>
<pre><code class="language-bash">Error: Failed to create account: insufficient funds
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Verify account balance</li>
<li>Check rent-exempt minimum:
<pre><code class="language-bash">arch-cli rent minimum-balance &lt;size&gt;
</code></pre>
</li>
<li>Ensure correct account size calculation</li>
</ul>
<h4 id="2-instruction-processing-errors"><a class="header" href="#2-instruction-processing-errors">2. Instruction Processing Errors</a></h4>
<pre><code class="language-bash">Error: Program failed to complete: Program failed to process instruction
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Enable program logging:
<pre><code class="language-rust ignore">msg!("Debug output: {:?}", data);</code></pre>
</li>
<li>Check account ownership</li>
<li>Verify instruction data format</li>
</ul>
<h2 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h2>
<h3 id="1-connection-problems"><a class="header" href="#1-connection-problems">1. Connection Problems</a></h3>
<pre><code class="language-bash">Error: Unable to connect to RPC endpoint
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check network status</li>
<li>Verify endpoint configuration:
<pre><code class="language-bash">arch-cli config get
</code></pre>
</li>
<li>Try alternate RPC endpoints</li>
</ul>
<h3 id="2-validator-issues"><a class="header" href="#2-validator-issues">2. Validator Issues</a></h3>
<pre><code class="language-bash">Error: Validator node is not responding
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check validator logs</li>
<li>Verify Bitcoin Core and Titan are running</li>
<li>Ensure sufficient system resources</li>
</ul>
<h2 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h2>
<h3 id="1-sdk-version-mismatch"><a class="header" href="#1-sdk-version-mismatch">1. SDK Version Mismatch</a></h3>
<pre><code class="language-bash">error: package `arch-sdk v0.1.0` cannot be built
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Update Arch SDK:
<pre><code class="language-bash">cargo update -p arch-sdk
</code></pre>
</li>
<li>Check compatibility matrix</li>
<li>Clean and rebuild project</li>
</ul>
<h3 id="2-tool-chain-issues"><a class="header" href="#2-tool-chain-issues">2. Tool Chain Issues</a></h3>
<pre><code class="language-bash">error: linker `cc` not found
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Install required system dependencies</li>
<li>Update Rust toolchain:
<pre><code class="language-bash">rustup update
</code></pre>
</li>
<li>Verify PATH configuration</li>
</ul>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="1-slow-transaction-processing"><a class="header" href="#1-slow-transaction-processing">1. Slow Transaction Processing</a></h3>
<p><strong>Solution:</strong></p>
<ul>
<li>Check compute budget usage</li>
<li>Optimize account lookups</li>
<li>Consider batching transactions</li>
</ul>
<h3 id="2-high-resource-usage"><a class="header" href="#2-high-resource-usage">2. High Resource Usage</a></h3>
<p><strong>Solution:</strong></p>
<ul>
<li>Monitor program size</li>
<li>Optimize data structures</li>
<li>Review account storage strategy</li>
</ul>
<h2 id="debugging-tools"><a class="header" href="#debugging-tools">Debugging Tools</a></h2>
<h3 id="1-program-logs"><a class="header" href="#1-program-logs">1. Program Logs</a></h3>
<p>Enable detailed logging:</p>
<pre><code class="language-bash">RUST_LOG=debug arch-cli program-logs &lt;PROGRAM_ID&gt;
</code></pre>
<h3 id="2-transaction-inspection"><a class="header" href="#2-transaction-inspection">2. Transaction Inspection</a></h3>
<p>Analyze transaction details:</p>
<pre><code class="language-bash">arch-cli transaction-info &lt;TX_SIGNATURE&gt;
</code></pre>
<h3 id="3-account-inspection"><a class="header" href="#3-account-inspection">3. Account Inspection</a></h3>
<p>View account data:</p>
<pre><code class="language-bash">arch-cli account &lt;ACCOUNT_ADDRESS&gt;
</code></pre>
<h2 id="best-practices-16"><a class="header" href="#best-practices-16">Best Practices</a></h2>
<ol>
<li>
<p><strong>Development Workflow</strong></p>
<ul>
<li>Use local validator for testing</li>
<li>Maintain separate development/production configs</li>
<li>Regular testing with minimal test accounts</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Implement comprehensive error types</li>
<li>Add detailed error messages</li>
<li>Log relevant debug information</li>
</ul>
</li>
<li>
<p><strong>Maintenance</strong></p>
<ul>
<li>Regular dependency updates</li>
<li>Security audits</li>
<li>Performance monitoring</li>
</ul>
</li>
</ol>
<h2 id="getting-help-5"><a class="header" href="#getting-help-5">Getting Help</a></h2>
<p>If you‚Äôre still experiencing issues:</p>
<ol>
<li>Check the <a href="https://github.com/arch-network/arch-node/issues">GitHub Issues</a></li>
<li>Join the <a href="https://discord.gg/arch-network">Discord Community</a></li>
<li>Review the <a href="https://docs.arch.network">API Documentation</a></li>
</ol>
<p>Remember to provide relevant information when seeking help:</p>
<ul>
<li>Error messages</li>
<li>Program logs</li>
<li>Environment details</li>
<li>Steps to reproduce</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources-4"><a class="header" href="#resources-4">Resources</a></h1>
<h3 id="bitcoin-mempool-and-blockchain-explorer"><a class="header" href="#bitcoin-mempool-and-blockchain-explorer">Bitcoin mempool and blockchain explorer</a></h3>
<ul>
<li><a href="https://mempool.dev.aws.archnetwork.xyz">mempool.space - Arch Regtest</a>
<ul>
<li>Bitcoin mempool and block explorer. This <a href="https://mempool.space">mempool.space</a> instance monitors the regtest Bitcoin blockchain being used to run and validate all examples in this repo.</li>
</ul>
</li>
<li><a href="https://docs.solanalabs.com/cli/install">Solana CLI</a></li>
<li><a href="https://solana.com/developers/guides/getstarted/setup-local-development">Solana Local Development Guide</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
