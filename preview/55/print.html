<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Arch Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for the Arch Network - A Bitcoin-native computation environment">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="getting-started/quick-start.html">Quick Start Guide</a></li><li class="chapter-item "><a href="getting-started/environment-setup.html">Environment Setup</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="getting-started/bitcoin-and-electrs-setup.html">Bitcoin and Electrs Setup</a></li><li class="chapter-item "><a href="getting-started/setting-up-a-project.html">Setting up a Project</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concepts/nodes.html">Nodes</a></li></ol></li></ol></li><li class="chapter-item "><a href="getting-started/resources.html">Resources</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="concepts/architecture.html">Architecture Overview</a></li><li class="chapter-item "><a href="concepts/network-architecture.html">Network Architecture</a></li><li class="chapter-item "><a href="concepts/bitcoin-integration.html">Bitcoin Integration</a></li><li class="chapter-item "><a href="concepts/nodes.html">Nodes</a></li><li class="chapter-item "><a href="program/program.html">Programs</a></li><li class="chapter-item "><a href="program/utxo.html">UTXOs</a></li><li class="chapter-item affix "><li class="part-title">Programs and beyond</li><li class="chapter-item "><a href="basics/basics.html">Basics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basics/building-deploying-interfacing.html">Building, deploying and interfacing</a></li><li class="chapter-item "><a href="basics/interaction.html">Program interaction</a></li></ol></li><li class="chapter-item "><a href="guides/guides.html">Guides</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="guides/how-to-write-arch-program.html">How to write an Arch program</a></li><li class="chapter-item "><a href="guides/how-to-write-oracle-program.html">How to write an oracle program</a></li><li class="chapter-item "><a href="guides/how-to-create-a-fungible-token.html">How to create a fungible token</a></li><li class="chapter-item "><a href="guides/how-to-build-runes-swap.html">How to build a Bitcoin Runes swap application</a></li><li class="chapter-item "><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html">How to configure the local validator with Bitcoin Testnet4</a></li><li class="chapter-item "><a href="guides/how-to-build-lending-protocol.html">How to Build a Bitcoin Lending Protocol</a></li></ol></li><li class="chapter-item "><li class="part-title">Reference</li><li class="chapter-item "><a href="program/program.html">Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="program/account.html">Account Structure</a></li><li class="chapter-item "><a href="program/accounts.html">Account Guide</a></li><li class="chapter-item "><a href="program/system-functions.html">System Functions</a></li><li class="chapter-item "><a href="program/entrypoint.html">Entrypoint</a></li><li class="chapter-item "><a href="program/instructions-and-messages.html">Instructions and Messages</a></li><li class="chapter-item "><a href="program/pubkey.html">Pubkey</a></li><li class="chapter-item "><a href="program/syscall.html">Syscall</a></li><li class="chapter-item "><a href="program/system-instruction.html">System Instruction</a></li><li class="chapter-item "><a href="program/utxo.html">UTXO</a></li></ol></li><li class="chapter-item "><a href="sdk/sdk.html">SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/processed-transaction.html">Processed Transaction</a></li><li class="chapter-item "><a href="sdk/runtime-transaction.html">Runtime Transaction</a></li><li class="chapter-item "><a href="sdk/signature.html">Signature</a></li></ol></li><li class="chapter-item "><a href="system-program/system-program.html">System Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="system-program/create-account.html">CreateAccount</a></li><li class="chapter-item "><a href="system-program/write-bytes.html">WriteBytes</a></li><li class="chapter-item "><a href="system-program/make-executable.html">MakeExecutable</a></li><li class="chapter-item "><a href="system-program/assign-ownership.html">AssignOwnership</a></li></ol></li><li class="chapter-item "><a href="rpc/rpc.html">RPC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rpc/http-methods.html">HTTP Methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rpc/http-methods/send-transaction.html">sendTransaction</a></li><li class="chapter-item "><a href="rpc/http-methods/send-transactions.html">sendTransactions</a></li><li class="chapter-item "><a href="rpc/http-methods/get-account-address.html">getAccountAddress</a></li><li class="chapter-item "><a href="rpc/http-methods/get-program-accounts.html">getProgramAccounts</a></li><li class="chapter-item "><a href="rpc/http-methods/get-block.html">getBlock</a></li><li class="chapter-item "><a href="rpc/http-methods/get-block-count.html">getBlockCount</a></li><li class="chapter-item "><a href="rpc/http-methods/get-block-hash.html">getBlockHash</a></li><li class="chapter-item "><a href="rpc/http-methods/get-current-state.html">getCurrentState</a></li><li class="chapter-item "><a href="rpc/http-methods/get-peers.html">getPeers</a></li><li class="chapter-item "><a href="rpc/http-methods/get-processed-transaction.html">getProcessedTransaction</a></li><li class="chapter-item "><a href="rpc/http-methods/read-account-info.html">readAccountInfo</a></li><li class="chapter-item "><a href="rpc/http-methods/start-dkg.html">startDkg</a></li><li class="chapter-item "><a href="rpc/http-methods/is-node-ready.html">isNodeReady</a></li><li class="chapter-item "><a href="rpc/http-methods/reset-network.html">resetNetwork</a></li></ol></li><li class="chapter-item "><a href="rpc/deprecated-methods.html">Deprecated Methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rpc/deprecated-methods/get-account-info.html">getAccountInfo</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Arch Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arch-network/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-arch-network"><a class="header" href="#welcome-to-arch-network">Welcome to Arch Network</a></h1>
<div class="info">
This documentation is actively maintained. If you find any issues or have suggestions for improvements, please visit our <a href="https://github.com/arch-network/docs">GitHub repository</a>.
</div>
<h2 id="what-is-arch-network"><a class="header" href="#what-is-arch-network">What is Arch Network?</a></h2>
<p>Arch Network is a computation environment that enhances Bitcoin’s capabilities by enabling complex operations on Bitcoin UTXOs through its specialized virtual machine. Unlike Layer 2 solutions, Arch Network provides a native computation layer that works directly with Bitcoin’s security model.</p>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<div class="feature-grid">
<div class="feature">
    <h4 id="bitcoin-native"><a class="header" href="#bitcoin-native">Bitcoin-Native</a></h4>
    <p>Direct <a href="concepts/bitcoin-integration.html">integration with Bitcoin</a> through UTXO management</p>
</div>
<div class="feature">
    <h4 id="computation-environment"><a class="header" href="#computation-environment">Computation Environment</a></h4>
    <p>Execute complex programs within the <a href="concepts/architecture.html">Arch VM</a></p>
</div>
<div class="feature">
    <h4 id="program-development"><a class="header" href="#program-development">Program Development</a></h4>
    <p>Write <a href="program/program.html">programs in Rust</a> to interact with <a href="program/utxo.html">Bitcoin UTXOs</a></p>
</div>
<div class="feature">
    <h4 id="security"><a class="header" href="#security">Security</a></h4>
    <p>Leverages Bitcoin's proven security guarantees through <a href="concepts/network-architecture.html#security-model">multi-signature validation</a></p>
</div>
<div class="feature">
    <h4 id="developer-tools"><a class="header" href="#developer-tools">Developer Tools</a></h4>
    <p>Complete development environment with <a href="getting-started/environment-setup.html">CLI tools</a> and explorer</p>
</div>
</div>
<h2 id="choose-your-path"><a class="header" href="#choose-your-path">Choose Your Path</a></h2>
<h3 id="-quick-start-15-minutes"><a class="header" href="#-quick-start-15-minutes">🚀 Quick Start (15 minutes)</a></h3>
<div class="path-box">
Build your first Arch program:
<ol>
<li><a href="getting-started/environment-setup.html">Set up your development environment</a></li>
<li><a href="guides/how-to-write-arch-program.html">Create and deploy a basic program</a></li>
<li><a href="program/utxo.html">Interact with Bitcoin UTXOs</a></li>
</ol>
</div>
<h3 id="-learning-path"><a class="header" href="#-learning-path">🎓 Learning Path</a></h3>
<div class="path-box">
Master Arch development:
<ol>
<li>
<p><strong>Network Architecture</strong> - Understand how nodes work together</p>
<ul>
<li><a href="concepts/network-architecture.html#node-types">Node Types</a></li>
<li><a href="concepts/network-architecture.html#network-communication">Network Communication</a></li>
<li><a href="concepts/network-architecture.html#security-model">Security Model</a></li>
</ul>
</li>
<li>
<p><a href="concepts/bitcoin-integration.html">Bitcoin Integration</a> - Learn Bitcoin interaction</p>
<ul>
<li><a href="concepts/bitcoin-integration.html#1-utxo-management">UTXO Management</a></li>
<li><a href="concepts/bitcoin-integration.html#2-bitcoin-rpc-integration">RPC Integration</a></li>
<li><a href="concepts/bitcoin-integration.html#transaction-flow">Transaction Flow</a></li>
</ul>
</li>
<li>
<p><a href="program/program.html">Program Development</a> - Write programs</p>
<ul>
<li><a href="program/accounts.html">Account Management</a></li>
<li><a href="program/instructions-and-messages.html">Instructions</a></li>
<li><a href="program/syscall.html">System Calls</a></li>
</ul>
</li>
</ol>
</div>
<h3 id="-reference"><a class="header" href="#-reference">🛠 Reference</a></h3>
<div class="reference-grid">
Technical documentation:
<ul>
<li><a href="rpc/rpc.html">API Reference</a>
<ul>
<li><a href="rpc/http-methods.html">HTTP Methods</a></li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a></li>
</ul>
</li>
<li><a href="guides/how-to-write-arch-program.html">Program Examples</a>
<ul>
<li><a href="guides/how-to-write-oracle-program.html">Oracle Program</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html">Fungible Token</a></li>
</ul>
</li>
<li><a href="system-program/system-program.html">System Program</a>
<ul>
<li><a href="system-program/create-account.html">Account Creation</a></li>
<li><a href="system-program/make-executable.html">Program Deployment</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<h3 id="how-arch-works"><a class="header" href="#how-arch-works">How Arch Works</a></h3>
<div class="architecture-overview">
Arch Network consists of three main components:
<ol>
<li><strong>Network Layer</strong></li>
</ol>
<ul>
<li><a href="concepts/network-architecture.html">Network Architecture</a>
<ul>
<li><a href="concepts/network-architecture.html#1-bootnode">Bootnode</a>: Network discovery and peer management</li>
<li><a href="concepts/network-architecture.html#2-leader-node">Leader Node</a>: Transaction coordination</li>
<li><a href="concepts/network-architecture.html#3-validator-nodes">Validator Nodes</a>: Program execution</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Bitcoin Integration</strong></li>
</ol>
<ul>
<li><a href="concepts/bitcoin-integration.html#1-utxo-management">UTXO Management</a>
<ul>
<li>Transaction tracking</li>
<li>State anchoring</li>
<li>Ownership validation</li>
</ul>
</li>
<li><a href="concepts/bitcoin-integration.html#2-bitcoin-rpc-integration">RPC Integration</a>
<ul>
<li>Bitcoin node communication</li>
<li>Transaction submission</li>
<li>Network synchronization</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Computation Layer</strong></li>
</ol>
<ul>
<li><a href="program/program.html">Programs</a>
<ul>
<li><a href="program/instructions-and-messages.html">Instructions</a></li>
<li><a href="program/accounts.html">Accounts</a></li>
<li><a href="program/syscall.html">System Calls</a></li>
</ul>
</li>
<li><a href="sdk/processed-transaction.html">Transaction Processing</a>
<ul>
<li>Message validation</li>
<li>State updates</li>
<li>UTXO management</li>
</ul>
</li>
</ul>
</div>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<div class="prerequisites-box">
Before you begin, ensure you have:
<ul>
<li>Node.js v19+ (<a href="getting-started/requirements.html">installation guide</a>)</li>
<li>Rust (latest stable)</li>
<li>Docker for local development</li>
<li>Basic understanding of <a href="program/utxo.html">Bitcoin UTXOs</a></li>
</ul>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<div class="next-steps-grid">
<a href="getting-started/environment-setup.html">Set Up Development Environment →</a>
<a href="guides/how-to-write-arch-program.html">Create Your First Program →</a>
<a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html">Configure Local Validator →</a>
<a href="https://github.com/Arch-Network/arch-examples">Explore Example Projects →</a>
</div>
<h2 id="need-help"><a class="header" href="#need-help">Need Help?</a></h2>
<div class="help-box">
<ul>
<li><a href="https://discord.gg/archnetwork">Join our Discord</a></li>
<li><a href="concepts/architecture.html">Read the Architecture Overview</a></li>
<li><a href="guides/how-to-write-arch-program.html">View Example Programs</a></li>
<li><a href="concepts/network-architecture.html#monitoring-and-telemetry">Check Network Status</a></li>
<li><a href="rpc/rpc.html">API Reference</a></li>
</ul>
</div>
<div class="tip">
💡 <strong>Pro Tip:</strong> Use the search function (press 's' or '/' on your keyboard) to quickly find what you're looking for in the documentation.
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-quick-start-guide"><a class="header" href="#-quick-start-guide">🚀 Quick Start Guide</a></h1>
<p>Welcome to Arch Network! Let’s get you up and running with a local development environment.</p>
<h2 id="-what-youll-build"><a class="header" href="#-what-youll-build">🎯 What You’ll Build</a></h2>
<pre class="mermaid">graph TD
    A[Bitcoin Core] --&gt;|Blockchain Data| B[Electrs]
    B --&gt;|Efficient Queries| C[Local Validator]
    C --&gt;|Development Environment| D[Your dApp]
    style A fill:#f9d71c
    style B fill:#3498db
    style C fill:#2ecc71
    style D fill:#e74c3c
</pre>
<p>In this guide, you’ll set up a complete local development environment for building applications on Arch Network. You’ll:</p>
<ul>
<li>🏗️ Set up Bitcoin Core for local blockchain development</li>
<li>⚡ Configure Electrs for efficient blockchain queries</li>
<li>🔧 Launch the Arch Network local validator</li>
<li>🎮 Test your setup with some fun experiments!</li>
</ul>
<h2 id="-time-estimate"><a class="header" href="#-time-estimate">⏱️ Time Estimate</a></h2>
<ul>
<li>Total time: 45-60 minutes</li>
<li>Active time: ~20 minutes</li>
<li>Waiting time: ~30 minutes (during installations)</li>
</ul>
<h2 id="-prerequisites"><a class="header" href="#-prerequisites">📋 Prerequisites</a></h2>
<ul>
<li>Command line familiarity</li>
<li>~10GB free disk space</li>
<li>macOS or Linux operating system</li>
<li>Git installed</li>
<li>Rust installed (we’ll help you set this up!)</li>
</ul>
<h2 id="-your-learning-path"><a class="header" href="#-your-learning-path">🏃‍♂️ Your Learning Path</a></h2>
<ol>
<li><input disabled="" type="checkbox"/>
Environment Setup (5 mins)</li>
<li><input disabled="" type="checkbox"/>
Bitcoin Core Installation (20 mins)</li>
<li><input disabled="" type="checkbox"/>
Electrs Setup (15 mins)</li>
<li><input disabled="" type="checkbox"/>
Local Validator Launch (10 mins)</li>
<li><input disabled="" type="checkbox"/>
First Experiments (5 mins)</li>
</ol>
<h2 id="-learning-track"><a class="header" href="#-learning-track">🎓 Learning Track</a></h2>
<p>We’ve designed this guide as an interactive learning experience. Each step will:</p>
<ul>
<li>Explain what we’re building and why</li>
<li>Show you exactly what to do</li>
<li>Help you verify your progress</li>
<li>Include fun experiments to test your setup</li>
</ul>
<h2 id="-ready-to-start"><a class="header" href="#-ready-to-start">🎮 Ready to Start?</a></h2>
<p>Choose your path:</p>
<ol>
<li><a href="getting-started/environment-setup.html">🔧 Full Environment Setup</a> - Recommended for most developers</li>
<li><a href="getting-started/dev-environment-setup.html">🚄 Quick Setup Script</a> - For experienced developers</li>
<li><a href="getting-started/bitcoin-and-electrs-setup.html">📚 Detailed Component Guide</a> - For those who want to understand every detail</li>
</ol>
<blockquote>
<p>💡 <strong>Tip</strong>: If this is your first time building on Arch Network, we recommend following the Full Environment Setup path. It includes detailed explanations that will help you understand the architecture better.</p>
</blockquote>
<h2 id="-need-help"><a class="header" href="#-need-help">🆘 Need Help?</a></h2>
<ul>
<li>Join our <a href="https://discord.gg/archnetwork">Discord</a> for real-time support</li>
<li>Check our <a href="getting-started/troubleshooting.html">Troubleshooting Guide</a></li>
<li>Browse our <a href="getting-started/faq.html">FAQ</a></li>
</ul>
<p>Let’s begin your journey into cross-chain development! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h1>
<p>Here you will find instructions on how to run a local Arch Network development environment.</p>
<p>The core components are outlined within this section to help paint a model for how applications interact with Arch and the Bitcoin network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-setting-up-bitcoin-core-and-electrs"><a class="header" href="#-setting-up-bitcoin-core-and-electrs">🔗 Setting up Bitcoin Core and Electrs</a></h1>
<p>Welcome to the detailed component setup guide! Here we’ll walk through setting up Bitcoin Core and Electrs, the foundational components for your Arch Network development environment.</p>
<h2 id="-what-were-building"><a class="header" href="#-what-were-building">🎯 What We’re Building</a></h2>
<pre class="mermaid">graph TD
    A[Your dApp] --&gt;|Interacts with| B[Local Validator]
    B --&gt;|Queries| C[Electrs]
    C --&gt;|Reads| D[Bitcoin Core]
    D --&gt;|Manages| E[Local Blockchain]
    style A fill:#e74c3c
    style B fill:#2ecc71
    style C fill:#3498db
    style D fill:#f9d71c
    style E fill:#95a5a6
</pre>
<h3 id="-understanding-the-components"><a class="header" href="#-understanding-the-components">🧩 Understanding the Components</a></h3>
<h4 id="bitcoin-core-"><a class="header" href="#bitcoin-core-">Bitcoin Core 🏦</a></h4>
<ul>
<li>Your personal Bitcoin node</li>
<li>Manages a local blockchain in regtest mode</li>
<li>Perfect for development - create test Bitcoin at will!</li>
</ul>
<h4 id="electrs-"><a class="header" href="#electrs-">Electrs ⚡</a></h4>
<ul>
<li>Lightning-fast Bitcoin data indexer</li>
<li>Makes blockchain queries super efficient</li>
<li>Essential for real-time dApp responses</li>
</ul>
<h2 id="-progress-tracker"><a class="header" href="#-progress-tracker">📋 Progress Tracker</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Install Bitcoin Core dependencies</li>
<li><input disabled="" type="checkbox"/>
Build Bitcoin Core</li>
<li><input disabled="" type="checkbox"/>
Configure Bitcoin Core</li>
<li><input disabled="" type="checkbox"/>
Test Bitcoin Core</li>
<li><input disabled="" type="checkbox"/>
Build Electrs</li>
<li><input disabled="" type="checkbox"/>
Configure Electrs</li>
<li><input disabled="" type="checkbox"/>
Test the full stack</li>
</ul>
<h2 id="1--bitcoin-core-setup"><a class="header" href="#1--bitcoin-core-setup">1. 🏗️ Bitcoin Core Setup</a></h2>
<h3 id="11-installing-dependencies"><a class="header" href="#11-installing-dependencies">1.1 Installing Dependencies</a></h3>
<p>Choose your operating system:</p>
<h4 id="-macos"><a class="header" href="#-macos">🍎 macOS</a></h4>
<pre><code class="language-bash"># Install required dependencies via Homebrew
brew install automake boost ccache git libevent libnatpmp libtool llvm miniupnpc pkg-config python qrencode qt@5 sqlite zeromq
</code></pre>
<h4 id="-ubuntudebian-linux"><a class="header" href="#-ubuntudebian-linux">🐧 Ubuntu/Debian Linux</a></h4>
<pre><code class="language-bash"># Install required dependencies
sudo apt-get install automake autotools-dev bsdmainutils build-essential ccache clang gcc git libboost-dev libboost-filesystem-dev libboost-system-dev libboost-test-dev libevent-dev libminiupnpc-dev libnatpmp-dev libsqlite3-dev libtool libzmq3-dev pkg-config python3 qtbase5-dev qttools5-dev qttools5-dev-tools qtwayland5 systemtap-sdt-dev
</code></pre>
<blockquote>
<p>💡 <strong>What are these packages?</strong> These are the building blocks needed to compile Bitcoin Core. Each one provides essential functionality, from cryptography to networking.</p>
</blockquote>
<h3 id="12--building-bitcoin-core"><a class="header" href="#12--building-bitcoin-core">1.2 🏭 Building Bitcoin Core</a></h3>
<p>Let’s get the source code and build it:</p>
<pre><code class="language-bash"># Clone Bitcoin Core
git clone https://github.com/bitcoin/bitcoin.git
cd bitcoin

# Switch to latest stable version
git checkout v28.0

# Prepare the build system
./autogen.sh

# Configure the build
./configure

# Build Bitcoin Core (this might take a while ☕)
make

# Install the binaries
sudo make install
</code></pre>
<blockquote>
<p>🎯 <strong>Progress Check!</strong> Run <code>bitcoin-cli --version</code> to verify the installation.</p>
</blockquote>
<h3 id="13--bitcoin-core-configuration"><a class="header" href="#13--bitcoin-core-configuration">1.3 ⚙️ Bitcoin Core Configuration</a></h3>
<p>First, let’s create our configuration directory:</p>
<pre><code class="language-bash"># For macOS
mkdir -p ~/Library/'Application Support'/Bitcoin

# For Linux
mkdir -p ~/.bitcoin
</code></pre>
<p>Create your <code>bitcoin.conf</code> file:</p>
<pre><code class="language-bash"># macOS
nano ~/Library/'Application Support'/Bitcoin/bitcoin.conf

# Linux
nano ~/.bitcoin/bitcoin.conf
</code></pre>
<p>Add this configuration:</p>
<pre><code class="language-ini"># 🌐 Network Settings
server=1
regtest=1
txindex=1
prune=0

# 🔒 Security
rpcuser=bitcoin
# Change this in production!
rpcpassword=bitcoinpass  

# 🔧 Performance
dbcache=150
maxmempool=100

# 🚀 Development Settings
fallbackfee=0.001
maxtxfee=0.002

[regtest]
rpcbind=0.0.0.0
rpcport=18443
wallet=testwallet
</code></pre>
<blockquote>
<p>🔐 <strong>Security Note</strong>: In a production environment, always use strong, unique passwords!</p>
</blockquote>
<h3 id="14--launch-bitcoin-core"><a class="header" href="#14--launch-bitcoin-core">1.4 🚀 Launch Bitcoin Core</a></h3>
<pre><code class="language-bash"># Start Bitcoin Core in regtest mode
bitcoind -regtest -daemon
</code></pre>
<h4 id="-fun-experiment-create-some-test-bitcoin"><a class="header" href="#-fun-experiment-create-some-test-bitcoin">🎮 Fun Experiment: Create Some Test Bitcoin!</a></h4>
<pre><code class="language-bash"># create wallet
bitcoin-cli -regtest createwallet "testwallet"

# Generate a new address
ADDR=$(bitcoin-cli -regtest getnewaddress)

# Mine 101 blocks (need 100 for coin maturity)
bitcoin-cli -regtest generatetoaddress 101 $ADDR

# Check your balance
bitcoin-cli -regtest getbalance
</code></pre>
<blockquote>
<p>🎉 You should see 50 BTC! In regtest mode, each block rewards you with 50 BTC.</p>
</blockquote>
<h2 id="2--electrs-setup"><a class="header" href="#2--electrs-setup">2. ⚡ Electrs Setup</a></h2>
<h3 id="21--building-electrs"><a class="header" href="#21--building-electrs">2.1 🔧 Building Electrs</a></h3>
<pre><code class="language-bash"># Clone our fork of Electrs
git clone https://github.com/Arch-Network/electrs
cd electrs

# Build and install
cargo install --path .
</code></pre>
<h3 id="22--running-electrs"><a class="header" href="#22--running-electrs">2.2 🚀 Running Electrs</a></h3>
<p>For local development:</p>
<pre><code class="language-bash">electrs -vvvv \
    --daemon-dir ~/.bitcoin \
    --network regtest \
    --cookie bitcoin:bitcoinpass \
    --main-loop-delay 0 
</code></pre>
<p>You should see output like:</p>
<pre><code>INFO - Electrum RPC server running on 127.0.0.1:50001
INFO - REST server running on 127.0.0.1:3002
</code></pre>
<h2 id="-verification"><a class="header" href="#-verification">🎯 Verification</a></h2>
<p>Let’s make sure everything is working:</p>
<pre><code class="language-bash"># 1. Check Bitcoin Core
bitcoin-cli -regtest getblockchaininfo

# 2. Check Electrs
curl http://localhost:3002/blocks/tip/height
</code></pre>
<h2 id="3--testnet4-configuration"><a class="header" href="#3--testnet4-configuration">3. 🌐 Testnet4 Configuration</a></h2>
<p>Want to test your dApp in a more realistic environment? Let’s set up testnet4!</p>
<h3 id="31-bitcoin-core-for-testnet4"><a class="header" href="#31-bitcoin-core-for-testnet4">3.1 Bitcoin Core for Testnet4</a></h3>
<p>Update your <code>bitcoin.conf</code> to include testnet4 settings:</p>
<pre><code class="language-ini"># Core Settings [Keep your existing settings]

# Testnet4 Configuration
[testnet4]
rpcbind=0.0.0.0           # Bind to all network interfaces
rpcport=18332             # RPC port for testnet
wallet=testwallet         # Default wallet name for testnet
</code></pre>
<h3 id="32-electrs-for-testnet4"><a class="header" href="#32-electrs-for-testnet4">3.2 Electrs for Testnet4</a></h3>
<p>For connecting to testnet4, use this configuration:</p>
<pre><code class="language-bash"># Run Electrs with testnet4 configuration
electrs -vvvv \
    --network testnet4 \
    --daemon-rpc-addr &lt;BITCOIN_NODE_ENDPOINT&gt;:&lt;PORT&gt; \
    --cookie "&lt;BITCOIN_RPC_USER&gt;:&lt;BITCOIN_RPC_PASSWORD&gt;" \
    --db-dir ./db \
    --main-loop-delay 0 \
    --lightmode \
    --jsonrpc-import \
    --electrum-rpc-addr="127.0.0.1:40001" \
    --http-addr="127.0.0.1:3004"
</code></pre>
<p>You should see output like:</p>
<pre><code class="language-bash">INFO - Electrum RPC server running on 127.0.0.1:40001
INFO - REST server running on 127.0.0.1:3004
</code></pre>
<h3 id="33-local-validator-with-testnet4"><a class="header" href="#33-local-validator-with-testnet4">3.3 Local Validator with Testnet4</a></h3>
<p>Start your local validator with testnet4 configuration:</p>
<pre><code class="language-bash">cli validator start \
    --network-mode testnet4 \
    --bitcoin-rpc-endpoint &lt;BITCOIN_NODE_ENDPOINT&gt; \
    --bitcoin-rpc-port &lt;PORT&gt; \
    --bitcoin-rpc-username &lt;BITCOIN_RPC_USER&gt; \
    --bitcoin-rpc-password &lt;BITCOIN_RPC_PASSWORD&gt;
</code></pre>
<h2 id="4--docker-configuration-alternative"><a class="header" href="#4--docker-configuration-alternative">4. 🐳 Docker Configuration (Alternative)</a></h2>
<p>If you prefer using Docker for a more isolated setup:</p>
<pre><code class="language-bash"># Pull the Bitcoin Core image
docker pull ruimarinho/bitcoin-core:latest

# Run Bitcoin Core in a container
docker run -d --name bitcoin-core \
    -p 18443:18443 \
    -e BITCOIN_RPC_USER=bitcoin \
    -e BITCOIN_RPC_PASSWORD=bitcoinpass \
    ruimarinho/bitcoin-core:latest \
    -regtest=1 \
    -txindex=1 \
    -rpcbind=0.0.0.0 \
    -rpcallowip=0.0.0.0/0 \
    -rpcuser=bitcoin \
    -rpcpassword=bitcoinpass
</code></pre>
<h2 id="5--next-steps"><a class="header" href="#5--next-steps">5. 🚀 Next Steps</a></h2>
<p>Now that you have Bitcoin Core and Electrs running, you can:</p>
<ol>
<li><a href="getting-started/./setting-up-a-project.html">Set up your first Arch Network project</a></li>
<li><a href="getting-started/../concepts/architecture.html">Explore the Arch Network architecture</a></li>
<li><a href="getting-started/../guides/how-to-write-arch-program.html">Learn how to write your first Arch program</a></li>
</ol>
<h2 id="-troubleshooting"><a class="header" href="#-troubleshooting">🆘 Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<h4 id="connection-refused-errors"><a class="header" href="#connection-refused-errors">“Connection refused” errors</a></h4>
<p>Make sure your Bitcoin Core is running. Check with:</p>
<pre><code class="language-bash">bitcoin-cli -regtest getblockchaininfo
</code></pre>
<h4 id="electrs-cant-connect-to-bitcoin-core"><a class="header" href="#electrs-cant-connect-to-bitcoin-core">Electrs can’t connect to Bitcoin Core</a></h4>
<p>Double-check the cookie and network settings:</p>
<pre><code class="language-bash"># Verify RPC connection
curl --user bitcoin:bitcoinpass -d '{"jsonrpc":"1.0","method":"getblockchaininfo","params":[]}' -H 'content-type:text/plain;' http://127.0.0.1:18443/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-an-arch-network-project"><a class="header" href="#setting-up-an-arch-network-project">Setting up an Arch Network Project</a></h1>
<p>This guide walks you through creating your first Arch Network project. You’ll learn how to set up, build, and deploy a “Hello World” program to the Arch Network using the Arch Network CLI tool.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting, ensure you have the following dependencies installed:</p>
<ul>
<li>Arch Network CLI (Latest)</li>
<li>Solana CLI (Latest stable version)</li>
<li>Cargo (v1.81.0 or later)</li>
<li>Rust (Latest stable version)</li>
<li>Bitcoin Core and Electrs: Required for local validation</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<h3 id="1-clone-the-example-repository"><a class="header" href="#1-clone-the-example-repository">1. Clone the Example Repository</a></h3>
<p>Start by cloning the Arch Network examples repository:</p>
<pre><code class="language-bash"># Clone the examples repository
git clone https://github.com/Arch-Network/arch-examples.git

# Navigate to the Hello World example
cd arch-examples/examples/helloworld
</code></pre>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<p>After cloning, you’ll see the following project structure:</p>
<p>The helloworld folder should look like this:</p>
<pre><code class="language-ignore">
helloworld/
├── Cargo.toml              # Workspace configuration
├── program/                # Program directory containing on-chain code
│   ├── Cargo.lock
│   ├── Cargo.toml         # Program dependencies
│   └── src/
│       └── lib.rs         # Program logic
└── src/                   # Client-side code
    └── lib.rs             # Client interface
</code></pre>
<h3 id="2-build-the-program"><a class="header" href="#2-build-the-program">2. Build the program</a></h3>
<p>Build the program using the Solana BPF compiler:</p>
<pre><code class="language-bash"># Navigate to the program directory
cd program

# Build the program using Solana's BPF compiler
cargo build-sbf
</code></pre>
<p>This command compiles your Rust code into a format that can be deployed to the Arch Network.</p>
<h3 id="3-start-the-local-validator"><a class="header" href="#3-start-the-local-validator">3. Start the local validator</a></h3>
<p>Start a local validator for testing:</p>
<pre><code class="language-bash"># Start the Arch Network validator
cli validator start
</code></pre>
<blockquote>
<p>Important: Ensure Bitcoin Core and Electrs are properly configured and running before starting the validator. See the setup guide for details.</p>
</blockquote>
<h3 id="4-deploy-the-program"><a class="header" href="#4-deploy-the-program">4. Deploy the program</a></h3>
<p>Deploy your compiled program to the local Arch Network:</p>
<pre><code class="language-bash"># Deploy the program
cli deploy ./target/deploy/
</code></pre>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<p>Common issues and solutions:</p>
<ul>
<li>
<p>If cargo build-sbf fails:</p>
<ul>
<li>Ensure you have the latest version of Rust and Cargo</li>
<li>Check that all dependencies are properly installed</li>
</ul>
</li>
<li>
<p>If validator fails to start:</p>
<ul>
<li>Verify Bitcoin Core and Electrs are running</li>
<li>Check the logs for specific error messages</li>
</ul>
</li>
</ul>
<h2 id="additional-cli-commands"><a class="header" href="#additional-cli-commands">Additional CLI Commands</a></h2>
<p>For more advanced operations, the Arch Network CLI provides additional commands:</p>
<pre><code class="language-bash"># Show program information
cli show &lt;PROGRAM_ADDRESS&gt;

# Confirm transaction status
cli confirm &lt;TX_ID&gt;

# Get block information
cli get-block &lt;BLOCK_HASH&gt;

# Get block height
cli get-block-height
</code></pre>
<p>For a complete list of available commands, refer to the <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network CLI documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Let’s introduce the nodes that comprise the Arch Network stack in greater detail.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Bootnode</a></p>
<p>The bootnode works similarly to DNS seeds in Bitcoin whereby the server handles the first connection to nodes joining the Arch Network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Leader</a></p>
<p>All signing is coordinated by the leader. Ultimately, the leader submits signed Bitcoin transactions to the Bitcoin network following program execution.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Validator</a></p>
<p>This node represents a generic node operated by another party. It performs the validator role and has a share in the network’s distributed signing key. The leader node passes transactions to validator nodes to validate and sign. After enough signatures have been collected (a threshold has been met), the leader can then submit a fully signed Bitcoin transaction to the Bitcoin network.</p>
<p>The validator node also runs the <a href="https://ebpf.io/">eBPF</a> virtual machine and executes the transactions asynchronously alongside the other validator nodes in the network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a></p>
<p>This validator is a lightweight server that only serves as an RPC for developers to get up and running quickly with the least amount of overhead. It simulates a single-node blockchain environment that is meant for efficient, rapid development.</p>
<blockquote>
<p>Note: the <a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a> node uses the same image as the <a href="https://github.com/Arch-Network/arch-node">Validator</a> node though operates singularly for maximum efficiency. You can start a lightweight validator using the <code>cli validator start</code> command.</p>
</blockquote>
<p>More can be read about the Arch Network architecture in our <a href="https://docs.arch.network">docs</a>.</p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h3 id="bitcoin-mempool-and-blockchain-explorer"><a class="header" href="#bitcoin-mempool-and-blockchain-explorer">Bitcoin mempool and blockchain explorer</a></h3>
<ul>
<li><a href="https://mempool.dev.aws.archnetwork.xyz">mempool.space - Arch Regtest</a>
<ul>
<li>Bitcoin mempool and block explorer. This <a href="https://mempool.space">mempool.space</a> instance monitors the regtest Bitcoin blockchain being used to run and validate all examples in this repo.</li>
</ul>
</li>
<li><a href="https://docs.solanalabs.com/cli/install">Solana CLI</a></li>
<li><a href="https://solana.com/developers/guides/getstarted/setup-local-development">Solana Local Development Guide</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<pre class="mermaid">graph TB
    subgraph &quot;Arch Network&quot;
        VM[Arch VM&lt;br/&gt;eBPF-based]
        BTC[Bitcoin Integration]
        
        subgraph &quot;Validator Network&quot;
            L[Leader Node]
            V1[Validator Node 1]
            V2[Validator Node 2]
            V3[Validator Node ...]
            B[Bootnode]
        end
        
        VM --&gt; BTC
        L --&gt; V1
        L --&gt; V2
        L --&gt; V3
        B --&gt; V1
        B --&gt; V2
        B --&gt; V3
    end
</pre>
<h3 id="arch-vm"><a class="header" href="#arch-vm">Arch VM</a></h3>
<p>The Arch Virtual Machine (VM) is built on eBPF technology, providing a secure and efficient environment for executing programs.</p>
<p>Key features:</p>
<ul>
<li>🔄 Manages program execution</li>
<li>⚡ Handles state transitions</li>
<li>🎯 Ensures deterministic computation</li>
<li>🔗 Provides syscalls for Bitcoin UTXO operations</li>
</ul>
<h3 id="bitcoin-integration"><a class="header" href="#bitcoin-integration">Bitcoin Integration</a></h3>
<p>Arch Network interacts directly with Bitcoin through:</p>
<ul>
<li>💼 Native UTXO management</li>
<li>✅ Transaction validation</li>
<li>🔐 Multi-signature coordination</li>
<li>📝 State commitment to Bitcoin</li>
</ul>
<h3 id="validator-network"><a class="header" href="#validator-network">Validator Network</a></h3>
<p>The validator network consists of multiple node types that work together:</p>
<h4 id="node-types"><a class="header" href="#node-types">Node Types</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Node Type</th><th>Primary Responsibilities</th></tr></thead><tbody>
<tr><td><strong>Leader Node</strong></td><td>• Coordinates transaction signing<br/>• Submits signed transactions to Bitcoin<br/>• Manages validator communication</td></tr>
<tr><td><strong>Validator Nodes</strong></td><td>• Execute programs in the Arch VM<br/>• Validate transactions<br/>• Participate in multi-signature operations<br/>• Maintain network state</td></tr>
<tr><td><strong>Bootnode</strong></td><td>• Handles initial network discovery<br/>• Similar to Bitcoin DNS seeds<br/>• Helps new nodes join the network</td></tr>
</tbody></table>
</div>
<h2 id="transaction-flow"><a class="header" href="#transaction-flow">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant V as Validators
    participant B as Bitcoin Network
    
    C-&gt;&gt;L: 1. Submit Transaction
    L-&gt;&gt;V: 2. Distribute to Validators
    V-&gt;&gt;V: 3. Execute in Arch VM
    V-&gt;&gt;L: 4. Sign Results
    L-&gt;&gt;B: 5. Submit to Bitcoin
</pre>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<p>Arch Network implements a robust multi-layered security model that directly leverages Bitcoin’s security guarantees:</p>
<h3 id="1-utxo-security"><a class="header" href="#1-utxo-security">1. UTXO Security</a></h3>
<ul>
<li>
<p>🔒 <strong>Ownership Verification</strong></p>
<ul>
<li>Public key cryptography using secp256k1</li>
<li>BIP322 message signing for secure ownership proofs</li>
<li>Double-spend prevention through UTXO consumption tracking</li>
</ul>
</li>
<li>
<p>🔗 <strong>State Management</strong></p>
<ul>
<li>State anchoring to Bitcoin transactions</li>
<li>Atomic state transitions with rollback capability</li>
<li>Cross-validator state consistency checks</li>
</ul>
</li>
</ul>
<h3 id="2-transaction-security"><a class="header" href="#2-transaction-security">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">pub struct SecurityParams {
    pub min_confirmations: u32,    // Required Bitcoin confirmations
    pub signature_threshold: u32,   // Multi-sig threshold
    pub timelock_blocks: u32,      // Timelock requirement
    pub max_witness_size: usize    // Maximum witness data size
}</code></pre>
<ul>
<li>📝 <strong>Multi-signature Validation</strong>
<ul>
<li>ROAST protocol for distributed signing</li>
<li>Threshold signature scheme (t-of-n)</li>
<li>Malicious signer detection and removal</li>
<li>Binding factor verification for signature shares</li>
</ul>
</li>
</ul>
<h3 id="3-network-security"><a class="header" href="#3-network-security">3. Network Security</a></h3>
<ul>
<li>
<p>🌐 <strong>Validator Selection</strong></p>
<pre><code class="language-rust ignore">pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32
}</code></pre>
<ul>
<li>Stake-weighted validator participation</li>
<li>Dynamic threshold adjustment</li>
<li>Automatic malicious node detection</li>
</ul>
</li>
<li>
<p>🛡️ <strong>State Protection</strong></p>
<ul>
<li>Multi-stage transaction verification</li>
<li>Bitcoin-based finality guarantees</li>
<li>State root commitment to Bitcoin</li>
<li>Mandatory signature verification for all state changes</li>
</ul>
</li>
</ul>
<h3 id="4-best-practices"><a class="header" href="#4-best-practices">4. Best Practices</a></h3>
<ul>
<li>
<p>✅ <strong>UTXO Management</strong></p>
<ul>
<li>Minimum 6 confirmations for finality</li>
<li>Comprehensive UTXO validation</li>
<li>Double-spend monitoring</li>
<li>Reorg handling for UTXO invalidation</li>
</ul>
</li>
<li>
<p>🔍 <strong>Transaction Processing</strong></p>
<ul>
<li>Full signature verification</li>
<li>Input/output validation</li>
<li>Proper error handling</li>
<li>Network partition handling</li>
</ul>
</li>
</ul>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-architecture"><a class="header" href="#network-architecture">Network Architecture</a></h1>
<p>Arch Network operates as a distributed system with different types of nodes working together to provide secure and efficient program execution on Bitcoin. This document details the network’s architecture and how different components interact.</p>
<h2 id="network-overview"><a class="header" href="#network-overview">Network Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph Core[&quot;Core Components&quot;]
        direction TB
        BN[Bitcoin Network]
        Boot[Bootnode]
    end

    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[MultiSig\nAggregation]
    end
    
    subgraph Validators[&quot;Validator Network&quot;]
        direction TB
        V1[Validator 1]
        V2[Validator 2]
        V3[Validator 3]
        VN[Validator N]
    end

    BN --&gt; LN[Leader Node]
    Boot --&gt; LN
    
    LN --&gt; TC
    LN --&gt; MS
    
    LN --&gt; V1
    LN --&gt; V2
    LN --&gt; V3
    LN --&gt; VN

    %% Styling
    classDef core fill:#e1f5fe,stroke:#01579b
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validators fill:#f3e5f5,stroke:#4a148c
    
    class BN,Boot core
    class TC,MS leader
    class V1,V2,V3,VN validators
</pre>
<h2 id="node-types-1"><a class="header" href="#node-types-1">Node Types</a></h2>
<h3 id="1-bootnode"><a class="header" href="#1-bootnode">1. Bootnode</a></h3>
<p>The bootnode serves as the network’s entry point, similar to DNS seeds in Bitcoin:</p>
<ul>
<li>Handles initial network discovery</li>
<li>Maintains whitelist of valid validators</li>
<li>Coordinates peer connections</li>
<li>Manages network topology</li>
</ul>
<pre class="mermaid">flowchart LR
    subgraph Bootnode[&quot;Bootnode Services&quot;]
        direction TB
        PR[Peer Registry]
        WL[Validator Whitelist]
    end

    NN[New Node]
    VN[Validator Network]

    %% Connections
    NN &lt;--&gt; PR
    PR &lt;--&gt; VN
    WL -.-&gt; PR

    %% Styling
    classDef bootnode fill:#e1f5fe,stroke:#01579b
    classDef external fill:#f5f5f5,stroke:#333
    classDef connection stroke-width:2px
    
    class PR,WL bootnode
    class NN,VN external
</pre>
<p>Configuration:</p>
<pre><code class="language-bash">cargo run -p bootnode -- \
    --network-mode localnet \
    --p2p-bind-port 19001 \
    --leader-peer-id "&lt;LEADER_ID&gt;" \
    --validator-whitelist "&lt;VALIDATOR_IDS&gt;"
</code></pre>
<h3 id="2-leader-node"><a class="header" href="#2-leader-node">2. Leader Node</a></h3>
<p>The leader node coordinates transaction processing and Bitcoin integration:</p>
<pre class="mermaid">flowchart TB
    %% Main Components
    BN[Bitcoin Network]
    LN[Leader Node]
    VN[Validator Network]
    PE[Program Execution]
    
    %% Leader Node Services
    subgraph Leader[&quot;Leader Node Services&quot;]
        direction LR
        TC[Transaction\nCoordination]
        MS[Multi-sig\nAggregation]
    end
    
    %% Connections
    BN &lt;--&gt; LN
    LN --&gt; Leader
    TC --&gt; VN
    MS --&gt; VN
    VN --&gt; PE
    
    %% Styling
    classDef bitcoin fill:#f7931a,stroke:#c16c07,color:white
    classDef leader fill:#fff3e0,stroke:#e65100
    classDef validator fill:#f3e5f5,stroke:#4a148c
    classDef execution fill:#e8f5e9,stroke:#1b5e20
    
    class BN bitcoin
    class LN,TC,MS leader
    class VN validator
    class PE execution
</pre>
<p>Key responsibilities:</p>
<ul>
<li>Transaction coordination</li>
<li>Multi-signature aggregation</li>
<li>Bitcoin transaction submission</li>
<li>Network state management</li>
</ul>
<h3 id="3-validator-nodes"><a class="header" href="#3-validator-nodes">3. Validator Nodes</a></h3>
<p>Validator nodes form the core of the network’s computation and validation:</p>
<pre class="mermaid">flowchart TB
    subgraph ValidatorNode[&quot;Validator Node&quot;]
        direction TB
        
        subgraph Execution[&quot;Execution Layer&quot;]
            direction LR
            VM[&quot;Arch VM\nExecution&quot;]
            SV[&quot;State\nValidation&quot;]
        end
        
        NP[&quot;Network Protocol&quot;]
        P2P[&quot;P2P Network&quot;]
        
        %% Connections within validator
        VM --&gt; NP
        SV --&gt; NP
        NP --&gt; P2P
    end
    
    %% Styling
    classDef validator fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef execution fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
    classDef network fill:#e3f2fd,stroke:#0d47a1,stroke-width:2px
    
    class ValidatorNode validator
    class VM,SV execution
    class NP,P2P network
</pre>
<p>Types:</p>
<ol>
<li>
<p><strong>Full Validator</strong></p>
<ul>
<li>Participates in consensus</li>
<li>Executes programs</li>
<li>Maintains full state</li>
</ul>
</li>
<li>
<p><strong>Lightweight Validator</strong></p>
<ul>
<li>Local development use</li>
<li>Single-node operation</li>
<li>Simulated environment</li>
</ul>
</li>
</ol>
<h2 id="network-communication"><a class="header" href="#network-communication">Network Communication</a></h2>
<h3 id="p2p-protocol"><a class="header" href="#p2p-protocol">P2P Protocol</a></h3>
<p>The network uses libp2p for peer-to-peer communication:</p>
<pre><code class="language-rust ignore">pub const ENABLED_PROTOCOLS: [&amp;str; 2] = [
    ArchNetworkProtocol::STREAM_PROTOCOL,
    ArchNetworkProtocol::VALIDATOR_PROTOCOL,
];

// Protocol versions
pub const PROTOCOL_VERSION: &amp;str = "/arch/1.0.0";
pub const VALIDATOR_VERSION: &amp;str = "/arch/validator/1.0.0";</code></pre>
<h3 id="message-types"><a class="header" href="#message-types">Message Types</a></h3>
<ol>
<li>
<p><strong>Network Messages</strong></p>
<pre><code class="language-rust ignore">pub enum NetworkMessage {
    Discovery(DiscoveryMessage),
    State(StateMessage),
    Transaction(TransactionMessage),
}</code></pre>
</li>
<li>
<p><strong>ROAST Protocol Messages</strong></p>
<pre><code class="language-rust ignore">pub enum RoastMessage {
    KeyGeneration(KeyGenMessage),
    Signing(SigningMessage),
    Aggregation(AggregationMessage),
}</code></pre>
</li>
</ol>
<h2 id="network-modes"><a class="header" href="#network-modes">Network Modes</a></h2>
<h3 id="1-devnet"><a class="header" href="#1-devnet">1. Devnet</a></h3>
<ul>
<li>Local development environment</li>
<li>Single validator setup</li>
<li>Simulated Bitcoin interactions</li>
<li>Fast block confirmation</li>
</ul>
<h3 id="2-testnet"><a class="header" href="#2-testnet">2. Testnet</a></h3>
<ul>
<li>Test environment with multiple validators</li>
<li>Bitcoin testnet integration</li>
<li>Real network conditions</li>
<li>Test transaction processing</li>
</ul>
<h3 id="3-mainnet"><a class="header" href="#3-mainnet">3. Mainnet</a></h3>
<ul>
<li>Production network</li>
<li>Full security model</li>
<li>Bitcoin mainnet integration</li>
<li>Live transaction processing</li>
</ul>
<h2 id="security-model-1"><a class="header" href="#security-model-1">Security Model</a></h2>
<h3 id="1-validator-selection"><a class="header" href="#1-validator-selection">1. Validator Selection</a></h3>
<pre><code class="language-rust ignore">pub struct ValidatorInfo {
    pub peer_id: PeerId,
    pub pubkey: Pubkey,
    pub stake: u64,
}

pub struct ValidatorSet {
    pub validators: Vec&lt;ValidatorInfo&gt;,
    pub threshold: u32,
}</code></pre>
<h3 id="2-transaction-security-1"><a class="header" href="#2-transaction-security-1">2. Transaction Security</a></h3>
<ul>
<li>Multi-signature validation using ROAST protocol</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Double-spend prevention</li>
</ul>
<h3 id="3-state-protection"><a class="header" href="#3-state-protection">3. State Protection</a></h3>
<pre><code class="language-rust ignore">pub struct StateUpdate {
    pub block_height: u64,
    pub state_root: Hash,
    pub bitcoin_height: u64,
    pub signatures: Vec&lt;Signature&gt;,
}</code></pre>
<h2 id="monitoring-and-telemetry"><a class="header" href="#monitoring-and-telemetry">Monitoring and Telemetry</a></h2>
<h3 id="1-node-metrics"><a class="header" href="#1-node-metrics">1. Node Metrics</a></h3>
<pre><code class="language-rust ignore">pub struct NodeMetrics {
    pub peer_id: PeerId,
    pub network_mode: ArchNetworkMode,
    pub bitcoin_block_height: u64,
    pub arch_block_height: u64,
    pub peers_connected: u32,
    pub transactions_processed: u64,
    pub program_count: u32,
}</code></pre>
<h3 id="2-network-health"><a class="header" href="#2-network-health">2. Network Health</a></h3>
<pre><code class="language-rust ignore">pub struct NetworkHealth {
    pub validator_count: u32,
    pub active_validators: u32,
    pub network_tps: f64,
    pub average_block_time: Duration,
    pub fork_count: u32,
}</code></pre>
<h3 id="3-monitoring-endpoints"><a class="header" href="#3-monitoring-endpoints">3. Monitoring Endpoints</a></h3>
<ul>
<li><code>/metrics</code> - Prometheus metrics</li>
<li><code>/health</code> - Node health check</li>
<li><code>/peers</code> - Connected peers</li>
<li><code>/status</code> - Network status</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-node-operation"><a class="header" href="#1-node-operation">1. Node Operation</a></h3>
<ul>
<li>Secure key management</li>
<li>Regular state verification</li>
<li>Proper shutdown procedures</li>
<li>Log management</li>
</ul>
<h3 id="2-network-participation"><a class="header" href="#2-network-participation">2. Network Participation</a></h3>
<ul>
<li>Maintain node availability</li>
<li>Monitor Bitcoin integration</li>
<li>Handle network upgrades</li>
<li>Backup critical data</li>
</ul>
<h3 id="3-development-setup"><a class="header" href="#3-development-setup">3. Development Setup</a></h3>
<ul>
<li>Use lightweight validator for testing</li>
<li>Monitor resource usage</li>
<li>Handle network modes properly</li>
<li>Implement proper error handling</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-integration-1"><a class="header" href="#bitcoin-integration-1">Bitcoin Integration</a></h1>
<p>Arch Network provides direct integration with Bitcoin, enabling programs to interact with Bitcoin’s UTXO model while maintaining Bitcoin’s security guarantees. This document details how Arch Network integrates with Bitcoin.</p>
<h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<pre class="mermaid">flowchart TB
    subgraph BN[Bitcoin Network]
        BNode[Bitcoin Node]
    end

    subgraph EC[Electrs Client]
        ECNode[Electrs Client]
    end

    subgraph AN[Arch Network]
        LN[Leader Node\nBitcoin Integration]
        subgraph VN[Validator Network]
            P1[Program 1]
            PN[Program N]
        end
    end

    BNode &lt;--&gt; ECNode
    ECNode &lt;--&gt; LN
    LN &lt;--&gt; VN
    P1 --- PN
</pre>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<h3 id="1-utxo-management"><a class="header" href="#1-utxo-management">1. UTXO Management</a></h3>
<p>Arch Network manages Bitcoin UTXOs through a specialized system:</p>
<pre class="mermaid">flowchart LR
    subgraph UTXO[Bitcoin UTXO]
        TxID[TransactionID]
        OutIdx[OutputIndex]
    end

    subgraph Account[Arch Account]
        Meta[UTXOMeta]
        State[ProgramState]
    end

    TxID --&gt; Meta
    OutIdx --&gt; Meta
    Meta --- State
</pre>
<pre><code class="language-rust ignore">// UTXO Metadata Structure
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Transaction ID
    pub vout: u32,       // Output index
    pub amount: u64,     // Amount in satoshis
    pub script_pubkey: Vec&lt;u8&gt;, // Output script
    pub confirmation_height: Option&lt;u32&gt;, // Block height of confirmation
}

// UTXO Account State
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: Vec&lt;u8&gt;,
    pub is_frozen: bool,
}</code></pre>
<p>Key operations:</p>
<pre><code class="language-rust ignore">// UTXO Operations
pub trait UtxoOperations {
    fn create_utxo(meta: UtxoMeta, owner: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn spend_utxo(utxo: &amp;UtxoMeta, signature: &amp;Signature) -&gt; Result&lt;()&gt;;
    fn freeze_utxo(utxo: &amp;UtxoMeta, authority: &amp;Pubkey) -&gt; Result&lt;()&gt;;
    fn delegate_utxo(utxo: &amp;UtxoMeta, delegate: &amp;Pubkey) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="2-bitcoin-rpc-integration"><a class="header" href="#2-bitcoin-rpc-integration">2. Bitcoin RPC Integration</a></h3>
<pre class="mermaid">flowchart LR
    AP[Arch\nProgram]
    RPC[Bitcoin RPC\nInterface]
    BN[Bitcoin\nNode]
    Config[Configuration]
    Network[Bitcoin\nNetwork]

    AP --&gt; RPC
    RPC --&gt; BN
    AP --&gt; Config
    Config --&gt; RPC
    BN --&gt; Network

    style AP fill:#f9f9f9,stroke:#333,stroke-width:2px
    style RPC fill:#f9f9f9,stroke:#333,stroke-width:2px
    style BN fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Config fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Network fill:#f9f9f9,stroke:#333,stroke-width:2px
</pre>
<p>Programs can interact with Bitcoin through RPC calls:</p>
<pre><code class="language-rust ignore">// Bitcoin RPC Configuration
pub struct BitcoinRpcConfig {
    pub endpoint: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub wallet: Option&lt;String&gt;,
    pub network: BitcoinNetwork,
    pub timeout: Duration,
}

// RPC Interface
pub trait BitcoinRpc {
    fn get_block_count(&amp;self) -&gt; Result&lt;u64&gt;;
    fn get_block_hash(&amp;self, height: u64) -&gt; Result&lt;BlockHash&gt;;
    fn get_transaction(&amp;self, txid: &amp;Txid) -&gt; Result&lt;Transaction&gt;;
    fn send_raw_transaction(&amp;self, tx: &amp;[u8]) -&gt; Result&lt;Txid&gt;;
    fn verify_utxo(&amp;self, utxo: &amp;UtxoMeta) -&gt; Result&lt;bool&gt;;
}</code></pre>
<h2 id="transaction-flow-1"><a class="header" href="#transaction-flow-1">Transaction Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Program
    participant Leader
    participant Validator
    participant Bitcoin

    Program-&gt;&gt;Leader: Create UTXO
    Leader-&gt;&gt;Validator: Validate
    Validator-&gt;&gt;Leader: Sign
    Leader-&gt;&gt;Bitcoin: Submit TX
    Bitcoin--&gt;&gt;Program: Confirmation
</pre>
<h3 id="1-transaction-creation"><a class="header" href="#1-transaction-creation">1. Transaction Creation</a></h3>
<pre><code class="language-rust ignore">// Create new UTXO transaction
pub struct UtxoCreation {
    pub amount: u64,
    pub owner: Pubkey,
    pub metadata: Option&lt;Vec&lt;u8&gt;&gt;,
}

impl UtxoCreation {
    pub fn new(amount: u64, owner: Pubkey) -&gt; Self {
        Self {
            amount,
            owner,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, metadata: Vec&lt;u8&gt;) -&gt; Self {
        self.metadata = Some(metadata);
        self
    }
}</code></pre>
<h3 id="2-transaction-validation"><a class="header" href="#2-transaction-validation">2. Transaction Validation</a></h3>
<pre><code class="language-rust ignore">// Validation rules
pub trait TransactionValidation {
    fn validate_inputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_outputs(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_signatures(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
    fn validate_script(&amp;self, tx: &amp;Transaction) -&gt; Result&lt;()&gt;;
}</code></pre>
<h3 id="3-state-management"><a class="header" href="#3-state-management">3. State Management</a></h3>
<pre><code class="language-rust ignore">// State transition
pub struct StateTransition {
    pub previous_state: Hash,
    pub next_state: Hash,
    pub utxos_created: Vec&lt;UtxoMeta&gt;,
    pub utxos_spent: Vec&lt;UtxoMeta&gt;,
    pub bitcoin_height: u64,
}</code></pre>
<h2 id="security-model-2"><a class="header" href="#security-model-2">Security Model</a></h2>
<h3 id="1-utxo-security-1"><a class="header" href="#1-utxo-security-1">1. UTXO Security</a></h3>
<ul>
<li>Ownership verification through public key cryptography</li>
<li>Double-spend prevention through UTXO consumption</li>
<li>State anchoring to Bitcoin transactions</li>
<li>Threshold signature requirements</li>
</ul>
<h3 id="2-transaction-security-2"><a class="header" href="#2-transaction-security-2">2. Transaction Security</a></h3>
<pre><code class="language-rust ignore">// Transaction security parameters
pub struct SecurityParams {
    pub min_confirmations: u32,
    pub signature_threshold: u32,
    pub timelock_blocks: u32,
    pub max_witness_size: usize,
}</code></pre>
<h3 id="3-network-security-1"><a class="header" href="#3-network-security-1">3. Network Security</a></h3>
<ul>
<li>Multi-signature validation</li>
<li>Threshold signing (t-of-n)</li>
<li>Bitcoin-based finality</li>
<li>Cross-validator consistency</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="1-bitcoin-errors"><a class="header" href="#1-bitcoin-errors">1. Bitcoin Errors</a></h3>
<pre><code class="language-rust ignore">pub enum BitcoinError {
    ConnectionFailed(String),
    InvalidTransaction(String),
    InsufficientFunds(u64),
    InvalidUtxo(UtxoMeta),
    RpcError(String),
}</code></pre>
<h3 id="2-utxo-errors"><a class="header" href="#2-utxo-errors">2. UTXO Errors</a></h3>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound(UtxoMeta),
    AlreadySpent(UtxoMeta),
    InvalidOwner(Pubkey),
    InvalidSignature(Signature),
    InvalidState(Hash),
}</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-utxo-management-1"><a class="header" href="#1-utxo-management-1">1. UTXO Management</a></h3>
<ul>
<li>Always verify UTXO ownership</li>
<li>Wait for sufficient confirmations</li>
<li>Handle reorganizations gracefully</li>
<li>Implement proper error handling</li>
</ul>
<h3 id="2-transaction-processing"><a class="header" href="#2-transaction-processing">2. Transaction Processing</a></h3>
<ul>
<li>Validate all inputs and outputs</li>
<li>Check signature thresholds</li>
<li>Maintain proper state transitions</li>
<li>Monitor Bitcoin network status</li>
</ul>
<h3 id="3-security-considerations"><a class="header" href="#3-security-considerations">3. Security Considerations</a></h3>
<ul>
<li>Protect private keys</li>
<li>Validate all signatures</li>
<li>Monitor for double-spend attempts</li>
<li>Handle network partitions</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes-1"><a class="header" href="#nodes-1">Nodes</a></h1>
<p>Let’s introduce the nodes that comprise the Arch Network stack in greater detail.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Bootnode</a></p>
<p>The bootnode works similarly to DNS seeds in Bitcoin whereby the server handles the first connection to nodes joining the Arch Network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Leader</a></p>
<p>All signing is coordinated by the leader. Ultimately, the leader submits signed Bitcoin transactions to the Bitcoin network following program execution.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Validator</a></p>
<p>This node represents a generic node operated by another party. It performs the validator role and has a share in the network’s distributed signing key. The leader node passes transactions to validator nodes to validate and sign. After enough signatures have been collected (a threshold has been met), the leader can then submit a fully signed Bitcoin transaction to the Bitcoin network.</p>
<p>The validator node also runs the <a href="https://ebpf.io/">eBPF</a> virtual machine and executes the transactions asynchronously alongside the other validator nodes in the network.</p>
<p><a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a></p>
<p>This validator is a lightweight server that only serves as an RPC for developers to get up and running quickly with the least amount of overhead. It simulates a single-node blockchain environment that is meant for efficient, rapid development.</p>
<blockquote>
<p>Note: the <a href="https://github.com/Arch-Network/arch-node">Lightweight Validator</a> node uses the same image as the <a href="https://github.com/Arch-Network/arch-node">Validator</a> node though operates singularly for maximum efficiency. You can start a lightweight validator using the <code>cli validator start</code> command.</p>
</blockquote>
<p>More can be read about the Arch Network architecture in our <a href="https://docs.arch.network">docs</a>.</p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="program"><a class="header" href="#program">Program</a></h1>
<p>A program is a special kind of <a href="program/./accounts.html">account</a> that contains executable <a href="https://ebpf.io">eBPF</a> bytecode, denoted by the <code>Account.is_executable: true</code> field. This allows an account to receive arbitrary <a href="program/./instructions-and-messages.html#instructions">instruction</a> data via a <a href="program/./transaction.html">transaction</a> to be processed by the runtime.</p>
<p>Every program is stateless, meaning that it can only read/write data to other accounts and that it <strong>cannot</strong> write to its own account; this, in-part, is how parallelized execution is made possible (see <a href="program/program.html#4-state">State</a> for more info).</p>
<blockquote>
<p>💡 Additionally, programs can send instructions to other programs which, in turn, receive instructions and thus extend program composability further. This is known as cross-program invocation (CPI) and will be detailed in future sections.</p>
</blockquote>
<h3 id="components"><a class="header" href="#components">Components:</a></h3>
<h4 id="1-entrypoint"><a class="header" href="#1-entrypoint">1. <a href="program/./entrypoint.html">Entrypoint</a></a></h4>
<p>Every Arch program includes a single entrypoint used to invoke the program. A <a href="program/./entrypoint.html#handler-function">handler function</a>, often named <code>process_instruction</code>, is then used to handle the data passed into the entrypoint.</p>
<p><em>These parameters are required for every <a href="program/./instructions-and-messages.html#instructions">instruction</a> to be processed.</em>_</p>
<pre><code class="language-rust ignore">use arch_program::entrypoint;
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    // Program logic here
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<h4 id="2-instruction"><a class="header" href="#2-instruction">2. <a href="program/./instructions-and-messages.html#instructions">Instruction</a></a></h4>
<p>The <code>instruction_data</code> is deserialized after being passed into the entrypoint. From there, if there are multiple instructions, a <code>match</code> statement can be utilized to point the logic flow to the appropriate handler function previously defined within the program which can continue processing the instruction.</p>
<h4 id="3-process-instruction"><a class="header" href="#3-process-instruction">3. Process Instruction</a></h4>
<p>If a program has multiple instructions, a corresponding <a href="program/./entrypoint.html#handler-function">handler function</a> should be defined to include the specific logic unique to the instruction.</p>
<h4 id="4-state"><a class="header" href="#4-state">4. State</a></h4>
<p>Since programs are stateless, a “data” <a href="program/./accounts.html">account</a> is needed to hold state for a user. This is a non-executable account that holds program data.</p>
<p>If a program receives instruction that results in a user’s state being altered, the program would manage this user’s state via a mapping within the program’s logic. This mapping would link the user’s <a href="program/./pubkey.html">pubkey</a> with a data <a href="program/./accounts.html">account</a> where the state would live for that specific program.</p>
<p>The program will likely include a struct to define the structure of its state and make it easier to work with. The deserialization of account data occurs during program invocation. After an update is made, state data gets re-serialized into a byte array and stored within the <code>data</code> field of the <a href="program/./accounts.html">account</a>.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-unspent-transaction-output"><a class="header" href="#utxo-unspent-transaction-output">UTXO (Unspent Transaction Output)</a></h1>
<p>UTXOs (Unspent Transaction Outputs) are fundamental to Bitcoin’s transaction model and serve as the foundation for state management in Arch Network. Unlike account-based systems that track balances, UTXOs represent discrete “coins” that must be consumed entirely in transactions.</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="what-is-a-utxo"><a class="header" href="#what-is-a-utxo">What is a UTXO?</a></h3>
<ul>
<li>A UTXO represents an unspent output from a previous transaction</li>
<li>Each UTXO is uniquely identified by a transaction ID (txid) and output index (vout)</li>
<li>UTXOs are immutable - they can only be created or spent, never modified</li>
<li>Once spent, a UTXO cannot be reused (prevents double-spending)</li>
</ul>
<h3 id="role-in-arch-network"><a class="header" href="#role-in-arch-network">Role in Arch Network</a></h3>
<ul>
<li>UTXOs anchor program state to Bitcoin’s security model</li>
<li>They provide deterministic state transitions</li>
<li>Enable atomic operations across the network</li>
<li>Allow for provable ownership and state validation</li>
</ul>
<h2 id="utxo-structure"><a class="header" href="#utxo-structure">UTXO Structure</a></h2>
<p>The <code>UtxoMeta</code> struct encapsulates the core UTXO identification data:</p>
<pre><code class="language-rust ignore">use arch_program::utxo::UtxoMeta;
use bitcoin::Txid;

#[derive(Debug, Clone, PartialEq)]
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Bitcoin transaction ID (32 bytes)
    pub vout: u32,       // Output index in the transaction
}

impl UtxoMeta {
    /// Creates a new UTXO metadata instance
    pub fn new(txid: [u8; 32], vout: u32) -&gt; Self {
        Self { txid, vout }
    }

    /// Deserializes UTXO metadata from a byte slice
    /// Format: [txid(32 bytes)][vout(4 bytes)]
    pub fn from_slice(data: &amp;[u8]) -&gt; Self {
        let mut txid = [0u8; 32];
        txid.copy_from_slice(&amp;data[0..32]);
        let vout = u32::from_le_bytes([
            data[32], data[33], data[34], data[35]
        ]);
        Self { txid, vout }
    }
}</code></pre>
<h2 id="utxo-lifecycle"><a class="header" href="#utxo-lifecycle">UTXO Lifecycle</a></h2>
<h3 id="1-creation-process"><a class="header" href="#1-creation-process">1. Creation Process</a></h3>
<h4 id="creating-a-utxo-with-bitcoin-rpc"><a class="header" href="#creating-a-utxo-with-bitcoin-rpc">Creating a UTXO with Bitcoin RPC</a></h4>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client as RpcClient, RpcApi};
use bitcoin::{Amount, Address};
use arch_program::pubkey::Pubkey;

// Initialize Bitcoin RPC client
let rpc = RpcClient::new(
    "http://localhost:18443",  // Bitcoin node RPC endpoint
    Auth::UserPass(
        "user".to_string(),
        "pass".to_string()
    )
).expect("Failed to create RPC client");

// Generate a new account address
let account_address = Pubkey::new_unique();
let btc_address = Address::from_pubkey(&amp;account_address);

// Create UTXO by sending Bitcoin
// Parameters explained:
// - address: Destination Bitcoin address
// - amount: Amount in satoshis (3000 sats = 0.00003 BTC)
// - comment: Optional transaction comment
// - replaceable: Whether the tx can be replaced (RBF)
let txid = rpc.send_to_address(
    &amp;btc_address,
    Amount::from_sat(3000),
    Some("Create Arch UTXO"),  // Comment
    None,                      // Comment_to
    Some(true),               // Replaceable
    None,                     // Fee rate
    None,                     // Fee estimate mode
    None                      // Avoid reuse
)?;

// Wait for confirmation (recommended)
rpc.wait_for_confirmation(&amp;txid, 1)?;</code></pre>
<h4 id="creating-an-arch-account-with-utxo"><a class="header" href="#creating-an-arch-account-with-utxo">Creating an Arch Account with UTXO</a></h4>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction::SystemInstruction,
    pubkey::Pubkey,
    transaction::Transaction,
};

// Create new program account backed by UTXO
let account_pubkey = Pubkey::new_unique();
let instruction = SystemInstruction::new_create_account_instruction(
    txid.try_into().unwrap(),
    0,  // vout index
    account_pubkey,
    // Additional parameters like:
    // - space: Amount of space to allocate
    // - owner: Program that owns the account
);

// Build and sign transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[instruction],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer],
    recent_blockhash
);</code></pre>
<h3 id="2-validation--usage"><a class="header" href="#2-validation--usage">2. Validation &amp; Usage</a></h3>
<p>Programs must implement proper UTXO validation:</p>
<pre><code class="language-rust ignore">fn validate_utxo(utxo: &amp;UtxoMeta) -&gt; Result&lt;(), ProgramError&gt; {
    // 1. Verify UTXO exists on Bitcoin
    let btc_tx = rpc.get_transaction(&amp;utxo.txid)?;
    
    // 2. Check confirmation count
    if btc_tx.confirmations &lt; MIN_CONFIRMATIONS {
        return Err(ProgramError::InsufficientConfirmations);
    }
    
    // 3. Verify output index exists
    if utxo.vout as usize &gt;= btc_tx.vout.len() {
        return Err(ProgramError::InvalidVout);
    }
    
    // 4. Verify UTXO is unspent
    if is_spent(utxo) {
        return Err(ProgramError::UtxoAlreadySpent);
    }
    
    Ok(())
}</code></pre>
<h3 id="3-state-management-1"><a class="header" href="#3-state-management-1">3. State Management</a></h3>
<pre><code class="language-rust ignore">// Example UTXO state tracking
#[derive(Debug)]
pub struct UtxoState {
    pub meta: UtxoMeta,
    pub status: UtxoStatus,
    pub owner: Pubkey,
    pub created_at: i64,
    pub spent_at: Option&lt;i64&gt;,
}

#[derive(Debug)]
pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li>
<p><strong>Validation</strong></p>
<ul>
<li>Always verify UTXO existence on Bitcoin</li>
<li>Check for sufficient confirmations (recommended: 6+)</li>
<li>Validate ownership and spending conditions</li>
<li>Handle Bitcoin reorgs that might invalidate UTXOs</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Implement robust UTXO tracking</li>
<li>Handle edge cases (reorgs, conflicting txs)</li>
<li>Consider implementing UTXO caching for performance</li>
<li>Maintain accurate UTXO sets for your program</li>
</ul>
</li>
<li>
<p><strong>Security</strong></p>
<ul>
<li>Never trust client-provided UTXO data without verification</li>
<li>Implement proper access controls</li>
<li>Consider timelock constraints for sensitive operations</li>
<li>Monitor for suspicious UTXO patterns</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Batch UTXO operations when possible</li>
<li>Implement efficient UTXO lookup mechanisms</li>
<li>Consider UTXO consolidation strategies</li>
<li>Cache frequently accessed UTXO data</li>
</ul>
</li>
</ol>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Common UTXO-related errors to handle:</p>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound,                    // UTXO doesn't exist
    AlreadySpent,               // UTXO was already consumed
    InsufficientConfirmations,  // Not enough confirmations
    InvalidOwner,               // Unauthorized attempt to spend
    Reorged,                    // UTXO invalidated by reorg
    InvalidVout,                // Output index doesn't exist
    SerializationError,         // Data serialization failed
}</code></pre>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<ul>
<li><a href="program/account.html">Account Model</a> - How UTXOs relate to Arch accounts</li>
<li><a href="program/program.html">Program State</a> - Using UTXOs for program state</li>
<li><a href="program/../system-program/system-program.html">System Program</a> - Core UTXO operations</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>To illustrate the basic process involved in developing an Arch <a href="basics/../program/program.html">Program</a>, we’re going to walk through how to build, deploy and interact with a simple application.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-deploying-and-interfacing"><a class="header" href="#building-deploying-and-interfacing">Building, deploying and interfacing</a></h1>
<p>Now that all of the dependencies are installed and we have successfully started our <a href="basics/../getting-started/starting-stack.html#choose-a-track">development stack</a>, we can finally discuss program development, including compiling, deploying and interacting with it.</p>
<p>This guide will walk you through a sample program that functions as a graffiti wall, where each message written to the wall contains a timestamp, name, and note.</p>
<p>You can find sample program code in the <a href="https://github.com/Arch-Network/arch-examples">arch-examples repository</a>.</p>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<p>In order to compile the program, we’ll make use of the <code>cargo-build-sbf</code> binary, a tool that comes with the <a href="basics/../getting-started/requirements.html#install-solana-cli">Solana-CLI</a> that installs the toolchain needed to produce Executable and Linkable Format (ELF) files which consist of <a href="https://ebpf.io/">eBPF</a> bytecode.</p>
<p>Navigate to your program directory:</p>
<pre><code class="language-bash">cd your-program-directory
</code></pre>
<p>Build the program:</p>
<pre><code class="language-bash">cargo build-sbf
</code></pre>
<p>You will find the generated shared object file at: <code>./target/deploy/your_program_name.so</code></p>
<p><em>If you are experiencing issues with this step, we recommend returning to review the <a href="basics/../getting-started/requirements.html">requirements</a> page or hopping in our <a href="https://discord.com/channels/1241112027963986001/1270921925991989268">Discord dev-chat</a> channel for support.</em></p>
<h3 id="deploy"><a class="header" href="#deploy">Deploy</a></h3>
<p>In this step, we will be submitting a transaction to store our program’s logic on the Arch Network.</p>
<blockquote>
<p>Note: make sure you have a validator running before deploying the program. If you don’t, run <code>arch-cli validator start</code></p>
</blockquote>
<pre><code class="language-bash">arch-cli deploy target/deploy/your_program_name.so
</code></pre>
<p>Copy the Program ID from the output as you will need this again later.</p>
<p>The Program ID can be thought of as a uniform resource locator (URL) for your deployed program on the Arch Network.</p>
<h3 id="create-an-account"><a class="header" href="#create-an-account">Create an Account</a></h3>
<p>An account is used to store the state for your application.</p>
<p>You’ll need to create an account that your program can control. This can be done using the system program through an RPC call:</p>
<pre><code class="language-bash"># This is a simplified example
# You'll need to construct, sign, and encode a transaction according to the Arch Network protocol
curl -X POST http://localhost:9002 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"sendTransaction",
    "params":[{
      "signature":"your_signature",
      "message":{
        "accountKeys":["your_pubkey", "your_program_id"],
        "instructions":[{
          "programId":"system_program_id",
          "accounts":["your_pubkey", "new_account_pubkey"],
          "data":"encoded_create_account_data"
        }]
      }
    }]
  }'
</code></pre>
<h3 id="create-a-frontend-application"><a class="header" href="#create-a-frontend-application">Create a frontend application</a></h3>
<p>To interact with your program, you’ll need to create a frontend application that can send instructions to your program and display the results.</p>
<p>Here’s a basic example of a React component that interacts with a graffiti wall program:</p>
<pre><code class="language-jsx">import React, { useState, useEffect, useCallback } from 'react';
import { RpcConnection, MessageUtil, PubkeyUtil, Instruction, Message } from '@saturnbtcio/arch-sdk';
import { useWallet } from '../hooks/useWallet';
import * as borsh from 'borsh';

// Environment variables for configuration
const client = new RpcConnection('/api');
const PROGRAM_PUBKEY = import.meta.env.VITE_PROGRAM_PUBKEY;
const WALL_ACCOUNT_PUBKEY = import.meta.env.VITE_WALL_ACCOUNT_PUBKEY;

// Message data structure
interface GraffitiMessage {
  timestamp: number;
  name: string;
  message: string;
}

function GraffitiWall() {
  // State management
  const wallet = useWallet();
  const [error, setError] = useState(null);
  const [isAccountCreated, setIsAccountCreated] = useState(false);
  const [isProgramDeployed, setIsProgramDeployed] = useState(false);
  const [wallData, setWallData] = useState([]);
  
  // Form state
  const [message, setMessage] = useState('');
  const [name, setName] = useState('');
  const [isFormValid, setIsFormValid] = useState(false);
  
  // Convert account pubkey once
  const accountPubkey = PubkeyUtil.fromHex(WALL_ACCOUNT_PUBKEY);
  
  // Check if the program is deployed on the network
  const checkProgramDeployed = useCallback(async () =&gt; {
    try {
      const pubkeyBytes = PubkeyUtil.fromHex(PROGRAM_PUBKEY);
      const accountInfo = await client.readAccountInfo(pubkeyBytes);
      if (accountInfo) {
        setIsProgramDeployed(true);
        setError(null);
      }
    } catch (error) {
      console.error('Error checking program:', error);
      setError('The Arch Graffiti program has not been deployed to the network yet.');
    }
  }, []);

  // Check if the wall account exists
  const checkAccountCreated = useCallback(async () =&gt; {
    try {
      const pubkeyBytes = PubkeyUtil.fromHex(WALL_ACCOUNT_PUBKEY);
      const accountInfo = await client.readAccountInfo(pubkeyBytes);
      if (accountInfo) {
        setIsAccountCreated(true);
        setError(null);
      }
    } catch (error) {
      console.error('Error checking account:', error);
      setIsAccountCreated(false);
      setError('The wall account has not been created yet.');
    }
  }, []);

  // Fetch and parse wall messages
  const fetchWallData = useCallback(async () =&gt; {
    try {
      const accountInfo = await client.readAccountInfo(accountPubkey);
      
      if (!accountInfo || !accountInfo.data) {
        setWallData([]);
        return;
      }

      const data = accountInfo.data;

      // Read header (first 8 bytes)
      const header = {
        message_count: new DataView(data.buffer).getUint32(0, true),
        max_messages: new DataView(data.buffer).getUint32(4, true)
      };

      const messages = [];
      const HEADER_SIZE = 8;
      const MESSAGE_SIZE = 8 + 64 + 64; // timestamp + name + message

      // Read messages
      for (let i = 0; i &lt; header.message_count; i++) {
        const offset = HEADER_SIZE + (i * MESSAGE_SIZE);
        
        // Read timestamp (8 bytes)
        const timestamp = Number(new DataView(data.buffer).getBigInt64(offset, true));
        
        // Read name (64 bytes)
        const nameBytes = data.slice(offset + 8, offset + 8 + 64);
        const name = new TextDecoder().decode(nameBytes.filter(x =&gt; x !== 0));
        
        // Read message (64 bytes)
        const messageBytes = data.slice(offset + 8 + 64, offset + 8 + 64 + 64);
        const message = new TextDecoder().decode(messageBytes.filter(x =&gt; x !== 0));

        messages.push({ timestamp, name, message });
      }

      setWallData(messages);
      setError(null);
    } catch (error) {
      console.error('Error fetching wall data:', error);
      setError('Failed to fetch wall data');
    }
  }, []);

  // Initialize component
  useEffect(() =&gt; {
    checkProgramDeployed();
    checkAccountCreated();
  }, [checkAccountCreated, checkProgramDeployed]);

  // Set up polling for wall data
  useEffect(() =&gt; {
    if (!isAccountCreated) return;

    fetchWallData();
    const interval = setInterval(fetchWallData, 5000);
    return () =&gt; clearInterval(interval);
  }, [isAccountCreated, fetchWallData]);

  // Message handlers
  const handleNameChange = (e) =&gt; {
    setName(e.target.value);
    setIsFormValid(e.target.value.trim() !== '' &amp;&amp; message.trim() !== '');
  };

  const handleMessageChange = (e) =&gt; {
    setMessage(e.target.value);
    setIsFormValid(name.trim() !== '' &amp;&amp; e.target.value.trim() !== '');
  };

  const handleAddToWall = async () =&gt; {
    if (!message.trim() || !name.trim() || !isAccountCreated || !wallet.isConnected) {
      setError("Name and message are required, account must be created, and wallet must be connected.");
      return;
    }

    try {
      const data = serializeGraffitiData(name, message);

      const instruction = {
        program_id: PubkeyUtil.fromHex(PROGRAM_PUBKEY),
        accounts: [
          { 
            pubkey: PubkeyUtil.fromHex(wallet.publicKey), 
            is_signer: true, 
            is_writable: false 
          },
          { 
            pubkey: accountPubkey, 
            is_signer: false, 
            is_writable: true 
          },
        ],
        data: new Uint8Array(data),
      };

      const messageObj = {
        signers: [PubkeyUtil.fromHex(wallet.publicKey)],
        instructions: [instruction],
      };

      const messageHash = MessageUtil.hash(messageObj);
      const signature = await wallet.signMessage(Buffer.from(messageHash).toString('hex'));
      
      const signatureBytes = new Uint8Array(Buffer.from(signature, 'base64')).slice(2);

      await client.sendTransaction({
        version: 0,
        signatures: [signatureBytes],
        message: messageObj,
      });

      // Refresh the wall data
      await fetchWallData();
      
      // Reset form
      setMessage('');
      setName('');
    } catch (error) {
      console.error('Error adding to wall:', error);
      setError(`Failed to add to wall: ${error.message}`);
    }
  };

  const serializeGraffitiData = (name, message) =&gt; {
    // Create fixed-size arrays
    const nameArray = new Uint8Array(64).fill(0);
    const messageArray = new Uint8Array(64).fill(0);
    
    // Convert strings to bytes
    const nameBytes = new TextEncoder().encode(name);
    const messageBytes = new TextEncoder().encode(message);
    
    // Copy bytes into fixed-size arrays (will truncate if too long)
    nameArray.set(nameBytes.slice(0, 64));
    messageArray.set(messageBytes.slice(0, 64));
    
    // Create the params object matching the Rust struct
    const params = {
        name: Array.from(nameArray),
        message: Array.from(messageArray)
    };
    
    // Define the schema for borsh serialization
    const schema = {
        struct: {
            name: { array: { type: 'u8', len: 64 } },
            message: { array: { type: 'u8', len: 64 } }
        }
    };
    
    return Array.from(borsh.serialize(schema, params));
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Graffiti Wall&lt;/h1&gt;
      
      {!wallet.isConnected ? (
        &lt;div&gt;
          &lt;p&gt;Please connect your wallet to interact with the Graffiti Wall&lt;/p&gt;
          &lt;button onClick={() =&gt; wallet.connect()}&gt;Connect Wallet&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;div&gt;
          &lt;p&gt;Connected: {wallet.publicKey}&lt;/p&gt;
          &lt;button onClick={wallet.disconnect}&gt;Disconnect&lt;/button&gt;
        &lt;/div&gt;
      )}
      
      {!isAccountCreated ? (
        &lt;div&gt;
          &lt;h3&gt;Account Setup Required&lt;/h3&gt;
          &lt;p&gt;To participate in the Graffiti Wall, please create an account using the Arch CLI.&lt;/p&gt;
        &lt;/div&gt;
      ) : (
        &lt;div&gt;
          &lt;div&gt;
            &lt;h3&gt;Add to Wall&lt;/h3&gt;
            &lt;input 
              type="text" 
              placeholder="Your name (max 64 bytes)" 
              value={name} 
              onChange={handleNameChange}
              required
            /&gt;
            &lt;textarea 
              placeholder="Your message (max 64 bytes)" 
              value={message} 
              onChange={handleMessageChange}
              required
            /&gt;
            &lt;button 
              onClick={handleAddToWall}
              disabled={!isFormValid}
            &gt;
              Add to the Wall
            &lt;/button&gt;
          &lt;/div&gt;
          
          &lt;div&gt;
            &lt;h3&gt;Wall Messages&lt;/h3&gt;
            &lt;div&gt;
              {[...wallData].reverse().map((item, index) =&gt; (
                &lt;div key={index}&gt;
                  &lt;p&gt;&lt;strong&gt;{new Date(item.timestamp * 1000).toLocaleString()}&lt;/strong&gt;&lt;/p&gt;
                  &lt;p&gt;&lt;strong&gt;{item.name}:&lt;/strong&gt; {item.message}&lt;/p&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

export default GraffitiWall;
</code></pre>
<p>Once you’ve created your frontend application, you can start it using your preferred development server (e.g., <code>npm run dev</code> or <code>yarn dev</code>) and interact with your deployed program.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-interaction"><a class="header" href="#program-interaction">Program interaction</a></h1>
<p>Table of Contents:</p>
<ul>
<li><a href="basics/interaction.html#description">Description</a></li>
<li><a href="basics/interaction.html#logic">Logic</a></li>
</ul>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Continuing with our example program, a Graffiti Wall, we’ll explore an implementation example of how to communicate with a deployed <a href="basics/../program/program.html">Program</a> by looking at the frontend code.</p>
<h2 id="logic"><a class="header" href="#logic">Logic</a></h2>
<pre><code class="language-typescript">const client = new RpcConnection((import.meta as any).env.VITE_RPC_URL || 'http://localhost:9002');
const PROGRAM_PUBKEY = (import.meta as any).env.VITE_PROGRAM_PUBKEY;
const WALL_ACCOUNT_PUBKEY = (import.meta as any).env.VITE_WALL_ACCOUNT_PUBKEY;
</code></pre>
<p>Here we initialize a new RPC connection and pass in the RPC URL that we wish to connect to; in this case, the URL is pulled from the environment variables or defaults to our locally running validator.</p>
<p>We then import the <a href="basics/../program/pubkey.html">Pubkey</a>s of the Graffiti Wall <a href="basics/../program/program.html">Program</a> as well as the Wall state Account. The Wall state Account stores the state of the Graffiti Wall and the Program’s <a href="basics/../program/pubkey.html">Pubkey</a> serves as the owner of the Graffiti Wall.</p>
<pre><code class="language-typescript">class GraffitiMessage {
  constructor(
    public timestamp: number,
    public name: string,
    public message: string
  ) {}

  static schema = new Map([
    [
      GraffitiMessage,
      {
        kind: 'struct',
        fields: [
          ['timestamp', 'i64'],
          ['name', ['u8', 64]],
          ['message', ['u8', 64]]
        ]
      }
    ]
  ]);
}

// Define the schema for the wall containing messages
class GraffitiWall {
  constructor(public messages: GraffitiMessage[]) {}

  static schema = new Map([
    [
      GraffitiWall,
      {
        kind: 'struct',
        fields: [
          ['messages', [GraffitiMessage]]
        ]
      }
    ]
  ]);
}
</code></pre>
<p>We then define the schemas for handling the Wall’s message data- these schemas mirror the data structure that are found within the Graffiti Wall program which ensures data uniformity between the application frontend and program backend during serialization/deserialization.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct GraffitiMessage {
    pub timestamp: i64,
    pub name: [u8; 64],
    pub message: [u8; 64],
}</code></pre>
<p>Above is the data structure as defined in our program source code.</p>
<pre><code class="language-typescript">  const accountPubkey = PubkeyUtil.fromHex(WALL_ACCOUNT_PUBKEY);

  const schema = {
    struct: {
      messages: {
        seq: {
          struct: {
            timestamp: 'i64',
            name: { array: { type: 'u8', len: 64 } },
            message: { array: { type: 'u8', len: 64 } }
          }
        }
      }
    }
  };
</code></pre>
<p>Moving along, we set the <code>accountPubkey</code> variable with our previously imported Wall account <a href="basics/../program/pubkey.html">Pubkey</a> converted from hexidecimal and then set a new schema for to handle the Graffiti Wall message data.</p>
<pre><code class="language-typescript">const checkProgramDeployed = useCallback(async () =&gt; {
  try {
    const pubkeyBytes = PubkeyUtil.fromHex(PROGRAM_PUBKEY);
    const accountInfo = await client.readAccountInfo(pubkeyBytes);
    if (accountInfo) {
      setIsProgramDeployed(true);
      setError(null);
    }
  } catch (error) {
    console.error('Error checking program:', error);
    setError('The Arch Graffiti program has not been deployed to the network yet. Please run `arch-cli deploy` to deploy your program.');
  }
}, []);
</code></pre>
<p>We then submit our first request to the Arch RPC service: <code>readAccountInfo</code>.</p>
<p>We pass the <code>pubkeyBytes</code>- which represents the <code>program_id</code>, indicating the unique resource location of the <a href="basics/../program/program.html">Program</a> within the Arch Network- as the argument to <code>readAccountInfo</code> in order to obtain the <a href="basics/../program/account.html">AccountInfo</a>.</p>
<p>If we are able to read the <code>accountInfo</code> successfully, then we can be sure the program was deployed.</p>
<pre><code class="language-typescript">  const checkAccountCreated = useCallback(async () =&gt; {
    try {
      const pubkeyBytes = PubkeyUtil.fromHex(WALL_ACCOUNT_PUBKEY);
      const accountInfo = await client.readAccountInfo(pubkeyBytes);
      if (accountInfo) {
        setIsAccountCreated(true);
        setError(null);
      }
    } catch (error) {
      console.error('Error checking account:', error);
      setIsAccountCreated(false);
      setError('The wall account has not been created yet. Please run the account creation command.');
    }
  }, []);
</code></pre>
<p>Similarly, we perform the same check against the Wall account, ensuring that the Graffiti wall has an account provisioned to manage the program’s state. Without this state account the program would not have any data to work with; as a reminder, every Arch <a href="basics/../program/program.html">Program</a> is stateless.</p>
<pre><code class="language-typescript">const fetchWallData = useCallback(async () =&gt; {
    try {
        const userAccount = await client.readAccountInfo(accountPubkey);
        if (!userAccount) {
            setError('Account not found.');
            return;
        }
        const wallData = userAccount.data;
        
        console.log(`Wall data: ${wallData}`);
...
</code></pre>
<p>We then begin to retrieve the Graffiti Wall data from the Wall account.</p>
<p>We make an RPC call to read in the account info just as we did in the previous step, only this time we access the data stored within the <a href="basics/../program/account.html">AccountInfo</a>. As of now, this data is not yet parsed, so it comes back as bytes which will need to be handled.</p>
<pre><code class="language-typescript">        // If data is empty or invalid length, just set empty messages without error
        if (!wallData || wallData.length &lt; 4) {
            setWallData([]);
            setError(null); // Clear any existing errors
            return;
        }
</code></pre>
<p>We perform a check against the length of this bytedata to ensure that it is not empty, meaning there is at least some data stored within the Wall account.</p>
<pre><code class="language-typescript">        // Deserialize the wall data using borsh
        // Read data directly from the buffer
        const messages = [];
        let offset = 0;

        // First 4 bytes are the array length
        const messageCount = new DataView(wallData.buffer).getUint32(offset, true);
        offset += 4;

        for (let i = 0; i &lt; messageCount; i++) {
            // Read timestamp (8 bytes)
            const timestamp = new DataView(wallData.buffer).getBigInt64(offset, true);
            offset += 8;

            // Read name (64 bytes)
            const nameBytes = wallData.slice(offset, offset + 64);
            const name = new TextDecoder().decode(nameBytes.filter(x =&gt; x !== 0));
            offset += 64;

            // Read message (64 bytes)
            const messageBytes = wallData.slice(offset, offset + 64);
            const message = new TextDecoder().decode(messageBytes.filter(x =&gt; x !== 0));
            offset += 64;

            messages.push(new GraffitiMessage(
                Number(timestamp),
                name,
                message
            ));
        }

        messages.sort((a, b) =&gt; b.timestamp - a.timestamp);

        setWallData(messages);
    } catch (error) {
        console.error('Error fetching wall data:', error);
        setError(`Failed to fetch wall data: ${error instanceof Error ? error.message : String(error)}`);
    }
    ...
</code></pre>
<p>We now need to deserialize the bytedata into a structure that is more manageable, in this case, we’ll make use of the <code>GraffitiMessage</code> schema we set earlier.</p>
<pre><code class="language-typescript">  const handleAddToWall = async () =&gt; {
    if (!message.trim() || !name.trim() || !isAccountCreated || !wallet.isConnected) {
      setError("Name and message are required, account must be created, and wallet must be connected.");
      return;
    }
</code></pre>
<p>We’ll again skip over some React state management.</p>
<p><code>handleAddToWall</code> contains the lion’s share of the logic for serializing data and submitting this data to the <a href="basics/../program/program.html">Program</a>.</p>
<pre><code class="language-typescript">  const serializeGraffitiData = (name: string, message: string): number[] =&gt; {
    // Create fixed-size arrays
    const nameArray = new Uint8Array(64).fill(0);
    const messageArray = new Uint8Array(64).fill(0);
    
    // Convert strings to bytes
    const nameBytes = new TextEncoder().encode(name);
    const messageBytes = new TextEncoder().encode(message);
    
    // Copy bytes into fixed-size arrays (will truncate if too long)
    nameArray.set(nameBytes.slice(0, 64));
    messageArray.set(messageBytes.slice(0, 64));
    
    // Create the params object matching the Rust struct
    const params = {
        name: Array.from(nameArray),
        message: Array.from(messageArray)
    };
    
    // Define the schema for borsh serialization
    const schema = {
        struct: {
            name: { array: { type: 'u8', len: 64 } },
            message: { array: { type: 'u8', len: 64 } }
        }
    };
    
    return Array.from(borsh.serialize(schema, params));
    ...
</code></pre>
<p>In this anonymous function we pass in our dapp data, <code>name</code> and <code>message</code> in order to prepare it for submission to the <a href="basics/../program/program.html">Program</a>.</p>
<p>We create two new <code>Uint8</code> byte arrays and initialize their appropriate lengths with placeholder zeros, eventually copying the encoded <code>name</code> and <code>message</code> data into into fixed-size arrays and storing them within the <code>params</code> object.</p>
<p>We define the schema for the data and serialize the scheme alongside the <code>params</code> object which we will use within the following <code>try</code> block.</p>
<pre><code class="language-typescript">    try {
      const data = serializeGraffitiData(name, message);
    
      const instruction: Instruction = {
        program_id: PubkeyUtil.fromHex(PROGRAM_PUBKEY),
        accounts: [
          { 
            pubkey: PubkeyUtil.fromHex(wallet.publicKey!), 
            is_signer: true, 
            is_writable: false 
          },
          { 
            pubkey: accountPubkey, 
            is_signer: false, 
            is_writable: true 
          },
        ],
        data: new Uint8Array(data),
      };
...
</code></pre>
<p>Stepping into our <code>try</code> block, we serialize our post data, in this case including the name of the author as well as the message they wish to post.</p>
<p>We construct an [Instruction] object, containing our <code>program_id</code>, serialized data, as well as the accounts involved, in this case, the signing <a href="basics/../program/pubkey.html">Pubkey</a> of our user’s wallet as well as the <code>accountPubkey</code>, the <a href="basics/../program/pubkey.html">Pubkey</a> of the Wall state account.</p>
<pre><code class="language-typescript">   const messageObj : Message = {
        signers: [PubkeyUtil.fromHex(wallet.publicKey!)],
        instructions: [instruction],
      };
</code></pre>
<p>We then construct our [Message] object to hold the needed signers (our user) as well as the previously formed [Instruction].</p>
<pre><code class="language-typescript">const messageBytes = MessageUtil.serialize(messageObj);
...
const signature = await wallet.signMessage(Buffer.from(MessageUtil.hash(messageObj)).toString('hex'));
</code></pre>
<p>We then serialize our [Message] and then craft our [Signature].</p>
<pre><code class="language-typescript">const signatureBytes = new Uint8Array(Buffer.from(signature, 'base64')).slice(2);
console.log(`Signature bytes: ${signatureBytes}`);

const result = await client.sendTransaction({
  version: 0,
  signatures: [signatureBytes],
  message: messageObj,
});
</code></pre>
<p>We then store our [Signature] within a new <code>Uint8</code> array and create a slice from it in order to segregate the last 64-bytes of the base64 decoded [Signature].</p>
<pre><code class="language-typescript">const result = await client.sendTransaction({
  version: 0,
  signatures: [signatureBytes],
  message: messageObj,
});
</code></pre>
<p>We then craft our [Transaction] object within the RPC call to <code>sendTransaction</code>, passing in our sliced [Signature] and serialized [Message], along with the correct [Transaction] version (<code>0</code>), successfully submitting our state change to the Arch Network for processing.</p>
<p>🎨</p>
<p>This concludes the logic walkthrough of the <a href="basics/../program/program.html">Program</a> interaction component of our [GraffitiWall].</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="guides"><a class="header" href="#guides">Guides</a></h1>
<p>In this section, we’ll provide a few guides that can step through constructing an Arch <a href="guides/../program/program.html">program</a>, as well as deploying and interacting with your program.</p>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-an-arch-program"><a class="header" href="#how-to-write-an-arch-program">How to write an Arch program</a></h1>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-write-arch-program.html#logic">Logic</a></li>
<li><a href="guides/how-to-write-arch-program.html#imports">Imports</a></li>
<li><a href="guides/how-to-write-arch-program.html#entrypoint">Entrypoint</a></li>
<li><a href="guides/how-to-write-arch-program.html#handler">Handler</a></li>
</ul>
<hr />
<p><a href="guides/../introduction.html">The Arch Book</a> can serve as a reference for concepts introduced here as well as our <a href="https://docs.arch.network">docs</a> for high-level architecture diagrams and comparisons to other similar projects building on Bitcoin.</p>
<p>For this guide, we will be walking through an example program: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">helloworld</a>.</p>
<h2 id="logic-1"><a class="header" href="#logic-1">Logic</a></h2>
<p>A smart contract on Arch is known as a <a href="guides/../program/program.html">Program</a>.</p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    entrypoint, msg,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    program::{
        get_account_script_pubkey, get_bitcoin_block_height,
        next_account_info, set_transaction_to_sign, invoke
    },
    program_error::ProgramError,
    pubkey::Pubkey, utxo::UtxoMeta, 
    transaction_to_sign::TransactionToSign,
    system_instruction::SystemInstruction,
};
use bitcoin::{self, Transaction, transaction::Version, absolute::LockTime};
use borsh::{BorshDeserialize, BorshSerialize};

entrypoint!(process_instruction);
pub fn process_instruction(
    _program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    if accounts.len() != 2 {
        return Err(ProgramError::Custom(501));
    }

    let bitcoin_block_height = get_bitcoin_block_height();
    msg!("bitcoin_block_height {:?}", bitcoin_block_height);

    let account_iter = &amp;mut accounts.iter();
    let account = next_account_info(account_iter)?;
    let account2 = next_account_info(account_iter)?;

    msg!("account {:?}", account);
    msg!("account2 {:?}", account2);

    if account2.utxo.clone() != UtxoMeta::from_slice(&amp;[0; 36]) {
        msg!("UTXO {:?}", account2.utxo.clone());
        return Err(ProgramError::Custom(502));
    }

    let params: HelloWorldParams = borsh::from_slice(instruction_data).unwrap();
    let fees_tx: Transaction = bitcoin::consensus::deserialize(&amp;params.tx_hex).unwrap();

    let new_data = format!("Hello {}", params.name);

    // Extend the account data to fit the new data
    let data_len = account.data.try_borrow().unwrap().len();
    if new_data.as_bytes().len() &gt; data_len {
        account.realloc(new_data.len(), true)?;
    }

    let script_pubkey = get_account_script_pubkey(account.key);
    msg!("script_pubkey {:?}", script_pubkey);

    account
        .data
        .try_borrow_mut()
        .unwrap()
        .copy_from_slice(new_data.as_bytes());

    if account2.is_writable {

        invoke(
            &amp;SystemInstruction::new_create_account_instruction(
                params.utxo.txid().try_into().unwrap(), 
                params.utxo.vout(), account2.key.clone()
            ), 
            &amp;[account2.clone()]
        ).expect("failed");
    }

    let mut tx = Transaction {
        version: Version::TWO,
        lock_time: LockTime::ZERO,
        input: vec![],
        output: vec![],
    };
    add_state_transition(&amp;mut tx, account);
    tx.input.push(fees_tx.input[0].clone());

    let tx_to_sign = TransactionToSign {
        tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
        inputs_to_sign: &amp;[InputToSign {
            index: 0,
            signer: account.key.clone(),
        }],
    };

    msg!("tx_to_sign{:?}", tx_to_sign);

    set_transaction_to_sign(accounts, tx_to_sign)
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct HelloWorldParams {
    pub name: String,
    pub tx_hex: Vec&lt;u8&gt;,
    pub utxo: UtxoMeta,
}</code></pre>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>First, let’s bring our <code>arch_program</code>, <code>borsh</code> and <code>bitcoin</code> crates into local namespace.</p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    entrypoint, msg,
    helper::add_state_transition,
    input_to_sign::InputToSign,
    program::{
        get_account_script_pubkey, get_bitcoin_block_height,
        next_account_info, set_transaction_to_sign, invoke
    },
    program_error::ProgramError,
    pubkey::Pubkey, utxo::UtxoMeta, 
    transaction_to_sign::TransactionToSign,
    system_instruction::SystemInstruction,
};
use bitcoin::{self, Transaction, transaction::Version, absolute::LockTime};
use borsh::{BorshDeserialize, BorshSerialize};</code></pre>
<p>Before we continue, let’s quickly introduce some helpful resources that we are importing:</p>
<ul>
<li><code>entrypoint</code>: a macro used for invoking our program.</li>
<li><code>msg</code>: a macro used for logging messages; these are visible within the node logs of your local validator.</li>
<li><code>borsh</code>: a crate for serialization/deserialization of data passed to/from our program.</li>
<li><code>bitcoin</code>: a crate for working with the Bitcoin blockchain.</li>
</ul>
<h2 id="entrypoint"><a class="header" href="#entrypoint">Entrypoint</a></h2>
<p>Every Arch program includes a single entrypoint used to invoke the program.</p>
<p>This tells Arch that the entrypoint to this program is the the <code>process_instruction</code> function, our <a href="guides/how-to-write-arch-program.html#handler">handler</a>.</p>
<pre><code class="language-rust ignore">entrypoint!(process_instruction);</code></pre>
<h2 id="handler"><a class="header" href="#handler">Handler</a></h2>
<p>Each handler function’s parameters must match what is required for a transaction <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a>.</p>
<ul>
<li><code>program_id</code> - Unique identifier of the currently executing program.</li>
<li><code>accounts</code> - Slice reference containing accounts needed to execute an instruction.</li>
<li><code>instruction_data</code> - Serialized data containing program instructions.</li>
</ul>
<pre><code class="language-rust ignore">pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    ...
}</code></pre>
<p>Now that we’re inside the function scope, first, we check that there are a sufficient number of accounts are passed into our program.</p>
<p>We perform a <a href="guides/../program/syscall.html">Syscall</a> to retrieve the latest Bitcoin block height (this can be omitted though is helpful for debugging) and then iterate over the accounts passed in to the program and retrieve the first one.</p>
<pre><code class="language-rust ignore">if accounts.len() != 2 {
    return Err(ProgramError::Custom(501));
}

let bitcoin_block_height = get_bitcoin_block_height();
msg!("bitcoin_block_height {:?}", bitcoin_block_height);

let account_iter = &amp;mut accounts.iter();
let account = next_account_info(account_iter)?;
let account2 = next_account_info(account_iter)?;

msg!("account {:?}", account);
msg!("account2 {:?}", account2);</code></pre>
<p>Next, we perform a check to ensure that the <a href="guides/../program/utxo.html">UTXO</a> passed into the <a href="guides/../program/account.html">Account</a> is not the default value of a 36-zero byte slice. This step is done to ensure that the <a href="guides/../program/utxo.html">UTXO</a> is properly unititialized before continuing.</p>
<pre><code class="language-rust ignore">if account2.utxo.clone() != UtxoMeta::from_slice(&amp;[0; 36]) {
    msg!("UTXO {:?}", account2.utxo.clone());
    return Err(ProgramError::Custom(502));
}</code></pre>
<p>Next, we deserialize our <code>instruction_data</code> into a newly initialized instance of <code>HelloWorldParams</code> to hold our program state and more easily manage it within our program logic.</p>
<pre><code class="language-rust ignore">let params: HelloWorldParams = borsh::from_slice(instruction_data).unwrap();</code></pre>
<p>Now that our <code>instruction_data</code> has been deserialized, we can access the fields, such as <code>params.tx_hex</code>.</p>
<p>In this step, we will use the <a href="https://docs.rs/bitcoin/latest/bitcoin/index.html">Bitcoin crate</a> to further deserialize a reference to the <code>tx_hex</code> field into an instance of a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Transaction.html">Bitcoin transaction</a>; this represents the fees that need to be paid to execute the program instruction.</p>
<pre><code class="language-rust ignore">let fees_tx: Transaction = bitcoin::consensus::deserialize(&amp;params.tx_hex).unwrap();</code></pre>
<blockquote>
<p>Note: <code>tx_hex</code> represents a serialized Bitcoin UTXO that is used to pay the fee for updating state/executing a transaction; it is a fully-signed Bitcoin UTXO that gets sent directly to Arch. The Arch leader node then submits this fee UTXO alongside the other state/asset UTXOs as a result of the program execution.</p>
<p>Including <code>tx_hex</code> is a convention, not a requirement.</p>
<p>Program invocation can be paid for by another source, although in the majority of cases it is most practical to have the caller be prepared to pay this.</p>
</blockquote>
<p>We’ll create our new message with the name we wish to store.</p>
<pre><code class="language-rust ignore">let new_data = format!("Hello {}", params.name);</code></pre>
<p>Next, we’ll extend the account data to fit the new data that we wish to store from the previous step.</p>
<p>We check whether the length of the new data that we wish to pass to the program exceeds the length that is stored within the existing account’s data (ie, the program state) by comparing byte lengths.</p>
<p>If the new data exceeds the length of what was currently stored in the account’s data field, then we re-allocate the account’s data as well as zero-initialize the new memory. This is done to ensure that no stale data remains in the account.</p>
<p>Read more about <a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/account.rs#L131-L149">memory reallocation</a> and zero-initialization.</p>
<pre><code class="language-rust ignore">let data_len = account.data.try_borrow().unwrap().len();
if new_data.as_bytes().len() &gt; data_len {
    account.realloc(new_data.len(), true)?;
}</code></pre>
<p>Next, we retrieve the <code>script_pubkey</code> from the <code>key</code> field of the <a href="guides/../program/account.html">Account</a>. This tells us how the Bitcoin can be spent; we log this out for debugging.</p>
<pre><code class="language-rust ignore">let script_pubkey = get_account_script_pubkey(account.key);
msg!("script_pubkey {:?}", script_pubkey);</code></pre>
<p>Next, we attempt a mutated borrow of the account data in order to copy contents in from the data passed into our program.</p>
<pre><code class="language-rust ignore">account.data.try_borrow_mut().unwrap().copy_from_slice(new_data.as_bytes());</code></pre>
<p>We then perform a check to ensure that the account is writable, if it is, we invoke a <a href="guides/../program/system-instruction.html">SystemInstruction</a> to create a new account instruction.</p>
<p>To create a new account instruction, we provide the <code>txid</code> and <code>vout</code> (the output index for identification) of our <a href="guides/../program/utxo.html">UTXO</a> for the instruction data, and include a copy of the account’s <a href="guides/../program/pubkey.html">Pubkey</a>.</p>
<pre><code class="language-rust ignore">if account2.is_writable {

    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            params.utxo.txid().try_into().unwrap(), 
            params.utxo.vout(), 
            account2.key.clone(),
        ), 
        &amp;[account2.clone()]
    ).expect("failed");
}</code></pre>
<p>Next, we initialize a new instance of a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Transaction.html">Bitcoin transaction</a> that we’ll fill in over the next few steps.</p>
<pre><code class="language-rust ignore">let mut tx = Transaction {
    version: Version::TWO,
    lock_time: LockTime::ZERO,
    input: vec![],
    output: vec![],
};</code></pre>
<p>We then modify the previously initialized <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Transaction.html">Bitcoin transaction</a> by updating <code>input</code> and <code>output</code> fields with the <a href="guides/../program/utxo.html">UTXO</a> data of the account, including the <code>fees_tx</code> that is needed to pay for the Bitcoin transaction.</p>
<pre><code class="language-rust ignore">add_state_transition(&amp;mut tx, account);
tx.input.push(fees_tx.input[0].clone());</code></pre>
<p>Now, we’re ready to sign and submit the transaction to Bitcoin which will cement our state alteration.</p>
<p>Here, we construct a new Arch transaction that includes our serialized <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Transaction.html">Bitcoin transaction</a> alongside our program’s <a href="guides/../program/pubkey.html">Pubkey</a> serving as the signer.</p>
<pre><code class="language-rust ignore">let tx_to_sign = TransactionToSign {
    tx_bytes: &amp;bitcoin::consensus::serialize(&amp;tx),
    inputs_to_sign: &amp;[InputToSign {
        index: 0,
        signer: account.key.clone()
    }]
};</code></pre>
<p>Finally, we pass in the list of accounts our program received initially alongside the previously constructed transaction (<code>tx_to_sign</code>) into a helper function that will serialize it and set the UTXOs to the account.</p>
<pre><code class="language-rust ignore">set_transaction_to_sign(accounts, tx_to_sign);</code></pre>
<p>🎉🎉🎉</p>
<p>Congratulations, you’ve walked through constructing the our <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">helloworld</a> program. In a future guide, we’ll walk you through how to test the logic of your program.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-an-oracle-program"><a class="header" href="#how-to-write-an-oracle-program">How to write an oracle program</a></h1>
<p>This guide walks through the innerworkings of an oracle program as well as details how oracle data can be utilized by other programs on Arch Network.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#description">Description</a></li>
<li><a href="guides/how-to-write-oracle-program.html#flow">Flow</a></li>
<li><a href="guides/how-to-write-oracle-program.html#logic">Logic</a></li>
<li><a href="guides/how-to-write-oracle-program.html#implementation">Implementation</a></li>
</ul>
<hr />
<h3 id="description-1"><a class="header" href="#description-1">Description</a></h3>
<p>Two important aspects of understanding how this oracle example is implemented within Arch:</p>
<ol>
<li>The oracle is a program that updates an account which holds the data</li>
<li>No cross-program invocation occurs since only the account is updated and read from versus this being another program that gets interacted with from another program</li>
</ol>
<p>The source code can be found within the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<ul>
<li>Project deploys oracle program</li>
<li>Project creates state account that the oracle program will control in order to write state to it</li>
<li>Projects submit data to the oracle state account by submitting instructions to the oracle program</li>
<li>Programs include oracle state account alongside their program instructions in order to use this referenced data stored in the oracle state account within their program</li>
<li>Projects submit instructions to oracle program periodically to update oracle state account with fresh data</li>
</ul>
<h3 id="logic-2"><a class="header" href="#logic-2">Logic</a></h3>
<p>If you haven’t already read <a href="guides/./how-to-write-arch-program.html">How to write an Arch program</a>, we recommend starting there to get a basic understanding of the program anatomy before going further.</p>
<p>We’ll look closely at the logic block contained within the <code>update_data</code> <a href="guides/how-to-write-oracle-program.html#logic">handler</a>.</p>
<pre><code class="language-rust ignore">pub fn update_data(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let oracle_account = next_account_info(account_iter)?;

    assert!(oracle_account.is_signer);
    assert_eq!(instruction_data.len(), 8);

    ...
}</code></pre>
<p>First, we’ll iterate over the accounts that get passed into the function, which includes the newly created state account that will be responsible for managing the oracle’s data.</p>
<p>We then assert that the oracle state account has the appropriate authority to be written to and update what it stores within its data field. Additionally, we assert that the data we wish to update the account with is at least a certain number of bytes.</p>
<pre><code class="language-rust ignore">let data_len = oracle_account.data.try_borrow().unwrap().len();
if instruction_data.len() &gt; data_len {
    oracle_account.realloc(instruction_data.len(), true)?;
}</code></pre>
<p>Next, we calculate the length of the new data that we are looking to store in the account and reallocate memory to the account if the new data is larger than the data currently existing within the account. This step is important for ensuring that there is no remaining, stale data stored in the account before adding new data to it.</p>
<pre><code class="language-rust ignore">oracle_account
    .data
    .try_borrow_mut()
    .unwrap()
    .copy_from_slice(instruction_data);

msg!("updated");

Ok(())</code></pre>
<p>Lastly, we store the new data that is passed into the program via the instruction to the state account for management, thus marking the end of the oracle update process.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Let’s look at an example implementation of this oracle program. This includes:</p>
<ul>
<li><a href="guides/how-to-write-oracle-program.html#create-oracle-project">Create oracle project</a></li>
<li><a href="guides/how-to-write-oracle-program.html#deploy-program">Deploy program</a></li>
<li><a href="guides/how-to-write-oracle-program.html#create-a-state-account">Create a state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#update-the-state-account">Update the state account</a></li>
<li><a href="guides/how-to-write-oracle-program.html#read-from-the-state-account">Read from the state account</a></li>
</ul>
<h4 id="create-oracle-project"><a class="header" href="#create-oracle-project">Create oracle project</a></h4>
<p>First, we’ll need to create a new project to hold our oracle logic.</p>
<pre><code class="language-bash"># Create a new directory for your oracle project
mkdir oracle
cd oracle

# Initialize a Rust project
cargo init --lib
</code></pre>
<blockquote>
<p>Note: The new CLI does not currently have a project creation command. We’ll manually set up our project structure.</p>
</blockquote>
<p>You’ll need to create and edit the following files:</p>
<ul>
<li><code>Cargo.toml</code> - Add dependencies for your oracle program</li>
<li><code>src/lib.rs</code> - Implement the oracle program logic</li>
</ul>
<p>Example program files can be found in the <a href="https://github.com/arch-network/arch-examples">arch-examples</a> repo.</p>
<h4 id="deploy-program"><a class="header" href="#deploy-program">Deploy program</a></h4>
<p>After the project is created, the program is written and the <code>Cargo.toml</code> is set with the proper dependencies, we can deploy the program.</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program
cli deploy target/deploy/oracle.so
</code></pre>
<p>During the deployment, a new account is created for the deployed program logic and set to be executable, marking it as a <a href="guides/../program/program.html">Program</a> rather than a data <a href="guides/../program/account.html">Account</a>.</p>
<h4 id="create-state-account"><a class="header" href="#create-state-account">Create state account</a></h4>
<p>From the deployment output, you should obtain the <code>program_id</code>. We can use this <code>program_id</code> to create a state account that is owned and updated by the program.</p>
<p>The oracle state account can then be read from by any program in order to retrieve the associated oracle data.</p>
<pre><code class="language-bash"># The new CLI may not have direct account creation functionality
# You'll need to use an RPC call to create the account

# For example, using curl:
curl -X POST http://localhost:9002 \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"sendTransaction",
    "params":[{
      "signature":"your_signature",
      "message":{
        "accountKeys":["your_pubkey", "your_program_id"],
        "instructions":[{
          "programId":"system_program_id",
          "accounts":["your_pubkey", "new_account_pubkey"],
          "data":"encoded_create_account_data"
        }]
      }
    }]
  }'
</code></pre>
<blockquote>
<p>Note: The above is a simplified example. You’ll need to properly construct, sign, and encode your transaction according to the Arch Network protocol.</p>
</blockquote>
<p>In this step, the account is created and ownership is transferred to the program. This allows the program to update the account’s data field which holds state for the program.</p>
<h4 id="update-the-state-account"><a class="header" href="#update-the-state-account">Update the state account</a></h4>
<p>Now that we have created an account and the oracle program has authority to update it, we now want to update the data that the account holds.</p>
<p>In order to update the data stored in the account, we simply need to make a transaction that includes the data that we wish to update the oracle state account to hold, and submit this within the context of an instruction.</p>
<p>As an example, below we have a sample rust program that we’ll use to fetch the Bitcoin fees from the <a href="https://mempool.space">mempool.space</a> API and store this fee data in our oracle state account that was created during deployment.</p>
<blockquote>
<p>Note: The below is a rust program and is not an Arch program.</p>
<p>The call to update the oracle state account can be written in any programming language as it is simply an RPC call. For sake of continuity, we’re using rust along with methods from both the <code>program</code> and <code>sdk</code> crates.</p>
</blockquote>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client};

let mut old_feerate = 0;

let body: Value = reqwest::blocking::get("https://mempool.space/api/v1/fees/recommended").unwrap().json().unwrap();
let feerate = body.get("fastestFee").unwrap().as_u64().unwrap();

if old_feerate != feerate {
    let (txid, instruction_hash) = sign_and_send_instruction(
        Instruction {
            program_id: program_pubkey.clone(),
            accounts: vec![AccountMeta {
                pubkey: caller_pubkey.clone(),
                is_signer: true,
                is_writable: true
            }],
            data: feerate.to_le_bytes().to_vec()
        },
        vec![caller_keypair],
    ).expect("signing and sending a transaction should not fail");

    let processed_tx = get_processed_transaction(NODE1_ADDRESS, txid.clone()).expect("get processed transaction should not fail");
    println!("processed_tx {:?}", processed_tx);

    println!("{:?}", read_account_info(NODE1_ADDRESS, caller_pubkey.clone()));

    old_feerate = feerate;
}</code></pre>
<h4 id="read-from-the-state-account"><a class="header" href="#read-from-the-state-account">Read from the state account</a></h4>
<p>Below is an example of a different program (we’ll call this app-program) that would like to access the oracle data.</p>
<p>Essentially, what happens here is that when we pass an instruction into our app-program, we must also include the oracle state account alongside any other account that we need for the app-program. In this way, the oracle state account is now in-scope and its data can be read from.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-create-a-fungible-token"><a class="header" href="#how-to-create-a-fungible-token">How to create a fungible token</a></h1>
<p>This guide walks through how to implement the Fungible Token Standard program, part of the Arch Program Library, or APL.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-create-a-fungible-token.html#description">Description</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#logic">Logic</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#implementation">Implementation</a></li>
</ul>
<hr />
<h3 id="description-2"><a class="header" href="#description-2">Description</a></h3>
<p>The Fungible Token Standard program provides a consistent interface for implementing fungible tokens on Arch. As with all programs within the APL, this program is predeployed and is tested against the Arch runtime.</p>
<p>The source code can be found within the <a href="https://github.com/Arch-Network/arch-examples/tree/main/examples/fungible-token-standard">arch-examples</a> repo.</p>
<h3 id="logic-3"><a class="header" href="#logic-3">Logic</a></h3>
<p>If you haven’t already read <a href="guides/./how-to-write-arch-program.html">How to write an Arch program</a>, we recommend starting there to get a basic understanding of the program anatomy before going further.</p>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<ul>
<li><a href="guides/how-to-create-a-fungible-token.html#deploy">Deploy</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#mint">Mint</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#transfer">Transfer</a></li>
<li><a href="guides/how-to-create-a-fungible-token.html#balance-check">Balance check</a></li>
</ul>
<h4 id="deploy-1"><a class="header" href="#deploy-1">Deploy</a></h4>
<p>Although the Fungible Token Standard program is part of the APL, and is there predeployed by the validators, for local testing, we can deploy it ourselves. Move to <a href="guides/how-to-create-a-fungible-token.html#mint">Mint</a> if you’d like to skip this step.</p>
<p>To demonstrate a deploy, we’ll reference: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/deploy.rs">deploy.rs</a></p>
<p>We make use of <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_deployment.rs#L1"><code>try_deploy_program</code></a>, a helper function from the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter">ebpf-counter</a> example to deploy our program.</p>
<pre><code class="language-rust ignore">pub const ELF_PATH: &amp;str = "./program/target/sbf-solana-solana/release/fungible-token-standard-program.so";

fn deploy_standard_program() {
    let program_pubkey =
        try_deploy_program(ELF_PATH, PROGRAM_FILE_PATH, "Fungible-Token-Standard").unwrap();

    println!(
        "Deployed Fungible token standard program account id {:?}!",
        program_pubkey.serialize()
    );
...
}</code></pre>
<h4 id="mint"><a class="header" href="#mint">Mint</a></h4>
<p>To mint tokens, we must supply a few pieces of information:</p>
<ul>
<li>Owner</li>
<li>Supply</li>
<li>Ticker</li>
<li>Decimals</li>
</ul>
<p>This data gets stored in the <code>InitializeMintInput</code> struct, which will be used to generate a new instance of the Fungible Token Standard.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeMintInput {
    owner: [u8; 32],
    supply: u64, // in lowest denomination
    ticker: String,
    decimals: u8,
}</code></pre>
<p>To demonstrate a mint, we’ll reference: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/tests_mint.rs">tests_mint.rs</a></p>
<p>We initialize a new instance of <code>InitializeMintInput</code> and pass in the necessary data. In the below case, our owner account will create the token “SPONK,” with a total supply of 1,000,000, which will have only a single decimal, meaning it is divisible by 1.</p>
<pre><code class="language-rust ignore">// deploy.rs
let mint_input = InitializeMintInput::new(
    mint_account_pubkey.serialize(),
    1000000,
    "SPONK".to_string(),
    1,
);</code></pre>
<p>We then serialize <code>mint_input</code> so that we can pass it as <code>instruction_data</code> within an <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a> which then gets submitted to the deployed Fungible Token Standard program.</p>
<pre><code class="language-rust ignore">let mut instruction_data = vec![0u8];

mint_input
    .serialize(&amp;mut instruction_data)
    .expect("Couldnt serialize mint input");

let initialize_mint_instruction = Instruction {
    program_id: program_pubkey.clone(),
    accounts: vec![AccountMeta {
        pubkey: mint_account_pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
};</code></pre>
<p>Next, we build a transaction using <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L163"><code>build_transaction</code></a> and then submit the transaction with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L196"><code>build_and_send_block</code></a>, both helper function from the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter">ebpf-counter</a> example.</p>
<pre><code class="language-rust ignore">let transaction = build_transaction(
    vec![mint_account_keypair],
    vec![initialize_mint_instruction],
);

let block_transactions = build_and_send_block(vec![transaction]);</code></pre>
<p>We fetch the result of the transaction with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L207"><code>fetch_processed_transactions</code></a> helper function (<a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter">ebpf-counter</a>) and then obtain the mint details by passing the <a href="guides/../program/pubkey.html">Pubkey</a> of the token owner.</p>
<pre><code class="language-rust ignore">let processed_transactions = fetch_processed_transactions(block_transactions).unwrap();

assert!(matches!(
    processed_transactions[0].status,
    Status::Processed
));

let mint_details = get_mint_info(&amp;mint_account_pubkey).expect("Couldnt deserialize mint info");

println!("Mint account {:?}", mint_account_pubkey.serialize());</code></pre>
<h4 id="transfer"><a class="header" href="#transfer">Transfer</a></h4>
<p>To demonstrate a transfer, we’ll reference: <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/tests_transfer.rs">tests_transfer.rs</a></p>
<p>We obtain a <code>mint_account_pubkey</code>, made possible by using the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/helpers.rs#L38"><code>try_create_mint_account</code></a> helper function. We pass <code>true</code> as this is a one-time mint event and this will generate a new keypair and <a href="guides/../program/pubkey.html">Pubkey</a>.</p>
<p>This step will actually create a new token with the following details:</p>
<ul>
<li>Supply: 1,000,000</li>
<li>Ticker: “ARCH”</li>
<li>Decimals: 2</li>
<li>Mint Price: 1000 sats</li>
</ul>
<pre><code class="language-rust ignore">let mint_account_pubkey = try_create_mint_account(true).unwrap();</code></pre>
<p>We then fetch the token mint details with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/helpers.rs#L173"><code>get_mint_info</code></a>.</p>
<pre><code class="language-rust ignore">let previous_mint_details = get_mint_info(&amp;mint_account_pubkey).unwrap();</code></pre>
<p>Now, let’s provision our two accounts: the sender and the receiver.</p>
<pre><code class="language-rust ignore">// sending account
let (first_account_owner_key_pair, first_account_owner_pubkey, _first_account_owner_address) =
        generate_new_keypair();

let first_balance_account_pubkey = create_balance_account(
        &amp;first_account_owner_pubkey,
        first_account_owner_key_pair,
        &amp;mint_account_pubkey,
        &amp;program_pubkey,
)
.unwrap();

// receiving account
let (second_account_owner_key_pair, second_account_owner_pubkey, _second_account_owner_address) =
    generate_new_keypair();

let second_balance_account_pubkey = create_balance_account(
    &amp;second_account_owner_pubkey,
    second_account_owner_key_pair,
    &amp;mint_account_pubkey,
    &amp;program_pubkey,
)
.unwrap();</code></pre>
<p>We then procure funds for the sending account. In this case, we’ll mint 10 tokens.</p>
<pre><code class="language-rust ignore">let mint_amount = 10u64;

let mint_instruction = mint_request_instruction(
    &amp;mint_account_pubkey,
    &amp;program_pubkey,
    &amp;first_balance_account_pubkey,
    &amp;first_account_owner_pubkey,
    mint_amount,
)
.unwrap();</code></pre>
<p>We utilize the <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/fungible-token-standard/src/instruction.rs#L116"><code>transfer_request_instruction</code></a> helper function to generate a transfer <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a>.</p>
<pre><code class="language-rust ignore">let transfer_instruction = transfer_request_instruction(
    &amp;mint_account_pubkey,
    &amp;program_pubkey,
    &amp;first_balance_account_pubkey,
    &amp;first_account_owner_pubkey,
    &amp;second_balance_account_pubkey,
    mint_amount,
)
.unwrap();</code></pre>
<p>We build the transaction by passing in the newly created transfer <a href="guides/../program/instructions-and-messages.html#instructions">Instruction</a> as well as the keypair of the sending account, necessary for authorizing the fund transfer.</p>
<pre><code class="language-rust ignore">let transfer_transaction = build_transaction(
    vec![first_account_owner_key_pair],
    vec![transfer_instruction],
);</code></pre>
<p>Next, we then submit the transaction with <a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/ebpf-counter/src/counter_instructions.rs#L196"><code>build_and_send_block</code></a> and then fetch the processed transaction to get the result.</p>
<pre><code class="language-rust ignore">let block_transactions = build_and_send_block(vec![transfer_transaction]);

let processed_transactions = fetch_processed_transactions(block_transactions).unwrap();

assert!(matches!(
    processed_transactions[0].status,
    Status::Processed
));</code></pre>
<h4 id="balance-check"><a class="header" href="#balance-check">Balance check</a></h4>
<p>In order to check the token balance of an account, we’ll make use of the <code>get_balance_account</code> function and pass in the account we are looking to query the balance of; in the below example, we’ll fetch the balances of both the sending and receiving accounts.</p>
<pre><code class="language-rust ignore">let resulting_sender_balance = get_balance_account(&amp;first_balance_account_pubkey).unwrap();

let resulting_receiver_balance = get_balance_account(&amp;second_balance_account_pubkey).unwrap();

assert_eq!(resulting_receiver_balance.current_balance, mint_amount);

assert_eq!(resulting_sender_balance.current_balance, 0);</code></pre>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-your-first-bitcoin-runes-swap-application"><a class="header" href="#building-your-first-bitcoin-runes-swap-application">Building Your First Bitcoin Runes Swap Application</a></h1>
<p>Welcome to this hands-on tutorial! Today, we’re going to build a decentralized application that enables users to swap Bitcoin Runes tokens on the Arch Network. By the end of this lesson, you’ll understand how to create a secure, trustless swap mechanism for Runes tokens.</p>
<h2 id="class-prerequisites"><a class="header" href="#class-prerequisites">Class Prerequisites</a></h2>
<p>Before we dive in, please ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch Network CLI installed</li>
</ul>
<h2 id="lesson-1-understanding-the-basics"><a class="header" href="#lesson-1-understanding-the-basics">Lesson 1: Understanding the Basics</a></h2>
<h3 id="what-are-runes"><a class="header" href="#what-are-runes">What are Runes?</a></h3>
<p>Before we write any code, let’s understand what we’re working with. Runes is a Bitcoin protocol for fungible tokens, similar to how BRC-20 works. Each Rune token has a unique identifier and can be transferred between Bitcoin addresses.</p>
<h3 id="what-are-we-building"><a class="header" href="#what-are-we-building">What are we building?</a></h3>
<p>We’re creating a swap program that will:</p>
<ol>
<li>Allow users to create swap offers (“I want to trade X amount of Rune A for Y amount of Rune B”)</li>
<li>Enable other users to accept these offers</li>
<li>Let users cancel their offers if they change their mind</li>
<li>Ensure all swaps are atomic (they either complete fully or not at all)</li>
</ol>
<h2 id="lesson-2-setting-up-our-project"><a class="header" href="#lesson-2-setting-up-our-project">Lesson 2: Setting Up Our Project</a></h2>
<p>Let’s start by creating our project structure. Open your terminal and run:</p>
<pre><code class="language-bash"># Create a new directory for your project
mkdir runes-swap
cd runes-swap

# Initialize a new Rust project
cargo init --lib

# Your project structure should look like this:
# runes-swap/
# ├── Cargo.toml
# ├── src/
# │   └── lib.rs
</code></pre>
<h2 id="lesson-3-defining-our-data-structures"><a class="header" href="#lesson-3-defining-our-data-structures">Lesson 3: Defining Our Data Structures</a></h2>
<p>Now, let’s define the building blocks of our swap program. In programming, it’s crucial to plan our data structures before implementing functionality.</p>
<pre><code class="language-rust ignore">use arch_program::{
    account::AccountInfo,
    entrypoint,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    utxo::UtxoMeta,
    borsh::{BorshDeserialize, BorshSerialize},
};

/// This structure represents a single swap offer in our system
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct SwapOffer {
    // Unique identifier for the offer
    pub offer_id: u64,
    // The public key of the person creating the offer
    pub maker: Pubkey,
    // The Rune ID they want to give
    pub rune_id_give: String,
    // Amount of Runes they want to give
    pub amount_give: u64,
    // The Rune ID they want to receive
    pub rune_id_want: String,
    // Amount of Runes they want to receive
    pub amount_want: u64,
    // When this offer expires (in block height)
    pub expiry: u64,
    // Current status of the offer
    pub status: OfferStatus,
}</code></pre>
<p>Let’s break down why we chose each field:</p>
<ul>
<li><code>offer_id</code>: Every offer needs a unique identifier so we can reference it later</li>
<li><code>maker</code>: We store who created the offer to ensure only they can cancel it</li>
<li><code>rune_id_give/want</code>: These identify which Runes are being swapped</li>
<li><code>amount_give/want</code>: The quantities of each Rune in the swap</li>
<li><code>expiry</code>: Offers shouldn’t live forever, so we add an expiration</li>
</ul>
<h2 id="lesson-4-implementing-the-swap-logic"><a class="header" href="#lesson-4-implementing-the-swap-logic">Lesson 4: Implementing the Swap Logic</a></h2>
<p>Now that we understand our data structures, let’s implement the core swap functionality. We’ll start with creating an offer:</p>
<pre><code class="language-rust ignore">fn process_create_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all the accounts we need
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    // Step 2: Verify the maker has the Runes they want to swap
    if let SwapInstruction::CreateOffer { 
        rune_id_give, 
        amount_give,
        rune_id_want,
        amount_want,
        expiry 
    } = instruction {
        // Security check: Ensure the maker owns enough Runes
        verify_rune_ownership(maker, &amp;rune_id_give, amount_give)?;
        
        // Step 3: Create and store the offer
        let offer = SwapOffer {
            offer_id: get_next_offer_id(offer_account)?,
            maker: *maker.key,
            rune_id_give,
            amount_give,
            rune_id_want,
            amount_want,
            expiry,
            status: OfferStatus::Active,
        };
        
        store_offer(offer_account, &amp;offer)?;
    }

    Ok(())
}</code></pre>
<h3 id="understanding-the-create-offer-process"><a class="header" href="#understanding-the-create-offer-process">Understanding the Create Offer Process</a></h3>
<ol>
<li>First, we extract the accounts passed to our program</li>
<li>We verify that the maker actually owns the Runes they want to trade</li>
<li>We create a new <code>SwapOffer</code> with an Active status</li>
<li>Finally, we store this offer in the program’s state</li>
</ol>
<h2 id="lesson-5-testing-our-program"><a class="header" href="#lesson-5-testing-our-program">Lesson 5: Testing Our Program</a></h2>
<p>Testing is crucial in blockchain development because once deployed, your program can’t be easily changed. Let’s write comprehensive tests for our swap program.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::test_utils::{create_test_account, create_test_pubkey};

    /// Helper function to create a test offer
    fn create_test_offer() -&gt; SwapOffer {
        SwapOffer {
            offer_id: 1,
            maker: create_test_pubkey(),
            rune_id_give: "RUNE1".to_string(),
            amount_give: 100,
            rune_id_want: "RUNE2".to_string(),
            amount_want: 200,
            expiry: 1000,
            status: OfferStatus::Active,
        }
    }

    #[test]
    fn test_create_offer() {
        // Arrange: Set up our test accounts
        let maker = create_test_account();
        let offer_account = create_test_account();
        
        // Act: Create an offer
        let result = process_create_offer(
            &amp;[maker.clone(), offer_account.clone()],
            SwapInstruction::CreateOffer {
                rune_id_give: "RUNE1".to_string(),
                amount_give: 100,
                rune_id_want: "RUNE2".to_string(),
                amount_want: 200,
                expiry: 1000,
            },
        );
        
        // Assert: Check the result
        assert!(result.is_ok());
        // Add more assertions here to verify the offer was stored correctly
    }
}</code></pre>
<h3 id="understanding-our-test-structure"><a class="header" href="#understanding-our-test-structure">Understanding Our Test Structure</a></h3>
<p>We follow the “Arrange-Act-Assert” pattern:</p>
<ol>
<li>Arrange: Set up the test environment and data</li>
<li>Act: Execute the functionality we’re testing</li>
<li>Assert: Verify the results match our expectations</li>
</ol>
<h2 id="lesson-6-implementing-offer-acceptance"><a class="header" href="#lesson-6-implementing-offer-acceptance">Lesson 6: Implementing Offer Acceptance</a></h2>
<p>Now let’s implement the logic for accepting an offer. This is where atomic swaps become crucial:</p>
<pre><code class="language-rust ignore">fn process_accept_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    // Step 1: Get all required accounts
    let account_iter = &amp;mut accounts.iter();
    let taker = next_account_info(account_iter)?;
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::AcceptOffer { offer_id } = instruction {
        // Step 2: Load and validate the offer
        let mut offer = load_offer(offer_account)?;
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Step 3: Verify the taker has the required Runes
        verify_rune_ownership(taker, &amp;offer.rune_id_want, offer.amount_want)?;
        
        // Step 4: Perform the atomic swap
        // Transfer Runes from maker to taker
        transfer_runes(
            maker,
            taker,
            &amp;offer.rune_id_give,
            offer.amount_give,
        )?;
        
        // Transfer Runes from taker to maker
        transfer_runes(
            taker,
            maker,
            &amp;offer.rune_id_want,
            offer.amount_want,
        )?;
        
        // Step 5: Update offer status
        offer.status = OfferStatus::Completed;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h3 id="understanding-atomic-swaps"><a class="header" href="#understanding-atomic-swaps">Understanding Atomic Swaps</a></h3>
<p>An atomic swap ensures that either:</p>
<ul>
<li>Both transfers complete successfully, or</li>
<li>Neither transfer happens at all</li>
</ul>
<p>This is crucial for preventing partial swaps where one party could lose their tokens.</p>
<h2 id="lesson-7-implementing-offer-cancellation"><a class="header" href="#lesson-7-implementing-offer-cancellation">Lesson 7: Implementing Offer Cancellation</a></h2>
<p>Finally, let’s implement the ability to cancel offers:</p>
<pre><code class="language-rust ignore">fn process_cancel_offer(
    accounts: &amp;[AccountInfo],
    instruction: SwapInstruction,
) -&gt; Result&lt;(), ProgramError&gt; {
    let account_iter = &amp;mut accounts.iter();
    let maker = next_account_info(account_iter)?;
    let offer_account = next_account_info(account_iter)?;
    
    if let SwapInstruction::CancelOffer { offer_id } = instruction {
        // Load the offer
        let mut offer = load_offer(offer_account)?;
        
        // Security checks
        require!(
            offer.maker == *maker.key,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.status == OfferStatus::Active,
            ProgramError::InvalidAccountData
        );
        require!(
            offer.offer_id == offer_id,
            ProgramError::InvalidArgument
        );
        
        // Update offer status
        offer.status = OfferStatus::Cancelled;
        store_offer(offer_account, &amp;offer)?;
    }
    
    Ok(())
}</code></pre>
<h2 id="deploying-your-runes-swap-program"><a class="header" href="#deploying-your-runes-swap-program">Deploying Your Runes Swap Program</a></h2>
<p>After you’ve written and tested your program, it’s time to deploy it to the Arch Network:</p>
<pre><code class="language-bash"># Build the program
cargo build-sbf

# Deploy the program to the Arch Network
cli deploy target/deploy/runes_swap.so
</code></pre>
<p>Make sure you have a validator node running before deployment:</p>
<pre><code class="language-bash"># Start a local validator
cli validator start
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Congratulations! You’ve built a complete Runes swap program. This program demonstrates several important blockchain concepts:</p>
<ol>
<li>Atomic transactions</li>
<li>State management</li>
<li>Security checks</li>
<li>Program testing</li>
</ol>
<p>Remember to always:</p>
<ul>
<li>Test thoroughly before deployment</li>
<li>Consider edge cases</li>
<li>Implement proper error handling</li>
<li>Add detailed documentation</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>To further improve your program, consider adding:</p>
<ol>
<li>A UI for interacting with the swap program</li>
<li>More sophisticated offer matching</li>
<li>Order book functionality</li>
<li>Price oracle integration</li>
<li>Additional security features</li>
</ol>
<p>Questions? Feel free to ask in the comments below!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-configure-the-local-validator-with-bitcoin-testnet4"><a class="header" href="#how-to-configure-the-local-validator-with-bitcoin-testnet4">How to configure the local validator with Bitcoin Testnet4</a></h1>
<p>This guide is intended for those wishing to view logs from their programs while benefitting from being connected to Bitcoin testnet4 and therefore gaining access to ordinals/runes helper tools.</p>
<p>Table of Contents:</p>
<ul>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#config">Config</a></li>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#local-validator">Local validator</a></li>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#help-commands">Help commands</a></li>
<li><a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#log-assistance">Log assistance</a></li>
</ul>
<h3 id="config"><a class="header" href="#config">Config</a></h3>
<p>First, you’ll need to configure the network settings for connecting to Bitcoin testnet4. The new CLI accepts these parameters directly when starting the validator.</p>
<blockquote>
<p>Note: We have redacted our Bitcoin node password to prevent abuse; contact us if you need this, otherwise provide your own node credentials and use the below as a reference.</p>
</blockquote>
<p>When starting the validator, you’ll need to include the following parameters:</p>
<pre><code class="language-bash">cli validator start --network-mode testnet \
  --bitcoin-rpc-endpoint bitcoin-node.test.aws.archnetwork.xyz \
  --bitcoin-rpc-port 49332 \
  --bitcoin-rpc-username bitcoin \
  --bitcoin-rpc-password redacted \
  --bitcoin-rpc-wallet testwallet
</code></pre>
<h3 id="local-validator"><a class="header" href="#local-validator">Local validator</a></h3>
<blockquote>
<p>Note: You can start a local validator using the Arch Network CLI tool.</p>
<p>Additionally, you can download pre-built binaries from the <a href="https://github.com/Arch-Network/arch-node/releases">arch-node releases page</a>.</p>
<p><strong>Be sure to download the local validator binary, not the regular validator.</strong></p>
</blockquote>
<h4 id="run-the-local-validator"><a class="header" href="#run-the-local-validator">Run the local validator</a></h4>
<p>Use the CLI command to run the local validator. You’ll need to have <a href="https://docker.com">Docker</a> installed and running.</p>
<pre><code class="language-bash">cli validator start --network-mode testnet
</code></pre>
<p>The validator logs can be viewed easily within the <a href="https://docker.com">Docker</a> desktop dashboard.</p>
<blockquote>
<p>Note: You can also run the standalone local validator binary where the logs will be streamed to <code>stdout</code> unless otherwise redirected.</p>
</blockquote>
<p><strong>Steps for running standalone validator binary:</strong></p>
<ol>
<li>
<p>Download the appropriate binary as well as the <code>system_program.so</code> file from <a href="https://github.com/Arch-Network/arch-node/releases/latest">arch-node releases page</a>.</p>
</li>
<li>
<p>Store the <code>system_program.so</code> file within a new directory called <code>/ebpf</code>.</p>
<p>Your directory structure should resemble the following:</p>
<pre><code class="language-bash">tmp/
├─ ebpf/
│  ├─ system_program.so
├─ local_validator
</code></pre>
</li>
<li>
<p>Run the binary and pass the relevant flags dependening on your target network.</p>
<pre><code class="language-bash">RUST_LOG=info \
./local_validator \
--network-mode testnet \
--rpc-bind-ip 127.0.0.1 \
--rpc-bind-port 9002 \
--bitcoin-rpc-endpoint bitcoin-node.test.aws.archnetwork.xyz \
--bitcoin-rpc-port 49332 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password redacted
</code></pre>
</li>
</ol>
<h3 id="help-commands"><a class="header" href="#help-commands">Help commands</a></h3>
<p>This section includes some helpful material when needing to restart the node state or better ensure our infrastructure is operational before proceeding.</p>
<h4 id="arch-node"><a class="header" href="#arch-node">Arch node</a></h4>
<p>The below commands can be used to assist with running the <a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#local-validator">Local validator</a>.</p>
<h5 id="start-fresh"><a class="header" href="#start-fresh">Start fresh</a></h5>
<p>By removing the <code>/.arch_data</code> directory, we can wipe the state and effective start the node again from genesis (block: 0).</p>
<pre><code class="language-bash">rm -rf .arch_data &amp;&amp; RUST_LOG=info \
./local_validator \
...
</code></pre>
<h5 id="pulse-check"><a class="header" href="#pulse-check">Pulse check</a></h5>
<p>This <code>cURL</code> command will allow us to ensure that our <a href="guides/how-to-configure-local-validator-bitcoin-testnet4.html#local-validator">Local validator</a> is up and running correctly. We can use this to effective get a pulse check on the node which is helpful for debugging.</p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<h3 id="log-assistance"><a class="header" href="#log-assistance">Log assistance</a></h3>
<p>Ordinarily, the arch-node logs will flood your terminal screen (or the <a href="https://docker.com">Docker</a> logs). This is less than idea when needing to review them carefully, so you can also direct the <code>stdout</code> to a file for later reading.</p>
<p>Here’s an example of how to do this:</p>
<pre><code class="language-bash">rm -rf .arch_data &amp;&amp; RUST_LOG=info \
./local_validator \
--network-mode testnet \
--rpc-bind-ip 127.0.0.1 \
--rpc-bind-port 9002 \
--bitcoin-rpc-endpoint bitcoin-node.test.aws.archnetwork.xyz \
--bitcoin-rpc-port 49332 \
--bitcoin-rpc-username bitcoin \
--bitcoin-rpc-password redacted \
&gt; node-logs.txt
</code></pre>
<p>Then you can <code>tail</code> the output and view the logs as they stream in.</p>
<pre><code class="language-bash">tail -f node-logs.txt
</code></pre>
<h3 id="deploy--interact"><a class="header" href="#deploy--interact">Deploy + interact</a></h3>
<p>Now that everything is setup correctly, we can now deploy our program and begin interacting with it. The deploy step will prove everything works correctly.</p>
<pre><code class="language-bash">cli deploy --network-mode testnet
</code></pre>
<p>And if you are running the local validator binary directly from the command-line, set the <code>--rpc-url</code> flag to specify your validator endpoint:</p>
<pre><code class="language-bash">cli deploy --network-mode testnet --rpc-url http://localhost:9002
</code></pre>
<p>We hope this guide has been helpful, but as always, feel free to ask question within our <a href="https://discord.com/channels/1241112027963986001/1270921925991989268">Discord dev-chat</a> or submit issues within out <a href="https://github.com/arch-network/public-issues">public-issues</a> repo.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-bitcoin-lending-protocol"><a class="header" href="#how-to-build-a-bitcoin-lending-protocol">How to Build a Bitcoin Lending Protocol</a></h1>
<p>This guide walks through building a lending protocol for Bitcoin-based assets (BTC, Runes, Ordinals) on Arch Network. We’ll create a decentralized lending platform similar to Aave, but specifically designed for Bitcoin-based assets.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>Completed the <a href="guides/../getting-started/environment-setup.html">environment setup</a></li>
<li>A basic understanding of <a href="guides/../concepts/bitcoin-integration.html">Bitcoin Integration</a></li>
<li>Familiarity with Rust programming language</li>
<li>Your development environment ready with the Arch CLI installed</li>
</ul>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<h3 id="basic-user-flow"><a class="header" href="#basic-user-flow">Basic User Flow</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Depositing
        A[User wants to lend] --&gt;|1. Deposits BTC| B[Lending Pool]
        B --&gt;|2. Receives interest| A
    end

    subgraph Borrowing
        C[User needs loan] --&gt;|3. Provides collateral| B
        B --&gt;|4. Lends BTC| C
        C --&gt;|5. Repays loan + interest| B
    end

    style A fill:#b3e0ff
    style B fill:#98FB98
    style C fill:#b3e0ff
</pre>
<h3 id="safety-system"><a class="header" href="#safety-system">Safety System</a></h3>
<pre class="mermaid">flowchart LR
    subgraph &quot;Price Monitoring&quot;
        direction TB
        A[Price Oracle] --&gt;|1. Updates prices| B[Health Checker]
    end

    subgraph &quot;Health Check&quot;
        direction TB
        B --&gt;|2. Monitors positions| C[User Position]
        C --&gt;|3. If position unsafe| D[Liquidator]
    end

    style A fill:#FFB6C1
    style B fill:#FFB6C1
    style C fill:#b3e0ff
    style D fill:#FFB6C1
</pre>
<h3 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h3>
<p>Let’s say Alice wants to borrow BTC and Bob wants to earn interest:</p>
<ol>
<li>
<p><strong>Bob (Lender)</strong></p>
<ul>
<li>Deposits 1 BTC into pool</li>
<li>Earns 3% APY interest</li>
</ul>
</li>
<li>
<p><strong>Alice (Borrower)</strong></p>
<ul>
<li>Provides 1.5 BTC as collateral</li>
<li>Borrows 1 BTC</li>
<li>Pays 5% APY interest</li>
</ul>
</li>
<li>
<p><strong>Safety System</strong></p>
<ul>
<li>Monitors BTC price</li>
<li>Checks if Alice’s collateral stays valuable enough</li>
<li>If BTC price drops too much, liquidates some collateral to protect Bob’s deposit</li>
</ul>
</li>
</ol>
<h2 id="architecture-overview-2"><a class="header" href="#architecture-overview-2">Architecture Overview</a></h2>
<p>Our lending protocol consists of several key components:</p>
<h3 id="1-pool-accounts"><a class="header" href="#1-pool-accounts">1. Pool Accounts</a></h3>
<p>Pool accounts are the core of our lending protocol. They serve as liquidity pools where users can:</p>
<ul>
<li>Deposit Bitcoin-based assets (BTC, Runes, Ordinals)</li>
<li>Earn interest on deposits</li>
<li>Borrow against their collateral</li>
<li>Manage protocol parameters</li>
</ul>
<p>Each pool account maintains:</p>
<ul>
<li>Total deposits and borrows</li>
<li>Interest rates and utilization metrics</li>
<li>Collateral factors and liquidation thresholds</li>
<li>Asset-specific parameters</li>
</ul>
<p>The pool account manages both state and UTXOs:</p>
<ul>
<li><strong>State Management</strong>: Tracks deposits, withdrawals, and user positions</li>
<li><strong>UTXO Management</strong>:
<ul>
<li>Maintains a collection of UTXOs for the pool’s Bitcoin holdings</li>
<li>Manages UTXO creation for withdrawals</li>
<li>Handles UTXO consolidation for efficient liquidity management</li>
</ul>
</li>
</ul>
<h3 id="2-price-oracle"><a class="header" href="#2-price-oracle">2. Price Oracle</a></h3>
<p>Track asset prices for liquidation calculations</p>
<h3 id="3-user-positions"><a class="header" href="#3-user-positions">3. User Positions</a></h3>
<p>User positions track all user interactions with the lending pools:</p>
<ul>
<li>Active deposits and their earned interest</li>
<li>Outstanding borrows and accrued interest</li>
<li>Collateral positions and health factors</li>
<li>Liquidation thresholds and warnings</li>
</ul>
<p>Each user can have multiple positions across different pools, and the protocol tracks:</p>
<ul>
<li>Position health through real-time monitoring</li>
<li>Collateralization ratios</li>
<li>Interest accrual</li>
<li>Liquidation risks</li>
</ul>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct LendingPool {
    pub pool_pubkey: Pubkey,
    pub asset_type: AssetType, // BTC, Runes, Ordinals
    pub total_deposits: u64,
    pub total_borrows: u64,
    pub interest_rate: u64,
    pub utilization_rate: u64,
    pub liquidation_threshold: u64,
    pub collateral_factor: u64,
    pub utxos: Vec&lt;UtxoMeta&gt;,
    pub validator_signatures: Vec&lt;Signature&gt;,
    pub min_signatures_required: u32,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserPosition {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub deposited_amount: u64,
    pub borrowed_amount: u64,
    pub collateral_amount: u64,
    pub last_update: i64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct InterestRateModel {
    pub base_rate: u64,
    pub multiplier: u64,
    pub jump_multiplier: u64,
    pub optimal_utilization: u64,
}

// Additional helper structures for managing positions
#[derive(BorshSerialize, BorshDeserialize)]
pub struct PositionHealth {
    pub health_factor: u64,
    pub liquidation_price: u64,
    pub safe_borrow_limit: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct PoolMetrics {
    pub total_value_locked: u64,
    pub available_liquidity: u64,
    pub utilization_rate: u64,
    pub supply_apy: u64,
    pub borrow_apy: u64,
}</code></pre>
<h2 id="custom-scoring-and-risk-management"><a class="header" href="#custom-scoring-and-risk-management">Custom Scoring and Risk Management</a></h2>
<h3 id="ltv-loan-to-value-scoring-system"><a class="header" href="#ltv-loan-to-value-scoring-system">LTV (Loan-to-Value) Scoring System</a></h3>
<pre class="mermaid">flowchart TD
    subgraph Core_Factors[Core Factors]
        P1[Transaction History]
        P2[Asset Quality]
        P3[Market Volatility]
        P4[Position Size]
    end
    
    subgraph User_Metrics[User Metrics]
        P5[Account History]
        P6[Repayment Record]
        P7[Portfolio Health]
    end
    
    subgraph Market_Context[Market Context]
        P8[Market Conditions]
        P9[Price Impact]
        P10[Network Status]
    end
    
    Core_Factors --&gt; SC[Scoring Engine]
    User_Metrics --&gt; SC
    Market_Context --&gt; SC
    SC --&gt; WF[Weight Calculation]
    WF --&gt; NM[Risk Normalization]
    NM --&gt; LTV[Final LTV Ratio]
    
    style Core_Factors fill:#e1f3d8
    style User_Metrics fill:#fff7e6
    style Market_Context fill:#e6f3ff
    style SC fill:#f9f9f9
    style WF fill:#f9f9f9
    style NM fill:#f9f9f9
    style LTV fill:#d4edda
</pre>
<h3 id="health-score-monitoring"><a class="header" href="#health-score-monitoring">Health Score Monitoring</a></h3>
<pre class="mermaid">sequenceDiagram
    participant User
    participant HealthMonitor
    participant PriceOracle
    participant LiquidationEngine
    participant Market

    loop Every Block
        PriceOracle-&gt;&gt;HealthMonitor: Update Asset Prices
        HealthMonitor-&gt;&gt;HealthMonitor: Calculate Health Score
        
        alt Health Score &lt; Threshold
            HealthMonitor-&gt;&gt;LiquidationEngine: Trigger Liquidation
            LiquidationEngine-&gt;&gt;User: Lock Account
            LiquidationEngine-&gt;&gt;Market: List Assets
            Market--&gt;&gt;LiquidationEngine: Asset Sale Complete
            LiquidationEngine-&gt;&gt;User: Update Position
        else Health Score &gt;= Threshold
            HealthMonitor-&gt;&gt;User: Position Safe
        end
    end
</pre>
<h3 id="liquidation-process"><a class="header" href="#liquidation-process">Liquidation Process</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Monitoring
    Monitoring --&gt; Warning: Health Score Declining
    Warning --&gt; AtRisk: Below Warning Threshold
    AtRisk --&gt; Liquidation: Below Critical Threshold
    Liquidation --&gt; Step1: Lock Account
    Step1 --&gt; Step2: List Assets
    Step2 --&gt; Recovery: Asset Sale
    Recovery --&gt; [*]: Position Cleared
    
    Warning --&gt; Monitoring: Health Restored
    AtRisk --&gt; Warning: Health Improved
</pre>
<h3 id="custom-scoring-implementation"><a class="header" href="#custom-scoring-implementation">Custom Scoring Implementation</a></h3>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UserScore {
    pub historical_data_score: u64,
    pub asset_quality_score: u64,
    pub market_volatility_score: u64,
    pub position_size_score: u64,
    pub account_age_score: u64,
    pub liquidation_history_score: u64,
    pub repayment_history_score: u64,
    pub cross_margin_score: u64,
    pub portfolio_diversity_score: u64,
    pub market_condition_score: u64,
    pub collateral_quality_score: u64,
    pub platform_activity_score: u64,
    pub time_weighted_score: u64,
    pub price_impact_score: u64,
    pub network_status_score: u64,
}

pub fn calculate_ltv_ratio(score: &amp;UserScore) -&gt; Result&lt;u64&gt; {
    // Weighted calculation of LTV based on all scoring parameters
    let weighted_score = calculate_weighted_score(score)?;
    let normalized_score = normalize_score(weighted_score)?;
    
    // Convert normalized score to LTV ratio
    let ltv_ratio = convert_score_to_ltv(normalized_score)?;
    
    // Apply market condition adjustments
    let adjusted_ltv = apply_market_adjustments(ltv_ratio)?;
    
    Ok(adjusted_ltv)
}

pub fn monitor_health_score(
    ctx: Context&lt;HealthCheck&gt;,
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;()&gt; {
    let health_score = calculate_health_score(position, score)?;
    
    if health_score &lt; CRITICAL_THRESHOLD {
        trigger_full_liquidation(ctx, position)?;
        lock_account(ctx.accounts.user_account)?;
    } else if health_score &lt; WARNING_THRESHOLD {
        emit_warning(ctx.accounts.user_account)?;
    }
    
    Ok(())
}

pub fn trigger_full_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    position: &amp;UserPosition,
) -&gt; Result&lt;()&gt; {
    // Step 1: Lock the account
    lock_account(ctx.accounts.user_account)?;
    
    // Step 2: Calculate current position value
    let position_value = calculate_position_value(position)?;
    
    // Step 3: List assets on marketplace
    list_assets_for_liquidation(
        ctx.accounts.marketplace,
        position.assets,
        position_value,
    )?;
    
    // Step 4: Monitor recovery process
    start_recovery_monitoring(ctx.accounts.recovery_manager)?;
    
    Ok(())
}

## Health Score Calculation
The health score is calculated using a combination of factors:

```rust,ignore
pub fn calculate_health_score(
    position: &amp;UserPosition,
    score: &amp;UserScore,
) -&gt; Result&lt;u64&gt; {
    // 1. Calculate base health ratio
    let base_health = calculate_base_health_ratio(
        position.collateral_value,
        position.borrowed_value,
    )?;
    
    // 2. Apply user score modifiers
    let score_adjusted_health = apply_score_modifiers(
        base_health,
        score,
    )?;
    
    // 3. Apply market condition adjustments
    let market_adjusted_health = apply_market_conditions(
        score_adjusted_health,
        &amp;position.asset_type,
    )?;
    
    // 4. Apply time-weighted factors
    let final_health_score = apply_time_weights(
        market_adjusted_health,
        position.last_update,
    )?;
    
    Ok(final_health_score)
}</code></pre>
<h3 id="liquidation-implementation"><a class="header" href="#liquidation-implementation">Liquidation Implementation</a></h3>
<p>The two-step liquidation process is implemented as follows:</p>
<pre><code class="language-rust ignore">pub struct LiquidationConfig {
    pub warning_threshold: u64,
    pub critical_threshold: u64,
    pub recovery_timeout: i64,
    pub minimum_recovery_value: u64,
}

pub fn handle_liquidation(
    ctx: Context&lt;Liquidation&gt;,
    config: &amp;LiquidationConfig,
) -&gt; Result&lt;()&gt; {
    // Step 1: Asset Recovery
    let recovery_listing = create_recovery_listing(
        ctx.accounts.marketplace,
        ctx.accounts.user_position,
        config.minimum_recovery_value,
    )?;
    
    // Step 2: Monitor Recovery
    start_recovery_monitoring(
        recovery_listing,
        config.recovery_timeout,
    )?;
    
    // Lock account until recovery complete
    lock_user_account(ctx.accounts.user_account)?;
    
    Ok(())
}</code></pre>
<h2 id="implementation-steps"><a class="header" href="#implementation-steps">Implementation Steps</a></h2>
<h3 id="1-initialize-lending-pool"><a class="header" href="#1-initialize-lending-pool">1. Initialize Lending Pool</a></h3>
<p>First, we’ll create a function to initialize a new lending pool:</p>
<pre><code class="language-rust ignore">pub fn initialize_lending_pool(
    ctx: Context&lt;InitializeLendingPool&gt;,
    asset_type: AssetType,
    initial_interest_rate: u64,
    liquidation_threshold: u64,
    collateral_factor: u64,
) -&gt; Result&lt;()&gt; {
    let lending_pool = &amp;mut ctx.accounts.lending_pool;
    
    lending_pool.pool_pubkey = ctx.accounts.pool.key();
    lending_pool.asset_type = asset_type;
    lending_pool.total_deposits = 0;
    lending_pool.total_borrows = 0;
    lending_pool.interest_rate = initial_interest_rate;
    lending_pool.utilization_rate = 0;
    lending_pool.liquidation_threshold = liquidation_threshold;
    lending_pool.collateral_factor = collateral_factor;
    
    Ok(())
}

// Initialize pool metrics
pub fn initialize_pool_metrics(
    ctx: Context&lt;InitializePoolMetrics&gt;,
) -&gt; Result&lt;()&gt; {
    let pool_metrics = &amp;mut ctx.accounts.pool_metrics;
    
    pool_metrics.total_value_locked = 0;
    pool_metrics.available_liquidity = 0;
    pool_metrics.utilization_rate = 0;
    pool_metrics.supply_apy = 0;
    pool_metrics.borrow_apy = 0;
    
    Ok(())
}</code></pre>
<h3 id="2-manage-user-positions"><a class="header" href="#2-manage-user-positions">2. Manage User Positions</a></h3>
<p>Functions to handle user position management:</p>
<pre><code class="language-rust ignore">pub fn create_user_position(
    ctx: Context&lt;CreateUserPosition&gt;,
    pool_pubkey: Pubkey,
) -&gt; Result&lt;()&gt; {
    let user_position = &amp;mut ctx.accounts.user_position;
    
    user_position.user_pubkey = ctx.accounts.user.key();
    user_position.pool_pubkey = pool_pubkey;
    user_position.deposited_amount = 0;
    user_position.borrowed_amount = 0;
    user_position.collateral_amount = 0;
    user_position.last_update = Clock::get()?.unix_timestamp;
    
    Ok(())
}

pub fn update_position_health(
    ctx: Context&lt;UpdatePositionHealth&gt;,
) -&gt; Result&lt;()&gt; {
    let position = &amp;ctx.accounts.user_position;
    let pool = &amp;ctx.accounts.lending_pool;
    let health = &amp;mut ctx.accounts.position_health;
    
    // Calculate health factor based on current prices and positions
    let collateral_value = calculate_collateral_value(
        position.collateral_amount,
        pool.asset_type,
    )?;
    
    let borrow_value = calculate_borrow_value(
        position.borrowed_amount,
        pool.asset_type,
    )?;
    
    health.health_factor = calculate_health_factor(
        collateral_value,
        borrow_value,
        pool.collateral_factor,
    )?;
    
    health.liquidation_price = calculate_liquidation_price(
        position.borrowed_amount,
        position.collateral_amount,
        pool.liquidation_threshold,
    )?;
    
    health.safe_borrow_limit = calculate_safe_borrow_limit(
        collateral_value,
        pool.collateral_factor,
    )?;
    
    Ok(())
}</code></pre>
<h3 id="3-pool-and-position-utilities"><a class="header" href="#3-pool-and-position-utilities">3. Pool and Position Utilities</a></h3>
<p>Helper functions for managing pools and positions:</p>
<pre><code class="language-rust ignore">// Calculate the utilization rate of a pool
pub fn calculate_utilization_rate(pool: &amp;LendingPool) -&gt; Result&lt;u64&gt; {
    if pool.total_deposits == 0 {
        return Ok(0);
    }
    
    Ok((pool.total_borrows * 10000) / pool.total_deposits)
}

// Calculate the health factor of a position
pub fn calculate_health_factor(
    collateral_value: u64,
    borrow_value: u64,
    collateral_factor: u64,
) -&gt; Result&lt;u64&gt; {
    if borrow_value == 0 {
        return Ok(u64::MAX);
    }
    
    Ok((collateral_value * collateral_factor) / (borrow_value * 10000))
}

// Update pool metrics
pub fn update_pool_metrics(
    pool: &amp;LendingPool,
    metrics: &amp;mut PoolMetrics,
) -&gt; Result&lt;()&gt; {
    metrics.total_value_locked = pool.total_deposits;
    metrics.available_liquidity = pool.total_deposits.saturating_sub(pool.total_borrows);
    metrics.utilization_rate = calculate_utilization_rate(pool)?;
    
    // Update APY rates based on utilization
    let (supply_apy, borrow_apy) = calculate_apy_rates(
        metrics.utilization_rate,
        pool.interest_rate,
    )?;
    
    metrics.supply_apy = supply_apy;
    metrics.borrow_apy = borrow_apy;
    
    Ok(())
}</code></pre>
<h3 id="4-deposit-assets"><a class="header" href="#4-deposit-assets">4. Deposit Assets</a></h3>
<p>Create a deposit function to allow users to provide liquidity:</p>
<pre><code class="language-rust ignore">pub fn deposit(
    ctx: Context&lt;Deposit&gt;,
    amount: u64,
    btc_txid: [u8; 32],
    vout: u32,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;
    
    // Verify the UTXO belongs to the user
    require!(
        validate_utxo_ownership(
            &amp;UtxoMeta {
                txid: btc_txid,
                vout,
                amount,
            },
            &amp;ctx.accounts.user.key()
        )?,
        ErrorCode::InvalidUTXO
    );

    // Create deposit account to hold the UTXO
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            btc_txid,
            vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.user.clone(), ctx.accounts.pool.clone()]
    )?;

    // Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    // Update utilization metrics
    update_utilization_rate(pool)?;
    
    Ok(())
}</code></pre>
<h3 id="5-borrow-assets"><a class="header" href="#5-borrow-assets">5. Borrow Assets</a></h3>
<p>Implement borrowing functionality:</p>
<pre><code class="language-rust ignore">pub fn borrow(
    ctx: Context&lt;Borrow&gt;,
    amount: u64,
    collateral_utxo: UtxoMeta,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let borrower_position = &amp;mut ctx.accounts.user_position;

    // Verify collateral UTXO ownership
    require!(
        validate_utxo_ownership(
            &amp;collateral_utxo,
            &amp;ctx.accounts.borrower.key()
        )?,
        ErrorCode::InvalidCollateral
    );

    // Check collateral requirements
    require!(
        is_collateral_sufficient(borrower_position, pool, amount)?,
        ErrorCode::InsufficientCollateral
    );

    // Create collateral account
    invoke(
        &amp;SystemInstruction::new_create_account_instruction(
            collateral_utxo.txid,
            collateral_utxo.vout,
            pool.pool_pubkey,
        ),
        &amp;[ctx.accounts.borrower.clone(), ctx.accounts.pool.clone()]
    )?;

    // Create borrow UTXO for user
    let mut btc_tx = Transaction::new();
    add_state_transition(&amp;mut btc_tx, ctx.accounts.pool);

    // Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;[InputToSign {
                index: 0,
                signer: pool.pool_pubkey
            }]
        }
    );

    // Update states
    pool.total_borrows = pool.total_borrows
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;
    
    borrower_position.borrowed_amount = borrower_position.borrowed_amount
        .checked_add(amount)
        .ok_or(ErrorCode::MathOverflow)?;

    update_utilization_rate(pool)?;
    update_interest_rate(pool)?;

    Ok(())
}</code></pre>
<h3 id="6-liquidation-logic"><a class="header" href="#6-liquidation-logic">6. Liquidation Logic</a></h3>
<p>Implement liquidation for underwater positions:</p>
<pre><code class="language-rust ignore">pub fn liquidate(
    ctx: Context&lt;Liquidate&gt;,
    repay_amount: u64,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let liquidated_position = &amp;mut ctx.accounts.liquidated_position;
    
    // Check if position is liquidatable
    require!(
        is_position_liquidatable(liquidated_position, pool)?,
        ErrorCode::PositionNotLiquidatable
    );
    
    // Calculate liquidation bonus
    let bonus = calculate_liquidation_bonus(repay_amount, pool.liquidation_threshold)?;
    
    // Process liquidation
    process_liquidation(
        pool,
        liquidated_position,
        repay_amount,
        bonus,
    )?;
    
    Ok(())
}</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Create comprehensive tests for your lending protocol:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_initialize_lending_pool() {
        // Test pool initialization
    }

    #[test]
    fn test_deposit() {
        // Test deposit functionality
    }

    #[test]
    fn test_borrow() {
        // Test borrowing
    }

    #[test]
    fn test_liquidation() {
        // Test liquidation scenarios
    }
}</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<ol>
<li><strong>Collateral Safety</strong>: Implement strict collateral requirements and regular position health checks</li>
<li><strong>Price Oracle Security</strong>: Use reliable price feeds and implement safeguards against price manipulation</li>
<li><strong>Interest Rate Model</strong>: Ensure the model can handle extreme market conditions</li>
<li><strong>Access Control</strong>: Implement proper permission checks for all sensitive operations</li>
<li><strong>Liquidation Thresholds</strong>: Set appropriate thresholds to maintain protocol solvency</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ol>
<li>
<p>Implement additional features:</p>
<ul>
<li>Flash loans</li>
<li>Multiple collateral types</li>
<li>Governance mechanisms</li>
</ul>
</li>
<li>
<p>Deploy and test on testnet:</p>
<ul>
<li>Monitor pool performance</li>
<li>Test liquidation scenarios</li>
<li>Validate interest rate model</li>
</ul>
</li>
<li>
<p>Security audit:</p>
<ul>
<li>Contract review</li>
<li>Economic model analysis</li>
<li>Risk assessment</li>
</ul>
</li>
</ol>
<h2 id="process-descriptions"><a class="header" href="#process-descriptions">Process Descriptions</a></h2>
<h3 id="1-pool-initialization-process"><a class="header" href="#1-pool-initialization-process">1. Pool Initialization Process</a></h3>
<p>The pool initialization process involves several steps:</p>
<pre class="mermaid">%%{init: {
  'theme': 'base',
  'themeVariables': { 'fontSize': '16px'},
  'flowchart': {
    'curve': 'basis',
    'nodeSpacing': 50,
    'rankSpacing': 50,
    'animation': {
      'sequence': true,
      'duration': 1000,
      'ease': 'linear',
      'diagramUpdate': 200
    }
  }
}}%%
graph LR
    A[Admin] --&gt;|Create Pool| B[Initialize Pool Account]
    B --&gt;|Set Parameters| C[Configure Pool]
    C --&gt;|Initialize Metrics| D[Create Pool Metrics]
    D --&gt;|Enable Oracle| E[Connect Price Feed]
    E --&gt;|Activate| F[Pool Active]

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef active fill:#4a9eff,color:white,stroke:#3182ce,opacity:0;
    classDef complete fill:#98FB98,stroke:#333;

</pre>
<ol>
<li>Admin creates a new pool account</li>
<li>Pool parameters are set (interest rates, thresholds)</li>
<li>Pool metrics are initialized</li>
<li>Price oracle connection is established</li>
<li>Pool is activated for user operations</li>
</ol>
<h3 id="2-deposit-and-borrow-flow"><a class="header" href="#2-deposit-and-borrow-flow">2. Deposit and Borrow Flow</a></h3>
<p>The lending and borrowing process follows this sequence:</p>
<pre class="mermaid">graph TD
    A[User] --&gt;|Deposit Assets| B[Lending Pool]
    B --&gt;|Create Position| C[User Position]
    C --&gt;|Calculate Capacity| D[Borrow Limit]
    D --&gt;|Enable Borrowing| E[Borrow Assets]
    E --&gt;|Update Metrics| F[Pool Metrics]
    F --&gt;|Adjust Rates| G[Interest Rates]
</pre>
<p>Key steps:</p>
<ol>
<li>User deposits assets into the pool</li>
<li>System creates or updates user position</li>
<li>Calculates borrowing capacity based on collateral</li>
<li>Enables borrowing up to the limit</li>
<li>Updates pool metrics and interest rates</li>
</ol>
<h3 id="3-health-monitoring-system"><a class="header" href="#3-health-monitoring-system">3. Health Monitoring System</a></h3>
<p>Continuous health monitoring process:</p>
<pre class="mermaid">graph TD
    A[Price Oracle] --&gt;|Update Prices| B[Position Valuation]
    B --&gt;|Calculate Ratios| C[Health Check]
    C --&gt;|Evaluate| D{Health Factor}
    D --&gt;|&gt;1| E[Healthy]
    D --&gt;|&lt;1| F[At Risk]
    F --&gt;|&lt;Threshold| G[Liquidatable]
    G --&gt;|Notify| H[Liquidators]
</pre>
<p>The system:</p>
<ol>
<li>Continuously monitors asset prices</li>
<li>Updates position valuations</li>
<li>Calculates health factors</li>
<li>Triggers liquidations when necessary</li>
</ol>
<h3 id="withdrawal-process"><a class="header" href="#withdrawal-process">Withdrawal Process</a></h3>
<p>The withdrawal process in our lending protocol involves two key components:</p>
<ol>
<li>State management through program accounts</li>
<li>Actual BTC transfer through UTXOs</li>
</ol>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct WithdrawRequest {
    pub user_pubkey: Pubkey,
    pub pool_pubkey: Pubkey,
    pub amount: u64,
    pub recipient_btc_address: String,
}

pub fn process_withdrawal(
    ctx: Context&lt;ProcessWithdraw&gt;,
    request: WithdrawRequest,
) -&gt; Result&lt;()&gt; {
    let pool = &amp;mut ctx.accounts.lending_pool;
    let user_position = &amp;mut ctx.accounts.user_position;

    // 1. Validate user position
    require!(
        user_position.deposited_amount &gt;= request.amount,
        ErrorCode::InsufficientBalance
    );

    // 2. Check pool liquidity
    require!(
        pool.available_liquidity() &gt;= request.amount,
        ErrorCode::InsufficientLiquidity
    );

    // 3. Find available UTXOs from pool
    let selected_utxos = select_utxos_for_withdrawal(
        &amp;pool.utxos,
        request.amount
    )?;

    // 4. Create Bitcoin withdrawal transaction
    let mut btc_tx = Transaction::new();
    
    // Add inputs from selected UTXOs
    for utxo in selected_utxos {
        btc_tx.input.push(TxIn {
            previous_output: OutPoint::new(utxo.txid, utxo.vout),
            script_sig: Script::new(),
            sequence: Sequence::MAX,
            witness: Witness::new(),
        });
    }

    // Add withdrawal output to user's address
    let recipient_script = Address::from_str(&amp;request.recipient_btc_address)?
        .script_pubkey();
    btc_tx.output.push(TxOut {
        value: request.amount,
        script_pubkey: recipient_script,
    });

    // Add change output back to pool if needed
    let total_input = selected_utxos.iter()
        .map(|utxo| utxo.amount)
        .sum::&lt;u64&gt;();
    if total_input &gt; request.amount {
        btc_tx.output.push(TxOut {
            value: total_input - request.amount,
            script_pubkey: get_account_script_pubkey(&amp;pool.pool_pubkey),
        });
    }

    // 5. Set transaction for validator signing
    set_transaction_to_sign(
        ctx.accounts,
        TransactionToSign {
            tx_bytes: &amp;bitcoin::consensus::serialize(&amp;btc_tx),
            inputs_to_sign: &amp;selected_utxos.iter()
                .enumerate()
                .map(|(i, _)| InputToSign {
                    index: i as u32,
                    signer: pool.pool_pubkey,
                })
                .collect::&lt;Vec&lt;_&gt;&gt;()
        }
    );

    // 6. Update pool state
    pool.total_deposits = pool.total_deposits
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 7. Update user position
    user_position.deposited_amount = user_position.deposited_amount
        .checked_sub(request.amount)
        .ok_or(ErrorCode::MathOverflow)?;

    // 8. Remove spent UTXOs from pool
    pool.utxos.retain(|utxo| !selected_utxos.contains(utxo));

    Ok(())
}

fn select_utxos_for_withdrawal(
    pool_utxos: &amp;[UtxoMeta],
    amount: u64,
) -&gt; Result&lt;Vec&lt;UtxoMeta&gt;&gt; {
    let mut selected = Vec::new();
    let mut total_selected = 0;

    for utxo in pool_utxos {
        if total_selected &gt;= amount {
            break;
        }
        
        // Verify UTXO is still valid and unspent
        validate_utxo(utxo)?;
        
        selected.push(utxo.clone());
        total_selected += utxo.amount;
    }

    require!(
        total_selected &gt;= amount,
        ErrorCode::InsufficientUtxos
    );

    Ok(selected)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-1"><a class="header" href="#program-1">Program</a></h1>
<p>A program is a special kind of <a href="program/./accounts.html">account</a> that contains executable <a href="https://ebpf.io">eBPF</a> bytecode, denoted by the <code>Account.is_executable: true</code> field. This allows an account to receive arbitrary <a href="program/./instructions-and-messages.html#instructions">instruction</a> data via a <a href="program/./transaction.html">transaction</a> to be processed by the runtime.</p>
<p>Every program is stateless, meaning that it can only read/write data to other accounts and that it <strong>cannot</strong> write to its own account; this, in-part, is how parallelized execution is made possible (see <a href="program/program.html#4-state">State</a> for more info).</p>
<blockquote>
<p>💡 Additionally, programs can send instructions to other programs which, in turn, receive instructions and thus extend program composability further. This is known as cross-program invocation (CPI) and will be detailed in future sections.</p>
</blockquote>
<h3 id="components-1"><a class="header" href="#components-1">Components:</a></h3>
<h4 id="1-entrypoint-1"><a class="header" href="#1-entrypoint-1">1. <a href="program/./entrypoint.html">Entrypoint</a></a></h4>
<p>Every Arch program includes a single entrypoint used to invoke the program. A <a href="program/./entrypoint.html#handler-function">handler function</a>, often named <code>process_instruction</code>, is then used to handle the data passed into the entrypoint.</p>
<p><em>These parameters are required for every <a href="program/./instructions-and-messages.html#instructions">instruction</a> to be processed.</em>_</p>
<pre><code class="language-rust ignore">use arch_program::entrypoint;
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
    // Program logic here
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<h4 id="2-instruction-1"><a class="header" href="#2-instruction-1">2. <a href="program/./instructions-and-messages.html#instructions">Instruction</a></a></h4>
<p>The <code>instruction_data</code> is deserialized after being passed into the entrypoint. From there, if there are multiple instructions, a <code>match</code> statement can be utilized to point the logic flow to the appropriate handler function previously defined within the program which can continue processing the instruction.</p>
<h4 id="3-process-instruction-1"><a class="header" href="#3-process-instruction-1">3. Process Instruction</a></h4>
<p>If a program has multiple instructions, a corresponding <a href="program/./entrypoint.html#handler-function">handler function</a> should be defined to include the specific logic unique to the instruction.</p>
<h4 id="4-state-1"><a class="header" href="#4-state-1">4. State</a></h4>
<p>Since programs are stateless, a “data” <a href="program/./accounts.html">account</a> is needed to hold state for a user. This is a non-executable account that holds program data.</p>
<p>If a program receives instruction that results in a user’s state being altered, the program would manage this user’s state via a mapping within the program’s logic. This mapping would link the user’s <a href="program/./pubkey.html">pubkey</a> with a data <a href="program/./accounts.html">account</a> where the state would live for that specific program.</p>
<p>The program will likely include a struct to define the structure of its state and make it easier to work with. The deserialization of account data occurs during program invocation. After an update is made, state data gets re-serialized into a byte array and stored within the <code>data</code> field of the <a href="program/./accounts.html">account</a>.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-structure"><a class="header" href="#account-structure">Account Structure</a></h1>
<blockquote>
<p><strong>Navigation</strong>: <a href="program/../SUMMARY.html#reference">Reference</a> → <a href="program/./program.html">Program</a> → Account Structure</p>
<p>For a comprehensive guide on working with accounts, see the <a href="program/./accounts.html">Account Guide</a>.</p>
</blockquote>
<p>Accounts are a fundamental data structure in Arch that store state and are owned by [programs]. Each account has a unique address ([pubkey]) and contains data that can be modified by its owner program.</p>
<h2 id="account-structure-1"><a class="header" href="#account-structure-1">Account Structure</a></h2>
<pre><code class="language-rust ignore">#[derive(Clone)]
#[repr(C)]
pub struct AccountInfo&lt;'a&gt; {
    pub key: &amp;'a Pubkey, // address of the account
    pub utxo: &amp;'a UtxoMeta, // utxo has this account key in script_pubkey
    pub data: Rc&lt;RefCell&lt;&amp;'a mut [u8]&gt;&gt;, 
    pub owner: &amp;'a Pubkey, 
    pub is_signer: bool,
    pub is_writable: bool,
    pub is_executable: bool, // true: program; false: data account
}</code></pre>
<h3 id="accountmeta"><a class="header" href="#accountmeta">AccountMeta</a></h3>
<pre><code class="language-rust ignore">#[derive(Debug, PartialEq, Eq, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
#[repr(C)]
pub struct AccountMeta {
    pub pubkey: Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/account.rs">account.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="account-guide"><a class="header" href="#account-guide">Account Guide</a></h1>
<blockquote>
<p><strong>Navigation</strong>: <a href="program/../SUMMARY.html#reference">Reference</a> → <a href="program/./program.html">Program</a> → Account Guide</p>
<p>For the core account structure and data types, see <a href="program/./account.html">Account Structure</a>.</p>
</blockquote>
<p>Accounts are the fundamental building blocks for state management and program interaction in Arch Network. They serve as containers for both program code and state data, bridging the gap between Bitcoin’s UTXO model and modern programmable state machines.</p>
<blockquote>
<p><strong>Note</strong>: For detailed documentation on core system functions used to interact with accounts (like <code>invoke</code>, <code>new_create_account_instruction</code>, <code>add_state_transition</code>, and <code>set_transaction_to_sign</code>), see <a href="program/./system-functions.html">System Functions</a>.</p>
</blockquote>
<pre class="mermaid">flowchart TD
    A[Account] --&gt; B[Program Account]
    A --&gt; C[Data Account]
    A --&gt; D[Native Account]
    B --&gt; E[Executable Code]
    C --&gt; F[Program State]
    C --&gt; G[UTXOs]
    D --&gt; H[System Operations]

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#f5f5f5,stroke:#666
    style C fill:#f5f5f5,stroke:#666
    style D fill:#f5f5f5,stroke:#666
</pre>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="account-fundamentals"><a class="header" href="#account-fundamentals">Account Fundamentals</a></h3>
<p>Every account in Arch Network is uniquely identified by a public key (pubkey) and contains four essential components:</p>
<pre><code class="language-rust ignore">pub struct Account {
    /// The program that owns this account
    pub owner: Pubkey,
    /// Number of lamports assigned to this account
    pub lamports: u64,
    /// Data held in this account
    pub data: Vec&lt;u8&gt;,
    /// Whether this account can process instructions
    pub executable: bool,
}</code></pre>
<h4 id="component-details"><a class="header" href="#component-details">Component Details:</a></h4>
<ol>
<li>
<p><strong>Owner (Pubkey)</strong></p>
<ul>
<li>Controls account modifications</li>
<li>Determines which program can modify data</li>
<li>Can be transferred to new programs</li>
<li>Required for all accounts</li>
</ul>
</li>
<li>
<p><strong>Lamports (u64)</strong></p>
<ul>
<li>Native token balance</li>
<li>Used for:
<ul>
<li>Transaction fees</li>
<li>Rent payments</li>
<li>State storage costs</li>
<li>Program execution fees</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Data (Vec<u8>)</strong></p>
<ul>
<li>Flexible byte array for state storage</li>
<li>Common uses:
<ul>
<li>Program code (if executable)</li>
<li>Program state</li>
<li>UTXO metadata</li>
<li>Configuration data</li>
</ul>
</li>
<li>Size determined at creation</li>
</ul>
</li>
<li>
<p><strong>Executable Flag (bool)</strong></p>
<ul>
<li>Determines if account contains program code</li>
<li>Immutable after deployment</li>
<li>Controls instruction processing capability</li>
</ul>
</li>
</ol>
<pre class="mermaid">flowchart LR
    A[Account Creation] --&gt; B[Initial State]
    B --&gt; C[Runtime Operations]
    C --&gt; D[State Updates]
    D --&gt; E[Account Closure]
    
    subgraph Lifecycle
        A -. Initialize .-&gt; B
        B -. Process Instructions .-&gt; C
        C -. Modify State .-&gt; D
        D -. Cleanup .-&gt; E
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#9ff,stroke:#333,stroke-width:2px
    style Lifecycle fill:#f5f5f5,stroke:#666,stroke-width:1px
</pre>
<h2 id="account-types--use-cases"><a class="header" href="#account-types--use-cases">Account Types &amp; Use Cases</a></h2>
<h3 id="1-program-accounts"><a class="header" href="#1-program-accounts">1. Program Accounts</a></h3>
<p>Program accounts contain executable code and form the backbone of Arch Network’s programmable functionality.</p>
<pre><code class="language-rust ignore">// Example program account creation
let program_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(program_data.len()),
    space: program_data.len() as u64,
    owner: bpf_loader::id(),  // BPF Loader owns program accounts
    executable: true,
    data: program_data,
};</code></pre>
<p>Key characteristics:</p>
<ul>
<li>Immutable after deployment</li>
<li>Owned by BPF loader</li>
<li>Contains verified program code</li>
<li>Processes instructions</li>
</ul>
<h3 id="2-data-accounts"><a class="header" href="#2-data-accounts">2. Data Accounts</a></h3>
<p>Data accounts store program state and user data. They’re highly flexible and can be structured to meet various needs.</p>
<pre><code class="language-rust ignore">// Example data structure for a game account
#[derive(BorshSerialize, BorshDeserialize)]
pub struct GameAccount {
    pub player: Pubkey,
    pub score: u64,
    pub level: u8,
    pub achievements: Vec&lt;Achievement&gt;,
    pub last_played: i64,
}

// Creating a data account
let game_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;GameAccount&gt;()),
    space: size_of::&lt;GameAccount&gt;() as u64,
    owner: game_program::id(),
    executable: false,
    data: Vec::new(),  // Will be initialized by program
};</code></pre>
<p>Common use cases:</p>
<ul>
<li>Player profiles</li>
<li>Game state</li>
<li>DeFi positions</li>
<li>NFT metadata</li>
<li>Configuration settings</li>
</ul>
<h3 id="3-utxo-accounts"><a class="header" href="#3-utxo-accounts">3. UTXO Accounts</a></h3>
<p>Special data accounts that bridge Bitcoin UTXOs with Arch Network state.</p>
<pre><code class="language-rust ignore">#[derive(BorshSerialize, BorshDeserialize)]
pub struct UtxoAccount {
    pub meta: UtxoMeta,
    pub owner: Pubkey,
    pub delegate: Option&lt;Pubkey&gt;,
    pub state: UtxoState,
    pub created_at: i64,
    pub last_updated: i64,
    pub constraints: Vec&lt;UtxoConstraint&gt;,
}

// Example UTXO account creation
let utxo_account = SystemInstruction::CreateAccount {
    lamports: rent.minimum_balance(size_of::&lt;UtxoAccount&gt;()),
    space: size_of::&lt;UtxoAccount&gt;() as u64,
    owner: utxo_program::id(),
    executable: false,
    data: Vec::new(),
};</code></pre>
<h2 id="account-interactions"><a class="header" href="#account-interactions">Account Interactions</a></h2>
<p>Account interactions in Arch Network are facilitated through a set of core system functions. These functions handle everything from account creation to state transitions and are documented in detail in <a href="program/./system-functions.html">System Functions</a>. Below are common patterns for account interactions:</p>
<h3 id="1-creation-patterns"><a class="header" href="#1-creation-patterns">1. Creation Patterns</a></h3>
<pre><code class="language-rust ignore">// 1. Basic account creation
pub fn create_basic_account(
    payer: &amp;Keypair,
    space: u64,
    owner: &amp;Pubkey,
) -&gt; Result&lt;Keypair, Error&gt; {
    let account = Keypair::new();
    let rent = banks_client.get_rent().await?;
    let lamports = rent.minimum_balance(space as usize);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;account.pubkey(),
        lamports,
        space,
        owner,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[ix],
        Some(&amp;payer.pubkey()),
        &amp;[payer, &amp;account],
        recent_blockhash,
    );
    
    banks_client.process_transaction(tx).await?;
    Ok(account)
}

// 2. PDA (Program Derived Address) creation
pub fn create_pda_account(
    program_id: &amp;Pubkey,
    seeds: &amp;[&amp;[u8]],
    space: u64,
) -&gt; Result&lt;Pubkey, Error&gt; {
    let (pda, bump) = Pubkey::find_program_address(seeds, program_id);
    
    let ix = system_instruction::create_account(
        &amp;payer.pubkey(),
        &amp;pda,
        lamports,
        space,
        program_id,
    );
    
    // Include the bump seed for deterministic address
    let seeds_with_bump = &amp;[&amp;seeds[..], &amp;[&amp;[bump]]].concat();
    let signer_seeds = &amp;[&amp;seeds_with_bump[..]];
    
    invoke_signed(&amp;ix, &amp;[payer, pda], signer_seeds)?;
    Ok(pda)
}</code></pre>
<h3 id="2-state-management"><a class="header" href="#2-state-management">2. State Management</a></h3>
<pre><code class="language-rust ignore">// Example of managing account state
pub trait AccountState: Sized {
    fn try_from_slice(data: &amp;[u8]) -&gt; Result&lt;Self, Error&gt;;
    fn try_serialize(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
    
    fn load(account: &amp;AccountInfo) -&gt; Result&lt;Self, Error&gt; {
        Self::try_from_slice(&amp;account.data.borrow())
    }
    
    fn save(&amp;self, account: &amp;AccountInfo) -&gt; Result&lt;(), Error&gt; {
        let data = self.try_serialize()?;
        let mut account_data = account.data.borrow_mut();
        account_data[..data.len()].copy_from_slice(&amp;data);
        Ok(())
    }
}

// Implementation example
impl AccountState for GameAccount {
    fn update_score(&amp;mut self, new_score: u64) -&gt; Result&lt;(), Error&gt; {
        self.score = new_score;
        self.last_played = Clock::get()?.unix_timestamp;
        Ok(())
    }
}</code></pre>
<h3 id="3-cross-program-invocation-cpi"><a class="header" href="#3-cross-program-invocation-cpi">3. Cross-Program Invocation (CPI)</a></h3>
<pre><code class="language-rust ignore">// Example of one program calling another
pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; ProgramResult {
    // Deserialize accounts
    let account_info_iter = &amp;mut accounts.iter();
    let source_info = next_account_info(account_info_iter)?;
    let dest_info = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;
    
    // Create CPI context
    let cpi_accounts = Transfer {
        from: source_info.clone(),
        to: dest_info.clone(),
    };
    let cpi_program = system_program.clone();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    
    // Perform cross-program invocation
    transfer(cpi_ctx, amount)?;
    
    Ok(())
}</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="1-access-control"><a class="header" href="#1-access-control">1. Access Control</a></h3>
<pre><code class="language-rust ignore">fn verify_account_access(
    account: &amp;AccountInfo,
    expected_owner: &amp;Pubkey,
    writable: bool,
) -&gt; ProgramResult {
    // Check account ownership
    if account.owner != expected_owner {
        return Err(ProgramError::IncorrectProgramId);
    }
    
    // Verify write permission if needed
    if writable &amp;&amp; !account.is_writable {
        return Err(ProgramError::InvalidAccountData);
    }
    
    // Additional checks...
    Ok(())
}</code></pre>
<h3 id="2-data-validation"><a class="header" href="#2-data-validation">2. Data Validation</a></h3>
<pre><code class="language-rust ignore">fn validate_account_data&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    validate_fn: impl Fn(&amp;T) -&gt; bool,
) -&gt; ProgramResult {
    // Load and validate account data
    let data = T::load(account)?;
    if !validate_fn(&amp;data) {
        return Err(ProgramError::InvalidAccountData);
    }
    Ok(())
}</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="1-account-management"><a class="header" href="#1-account-management">1. Account Management</a></h3>
<ul>
<li>Always validate account ownership before modifications</li>
<li>Use PDAs for deterministic addresses</li>
<li>Implement proper error handling</li>
<li>Close unused accounts to reclaim rent</li>
</ul>
<h3 id="2-data-safety"><a class="header" href="#2-data-safety">2. Data Safety</a></h3>
<ul>
<li>Validate all input data</li>
<li>Use proper serialization</li>
<li>Handle account size limits</li>
<li>Implement atomic operations</li>
</ul>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<ul>
<li>Minimize account creations</li>
<li>Batch operations when possible</li>
<li>Use appropriate data structures</li>
<li>Cache frequently accessed data</li>
</ul>
<h3 id="4-upgrades"><a class="header" href="#4-upgrades">4. Upgrades</a></h3>
<ul>
<li>Plan for version management</li>
<li>Implement migration strategies</li>
<li>Use flexible data structures</li>
<li>Document state changes</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="1-account-initialization"><a class="header" href="#1-account-initialization">1. Account Initialization</a></h3>
<pre><code class="language-rust ignore">pub fn initialize_account&lt;T: AccountState&gt;(
    program_id: &amp;Pubkey,
    account: &amp;AccountInfo,
    initial_state: T,
) -&gt; ProgramResult {
    // Verify account is uninitialized
    if !account.data_is_empty() {
        return Err(ProgramError::AccountAlreadyInitialized);
    }
    
    // Set account owner
    account.set_owner(program_id)?;
    
    // Initialize state
    initial_state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="2-account-updates"><a class="header" href="#2-account-updates">2. Account Updates</a></h3>
<pre><code class="language-rust ignore">pub fn update_account&lt;T: AccountState&gt;(
    account: &amp;AccountInfo,
    update_fn: impl FnOnce(&amp;mut T) -&gt; ProgramResult,
) -&gt; ProgramResult {
    // Load current state
    let mut state = T::load(account)?;
    
    // Apply update
    update_fn(&amp;mut state)?;
    
    // Save updated state
    state.save(account)?;
    
    Ok(())
}</code></pre>
<h3 id="3-account-closure"><a class="header" href="#3-account-closure">3. Account Closure</a></h3>
<pre><code class="language-rust ignore">pub fn close_account(
    account: &amp;AccountInfo,
    destination: &amp;AccountInfo,
) -&gt; ProgramResult {
    // Transfer lamports
    let dest_starting_lamports = destination.lamports();
    **destination.lamports.borrow_mut() = dest_starting_lamports
        .checked_add(account.lamports())
        .ok_or(ProgramError::Overflow)?;
    **account.lamports.borrow_mut() = 0;
    
    // Clear data
    account.data.borrow_mut().fill(0);
    
    Ok(())
}</code></pre>
<h2 id="related-topics-1"><a class="header" href="#related-topics-1">Related Topics</a></h2>
<ul>
<li><a href="program/./utxo.html">UTXOs</a> - How UTXOs integrate with accounts</li>
<li><a href="program/./program.html">Programs</a> - Programs that own and modify accounts</li>
<li><a href="program/./instructions-and-messages.html">Instructions</a> - How to interact with accounts</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-functions"><a class="header" href="#system-functions">System Functions</a></h1>
<blockquote>
<p><strong>Navigation</strong>: <a href="program/../SUMMARY.html#reference">Reference</a> → <a href="program/./program.html">Program</a> → System Functions</p>
</blockquote>
<p>Core system functions that enable program interactions, account management, and state transitions in Arch Network.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>These functions form the foundation for program-to-program communication, account management, and state transitions in Arch Network:</p>
<ol>
<li><code>invoke</code> - Cross-program invocation</li>
<li><code>new_create_account_instruction</code> - Account creation</li>
<li><code>add_state_transition</code> - State management</li>
<li><code>set_transaction_to_sign</code> - Transaction preparation</li>
</ol>
<h2 id="detailed-function-documentation"><a class="header" href="#detailed-function-documentation">Detailed Function Documentation</a></h2>
<h3 id="1-invoke"><a class="header" href="#1-invoke">1. <code>invoke</code></a></h3>
<pre><code class="language-rust ignore">pub fn invoke(instruction: &amp;Instruction, account_infos: &amp;[AccountInfo]) -&gt; ProgramResult</code></pre>
<p>The <code>invoke</code> function enables cross-program communication and execution:</p>
<ul>
<li><strong>Purpose</strong>: Allows one program to call another program securely</li>
<li><strong>Key Features</strong>:
<ul>
<li>Validates account permissions</li>
<li>Manages account borrowing</li>
<li>Handles cross-program context</li>
<li>Provides error handling</li>
</ul>
</li>
</ul>
<p><strong>Example Usage</strong>:</p>
<pre><code class="language-rust ignore">// Invoke system program to create account
invoke(
    &amp;SystemInstruction::new_create_account_instruction(
        txid.try_into().unwrap(),
        vout,
        account_pubkey
    ),
    &amp;[account_info.clone()]
)?;</code></pre>
<h3 id="2-new_create_account_instruction"><a class="header" href="#2-new_create_account_instruction">2. <code>new_create_account_instruction</code></a></h3>
<pre><code class="language-rust ignore">pub fn new_create_account_instruction(
    txid: [u8; 32],
    vout: u32,
    pubkey: Pubkey,
) -&gt; Instruction</code></pre>
<p>Creates instructions for new account initialization:</p>
<ul>
<li><strong>Purpose</strong>: Creates new accounts with UTXO backing</li>
<li><strong>Key Features</strong>:
<ul>
<li>Sets up UTXO metadata</li>
<li>Configures permissions</li>
<li>Associates with system program</li>
<li>Prepares initialization</li>
</ul>
</li>
</ul>
<p><strong>Example Usage</strong>:</p>
<pre><code class="language-rust ignore">let instruction = SystemInstruction::new_create_account_instruction(
    txid.try_into().unwrap(),
    0,  // vout index
    account_pubkey,
);</code></pre>
<h3 id="3-add_state_transition"><a class="header" href="#3-add_state_transition">3. <code>add_state_transition</code></a></h3>
<pre><code class="language-rust ignore">pub fn add_state_transition(transaction: &amp;mut Transaction, account: &amp;AccountInfo)</code></pre>
<p>Manages state transitions for accounts:</p>
<ul>
<li><strong>Purpose</strong>: Updates Bitcoin transactions with account changes</li>
<li><strong>Key Features</strong>:
<ul>
<li>Adds UTXO inputs</li>
<li>Sets up script signatures</li>
<li>Configures outputs</li>
<li>Manages state</li>
</ul>
</li>
</ul>
<p><strong>Example Usage</strong>:</p>
<pre><code class="language-rust ignore">let mut tx = Transaction {
    version: Version::TWO,
    lock_time: LockTime::ZERO,
    input: vec![],
    output: vec![],
};
add_state_transition(&amp;mut tx, account);</code></pre>
<h3 id="4-set_transaction_to_sign"><a class="header" href="#4-set_transaction_to_sign">4. <code>set_transaction_to_sign</code></a></h3>
<pre><code class="language-rust ignore">pub fn set_transaction_to_sign(
    accounts: &amp;[AccountInfo],
    transaction_to_sign: TransactionToSign,
) -&gt; ProgramResult</code></pre>
<p>Prepares transactions for signing:</p>
<ul>
<li><strong>Purpose</strong>: Sets up transaction metadata and permissions</li>
<li><strong>Key Features</strong>:
<ul>
<li>Validates size limits</li>
<li>Checks signer permissions</li>
<li>Sets up metadata</li>
<li>Manages requirements</li>
</ul>
</li>
</ul>
<p><strong>Example Usage</strong>:</p>
<pre><code class="language-rust ignore">let transaction_to_sign = TransactionToSign {
    tx_bytes: serialized_tx,
    inputs_to_sign: vec![
        InputToSign {
            signer: account.key,
            ..Default::default()
        }
    ],
};
set_transaction_to_sign(accounts, transaction_to_sign)?;</code></pre>
<pre class="mermaid">graph LR
    A[Program Request] ==&gt; B[new_create_account_instruction]
    B ==&gt; C[invoke]
    C ==&gt; D[add_state_transition]
    D ==&gt; E[set_transaction_to_sign]
    E ==&gt; F[Bitcoin Transaction]

    style A fill:#4a9eff,stroke:#3182ce,stroke-width:2px,color:#fff
    style B fill:#ffffff,stroke:#ccd7e0,stroke-width:2px
    style C fill:#ffffff,stroke:#ccd7e0,stroke-width:2px
    style D fill:#ffffff,stroke:#ccd7e0,stroke-width:2px
    style E fill:#ffffff,stroke:#ccd7e0,stroke-width:2px
    style F fill:#f687b3,stroke:#d53f8c,stroke-width:2px,color:#fff
</pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li>
<p><strong>Validation</strong></p>
<ul>
<li>Always check account permissions</li>
<li>Verify transaction limits</li>
<li>Validate UTXO states</li>
<li>Handle errors properly</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Use atomic operations</li>
<li>Maintain state consistency</li>
<li>Handle failures gracefully</li>
<li>Implement rollbacks</li>
</ul>
</li>
<li>
<p><strong>Security</strong></p>
<ul>
<li>Validate all signatures</li>
<li>Check account ownership</li>
<li>Verify transaction data</li>
<li>Handle edge cases</li>
</ul>
</li>
</ol>
<h2 id="related-topics-2"><a class="header" href="#related-topics-2">Related Topics</a></h2>
<ul>
<li><a href="program/./accounts.html">Accounts</a></li>
<li><a href="program/./utxo.html">UTXOs</a></li>
<li><a href="program/./program.html">Programs</a></li>
<li><a href="program/./instructions-and-messages.html">Instructions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrypoint-and-handler-functions"><a class="header" href="#entrypoint-and-handler-functions">Entrypoint and Handler Functions</a></h1>
<h2 id="entrypoint-1"><a class="header" href="#entrypoint-1">Entrypoint</a></h2>
<p>Every Arch program includes a single entrypoint used to invoke the program. A <a href="program/entrypoint.html#handler-function">handler function</a> is then used to process the data passed into the entrypoint.</p>
<pre><code class="language-rust ignore">entrypoint!(process_instruction);</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<h4 id="initialization-and-data-reading"><a class="header" href="#initialization-and-data-reading">Initialization and Data Reading:</a></h4>
<p>The entrypoint begins by initializing and reading serialized data that is passed in, which includes everything needed for program execution. It then deserializes this data to obtain the <a href="program/../program/instruction.html">instruction</a>, an object which contains all necessary details like the <code>program_id</code> and associated <a href="program/../program/utxo.html">UTXO</a> information.</p>
<p>It passes in all deserialized data in to the <a href="program/entrypoint.html#handler-function">handler function</a> for processing of the <a href="program/../program/program.html">program</a>’s business logic; this could involve transactions, state updates, or other program-specific operations.</p>
<h2 id="handler-function"><a class="header" href="#handler-function">Handler function</a></h2>
<p>Here we’ll discuss the dispatcher function, in our case, named: <code>process_instruction</code>.</p>
<p>This dispatcher function requires the following parameters:</p>
<ul>
<li><code>program_id</code> - Unique identifier of the currently executing program.</li>
<li><code>accounts</code> - Slice reference containing accounts needed to execute an instruction.</li>
<li><code>instruction_data</code> - Serialized data containing program instructions.</li>
</ul>
<p>This returns a <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> representing success (<code>Ok</code>) or failture (<a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/program_error.rs"><code>ProgramError</code></a>).</p>
<pre><code class="language-rust ignore">pub fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -&gt; Result&lt;(), ProgramError&gt; {
...
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/examples/helloworld/program/src/lib.rs">lib.rs</a></p>
<p>This function is responsible for parsing and directing the execution flow based on the type of transaction or method specified. It is a critical component that developers must implement to ensure that their programs can appropriately respond to different operational requests.</p>
<p>The handler function is defined as part of the program and is facilitated via the <a href="program/entrypoint.html#entrypoint"><code>entrypoint!</code></a>. This macro binds the <code>process_instruction</code> function to be the first receiver of any execution call made by the Arch virtual machine, effectively making it the gatekeeper for all incoming instructions.</p>
<h4 id="deserialize-input-data"><a class="header" href="#deserialize-input-data">Deserialize Input Data</a></h4>
<p>The function starts by deserializing the input data (<code>instruction_data</code>) into a known format, typically a custom struct that represents different methods or commands the program can execute.</p>
<h4 id="method-dispatch"><a class="header" href="#method-dispatch">Method Dispatch</a></h4>
<p>Based on the deserialized data, the function determines which specific method to execute. This is often handled through a match statement that routes to different functions or modules within the program.</p>
<h4 id="execute-business-logic"><a class="header" href="#execute-business-logic">Execute Business Logic</a></h4>
<p>Each routed function performs specific business logic related to the program’s purpose, such as managing assets, updating state, or interacting with other program or tokens.</p>
<h4 id="result-commitment"><a class="header" href="#result-commitment">Result Commitment:</a></h4>
<p>Upon successful execution, the new UTXO authorities, new UTXO Data and a Bitcoin transaction are committed back to the network.</p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="instructions-and-messages"><a class="header" href="#instructions-and-messages">Instructions and Messages</a></h1>
<p>Instructions and messages are fundamental components of Arch’s transaction processing system that enable communication between clients and <a href="program/./program.html">programs</a>. They form the basis for all state changes and interactions within the Arch network.</p>
<h3 id="instructions"><a class="header" href="#instructions">Instructions</a></h3>
<p>An instruction is the basic unit of program execution in Arch. It contains all the information needed for a <a href="program/./program.html">program</a> to execute a specific operation. Instructions are processed atomically, meaning they either complete entirely or have no effect.</p>
<h4 id="structure"><a class="header" href="#structure">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Instruction {
    /// Program ID that executes this instruction
    pub program_id: Pubkey,
    /// Accounts required for this instruction
    pub accounts: Vec&lt;AccountMeta&gt;,
    /// Instruction data
    pub data: Vec&lt;u8&gt;,
}</code></pre>
<h4 id="components-2"><a class="header" href="#components-2">Components:</a></h4>
<ol>
<li><strong>Program ID</strong>: The <a href="program/./pubkey.html">pubkey</a> of the <a href="program/./program.html">program</a> that will process the instruction</li>
<li><strong>Accounts</strong>: List of accounts required for the instruction, with their metadata</li>
<li><strong>Instruction Data</strong>: Custom data specific to the instruction, typically serialized using Borsh or another format</li>
</ol>
<h4 id="account-metadata"><a class="header" href="#account-metadata">Account Metadata</a></h4>
<pre><code class="language-rust ignore">pub struct AccountMeta {
    pub pubkey: Pubkey,
    pub is_signer: bool,
    pub is_writable: bool,
}</code></pre>
<ul>
<li><code>pubkey</code>: The account’s public key</li>
<li><code>is_signer</code>: Whether the account must sign the transaction</li>
<li><code>is_writable</code>: Whether the account’s data can be modified</li>
</ul>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>A message is a collection of instructions that form a <a href="program/./transaction.html">transaction</a>. Messages ensure atomic execution of multiple instructions, meaning either all instructions succeed or none take effect.</p>
<h4 id="structure-1"><a class="header" href="#structure-1">Structure</a></h4>
<pre><code class="language-rust ignore">pub struct Message {
    /// List of account keys referenced by the instructions
    pub account_keys: Vec&lt;Pubkey&gt;,
    /// Recent blockhash
    pub recent_blockhash: Hash,
    /// List of instructions to execute
    pub instructions: Vec&lt;CompiledInstruction&gt;,
}</code></pre>
<h4 id="components-3"><a class="header" href="#components-3">Components:</a></h4>
<ol>
<li><strong>Account Keys</strong>: All unique accounts referenced across instructions</li>
<li><strong>Recent Blockhash</strong>: Used for transaction uniqueness and timeout</li>
<li><strong>Instructions</strong>: List of instructions to execute in sequence</li>
</ol>
<h3 id="instruction-processing-flow"><a class="header" href="#instruction-processing-flow">Instruction Processing Flow:</a></h3>
<ol>
<li>
<p>Client creates an instruction with:</p>
<ul>
<li><a href="program/./program.html">Program</a> ID to execute the instruction</li>
<li>Required accounts with appropriate permissions</li>
<li>Instruction-specific data (serialized parameters)</li>
</ul>
</li>
<li>
<p>Instruction(s) are bundled into a message:</p>
<ul>
<li>Multiple instructions can be atomic</li>
<li>Account permissions are consolidated</li>
<li>Blockhash is included for uniqueness</li>
</ul>
</li>
<li>
<p>Message is signed to create a <a href="program/./transaction.html">transaction</a>:</p>
<ul>
<li>All required signers must sign</li>
<li>Transaction size limits apply</li>
<li>Fees are calculated</li>
</ul>
</li>
<li>
<p>Transaction is sent to the network:</p>
<ul>
<li>Validated by validators</li>
<li>Processed in parallel when possible</li>
<li>Results are confirmed</li>
</ul>
</li>
<li>
<p>Program processes the instruction:</p>
<ul>
<li>Deserializes instruction data</li>
<li>Validates accounts and permissions</li>
<li>Executes operation</li>
<li>Updates account state</li>
</ul>
</li>
</ol>
<h3 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices:</a></h3>
<ol>
<li>
<p><strong>Account Validation</strong></p>
<ul>
<li>Always verify account ownership</li>
<li>Check account permissions</li>
<li>Validate account relationships</li>
</ul>
</li>
<li>
<p><strong>Data Serialization</strong></p>
<ul>
<li>Use consistent serialization format (preferably Borsh)</li>
<li>Include version information</li>
<li>Handle errors gracefully</li>
<li>Validate data lengths</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong></p>
<ul>
<li>Return specific error types</li>
<li>Provide clear error messages</li>
<li>Handle all edge cases</li>
<li>Implement proper cleanup</li>
</ul>
</li>
</ol>
<h3 id="cross-program-invocation-cpi"><a class="header" href="#cross-program-invocation-cpi">Cross-Program Invocation (CPI)</a></h3>
<p>Instructions can invoke other <a href="program/./program.html">programs</a> through CPI, enabling composability:</p>
<ol>
<li>
<p>Create new instruction for target program:</p>
<ul>
<li>Specify program ID</li>
<li>Include required accounts</li>
<li>Prepare instruction data</li>
</ul>
</li>
<li>
<p>Pass required accounts:</p>
<ul>
<li>Include all necessary accounts</li>
<li>Set proper permissions</li>
<li>Handle PDA derivation</li>
</ul>
</li>
<li>
<p>Invoke using <code>invoke</code> or <code>invoke_signed</code>:</p>
<ul>
<li>For regular accounts: <code>invoke</code></li>
<li>For PDAs: <code>invoke_signed</code></li>
<li>Handle return values</li>
</ul>
</li>
<li>
<p>Handle results:</p>
<ul>
<li>Check return status</li>
<li>Process any returned data</li>
<li>Handle errors appropriately</li>
</ul>
</li>
</ol>
<h3 id="security-considerations-2"><a class="header" href="#security-considerations-2">Security Considerations:</a></h3>
<ol>
<li>
<p><strong>Account Verification</strong></p>
<ul>
<li>Verify all account permissions</li>
<li>Check ownership and signatures</li>
<li>Validate account relationships</li>
<li>Prevent privilege escalation</li>
</ul>
</li>
<li>
<p><strong>Data Validation</strong></p>
<ul>
<li>Sanitize all input data</li>
<li>Check buffer lengths</li>
<li>Validate numerical ranges</li>
<li>Prevent integer overflow</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Maintain atomic operations</li>
<li>Handle partial failures</li>
<li>Prevent race conditions</li>
<li>Ensure consistent state</li>
</ul>
</li>
</ol>
<h3 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns:</a></h3>
<ol>
<li>
<p><strong>Initialization</strong></p>
<ul>
<li>Create necessary accounts</li>
<li>Set initial state</li>
<li>Assign proper ownership</li>
</ul>
</li>
<li>
<p><strong>State Updates</strong></p>
<ul>
<li>Validate permissions</li>
<li>Update account data</li>
<li>Maintain invariants</li>
</ul>
</li>
<li>
<p><strong>Account Management</strong></p>
<ul>
<li>Close accounts when done</li>
<li>Manage PDAs properly</li>
</ul>
</li>
</ol>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubkey"><a class="header" href="#pubkey">Pubkey</a></h1>
<p>A pubkey, or public key, is a custom type that contains a 256-bit (32 bytes) integer derived from the private key.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct Pubkey([u8; 32]);</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/pubkey.rs">pubkey.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscalls"><a class="header" href="#syscalls">Syscalls</a></h1>
<p>A syscall is a function that can be used to obtain information from the underlying virtual machine.</p>
<pre><code class="language-rust ignore">// Used for cross-program invocation (CPI)

// Invokes a cross-program call
define_syscall!(fn sol_invoke_signed_rust(instruction_addr: *const u8, account_infos_addr: *const u8, account_infos_len: u64) -&gt; u64);

// Sets the data to be returned for the cross-program invocation
define_syscall!(fn sol_set_return_data(data: *const u8, length: u64));

// Returns the cross-program invocation data
define_syscall!(fn sol_get_return_data(data: *mut u8, length: u64, program_id: *mut Pubkey) -&gt; u64);

// Arch

// Validates and sets up transaction for being signed
define_syscall!(fn arch_set_transaction_to_sign(transaction_to_sign: *const TransactionToSign));

// Retrieves raw Bitcoin transaction from RPC and copies into memory buffer
define_syscall!(fn arch_get_bitcoin_tx(data: *mut u8, length: u64, txid: &amp;[u8; 32]) -&gt; u64);

// Retrieves the multi-sig public key and copies into memory buffer
define_syscall!(fn arch_get_network_xonly_pubkey(data: *mut u8) -&gt; u64);

// Validates ownership of a Bitcoin UTXO against a public key
define_syscall!(fn arch_validate_utxo_ownership(utxo: *const UtxoMeta, owner: *const Pubkey) -&gt; u64);

// Generates a Bitcoin script public key and copies into memory buffer
define_syscall!(fn arch_get_account_script_pubkey(script: *mut u8, pubkey: *const Pubkey) -&gt; u64);

// Retrieves the latest Bitcoin block height
define_syscall!(fn arch_get_bitcoin_block_height() -&gt; u64);

// logs

// Prints the hexidecimal representation of a string slice to stdout
define_syscall!(fn sol_log_(message: *const u8, len: u64));

// Prints 64-bit values represented as hexadecimal to stdout
define_syscall!(fn sol_log_64_(arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64));

// Prints the hexidecimal representation of a public key to stdout
define_syscall!(fn sol_log_pubkey(pubkey_addr: *const u8));

// Prints the base64 representation of a data array to stdout
define_syscall!(fn sol_log_data(data: *const u8, data_len: u64));</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/syscalls/definitions.rs">syscalls/definition.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-instruction"><a class="header" href="#system-instruction">System Instruction</a></h1>
<p>By default, every <a href="program/./account.html">account</a> is owned by the System Program (<a href="program/./pubkey.html">Pubkey</a>). Only the System Program can create a new account.</p>
<pre><code class="language-rust ignore">#[derive(Clone, PartialEq, Eq, Debug)]
pub enum SystemInstruction {
    CreateAccount(UtxoMeta),
    ExtendBytes(Vec&lt;u8&gt;),
}

...

pub fn new_create_account_instruction(
    txid: [u8; 32],
    vout: u32,
    pubkey: Pubkey,
) -&gt; Instruction {
    Instruction {
        program_id: Pubkey::system_program(),
        accounts: vec![AccountMeta {
            pubkey,
            is_signer: true,
            is_writable: true,
        }],
        data: SystemInstruction::CreateAccount(UtxoMeta::from(txid, vout)).serialise(),
    }
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/program/src/system_instruction.rs">system_instruction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-unspent-transaction-output-1"><a class="header" href="#utxo-unspent-transaction-output-1">UTXO (Unspent Transaction Output)</a></h1>
<p>UTXOs (Unspent Transaction Outputs) are fundamental to Bitcoin’s transaction model and serve as the foundation for state management in Arch Network. Unlike account-based systems that track balances, UTXOs represent discrete “coins” that must be consumed entirely in transactions.</p>
<h2 id="core-concepts-2"><a class="header" href="#core-concepts-2">Core Concepts</a></h2>
<h3 id="what-is-a-utxo-1"><a class="header" href="#what-is-a-utxo-1">What is a UTXO?</a></h3>
<ul>
<li>A UTXO represents an unspent output from a previous transaction</li>
<li>Each UTXO is uniquely identified by a transaction ID (txid) and output index (vout)</li>
<li>UTXOs are immutable - they can only be created or spent, never modified</li>
<li>Once spent, a UTXO cannot be reused (prevents double-spending)</li>
</ul>
<h3 id="role-in-arch-network-1"><a class="header" href="#role-in-arch-network-1">Role in Arch Network</a></h3>
<ul>
<li>UTXOs anchor program state to Bitcoin’s security model</li>
<li>They provide deterministic state transitions</li>
<li>Enable atomic operations across the network</li>
<li>Allow for provable ownership and state validation</li>
</ul>
<h2 id="utxo-structure-1"><a class="header" href="#utxo-structure-1">UTXO Structure</a></h2>
<p>The <code>UtxoMeta</code> struct encapsulates the core UTXO identification data:</p>
<pre><code class="language-rust ignore">use arch_program::utxo::UtxoMeta;
use bitcoin::Txid;

#[derive(Debug, Clone, PartialEq)]
pub struct UtxoMeta {
    pub txid: [u8; 32],  // Bitcoin transaction ID (32 bytes)
    pub vout: u32,       // Output index in the transaction
}

impl UtxoMeta {
    /// Creates a new UTXO metadata instance
    pub fn new(txid: [u8; 32], vout: u32) -&gt; Self {
        Self { txid, vout }
    }

    /// Deserializes UTXO metadata from a byte slice
    /// Format: [txid(32 bytes)][vout(4 bytes)]
    pub fn from_slice(data: &amp;[u8]) -&gt; Self {
        let mut txid = [0u8; 32];
        txid.copy_from_slice(&amp;data[0..32]);
        let vout = u32::from_le_bytes([
            data[32], data[33], data[34], data[35]
        ]);
        Self { txid, vout }
    }
}</code></pre>
<h2 id="utxo-lifecycle-1"><a class="header" href="#utxo-lifecycle-1">UTXO Lifecycle</a></h2>
<h3 id="1-creation-process-1"><a class="header" href="#1-creation-process-1">1. Creation Process</a></h3>
<h4 id="creating-a-utxo-with-bitcoin-rpc-1"><a class="header" href="#creating-a-utxo-with-bitcoin-rpc-1">Creating a UTXO with Bitcoin RPC</a></h4>
<pre><code class="language-rust ignore">use bitcoincore_rpc::{Auth, Client as RpcClient, RpcApi};
use bitcoin::{Amount, Address};
use arch_program::pubkey::Pubkey;

// Initialize Bitcoin RPC client
let rpc = RpcClient::new(
    "http://localhost:18443",  // Bitcoin node RPC endpoint
    Auth::UserPass(
        "user".to_string(),
        "pass".to_string()
    )
).expect("Failed to create RPC client");

// Generate a new account address
let account_address = Pubkey::new_unique();
let btc_address = Address::from_pubkey(&amp;account_address);

// Create UTXO by sending Bitcoin
// Parameters explained:
// - address: Destination Bitcoin address
// - amount: Amount in satoshis (3000 sats = 0.00003 BTC)
// - comment: Optional transaction comment
// - replaceable: Whether the tx can be replaced (RBF)
let txid = rpc.send_to_address(
    &amp;btc_address,
    Amount::from_sat(3000),
    Some("Create Arch UTXO"),  // Comment
    None,                      // Comment_to
    Some(true),               // Replaceable
    None,                     // Fee rate
    None,                     // Fee estimate mode
    None                      // Avoid reuse
)?;

// Wait for confirmation (recommended)
rpc.wait_for_confirmation(&amp;txid, 1)?;</code></pre>
<h4 id="creating-an-arch-account-with-utxo-1"><a class="header" href="#creating-an-arch-account-with-utxo-1">Creating an Arch Account with UTXO</a></h4>
<pre><code class="language-rust ignore">use arch_program::{
    system_instruction::SystemInstruction,
    pubkey::Pubkey,
    transaction::Transaction,
};

// Create new program account backed by UTXO
let account_pubkey = Pubkey::new_unique();
let instruction = SystemInstruction::new_create_account_instruction(
    txid.try_into().unwrap(),
    0,  // vout index
    account_pubkey,
    // Additional parameters like:
    // - space: Amount of space to allocate
    // - owner: Program that owns the account
);

// Build and sign transaction
let transaction = Transaction::new_signed_with_payer(
    &amp;[instruction],
    Some(&amp;payer.pubkey()),
    &amp;[&amp;payer],
    recent_blockhash
);</code></pre>
<h3 id="2-validation--usage-1"><a class="header" href="#2-validation--usage-1">2. Validation &amp; Usage</a></h3>
<p>Programs must implement proper UTXO validation:</p>
<pre><code class="language-rust ignore">fn validate_utxo(utxo: &amp;UtxoMeta) -&gt; Result&lt;(), ProgramError&gt; {
    // 1. Verify UTXO exists on Bitcoin
    let btc_tx = rpc.get_transaction(&amp;utxo.txid)?;
    
    // 2. Check confirmation count
    if btc_tx.confirmations &lt; MIN_CONFIRMATIONS {
        return Err(ProgramError::InsufficientConfirmations);
    }
    
    // 3. Verify output index exists
    if utxo.vout as usize &gt;= btc_tx.vout.len() {
        return Err(ProgramError::InvalidVout);
    }
    
    // 4. Verify UTXO is unspent
    if is_spent(utxo) {
        return Err(ProgramError::UtxoAlreadySpent);
    }
    
    Ok(())
}</code></pre>
<h3 id="3-state-management-2"><a class="header" href="#3-state-management-2">3. State Management</a></h3>
<pre><code class="language-rust ignore">// Example UTXO state tracking
#[derive(Debug)]
pub struct UtxoState {
    pub meta: UtxoMeta,
    pub status: UtxoStatus,
    pub owner: Pubkey,
    pub created_at: i64,
    pub spent_at: Option&lt;i64&gt;,
}

#[derive(Debug)]
pub enum UtxoStatus {
    Pending,    // Waiting for confirmations
    Active,     // Confirmed and spendable
    Spent,      // UTXO has been consumed
    Invalid,    // UTXO was invalidated (e.g., by reorg)
}</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ol>
<li>
<p><strong>Validation</strong></p>
<ul>
<li>Always verify UTXO existence on Bitcoin</li>
<li>Check for sufficient confirmations (recommended: 6+)</li>
<li>Validate ownership and spending conditions</li>
<li>Handle Bitcoin reorgs that might invalidate UTXOs</li>
</ul>
</li>
<li>
<p><strong>State Management</strong></p>
<ul>
<li>Implement robust UTXO tracking</li>
<li>Handle edge cases (reorgs, conflicting txs)</li>
<li>Consider implementing UTXO caching for performance</li>
<li>Maintain accurate UTXO sets for your program</li>
</ul>
</li>
<li>
<p><strong>Security</strong></p>
<ul>
<li>Never trust client-provided UTXO data without verification</li>
<li>Implement proper access controls</li>
<li>Consider timelock constraints for sensitive operations</li>
<li>Monitor for suspicious UTXO patterns</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Batch UTXO operations when possible</li>
<li>Implement efficient UTXO lookup mechanisms</li>
<li>Consider UTXO consolidation strategies</li>
<li>Cache frequently accessed UTXO data</li>
</ul>
</li>
</ol>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Common UTXO-related errors to handle:</p>
<pre><code class="language-rust ignore">pub enum UtxoError {
    NotFound,                    // UTXO doesn't exist
    AlreadySpent,               // UTXO was already consumed
    InsufficientConfirmations,  // Not enough confirmations
    InvalidOwner,               // Unauthorized attempt to spend
    Reorged,                    // UTXO invalidated by reorg
    InvalidVout,                // Output index doesn't exist
    SerializationError,         // Data serialization failed
}</code></pre>
<h2 id="related-topics-3"><a class="header" href="#related-topics-3">Related Topics</a></h2>
<ul>
<li><a href="program/account.html">Account Model</a> - How UTXOs relate to Arch accounts</li>
<li><a href="program/program.html">Program State</a> - Using UTXOs for program state</li>
<li><a href="program/../system-program/system-program.html">System Program</a> - Core UTXO operations</li>
</ul>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk"><a class="header" href="#sdk">SDK</a></h1>
<p>This section includes reference documentation for our <a href="https://github.com/Arch-Network/arch-sdk/tree/main/sdk/">SDK</a>.</p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="processed-transaction"><a class="header" href="#processed-transaction">Processed Transaction</a></h1>
<p>A processed transaction is a custom data type that contains a <a href="sdk/./runtime-transaction.html">runtime transaction</a>, a status, denoting the result of executing this runtime transaction, as well as a collection of Bitcoin transaction IDs.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Deserialize, Serialize, BorshDeserialize, BorshSerialize)]
pub enum Status {
    Processing,
    Processed,
}

#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct ProcessedTransaction {
    pub runtime_transaction: RuntimeTransaction,
    pub status: Status,
    pub bitcoin_txids: Vec&lt;String&gt;,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/processed_transaction.rs">processed_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-transaction"><a class="header" href="#runtime-transaction">Runtime Transaction</a></h1>
<p>A runtime transaction includes a version number, a slice of <a href="sdk/./signature.html">signatures</a> included on the transaction and a <a href="sdk/../program/message.html">message</a> field, which details a list of <a href="sdk/../program/instructions-and-messages.html#instructions">instructions</a> to be processed atomically.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
pub struct RuntimeTransaction {
    pub version: u32,
    pub signatures: Vec&lt;Signature&gt;,
    pub message: Message,
}</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/runtime_transaction.rs">runtime_transaction.rs</a></p>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature"><a class="header" href="#signature">Signature</a></h1>
<p>A signature is a custom data type that holds a slice of 64 bytes.</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct Signature(pub Vec&lt;u8&gt;);</code></pre>
<p><a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/signature.rs">signature.rs</a></p>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-program"><a class="header" href="#system-program">System Program</a></h1>
<p>The Arch System Program is Arch’s core program. This program contains a set of variants that can be thought-of as native functionality that can be used within any Arch program.</p>
<p>The System Program creates new accounts, assigns accounts to owning programs, marks accounts as executable, and writes data to the accounts.</p>
<p>In order to make calls to the System Program, the following mapping can help you point to the correct functionality.</p>
<div class="table-wrapper"><table><thead><tr><th>index</th><th>method</th></tr></thead><tbody>
<tr><td>0</td><td>CreateAccount</td></tr>
<tr><td>1</td><td>WriteBytes</td></tr>
<tr><td>2</td><td>MakeExecutable</td></tr>
<tr><td>3</td><td>AssignOwnership</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="createaccount"><a class="header" href="#createaccount"><code>CreateAccount</code></a></h1>
<p><strong>Index:</strong> <code>0</code></p>
<p>Create a new account.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![0]</code>, the correct index for making a call to <code>SystemProgram::CreateAccount</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![0];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="writebytes"><a class="header" href="#writebytes"><code>WriteBytes</code></a></h1>
<p><strong>Index:</strong> <code>1</code></p>
<p>Writes bytes to an array and serializes it.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![1]</code>, the correct index for making a call to <code>SystemProgram::WriteBytes</code>.</p>
<pre><code class="language-rust ignore">let offset = 4u32.to_le_bytes();
let mut instruction_data = vec![1];
instruction_data.extend_from_slice(&amp;offset);

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="makeexecutable"><a class="header" href="#makeexecutable"><code>MakeExecutable</code></a></h1>
<p><strong>Index:</strong> <code>2</code></p>
<p>Sets the account as executable, marking it as a program.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![2]</code>, the correct index for making a call to <code>SystemProgram::MakeExecutable</code>.</p>
<pre><code class="language-rust ignore">let instruction_data = vec![2];

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<p>We can proceed to confirm that the program is executable with <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L368">read_account_info</a> which returns an <a href="https://github.com/Arch-Network/arch-examples/blob/main/sdk/src/helper.rs#L358">AccountInfoResult</a> that gets parsed to obtain the <code>is_executable</code> value.</p>
<pre><code class="language-rust ignore">assert!(
    read_account_info("node_url", program_pubkey)
        .unwrap()
        .is_executable
);</code></pre>
<!-- Internal -->
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignownership"><a class="header" href="#assignownership"><code>AssignOwnership</code></a></h1>
<p><strong>Index:</strong> <code>3</code></p>
<p>Sets a <a href="system-program/../program/pubkey.html">Pubkey</a> to be the owner of an account.</p>
<p>Below, within the <a href="system-program/../program/instructions-and-messages.html#instructions">Instruction</a> <code>data</code> field, we find a local variable <code>instruction_data</code> that contains <code>vec![3]</code>, the correct index for making a call to <code>SystemProgram::AssignOwnership</code>.</p>
<p>The <code>instruction_data</code> also contains the serialized <a href="system-program/../program/pubkey.html">Pubkey</a> of the owner account.</p>
<pre><code class="language-rust ignore">let mut instruction_data = vec![3];
instruction_data.extend(program_pubkey.serialize());

let instruction = Instruction {
    program_id: Pubkey::system_program(),
    accounts: vec![AccountMeta {
        pubkey,
        is_signer: true,
        is_writable: true,
    }],
    data: instruction_data,
}</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">RPC</a></h1>
<p>Interact with Arch nodes directly with the JSON RPC API via the HTTP methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-methods"><a class="header" href="#http-methods">HTTP Methods</a></h1>
<p>Interact with Arch nodes directly with the JSON RPC API via this list of available HTTP methods.</p>
<blockquote>
<p>Note: For client-side needs, use the <a href="https://www.npmjs.com/package/@saturnbtcio/arch-sdk">@saturnbtcio/arch-sdk</a> library as an interface for the RPC methods to interact with an Arch node. Alternatively, the new Arch Network CLI tool provides convenient commands to interact with the network.</p>
</blockquote>
<h3 id="endpoint"><a class="header" href="#endpoint">Endpoint</a></h3>
<p>Default port: <code>9002</code></p>
<ul>
<li>http://localhost:9002</li>
</ul>
<h3 id="request-format"><a class="header" href="#request-format">Request Format:</a></h3>
<p>To make a JSON-RPC request, send an HTTP <code>POST</code> request with a <code>Content-Type: application/json</code> header.</p>
<p>The JSON request data should contain 4 fields:</p>
<ul>
<li><code>jsonrpc: &lt;string&gt;</code> - set to “2.0.”</li>
<li><code>id: &lt;number&gt;</code> - a unique client-generated identifying integer.</li>
<li><code>method: &lt;string&gt;</code> - a string containing the method to be invoked.</li>
<li><code>params: &lt;array&gt;</code> - a JSON array of ordered parameter values.</li>
</ul>
<h3 id="response-format"><a class="header" href="#response-format">Response Format:</a></h3>
<p>The response output will be a JSON object with the following fields:</p>
<ul>
<li><code>jsonrpc: &lt;string&gt;</code> - matching the value set in the request.</li>
<li><code>id: &lt;number&gt;</code> - matching the value set in the request.</li>
<li><code>result: &lt;array|boolean|number|object|string&gt;</code> - requested data, success confirmation or boolean flag.</li>
</ul>
<h3 id="cli-alternative"><a class="header" href="#cli-alternative">CLI Alternative</a></h3>
<p>Many of these RPC methods can be accessed through the Arch Network CLI tool with simpler commands:</p>
<pre><code class="language-bash"># Start a local validator
cli validator start

# Deploy a program
cli deploy &lt;ELF_PATH&gt;

# Show program information
cli show &lt;PROGRAM_ADDRESS&gt;

# Confirm transaction status
cli confirm &lt;TX_ID&gt;

# Get block information
cli get-block &lt;BLOCK_HASH&gt;

# Get current block height
cli get-block-height

# Log program messages in a transaction
cli log-program-messages &lt;TX_ID&gt;

# Get group key
cli get-group-key &lt;PUBKEY&gt;

# Change account owner
cli change-owner &lt;ACCOUNT_ADDRESS&gt; &lt;NEW_OWNER&gt;
</code></pre>
<p>For more details on the CLI tool, download the latest version from the <a href="https://github.com/Arch-Network/arch-node/releases/latest">Arch Network CLI releases page</a>.</p>
<!-- External -->
<!-- Note: The main Arch Network repository is not yet publicly accessible. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sendtransaction"><a class="header" href="#sendtransaction"><code>sendTransaction</code></a></h1>
<p><strong>Description:</strong> Relays a single transaction to the nodes for execution.</p>
<p>The following pre-flight checks are performed:</p>
<ol>
<li>It verifies the transaction size limit.</li>
<li>It verifies the transaction signatures.</li>
<li>It verifies that the UTXOs are not already spent.</li>
</ol>
<p><em>The same checks are performed on <a href="rpc/http-methods/./send-transactions.html">sendTransactions</a>.</em></p>
<p>If these checks pass, the transaction is forwarded to the rest of the nodes for processing.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>params: &lt;serialized_object&gt;</code> - A serialized <a href="rpc/http-methods/../../sdk/runtime-transaction.html">Runtime Transaction</a> object representing the transaction to be sent.</p>
<p><strong>Returns:</strong> A string containing the transaction IDs (<code>txid</code>) of the submitted transaction.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
  "jsonrpc":"2.0",
  "id":1,
  "method":"send_transaction",
  "params": [
    [1,2,3,4,...]
  ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
  "id": "1"
}
</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sendtransactions"><a class="header" href="#sendtransactions"><code>sendTransactions</code></a></h1>
<p><strong>Description:</strong>  Sends multiple transactions in a single batch request.</p>
<p>The following pre-flight checks are performed:</p>
<ol>
<li>It verifies the transaction size limit.</li>
<li>It verifies the transaction signatures.</li>
<li>It verifies that the UTXOs are not already spent.</li>
</ol>
<p><em>The same checks are performed on <a href="rpc/http-methods/./send-transaction.html">sendTransaction</a>.</em></p>
<p>If these checks pass, the transaction is forwarded to the rest of the nodes for processing.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>params: &lt;array[serialized_object]&gt;</code> - An array of serialized <a href="rpc/http-methods/../../sdk/runtime-transaction.html">Runtime Transaction</a> objects to be sent.</p>
<p><strong>Returns:</strong> An array of strings containing the transaction IDs (<code>txids</code>) of the submitted transactions.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"send_transactions",
    "params": [
        [
            [1,2,3,4,...],
            [5,6,7,8,...]
        ]
    ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
  ],
  "id": "1"
}
</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="getaccountaddress"><a class="header" href="#getaccountaddress"><code>getAccountAddress</code></a></h1>
<p><strong>Description:</strong>  Fetches the account address associated with a public key.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>pubkey: &lt;byte_array&gt;</code> - The public key (<a href="rpc/http-methods/../../program/pubkey.html">Pubkey</a>) of the account.</p>
<p><strong>Returns:</strong> The account address as a string.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_account_address",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32] 
    ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq",
  "id": "1"
}
</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="getprogramaccounts"><a class="header" href="#getprogramaccounts"><code>getProgramAccounts</code></a></h1>
<blockquote>
<p>⚠️ Note: This endpoint is not available for local validators.</p>
</blockquote>
<p><strong>Description</strong>: Fetches all accounts owned by the specified program ID.</p>
<p><strong>Parameters:</strong> <code>program_id: &lt;byte_array&gt;</code> - Pubkey of the program to query, as an array of 32 bytes.</p>
<p><code>filters</code> (optional) - Array of filter objects, each filter should be either:</p>
<ul>
<li><code>{ "DataSize": &lt;size&gt; }</code> where <code>&lt;size&gt;</code> is the required size of the account data</li>
<li><code>{ "DataContent": { "offset": &lt;offset&gt;, "bytes": &lt;byte_array&gt; } }</code> where <code>&lt;offset&gt;</code> is the offset into the account data, and <code>&lt;byte_array&gt;</code> is an array of bytes to match</li>
</ul>
<p><strong>Returns:</strong> An array of account objects, each containing:</p>
<ul>
<li><code>pubkey: &lt;byte_array&gt;</code>: The account’s public key.</li>
<li><code>account: &lt;object&gt;</code>: An object containing the account’s data and metadata.</li>
</ul>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
  "jsonrpc":"2.0",
  "id":1,
  "method": "get_program_accounts",
  "params": [
    [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
    [
      {
        "DataSize": 165
      },
      {
        "DataContent": {
          "offset": 0,
          "bytes": [1, 2, 3, 4]
        }
      }
    ]
  ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    {
      "pubkey": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],
      "account": {
        "data": [1,2,3,4,...],
        "owner": [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
        "utxo": "txid:vout",
        "is_executable": false
      }
    }
  ],
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getblock"><a class="header" href="#getblock"><code>getBlock</code></a></h1>
<p><strong>Description:</strong>  Retrieves block data based on a block hash.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>blockHash: &lt;string&gt;</code> - A string representing the block hash.</p>
<p><strong>Returns:</strong> A <code>Block</code> object or <code>undefined</code> if the block is not found.</p>
<p><strong>Error Handling:</strong> Returns <code>undefined</code> if the block is not found (404).</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block",
    "params":[
        "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f" 
    ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    /* Block object */
  },
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getblockcount"><a class="header" href="#getblockcount"><code>getBlockCount</code></a></h1>
<p><strong>Description:</strong>  Retrieves the current block count.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
None.</p>
<p><strong>Returns:</strong> The current block count as a number.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block_count",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": 680000,
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getblockhash"><a class="header" href="#getblockhash"><code>getBlockHash</code></a></h1>
<p><strong>Description:</strong>  Retrieves the block hash at a specific block height.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>blockHeight: &lt;number&gt;</code> - The block height for which to retrieve the block hash.</p>
<p><strong>Returns:</strong> A string representing the block hash.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_block_hash",
    "params":["680000"]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getcurrentstate"><a class="header" href="#getcurrentstate"><code>getCurrentState</code></a></h1>
<blockquote>
<p>️️⚠️ Note: This endpoint is not available for local validators.</p>
</blockquote>
<p><strong>Description:</strong> Retrieves the current state of the node, including information about the blockchain and network status.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
None.</p>
<p><strong>Returns:</strong> A <code>CurrentState</code> object.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_current_state",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "state": "Running",
    "last_state_transition": "2023-10-01T12:00:00Z"
  },
  "id": 1
}
</code></pre>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="getpeers"><a class="header" href="#getpeers"><code>getPeers</code></a></h1>
<blockquote>
<p>️️⚠️ Note: This endpoint is not available for local validators.</p>
</blockquote>
<p><strong>Description:</strong> Retrieves a list of peers currently connected to the node.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
None.</p>
<p><strong>Returns:</strong> An array of <code>PeerStats</code>.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_peers",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    {
      "peer_id": "12D3KooW...",
      "address": "/ip4/192.168.1.1/tcp/30303",
      "status": "connected"
    }
  ],
  "id": 1
}
</code></pre>
<!-- External -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="getprocessedtransaction"><a class="header" href="#getprocessedtransaction"><code>getProcessedTransaction</code></a></h1>
<p><strong>Description:</strong>  Fetches details of a processed transaction using a transaction ID.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>txid: &lt;string&gt;</code> - A string representing the transaction ID.</p>
<p><strong>Returns:</strong> A <code>ProcessedTransaction</code> object or undefined if the transaction is not found.</p>
<p><strong>Error Handling:</strong> Returns <code>undefined</code> if the transaction is not found (404).</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_processed_transaction",
    "params":[
        "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "runtime_transaction": { /* RuntimeTransaction object */ },
    "status": "Confirmed",
    "bitcoin_txids": ["txid1", "txid2"]
  },
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="readaccountinfo"><a class="header" href="#readaccountinfo"><code>readAccountInfo</code></a></h1>
<p><strong>Description:</strong>  Retrieves detailed information for the specified account.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>pubkey: &lt;byte_array&gt;</code> - The public key (<a href="rpc/http-methods/../../program/pubkey.html">Pubkey</a>) of the account to query, as an array of 32 bytes.</p>
<p><strong>Returns:</strong> An object containing the account’s information:</p>
<ul>
<li><code>data</code>: The account’s data as a byte array.</li>
<li><code>owner</code>: The account’s owner as a byte array (<code>program_id</code>).</li>
<li><code>utxo</code>: The UTXO associated with this account.</li>
<li><code>is_executable</code>: A boolean indicating if the account contains executable code.</li>
</ul>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"read_account_info",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "data": [1,2,3,4,...],
    "owner": [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
    "utxo": "txid:vout",
    "is_executable": false
  },
  "id": "1"
}
</code></pre>
<!-- Internal -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="startdkg"><a class="header" href="#startdkg"><code>startDkg</code></a></h1>
<blockquote>
<p>️️⚠️ Note: This endpoint is not available for local validators.</p>
</blockquote>
<p><strong>Description:</strong> Initiates the Distributed Key Generation (DKG) process.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
None.</p>
<p><strong>Returns:</strong> A success message if the DKG process is initiated.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"start_dkg",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "DKG process initiated",
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isnodeready"><a class="header" href="#isnodeready"><code>isNodeReady</code></a></h1>
<p><strong>Description:</strong> Checks if the node is ready to process requests.</p>
<p><strong>Parameters:</strong>
None.</p>
<p><strong>Returns:</strong> A boolean indicating whether the node is ready.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"is_node_ready",
    "params":[]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": true,
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resetnetwork"><a class="header" href="#resetnetwork"><code>resetNetwork</code></a></h1>
<blockquote>
<p>⚠️ Note:</p>
<p><em>This method is only callable by the Leader node, which for the time being will be Arch. This method is used for internal debugging purposes as we get the Testnet operational.</em></p>
<p>This endpoint is also not available for local validators.</p>
</blockquote>
<p><strong>Description:</strong> Resets the network state.</p>
<p><strong>Parameters:</strong>
None.</p>
<p><strong>Returns:</strong> A success message if the network reset is successful.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
  "jsonrpc":"2.0",
  "id":1,
  "method":"reset_network",
  "params":[]
}' \
http://localhost:9002/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "Success!",
  "id": "1"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecated-methods"><a class="header" href="#deprecated-methods">Deprecated Methods</a></h1>
<p>The following includes a list of RPC methods which are no longer supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getaccountinfo"><a class="header" href="#getaccountinfo"><code>getAccountInfo</code></a></h1>
<p><strong>Description:</strong>  Retrieves detailed information for the specified account.</p>
<p><strong>Method:</strong> <code>POST</code></p>
<p><strong>Parameters:</strong>
<code>pubkey: &lt;byte_array&gt;</code> - The public key (<a href="rpc/deprecated-methods/../../program/pubkey.html">Pubkey</a>) of the account to query, as an array of 32 bytes.</p>
<p><strong>Returns:</strong> An object containing the account’s information:</p>
<ul>
<li><code>data</code>: The account’s data as a byte array.</li>
<li><code>owner</code>: The account’s owner as a byte array (<code>program_id</code>).</li>
<li><code>utxo</code>: The UTXO associated with this account.</li>
<li><code>is_executable</code>: A boolean indicating if the account contains executable code.</li>
</ul>
<p><strong>Request:</strong></p>
<pre><code class="language-bash">curl -vL POST -H 'Content-Type: application/json' -d '
{
    "jsonrpc":"2.0",
    "id":1,
    "method":"get_account_info",
    "params":[
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]
    ]
}' \
http://localhost:9001/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "data": [1,2,3,4,...],
    "owner": [80,82,242,228,43,246,248,133,88,238,139,124,88,96,107,32,71,40,52,251,90,42,66,176,66,32,147,203,137,211,253,40],
    "utxo": "txid:vout",
    "is_executable": false
  },
  "id": "1"
}
</code></pre>
<!-- Internal -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>
        <script src="theme/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
