<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Testing Your Program - The Arch Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for the Arch Network - A Bitcoin-native computation environment">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item affix "><li class="part-title">Getting Started</li><li class="chapter-item "><a href="../getting-started/quick-start.html">üöÄ Quick Start Guide</a></li><li class="chapter-item "><a href="../getting-started/bitcoin-and-titan-setup.html">üèóÔ∏è Validator Setup</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../getting-started/requirements.html">System Requirements</a></li><li class="chapter-item "><a href="../guides/how-to-configure-local-validator-bitcoin-testnet4.html">Setup Options</a></li><li class="chapter-item "><a href="../getting-started/validator-staking.html">Running Your Node</a></li></ol></li><li class="chapter-item "><li class="part-title">Program Development</li><li class="chapter-item "><a href="../guides/understanding-arch-programs.html">Understanding Arch Programs</a></li><li class="chapter-item "><a href="../getting-started/setting-up-a-project.html">Setting Up a Project</a></li><li class="chapter-item "><a href="../guides/writing-your-first-program.html">Writing Your First Program</a></li><li class="chapter-item expanded "><a href="../guides/testing-guide.html" class="active">Testing Your Program</a></li><li class="chapter-item "><a href="../guides/guides.html">Program Examples</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../guides/how-to-create-a-fungible-token.html">Fungible Token</a></li><li class="chapter-item "><a href="../guides/how-to-write-oracle-program.html">Oracle Program</a></li><li class="chapter-item "><a href="../guides/how-to-build-runes-swap.html">Runes Swap</a></li><li class="chapter-item "><a href="../guides/how-to-build-lending-protocol.html">Lending Protocol</a></li></ol></li><li class="chapter-item "><li class="part-title">Arch Program Library (APL)</li><li class="chapter-item "><a href="../apl/introduction.html">Introduction</a></li><li class="chapter-item "><a href="../apl/token-program.html">Token Program</a></li><li class="chapter-item "><a href="../apl/associated-token-account.html">Associated Token Account Program</a></li><li class="chapter-item affix "><li class="part-title">Core Concepts</li><li class="chapter-item "><a href="../concepts/architecture.html">Architecture Overview</a></li><li class="chapter-item "><a href="../concepts/network-architecture.html">Network Architecture</a></li><li class="chapter-item "><a href="../concepts/bitcoin-integration.html">Bitcoin Integration</a></li><li class="chapter-item "><a href="../concepts/consensus.html">ROAST and FROST Consensus</a></li><li class="chapter-item "><a href="../program/program.html">Programs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../program/utxo.html">UTXOs</a></li><li class="chapter-item "><a href="../program/accounts.html">Accounts</a></li><li class="chapter-item "><a href="../program/instructions-and-messages.html">Instructions</a></li><li class="chapter-item "><a href="../program/syscall.html">System Calls</a></li></ol></li><li class="chapter-item "><a href="../concepts/nodes.html">Node Operation</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="../rpc/rpc.html">API Reference</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rpc/http-methods.html">HTTP Methods</a></li><li class="chapter-item "><a href="../sdk/processed-transaction.html">Transaction Processing</a></li></ol></li><li class="chapter-item "><a href="../system-program/system-program.html">System Program</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../system-program/create-account.html">Account Creation</a></li><li class="chapter-item "><a href="../system-program/make-executable.html">Program Deployment</a></li></ol></li><li class="chapter-item "><li class="part-title">Resources</li><li class="chapter-item "><a href="../reference/troubleshooting.html">Troubleshooting</a></li><li class="chapter-item "><a href="../getting-started/faq.html">FAQ</a></li><li class="chapter-item "><a href="../getting-started/resources.html">External Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Arch Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arch-network/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/arch-network/book/edit/main/src/guides/testing-guide.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="comprehensive-testing-guide-for-arch-network-programs"><a class="header" href="#comprehensive-testing-guide-for-arch-network-programs">Comprehensive Testing Guide for Arch Network Programs</a></h1>
<p>This guide provides complete coverage of testing strategies, tools, and best practices for building robust and reliable Arch Network programs. Proper testing is essential for ensuring your programs work correctly and securely before deployment.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Testing Arch programs involves multiple layers:</p>
<ul>
<li><strong>Unit Tests</strong>: Individual function and logic testing</li>
<li><strong>Integration Tests</strong>: Cross-component functionality testing</li>
<li><strong>End-to-End Tests</strong>: Full program workflow testing</li>
<li><strong>Security Tests</strong>: Vulnerability and attack vector testing</li>
<li><strong>Performance Tests</strong>: Load and efficiency testing</li>
</ul>
<h2 id="project-setup-for-testing"><a class="header" href="#project-setup-for-testing">Project Setup for Testing</a></h2>
<h3 id="test-directory-structure"><a class="header" href="#test-directory-structure">Test Directory Structure</a></h3>
<pre><code>my-program/
‚îú‚îÄ‚îÄ program/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ integration.rs
‚îÇ   ‚îú‚îÄ‚îÄ security.rs
‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îÇ       ‚îî‚îÄ‚îÄ mod.rs
‚îî‚îÄ‚îÄ Cargo.toml (workspace)
</code></pre>
<h3 id="test-dependencies-configuration"><a class="header" href="#test-dependencies-configuration">Test Dependencies Configuration</a></h3>
<p><strong>Cargo.toml (workspace root)</strong></p>
<pre><code class="language-toml">[workspace]
members = ["program", "tests"]

[workspace.dependencies]
arch_program = "0.5.2"
arch_sdk = "0.5.2"
borsh = { version = "1.5.1", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<p><strong>tests/Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
name = "program-tests"
version = "0.1.0"
edition = "2021"

[dependencies]
arch_program = { workspace = true }
arch_sdk = { workspace = true }
borsh = { workspace = true }
tokio = { workspace = true }

# Test utilities
proptest = "1.0"
rstest = "0.18"
serial_test = "3.0"

# Your program dependency
my_program = { path = "../program" }

[[bin]]
name = "test-runner"
path = "src/main.rs"
</code></pre>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<h3 id="basic-unit-tests"><a class="header" href="#basic-unit-tests">Basic Unit Tests</a></h3>
<p>Unit tests go directly in your program‚Äôs <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use arch_program::{
        account::AccountInfo,
        program_error::ProgramError,
        pubkey::Pubkey,
    };

    #[test]
    fn test_counter_account_serialization() {
        let counter = CounterAccount::new(Pubkey::new_unique(), 100);
        
        // Test serialization
        let serialized = borsh::to_vec(&amp;counter).unwrap();
        let deserialized: CounterAccount = borsh::from_slice(&amp;serialized).unwrap();
        
        assert_eq!(counter, deserialized);
    }

    #[test]
    fn test_instruction_parsing() {
        let instruction = CounterInstruction::Increment { amount: 5 };
        let params = CounterParams {
            instruction,
            tx_hex: vec![0x01, 0x02, 0x03],
        };
        
        let serialized = borsh::to_vec(&amp;params).unwrap();
        let parsed: CounterParams = borsh::from_slice(&amp;serialized).unwrap();
        
        match parsed.instruction {
            CounterInstruction::Increment { amount } =&gt; assert_eq!(amount, 5),
            _ =&gt; panic!("Wrong instruction type"),
        }
    }

    #[test]
    fn test_error_codes() {
        let error: ProgramError = CounterError::CounterFrozen.into();
        assert_eq!(error, ProgramError::Custom(1001));
    }

    #[test]
    fn test_overflow_protection() {
        let mut counter = CounterAccount::new(Pubkey::new_unique(), 100);
        counter.count = i64::MAX;
        
        // This should detect overflow
        let result = counter.count.checked_add(1);
        assert!(result.is_none());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-unit-testing"><a class="header" href="#advanced-unit-testing">Advanced Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod advanced_tests {
    use super::*;
    use proptest::prelude::*;

    // Property-based testing
    proptest! {
        #[test]
        fn test_counter_operations_never_panic(
            initial_value in i32::MIN..i32::MAX,
            operation_value in 1u32..1000u32
        ) {
            let mut counter = CounterAccount::new(Pubkey::new_unique(), 100);
            counter.count = initial_value as i64;

            // These operations should never panic
            let _ = counter.count.checked_add(operation_value as i64);
            let _ = counter.count.checked_sub(operation_value as i64);
        }
    }

    // Parameterized tests
    use rstest::rstest;

    #[rstest]
    #[case(CounterInstruction::Increment { amount: 1 })]
    #[case(CounterInstruction::Decrement { amount: 1 })]
    #[case(CounterInstruction::Reset)]
    #[case(CounterInstruction::Freeze)]
    #[case(CounterInstruction::Unfreeze)]
    fn test_instruction_serialization(#[case] instruction: CounterInstruction) {
        let params = CounterParams {
            instruction: instruction.clone(),
            tx_hex: vec![],
        };
        
        let serialized = borsh::to_vec(&amp;params).unwrap();
        let deserialized: CounterParams = borsh::from_slice(&amp;serialized).unwrap();
        
        assert_eq!(params.instruction, deserialized.instruction);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h3>
<p><strong>tests/common/mod.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::{
    client::ArchClient,
    instruction::Instruction,
    pubkey::Pubkey,
    signer::Keypair,
    transaction::Transaction,
};
use std::sync::Once;

static INIT: Once = Once::new();

pub struct TestEnvironment {
    pub client: ArchClient,
    pub payer: Keypair,
    pub program_id: Pubkey,
}

impl TestEnvironment {
    pub async fn new() -&gt; Self {
        INIT.call_once(|| {
            env_logger::init();
        });

        let client = ArchClient::new("http://localhost:9001").unwrap();
        let payer = Keypair::new();
        
        // Fund the payer
        let airdrop_signature = client
            .request_airdrop(&amp;payer.pubkey(), 10_000_000)
            .await
            .unwrap();
        
        client.confirm_transaction(&amp;airdrop_signature).await.unwrap();

        // Deploy program
        let program_id = deploy_test_program(&amp;client, &amp;payer).await;

        TestEnvironment {
            client,
            payer,
            program_id,
        }
    }

    pub async fn create_funded_account(&amp;self) -&gt; Keypair {
        let account = Keypair::new();
        let signature = self.client
            .request_airdrop(&amp;account.pubkey(), 1_000_000)
            .await
            .unwrap();
        
        self.client.confirm_transaction(&amp;signature).await.unwrap();
        account
    }
}

async fn deploy_test_program(client: &amp;ArchClient, payer: &amp;Keypair) -&gt; Pubkey {
    let program_data = include_bytes!("../../program/target/deploy/my_counter_program.so");
    
    let program_id = client
        .deploy_program(payer, program_data)
        .await
        .unwrap();
    
    program_id
}

// Helper functions for test data
pub fn create_counter_initialize_instruction(
    program_id: &amp;Pubkey,
    counter_account: &amp;Pubkey,
    authority: &amp;Pubkey,
) -&gt; Instruction {
    use my_program::{CounterInstruction, CounterParams};
    
    let params = CounterParams {
        instruction: CounterInstruction::Initialize,
        tx_hex: create_test_fee_transaction(),
    };
    
    Instruction {
        program_id: *program_id,
        accounts: vec![
            AccountMeta::new(*counter_account, true),
            AccountMeta::new_readonly(*authority, true),
        ],
        data: borsh::to_vec(&amp;params).unwrap(),
    }
}

pub fn create_test_fee_transaction() -&gt; Vec&lt;u8&gt; {
    // Return a minimal valid Bitcoin transaction for testing
    vec![
        0x02, 0x00, 0x00, 0x00, // version
        0x01, // input count
        // ... simplified test transaction data
    ]
}
<span class="boring">}</span></code></pre></pre>
<h3 id="complete-integration-tests"><a class="header" href="#complete-integration-tests">Complete Integration Tests</a></h3>
<p><strong>tests/integration.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::prelude::*;
use my_program::*;
use serial_test::serial;

mod common;
use common::*;

#[tokio::test]
#[serial]
async fn test_complete_counter_workflow() {
    let env = TestEnvironment::new().await;
    
    // Create counter account
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Test 1: Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Initialize should succeed");
    
    // Verify initial state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 0);
    assert_eq!(counter_state.authority, user.pubkey());
    assert!(!counter_state.is_frozen);
    
    // Test 2: Increment counter
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        10,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Increment should succeed");
    
    // Verify incremented state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 10);
    assert_eq!(counter_state.operation_count, 1);
    
    // Test 3: Freeze counter
    let freeze_ix = create_counter_freeze_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[freeze_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Freeze should succeed");
    
    // Test 4: Try to increment frozen counter (should fail)
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        5,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Increment should fail when frozen");
    
    // Test 5: Unfreeze and increment
    let unfreeze_ix = create_counter_unfreeze_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        5,
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[unfreeze_ix, increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_ok(), "Unfreeze and increment should succeed");
    
    // Final verification
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, 15);
    assert!(!counter_state.is_frozen);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-testing"><a class="header" href="#security-testing">Security Testing</a></h2>
<p><strong>tests/security.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::prelude::*;
use my_program::*;
use serial_test::serial;

mod common;
use common::*;

#[tokio::test]
#[serial]
async fn test_unauthorized_access() {
    let env = TestEnvironment::new().await;
    
    // Create counter with user1 as authority
    let counter_keypair = Keypair::new();
    let user1 = env.create_funded_account().await;
    let user2 = env.create_funded_account().await;
    
    // Initialize counter with user1 as authority
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user1.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user1],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Try to reset counter with user2 (should fail)
    let reset_ix = create_counter_reset_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user2.pubkey(), // Wrong authority
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[reset_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user2],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Reset should fail with wrong authority");
}

#[tokio::test]
#[serial]
async fn test_overflow_protection() {
    let env = TestEnvironment::new().await;
    
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Try to increment by maximum value (should fail due to overflow protection)
    let increment_ix = create_counter_increment_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
        u32::MAX, // This should cause overflow
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[increment_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    let result = env.client.send_and_confirm_transaction(&amp;tx).await;
    assert!(result.is_err(), "Large increment should fail due to overflow protection");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p><strong>tests/performance.rs</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use arch_sdk::prelude::*;
use my_program::*;
use std::time::Instant;
use tokio::time::{sleep, Duration};

mod common;
use common::*;

#[tokio::test]
async fn test_transaction_throughput() {
    let env = TestEnvironment::new().await;
    
    let counter_keypair = Keypair::new();
    let user = env.create_funded_account().await;
    
    // Initialize counter
    let init_ix = create_counter_initialize_instruction(
        &amp;env.program_id,
        &amp;counter_keypair.pubkey(),
        &amp;user.pubkey(),
    );
    
    let tx = Transaction::new_signed_with_payer(
        &amp;[init_ix],
        Some(&amp;env.payer.pubkey()),
        &amp;[&amp;env.payer, &amp;counter_keypair, &amp;user],
        env.client.get_latest_blockhash().await.unwrap(),
    );
    
    env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
    
    // Benchmark multiple increments
    let start_time = Instant::now();
    let num_operations = 100;
    
    for i in 0..num_operations {
        let increment_ix = create_counter_increment_instruction(
            &amp;env.program_id,
            &amp;counter_keypair.pubkey(),
            &amp;user.pubkey(),
            1,
        );
        
        let tx = Transaction::new_signed_with_payer(
            &amp;[increment_ix],
            Some(&amp;env.payer.pubkey()),
            &amp;[&amp;env.payer, &amp;user],
            env.client.get_latest_blockhash().await.unwrap(),
        );
        
        env.client.send_and_confirm_transaction(&amp;tx).await.unwrap();
        
        if i % 10 == 0 {
            println!("Completed {} operations", i + 1);
        }
        
        // Small delay to avoid overwhelming the network
        sleep(Duration::from_millis(10)).await;
    }
    
    let elapsed = start_time.elapsed();
    let ops_per_second = num_operations as f64 / elapsed.as_secs_f64();
    
    println!("Completed {} operations in {:?}", num_operations, elapsed);
    println!("Throughput: {:.2} operations/second", ops_per_second);
    
    // Verify final state
    let account_data = env.client
        .get_account(&amp;counter_keypair.pubkey())
        .await
        .unwrap()
        .unwrap();
    
    let counter_state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    assert_eq!(counter_state.count, num_operations);
    assert_eq!(counter_state.operation_count, num_operations as u64);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-execution"><a class="header" href="#test-execution">Test Execution</a></h2>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test

# Run specific test categories
cargo test --test integration
cargo test --test security
cargo test --test performance

# Run with logs
RUST_LOG=debug cargo test

# Run tests in sequence (for tests that modify shared state)
cargo test -- --test-threads=1
</code></pre>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<p><strong>.github/workflows/test.yml</strong></p>
<pre><code class="language-yaml">name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      bitcoind:
        image: ruimarinho/bitcoin-core:22
        options: &gt;-
          --health-cmd "bitcoin-cli -regtest getblockchaininfo"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 18443:18443
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        
    - name: Install Solana CLI
      run: |
        sh -c "$(curl -sSfL https://release.solana.com/v1.16.27/install)"
        echo "$HOME/.local/share/solana/install/active_release/bin" &gt;&gt; $GITHUB_PATH
        
    - name: Start local validator
      run: |
        solana-test-validator --detach
        
    - name: Build program
      run: |
        cargo build-sbf
        
    - name: Run tests
      run: |
        cargo test
        
    - name: Run integration tests
      run: |
        cargo test --test integration
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-test-organization"><a class="header" href="#1-test-organization">1. Test Organization</a></h3>
<ul>
<li>Separate unit, integration, and security tests</li>
<li>Use common test utilities to reduce duplication</li>
<li>Group related tests into modules</li>
</ul>
<h3 id="2-test-data-management"><a class="header" href="#2-test-data-management">2. Test Data Management</a></h3>
<ul>
<li>Use deterministic test data when possible</li>
<li>Clean up test accounts and state</li>
<li>Use property-based testing for edge cases</li>
</ul>
<h3 id="3-error-testing"><a class="header" href="#3-error-testing">3. Error Testing</a></h3>
<ul>
<li>Test all error conditions explicitly</li>
<li>Verify correct error codes are returned</li>
<li>Test permission and access control</li>
</ul>
<h3 id="4-performance-considerations"><a class="header" href="#4-performance-considerations">4. Performance Considerations</a></h3>
<ul>
<li>Monitor transaction costs in tests</li>
<li>Test with realistic data sizes</li>
<li>Benchmark critical operations</li>
</ul>
<h3 id="5-security-focus"><a class="header" href="#5-security-focus">5. Security Focus</a></h3>
<ul>
<li>Test privilege escalation attempts</li>
<li>Verify input validation</li>
<li>Test resource exhaustion scenarios</li>
</ul>
<h2 id="debugging-tests"><a class="header" href="#debugging-tests">Debugging Tests</a></h2>
<h3 id="logging-and-diagnostics"><a class="header" href="#logging-and-diagnostics">Logging and Diagnostics</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod debug_tests {
    use super::*;
    use arch_program::msg;
    
    #[test]
    fn test_with_logging() {
        env_logger::init();
        
        // Your test code with msg! calls will now show logs
        msg!("Debug: Testing counter initialization");
        
        // ... test code ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-helpers-for-debugging"><a class="header" href="#test-helpers-for-debugging">Test Helpers for Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn debug_account_state(client: &amp;ArchClient, account: &amp;Pubkey) -&gt; CounterAccount {
    let account_data = client.get_account(account).unwrap().unwrap();
    let state: CounterAccount = borsh::from_slice(&amp;account_data.data).unwrap();
    
    println!("Account: {}", account);
    println!("Count: {}", state.count);
    println!("Authority: {}", state.authority);
    println!("Frozen: {}", state.is_frozen);
    println!("Operations: {}", state.operation_count);
    
    state
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Comprehensive testing is crucial for Arch Network program development. This guide provides:</p>
<ul>
<li><strong>Complete test setup</strong> with proper dependencies and project structure</li>
<li><strong>Multi-layer testing strategy</strong> covering unit, integration, security, and performance</li>
<li><strong>Real working examples</strong> that you can adapt for your programs</li>
<li><strong>Best practices</strong> for maintainable and effective test suites</li>
<li><strong>CI/CD integration</strong> for automated testing</li>
</ul>
<p>Remember to test early, test often, and test thoroughly. Your users depend on your programs being secure and reliable!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../guides/writing-your-first-program.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../guides/guides.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../guides/writing-your-first-program.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../guides/guides.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/mermaid.min.js"></script>
        <script src="../theme/mermaid-init.js"></script>
        <script src="../theme/custom.js"></script>


    </div>
    </body>
</html>
